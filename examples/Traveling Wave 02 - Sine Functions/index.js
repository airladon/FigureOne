(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Fig", [], factory);
	else if(typeof exports === 'object')
		exports["Fig"] = factory();
	else
		root["Fig"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _js_tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _js_figure_Figure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/figure/Figure */ "./src/js/figure/Figure.js");
/* harmony import */ var _js_figure_Recorder_Recorder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/figure/Recorder/Recorder */ "./src/js/figure/Recorder/Recorder.js");
/* harmony import */ var _js_tools_FunctionMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/tools/FunctionMap */ "./src/js/tools/FunctionMap.js");
/* harmony import */ var _js_tools_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./js/tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _js_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./js/tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _js_tools_tools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./js/tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _js_tools_styleSheets__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./js/tools/styleSheets */ "./src/js/tools/styleSheets.js");
/* harmony import */ var _js_figure_geometries_lines_lines__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./js/figure/geometries/lines/lines */ "./src/js/figure/geometries/lines/lines.js");
/* harmony import */ var _js_figure_Element__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./js/figure/Element */ "./src/js/figure/Element.js");
/* harmony import */ var _js_figure_DrawContext2D__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./js/figure/DrawContext2D */ "./src/js/figure/DrawContext2D.js");
/* harmony import */ var _js_figure_webgl_webgl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./js/figure/webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _js_figure_DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./js/figure/DrawingObjects/DrawingObject */ "./src/js/figure/DrawingObjects/DrawingObject.js");
/* harmony import */ var _js_figure_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./js/figure/DrawingObjects/VertexObject/VertexObject */ "./src/js/figure/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _js_figure_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./js/figure/DrawingObjects/TextObject/TextObject */ "./src/js/figure/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _js_figure_DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./js/figure/DrawingObjects/HTMLObject/HTMLObject */ "./src/js/figure/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _js_figure_Equation_HTMLEquation__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./js/figure/Equation/HTMLEquation */ "./src/js/figure/Equation/HTMLEquation.js");
/* harmony import */ var _js_figure_FigureCollections_Angle__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./js/figure/FigureCollections/Angle */ "./src/js/figure/FigureCollections/Angle.js");
/* harmony import */ var _js_figure_FigureCollections_Line__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./js/figure/FigureCollections/Line */ "./src/js/figure/FigureCollections/Line.js");
/* harmony import */ var _js_figure_FigureCollections_PolyLine__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./js/figure/FigureCollections/PolyLine */ "./src/js/figure/FigureCollections/PolyLine.js");
/* harmony import */ var _js_figure_FigureCollections_EqnNavigator__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./js/figure/FigureCollections/EqnNavigator */ "./src/js/figure/FigureCollections/EqnNavigator.js");
/* harmony import */ var _js_figure_FigureCollections_EquationLabel__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./js/figure/FigureCollections/EquationLabel */ "./src/js/figure/FigureCollections/EquationLabel.js");
/* harmony import */ var _js_figure_Equation_Equation__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./js/figure/Equation/Equation */ "./src/js/figure/Equation/Equation.js");
/* harmony import */ var _js_figure_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./js/figure/Equation/EquationForm */ "./src/js/figure/Equation/EquationForm.js");
/* harmony import */ var _js_figure_Animation_Animation__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./js/figure/Animation/Animation */ "./src/js/figure/Animation/Animation.js");
/* harmony import */ var _js_tools_types__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./js/tools/types */ "./src/js/tools/types.js");

























 // This helps the docgen find the types file
// eslint-disable-next-line


// /** Tools object that is so great
// * @namespace tools
// * @memberof module:Fig
// * @property {object} math   - Math tools
// * @property {object} g2     - 2D geometry tools
// * @property {object} color  - Color tools
// * @property {object} css    - CSS tools
// */
var tools = {
  math: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__,
  g2: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__,
  color: _js_tools_color__WEBPACK_IMPORTED_MODULE_5__,
  css: _js_tools_styleSheets__WEBPACK_IMPORTED_MODULE_8__,
  html: _js_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_6__,
  misc: _js_tools_tools__WEBPACK_IMPORTED_MODULE_7__,
  lines: _js_figure_geometries_lines_lines__WEBPACK_IMPORTED_MODULE_9__
};
/**
 * FigureOne entry point
 * @module Fig
 * @global
 * @property {class} {@link Figure}      - Figure Class
 */

var Fig = {
  tools: tools,
  Figure: _js_figure_Figure__WEBPACK_IMPORTED_MODULE_2__["default"],
  Recorder: _js_figure_Recorder_Recorder__WEBPACK_IMPORTED_MODULE_3__["Recorder"],
  FunctionMap: _js_tools_FunctionMap__WEBPACK_IMPORTED_MODULE_4__["FunctionMap"],
  GlobalFunctionMap: _js_tools_FunctionMap__WEBPACK_IMPORTED_MODULE_4__["GlobalFunctionMap"],
  //
  FigureElement: _js_figure_Element__WEBPACK_IMPORTED_MODULE_10__["FigureElement"],
  FigureElementCollection: _js_figure_Element__WEBPACK_IMPORTED_MODULE_10__["FigureElementCollection"],
  FigureElementPrimitive: _js_figure_Element__WEBPACK_IMPORTED_MODULE_10__["FigureElementPrimitive"],
  DrawContext2D: _js_figure_DrawContext2D__WEBPACK_IMPORTED_MODULE_11__["default"],
  WebGLInstance: _js_figure_webgl_webgl__WEBPACK_IMPORTED_MODULE_12__["default"],
  //
  DrawingObject: _js_figure_DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_13__["default"],
  VertexObject: _js_figure_DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_14__["default"],
  TextObject: _js_figure_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_15__["TextObject"],
  FigureText: _js_figure_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_15__["FigureText"],
  FigureFont: _js_figure_DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_15__["FigureFont"],
  HTMLObject: _js_figure_DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_16__["default"],
  //
  CollectionsAngle: _js_figure_FigureCollections_Angle__WEBPACK_IMPORTED_MODULE_18__["default"],
  CollectionsLine: _js_figure_FigureCollections_Line__WEBPACK_IMPORTED_MODULE_19__["default"],
  CollectionsPolyline: _js_figure_FigureCollections_PolyLine__WEBPACK_IMPORTED_MODULE_20__["default"],
  EqnNavigator: _js_figure_FigureCollections_EqnNavigator__WEBPACK_IMPORTED_MODULE_21__["default"],
  EquationLabel: _js_figure_FigureCollections_EquationLabel__WEBPACK_IMPORTED_MODULE_22__["default"],
  //
  EquationForm: _js_figure_Equation_EquationForm__WEBPACK_IMPORTED_MODULE_24__["default"],
  Equation: _js_figure_Equation_Equation__WEBPACK_IMPORTED_MODULE_23__["Equation"],
  //
  HTMLEquation: _js_figure_Equation_HTMLEquation__WEBPACK_IMPORTED_MODULE_17__["default"],
  //
  Animation: _js_figure_Animation_Animation__WEBPACK_IMPORTED_MODULE_25__,
  //
  Point: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"],
  Line: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"],
  Rect: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"],
  Transform: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"],
  Translation: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"],
  Scale: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"],
  Rotation: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"],
  parsePoint: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"],
  LineBounds: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["LineBounds"],
  TransformBounds: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformBounds"],
  RectBounds: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["RectBounds"],
  RangeBounds: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["RangeBounds"],
  minAngleDiff: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["minAngleDiff"],
  getTriangleCenter: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTriangleCenter"],
  polarToRect: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"],
  rectToPolar: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["rectToPolar"],
  threePointAngle: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngle"],
  threePointAngleMin: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngleMin"],
  clipAngle: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"],
  getPoint: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"],
  getPoints: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"],
  getScale: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getScale"],
  getLine: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getLine"],
  getRect: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getRect"],
  getTransform: _js_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"],
  // math
  round: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"],
  range: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__["range"],
  randSign: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__["randSign"],
  randInt: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__["randInt"],
  rand: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__["rand"],
  randElement: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__["randElement"],
  randElements: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__["randElements"],
  removeRandElement: _js_tools_math__WEBPACK_IMPORTED_MODULE_1__["removeRandElement"]
};
/* harmony default export */ __webpack_exports__["default"] = (Fig);

/***/ }),

/***/ "./src/js/figure/Animation/Animation.js":
/*!**********************************************!*\
  !*** ./src/js/figure/Animation/Animation.js ***!
  \**********************************************/
/*! exports provided: PositionAnimationStep, AnimationBuilder, ParallelAnimationStep, SerialAnimationStep, TransformAnimationStep, AnimationStep, DelayAnimationStep, TriggerAnimationStep, inParallel, inSerial, trigger, delay, ColorAnimationStep, DissolveInAnimationStep, dissolveIn, DissolveOutAnimationStep, dissolveOut, CustomAnimationStep, custom, AnimationManager, RotationAnimationStep, ScaleAnimationStep, PulseAnimationStep, OpacityAnimationStep, DimAnimationStep, dim, UndimAnimationStep, undim, ScenarioAnimationStep, PulseTransformAnimationStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AnimationStep_ElementAnimationStep_PositionAnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/PositionAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PositionAnimationStep", function() { return _AnimationStep_ElementAnimationStep_PositionAnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_ScenarioAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/ScenarioAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ScenarioAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScenarioAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ScenarioAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/ColorAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_2__["ColorAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DimAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_2__["DimAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dim", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_2__["dim"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UndimAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_2__["UndimAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "undim", function() { return _AnimationStep_ElementAnimationStep_ColorAnimationStep__WEBPACK_IMPORTED_MODULE_2__["undim"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/OpacityAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DissolveInAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_3__["DissolveInAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissolveIn", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_3__["dissolveIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DissolveOutAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_3__["DissolveOutAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dissolveOut", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_3__["dissolveOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OpacityAnimationStep", function() { return _AnimationStep_ElementAnimationStep_OpacityAnimationStep__WEBPACK_IMPORTED_MODULE_3__["OpacityAnimationStep"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_TransformAnimationStep__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/TransformAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformAnimationStep", function() { return _AnimationStep_ElementAnimationStep_TransformAnimationStep__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_PulseTransformAnimationStep__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/PulseTransformAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PulseTransformAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PulseTransformAnimationStep", function() { return _AnimationStep_ElementAnimationStep_PulseTransformAnimationStep__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_RotationAnimationStep__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/RotationAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RotationAnimationStep", function() { return _AnimationStep_ElementAnimationStep_RotationAnimationStep__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_ScaleAnimationStep__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/ScaleAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScaleAnimationStep", function() { return _AnimationStep_ElementAnimationStep_ScaleAnimationStep__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _AnimationStep_ElementAnimationStep_PulseAnimationStep__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AnimationStep/ElementAnimationStep/PulseAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PulseAnimationStep", function() { return _AnimationStep_ElementAnimationStep_PulseAnimationStep__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AnimationStep/TriggerStep */ "./src/js/figure/Animation/AnimationStep/TriggerStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TriggerAnimationStep", function() { return _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_9__["TriggerAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return _AnimationStep_TriggerStep__WEBPACK_IMPORTED_MODULE_9__["trigger"]; });

/* harmony import */ var _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./AnimationStep/CustomStep */ "./src/js/figure/Animation/AnimationStep/CustomStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CustomAnimationStep", function() { return _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_10__["CustomAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "custom", function() { return _AnimationStep_CustomStep__WEBPACK_IMPORTED_MODULE_10__["custom"]; });

/* harmony import */ var _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./AnimationStep/ParallelAnimationStep */ "./src/js/figure/Animation/AnimationStep/ParallelAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParallelAnimationStep", function() { return _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_11__["ParallelAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inParallel", function() { return _AnimationStep_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_11__["inParallel"]; });

/* harmony import */ var _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./AnimationStep/SerialAnimationStep */ "./src/js/figure/Animation/AnimationStep/SerialAnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SerialAnimationStep", function() { return _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_12__["SerialAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inSerial", function() { return _AnimationStep_SerialAnimationStep__WEBPACK_IMPORTED_MODULE_12__["inSerial"]; });

/* harmony import */ var _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./AnimationStep/DelayStep */ "./src/js/figure/Animation/AnimationStep/DelayStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DelayAnimationStep", function() { return _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_13__["DelayAnimationStep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return _AnimationStep_DelayStep__WEBPACK_IMPORTED_MODULE_13__["delay"]; });

/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./AnimationStep */ "./src/js/figure/Animation/AnimationStep.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationStep", function() { return _AnimationStep__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _AnimationManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./AnimationManager */ "./src/js/figure/Animation/AnimationManager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationManager", function() { return _AnimationManager__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _AnimationBuilder__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./AnimationBuilder */ "./src/js/figure/Animation/AnimationBuilder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationBuilder", function() { return _AnimationBuilder__WEBPACK_IMPORTED_MODULE_16__["default"]; });













 // import type {
//   OBJ_AnimationStep,
// } from './AnimationStep/DelayAnimationStep';



// eslint-disable-next-line import/no-cycle

// eslint-disable-next-line import/no-cycle



/***/ }),

/***/ "./src/js/figure/Animation/AnimationBuilder.js":
/*!*****************************************************!*\
  !*** ./src/js/figure/Animation/AnimationBuilder.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationBuilder; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation */ "./src/js/figure/Animation/Animation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import * as tools from '../../tools/math';
// eslint-disable-next-line import/no-cycle

// import PositionAnimationStep from './AnimationStep/ElementAnimationStep/PositionAnimationStep';
// import SerialAnimationStep from './AnimationStep/SerialAnimationStep';
// eslint-disable-next-line import/no-cycle

 // import { getState, setState } from '../state';
// import type Figure from '../Figure';

/**
 * Animation builder options object
 * @extends OBJ_SerialAnimationStep
 * @property {FigureElement} [element]
 */

/**
 * Animation Builder
 *
 * Convenient way to build animation steps in serial. Each step returns the
 * same builder object, and so chaining in a fluent like API can be achieved.
 *
 * @extends SerialAnimationStep
 * @see <a href="#animationmanagernew">AnimationManager.new</a>
 *
 * @example
 * p.animations.new()
 *   .delay(1)
 *   .position({ target: [1, 0], duration: 2 })
 *   .delay(1)
 *   .rotation({ target: Math.PI, duration: 2 })
 *   .start();
 */
var AnimationBuilder = /*#__PURE__*/function (_animation$SerialAnim) {
  _inherits(AnimationBuilder, _animation$SerialAnim);

  var _super = _createSuper(AnimationBuilder);

  /**
   * @hideconstructor
   */
  function AnimationBuilder() {
    var _this;

    var elementOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationBuilder);

    var defaultOptions = {
      customSteps: []
    };
    var optionsToUse;

    for (var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      options[_key - 1] = arguments[_key];
    }

    if (elementOrOptions instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["FigureElement"]) {
      optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
      optionsToUse.element = elementOrOptions;
    } else {
      optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, elementOrOptions].concat(options));
    }

    _this = _super.call(this, optionsToUse);
    _this.element = optionsToUse.element;
    _this._stepType = 'builder';
    optionsToUse.customSteps.forEach(function (customStep) {
      // $FlowFixMe
      _this[customStep.name] = function () {
        var defOptions = {
          element: _this.element
        };

        for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          optionsIn[_key2] = arguments[_key2];
        }

        var o = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defOptions].concat(optionsIn));

        _this.then(customStep.step(o));

        return _assertThisInitialized(_this);
      };
    });
    return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
  } // eslint-disable-next-line class-methods-use-this
  // _finishSetState(figure: Figure) {
  //   if (this.element != null && typeof this.element === 'string') {
  //     const element = figure.getElement(this.element);
  //     if (element != null) {
  //       this.element = element;
  //     }
  //   }
  // }
  // _getState() {
  //   const state = super._getState();
  //   // const state = getState(this, keys);
  //   if (this.element != null) {
  //     state.element = this.element.getPath();
  //   }
  //   return state;
  // }
  // fnExec(idOrFn: string | Function | null, ...args: any) {
  //   const result = this.fnMap.exec(idOrFn, ...args);
  //   if (result == null && this.element != null) {
  //     return this.element.fnMap.exec(idOrFn, ...args);
  //   }
  //   return result;
  // }


  _createClass(AnimationBuilder, [{
    key: "fnExec",
    value: function fnExec(idOrFn) {
      var _this$fnMap2;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      // const result = this.fnMap.exec(idOrFn, ...args);
      // if (result == null && this.element != null) {
      //   return this.element.fnMap.exec(idOrFn, ...args);
      // }
      // return result;
      if (this.element != null) {
        var _this$fnMap;

        return (_this$fnMap = this.fnMap).execOnMaps.apply(_this$fnMap, [idOrFn, [this.element.fnMap.map]].concat(args));
      }

      return (_this$fnMap2 = this.fnMap).exec.apply(_this$fnMap2, [idOrFn].concat(args));
    }
  }, {
    key: "_fromState",
    value: function _fromState(state, getElement) {
      // const obj = new this.constructor();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])(this, state);

      if (this.element != null && typeof this.element === 'string' && getElement != null) {
        this.element = getElement(this.element);
      }

      return this;
    } // _getStateProperties() {  // eslint-disable-line class-methods-use-this
    //   return [...super._getStateProperties(),
    //     'steps',
    //   ];
    // }

  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'animationBuilder';
    }
  }, {
    key: "_state",
    value: function _state(options) {
      var state = _get(_getPrototypeOf(AnimationBuilder.prototype), "_state", this).call(this, options); // definition.f1Type = 'animationBuilder';
      // if (this.element != null) {
      //   definition.state.element = this.element.getPath();
      // }


      if (this.element != null) {
        state.state.element = {
          f1Type: 'de',
          state: this.element.getPath()
        };
      } // if (this.steps.length > 0) {
      //   definition.def.steps = getState()
      // }


      return state;
    }
    /**
     * Add a custom animation step that uses this element by default
     * @param {OBJ_CustomAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "custom",
    value: function custom() {
      for (var _len4 = arguments.length, optionsIn = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        optionsIn[_key4] = arguments[_key4];
      }

      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };
        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["CustomAnimationStep"](options));
      } else {
        this.then(_construct(_Animation__WEBPACK_IMPORTED_MODULE_1__["CustomAnimationStep"], optionsIn));
      }

      return this;
    }
    /**
     * Add a rotation animation step that uses this element by default
     * @param {OBJ_RotationAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "rotation",
    value: function rotation() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len5 = arguments.length, options = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          options[_key5] = arguments[_key5];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["RotationAnimationStep"](optionsToUse));
      }

      return this;
    }
    /**
     * Add a position animation step that uses this element by default
     * @param {OBJ_PositionAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "position",
    value: function position() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len6 = arguments.length, options = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          options[_key6] = arguments[_key6];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["PositionAnimationStep"](optionsToUse));
      }

      return this;
    }
    /**
     * Add a translation animation step that uses this element by default
     * @param {OBJ_PositionAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "translation",
    value: function translation() {
      return this.position.apply(this, arguments);
    }
    /**
     * Add a scale animation step that uses this element by default
     * @param {OBJ_ScaleAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "scale",
    value: function scale() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len7 = arguments.length, options = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          options[_key7] = arguments[_key7];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["ScaleAnimationStep"](optionsToUse));
      }

      return this;
    } // moveTo(...optionsIn: Array<OBJ_PositionAnimationStep>) {
    //   return this.moveToPosition(...optionsIn);
    // }
    // positionTo(...optionsIn: Array<OBJ_PositionAnimationStep>) {
    //   return this.moveToPosition(...optionsIn);
    // }

    /**
     * Add a transform animation step that uses this element by default
     * @param {OBJ_ScaleAnimaOBJ_TransformAnimationStepionStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "transform",
    value: function transform() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len8 = arguments.length, options = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          options[_key8] = arguments[_key8];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["TransformAnimationStep"](optionsToUse));
      }

      return this;
    }
  }, {
    key: "pulseTransforms",
    value: function pulseTransforms() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len9 = arguments.length, options = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
          options[_key9] = arguments[_key9];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["PulseTransformAnimationStep"](optionsToUse));
      }

      return this;
    }
    /**
     * Add a scenario animation step that uses this element by default
     * @param {OBJ_ScenarioAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "scenario",
    value: function scenario() {
      // if (this.element != null) {
      //   const defaultOptions = { element: this.element };
      //   const optionsToUse = joinObjects({}, defaultOptions, ...options);
      //   this.then(optionsToUse.element.anim.scenario(optionsToUse));
      // }
      // return this;
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len10 = arguments.length, options = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          options[_key10] = arguments[_key10];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["ScenarioAnimationStep"](optionsToUse));
      }

      return this;
    }
    /**
     * Add a scenarios animation step that uses this element by default
     * @param {OBJ_ScenariosAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "scenarios",
    value: function scenarios() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len11 = arguments.length, options = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
          options[_key11] = arguments[_key11];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(optionsToUse.element.animations.scenarios(optionsToUse));
      }

      return this;
    }
    /**
     * Add a color animation step that uses this element by default
     * @param {OBJ_ColorAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "color",
    value: function color() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len12 = arguments.length, options = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
          options[_key12] = arguments[_key12];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["ColorAnimationStep"](optionsToUse));
      }

      return this;
    }
    /**
     * Add an opacity animation step that uses this element by default
     * @param {OBJ_OpacityAnimationStep} options
     * @return {AnimationBuilder}
     */

  }, {
    key: "opacity",
    value: function opacity() {
      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };

        for (var _len13 = arguments.length, options = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
          options[_key13] = arguments[_key13];
        }

        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
        this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["OpacityAnimationStep"](optionsToUse));
      }

      return this;
    }
    /**
     * Add an dissolve out animation step that uses this element by default
     * @param {OBJ_ElementAnimationStep} durationOrOptions
     * @return {AnimationBuilder}
     */

  }, {
    key: "dissolveOut",
    value: function dissolveOut() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len14 = arguments.length, args = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
        args[_key14 - 1] = arguments[_key14];
      }

      if (typeof durationOrOptions === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: durationOrOptions
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, durationOrOptions].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["dissolveOut"](options));
      return this;
    }
    /**
     * Add an dissolve in animation step that uses this element by default
     * @param {OBJ_ElementAnimationStep} durationOrOptions
     * @return {AnimationBuilder}
     */

  }, {
    key: "dissolveIn",
    value: function dissolveIn() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len15 = arguments.length, args = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
        args[_key15 - 1] = arguments[_key15];
      }

      if (typeof durationOrOptions === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: durationOrOptions
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, durationOrOptions].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["dissolveIn"](options));
      return this;
    }
    /**
     * Add an dim animation step that uses this element by default
     * @param {OBJ_ElementAnimationStep} durationOrOptions
     * @return {AnimationBuilder}
     */

  }, {
    key: "dim",
    value: function dim() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len16 = arguments.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {
        args[_key16 - 1] = arguments[_key16];
      }

      if (typeof durationOrOptions === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: durationOrOptions
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, durationOrOptions].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["dim"](options));
      return this;
    }
    /**
     * Add an undim animation step that uses this element by default
     * @param {OBJ_ElementAnimationStep} durationOrOptions
     * @return {AnimationBuilder}
     */

  }, {
    key: "undim",
    value: function undim() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var options;

      for (var _len17 = arguments.length, args = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {
        args[_key17 - 1] = arguments[_key17];
      }

      if (typeof durationOrOptions === 'number') {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, {
          duration: durationOrOptions
        }].concat(args));
      } else {
        options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, durationOrOptions].concat(args));
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["undim"](options));
      return this;
    }
    /**
     * Add a delay animation step
     * @param {OBJ_AnimationStep} durationOrOptions
     * @return {AnimationBuilder}
     */

  }, {
    key: "delay",
    value: function delay() {
      var delayOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len18 = arguments.length, args = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {
        args[_key18 - 1] = arguments[_key18];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["delay"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [delayOrOptions].concat(args)));
      return this;
    }
    /**
     * Add a trigger animation step
     * @param {OBJ_TriggerAnimationStep} triggerOrOptions
     * @return {AnimationBuilder}
     */

  }, {
    key: "trigger",
    value: function trigger() {
      var triggerOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len19 = arguments.length, args = new Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {
        args[_key19 - 1] = arguments[_key19];
      }

      if (this.element != null) {
        var defaultOptions = {
          element: this.element
        };
        var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(args));
        this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["trigger"](triggerOrOptions, optionsToUse));
      } else {
        this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["trigger"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [triggerOrOptions].concat(args)));
      } // this.then(animation.trigger(triggerOrOptionsIn, ...optionsIn));


      return this;
    }
    /**
     * Add a parallel animation step
     * @param {Array<AnimationStep | null> | OBJ_ParallelAnimationStep} stepsOrOptions
     * @return {AnimationBuilder}
     */

  }, {
    key: "inParallel",
    value: function inParallel() {
      var stepsOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len20 = arguments.length, options = new Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {
        options[_key20 - 1] = arguments[_key20];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["inParallel"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [stepsOrOptions].concat(options)));
      return this;
    }
    /**
     * Add a serial animation step
     * @param {Array<AnimationStep | null> | OBJ_SerialAnimationStep} stepsOrOptions
     * @return {AnimationBuilder}
     */

  }, {
    key: "inSerial",
    value: function inSerial() {
      var stepsOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var _len21 = arguments.length, options = new Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {
        options[_key21 - 1] = arguments[_key21];
      }

      this.then(_Animation__WEBPACK_IMPORTED_MODULE_1__["inSerial"].apply(_Animation__WEBPACK_IMPORTED_MODULE_1__, [stepsOrOptions].concat(options)));
      return this;
    }
  }, {
    key: "pulse",
    value: function pulse() {
      var defaultOptions = {
        element: this.element
      };

      for (var _len22 = arguments.length, optionsIn = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++) {
        optionsIn[_key22] = arguments[_key22];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      this.then(new _Animation__WEBPACK_IMPORTED_MODULE_1__["PulseAnimationStep"](options));
      return this;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.steps = [];
      this.state = 'idle';
    } // whenFinished(callback: (boolean) => void) {
    //   super.whenFinished(callback);
    //   return this;
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var newBuilder = new AnimationBuilder();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, newBuilder, ['element']);
      newBuilder.element = this.element;
      return newBuilder;
    }
  }]);

  return AnimationBuilder;
}(_Animation__WEBPACK_IMPORTED_MODULE_1__["SerialAnimationStep"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationManager.js":
/*!*****************************************************!*\
  !*** ./src/js/figure/Animation/AnimationManager.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationManager; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation */ "./src/js/figure/Animation/Animation.js");
/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/GlobalAnimation */ "./src/js/figure/webgl/GlobalAnimation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Recorder_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Recorder/state */ "./src/js/figure/Recorder/state.js");
/* harmony import */ var _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/FunctionMap */ "./src/js/tools/FunctionMap.js");
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import * as tools from '../../tools/math';
// eslint-disable-next-line import/no-cycle
 // import type { OBJ_SerialAnimationStep } from './AnimationStep/SerialAnimationStep';
// import type {
//   OBJ_PositionAnimationStep, OBJ_ParallelAnimationStep,
//   OBJ_AnimationStep, OBJ_TriggerAnimationStep,
//   OBJ_ColorAnimationStep, OBJ_CustomAnimationStep,
// } from './Animation';
// eslint-disable-next-line import/no-cycle


// eslint-disable-next-line import/no-cycle
// import {
//   AnimationStep,
// } from './Animation';





/* eslint-disable max-len */

/**
 * Animation Manager
 *
 * This class manages animations and creates animation steps for use in
 * animations.
 *
 * Each {@link FigureElement} has its own `AnimationManager` in the
 * `animations` property, though any
 * animation manager can animate any other element. Therefore all parallel
 * animations can go through the same manager, or be spread throughout
 * different element's animation managers. Spread animations out between
 * elements, or keeping them all in one `AnimationManager` can change how
 * readable code is, how convenient it is to cancel running animations, and
 * what order the animations are performed in (`AnimationManager`s tied
 * to elements drawn earlier will perform their animation steps before those
 * tied to elements drawn later). `AnimationManager`s will only be processed
 * on each animation frame if the element they are tied to is not hidden.
 *
 * The `animations` property within `AnimationManager` is simply an array that
 * contains a number {@link AnimationStep}s that are executed in parallel.
 * Typically, these steps would themselves be {@link SerialAnimationStep}s or a
 * series of animations. This means the animation manager is running a number of
 * animation series in parallel.
 *
 *
 * The `AnimationManager`s on {@link FigureElement}s should be used instead
 * of instantiating this class separately, as those on `FigureElements` will
 * be automatically processed every animation frame.
 *
 * @param
 * @property {'animating' | 'idle' | 'waitingToStart'} state
 * @property {Array<AnimationStep>} animations
 * @property {SubscriptionManager} subscriptions
 * @see {@link FigureElement}
 * @see {@link AnimationBuilder}
 * @example
 * // At its heart the `AnimationManager` is just executing
 * // an array of animation steps.
 *
 * // Create animation steps
 * const position = new Fig.Animation.PositionAnimationStep({
 *   element: p,
 *   target: [1, 0],
 *   duration: 2,
 * });
 * const rotation = new Fig.Animation.RotationAnimationStep({
 *   element: p,
 *   target: Math.PI,
 *   duration: 2,
 * });
 *
 * // Combine the animations into a SerialAnimationStep
 * const series = new Fig.Animation.SerialAnimationStep([
 *   position,
 *   rotation,
 * ]);
 *
 * // Add the animations to the animation manager and start
 * p.animations.animations.push(series);
 * p.animations.start();
 *
 * @example
 * // Using the `new` method in `AnimationManager` creates a convenient
 * // `AnimationBuilder` which extends a `SerialAnimationStep` by using
 * // a fluent API pattern
 * //
 * // Create animation steps
 * const position = new Fig.Animation.PositionAnimationStep({
 *   element: p,
 *   target: [1, 0],
 *   duration: 2,
 * });
 * const rotation = new Fig.Animation.RotationAnimationStep({
 *   element: p,
 *   target: Math.PI,
 *   duration: 2,
 * });
 *
 * // Build and start the animation
 * p.animations.new()
 *   .then(position)
 *   .then(rotation)
 *   .start();
 *
 * @example
 * // `AnimationStep`s can also be created from the `AnimationManager`
 * // with the added convenience that the `FigureElement` that
 * // has the `AnimationManager` will be used as the default
 * // `element` property. This combined with the `AnimationBuilder`
 * // makes defining most animations clean and readable code
 *
 * // Build and start the animation
 * p.animations.new()
 *   .position({ target: [1, 0], duration: 2 })
 *   .rotation({ target: Math.PI, duration: 2 })
 *   .start();
 *
 * @example
 * // Parallel animations however still need to use explicit animation steps.
 * // Creating the steps from the `AnimationManager` means the `element` doesn't
 * // need to be defined.
 * //
 * p.animations.new()
 *   .inParallel([
 *     p.animations.position({ target: [1, 0], duration: 2 }),
 *     p.animations.rotation({ target: Math.PI, duration: 2 })
 *   ])
 *   .start();
 */
var AnimationManager = /*#__PURE__*/function () {
  /* eslint-enable max-len */

  /**
   * @hideconstructor
   */
  function AnimationManager() {
    var elementOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationManager);

    var defaultOptions = {
      finishedCallback: null
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (elementOrOptionsIn instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["FigureElement"]) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.element = elementOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, defaultOptions, elementOrOptionsIn].concat(optionsIn));
    }

    this.element = options.element;
    this.animations = [];
    this.state = 'idle'; // $FlowFixMe

    this.options = {
      translation: {}
    };
    this.fnMap = new _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_5__["FunctionMap"]();
    this.finishedCallback = options.finishedCallback;
    this.subscriptions = new _tools_tools__WEBPACK_IMPORTED_MODULE_3__["SubscriptionManager"]();
    this.customSteps = [];
    this.animationSpeed = 1; // this.setupAnimationSteps();

    return this;
  }
  /**
   * New animation builder attached to this animation manager
   * @return AnimationBuilder
   * @example
   * p.animations.new()
   *   .position({ target: [0.5, 0], duration: 2 })
   *   .rotation({ target: Math.PI, duration: 2 })
   *   .start();
   *
   */


  _createClass(AnimationManager, [{
    key: "new",
    value: function _new(name) {
      var options = {
        customSteps: this.customSteps
      };

      if (this.element != null) {
        // $FlowFixMe
        options.element = this.element;
      }

      if (name != null) {
        // $FlowFixMe
        options.name = name;
      }

      var animation = new _Animation__WEBPACK_IMPORTED_MODULE_1__["AnimationBuilder"](options);
      this.animations.push(animation);

      if (this.element != null) {
        this.element.animateNextFrame();
      }

      return animation;
    }
    /**
     * Set time speed of animation relative to real time, where 1 is real time,
     * <1 is slower than real time and >1 is faster than real time.
     *
     * @param {number} speed
     */

  }, {
    key: "setTimeSpeed",
    value: function setTimeSpeed() {
      var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      this.animationSpeed = speed;
    }
    /**
     * Animation builder object
     * @param {OBJ_AnimationBuilder} options
     * @return {AnimationBuilder}
     */
    // eslint-disable-next-line max-len

  }, {
    key: "builder",
    value: function builder() {
      for (var _len2 = arguments.length, options = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        options[_key2] = arguments[_key2];
      }

      // $FlowFixMe
      return _construct(_Animation__WEBPACK_IMPORTED_MODULE_1__["AnimationBuilder"], [this, {
        customSteps: this.customSteps
      }].concat(options));
    }
    /**
     * Create a Rotation animation step that uses this element by default
     * @param {OBJ_RotationAnimationStep} options
     * @return {RotationAnimationStep}
     * @example
     * const rot = p.animations.rotation({ target: Math.PI, duration: 2 });
     * p.animations.new()
     *   .then(rot)
     *   .start();
     */

  }, {
    key: "rotation",
    value: function rotation() {
      for (var _len3 = arguments.length, options = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        options[_key3] = arguments[_key3];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["RotationAnimationStep"](optionsToUse);
    }
    /**
     * Create a Scale animation step tied to this element
     * @param {OBJ_ScaleAnimationStep} options
     * @return {ScaleAnimationStep}
     */

  }, {
    key: "scale",
    value: function scale() {
      for (var _len4 = arguments.length, options = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        options[_key4] = arguments[_key4];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["ScaleAnimationStep"](optionsToUse);
    }
    /**
     * Create a Trigger animation step
     * @param {OBJ_TriggerAnimationStep | function(): void} options
     * @return {TriggerAnimationStep}
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "trigger",
    value: function trigger(options) {
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["TriggerAnimationStep"](options);
    }
    /**
     * Create a Delay animation step
     * Use the `duration` value in `options` to define delay duration
     * @param {number | OBJ_AnimationStep} delayOrOptions
     * @return {DelayAnimationStep}
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "delay",
    value: function delay() // ...args: Array<OBJ_AnimationStep>
    {
      var delayOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // let optionsToUse;
      // if (typeof delayOrOptions === 'number') {
      //   optionsToUse = joinObjects({}, { duration: delayOrOptions }, ...args);
      // } else {
      //   optionsToUse = joinObjects({}, delayOrOptions, ...args);
      // }
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["DelayAnimationStep"](delayOrOptions);
    }
    /**
     * Create a Translation or Position animation step tied to this element
     * @param {OBJ_PositionAnimationStep} options
     * @return {PositionAnimationStep}
     */

  }, {
    key: "translation",
    value: function translation() {
      for (var _len5 = arguments.length, options = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        options[_key5] = arguments[_key5];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["PositionAnimationStep"](optionsToUse);
    }
    /**
     * Create a Translation or Position animation step tied to this element
     * @param {OBJ_PositionAnimationStep} options
     * @return {PositionAnimationStep}
     */

  }, {
    key: "position",
    value: function position() {
      for (var _len6 = arguments.length, options = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        options[_key6] = arguments[_key6];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["PositionAnimationStep"](optionsToUse);
    }
    /**
     * Create a Color animation step tied to this element
     * @param {OBJ_ColorAnimationStep} options
     * @return {ColorAnimationStep}
     */

  }, {
    key: "color",
    value: function color() {
      for (var _len7 = arguments.length, options = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        options[_key7] = arguments[_key7];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["ColorAnimationStep"](optionsToUse);
    }
    /**
     * Create a Opacity animation step tied to this element
     * @param {OBJ_OpacityAnimationStep} options
     * @return {OpacityAnimationStep}
     */

  }, {
    key: "opacity",
    value: function opacity() {
      for (var _len8 = arguments.length, options = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        options[_key8] = arguments[_key8];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["OpacityAnimationStep"](optionsToUse);
    }
    /**
     * Create a Transform animation step tied to this element
     * @param {OBJ_TransformAnimationStep} options
     * @return {TransformAnimationStep}
     */

  }, {
    key: "transform",
    value: function transform() {
      for (var _len9 = arguments.length, options = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        options[_key9] = arguments[_key9];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["TransformAnimationStep"](optionsToUse);
    }
  }, {
    key: "pulseTransform",
    value: function pulseTransform() {
      for (var _len10 = arguments.length, options = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        options[_key10] = arguments[_key10];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["PulseTransformAnimationStep"](optionsToUse);
    }
  }, {
    key: "pulse",
    value: function pulse() {
      for (var _len11 = arguments.length, options = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        options[_key11] = arguments[_key11];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["PulseAnimationStep"](optionsToUse);
    }
    /**
     * Create a Dissolve in animation step
     * Use the `duration` value in `options` to define dissolving duration
     * @param {number | OBJ_ElementAnimationStep} timeOrOptions
     * @return {DissolveInAnimationStep}
     */

  }, {
    key: "dissolveIn",
    value: function dissolveIn() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var optionsToUse;

      if (typeof durationOrOptions === 'number') {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, {
          duration: durationOrOptions
        });
      } else {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, durationOrOptions);
      }

      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["DissolveInAnimationStep"](optionsToUse);
    }
    /**
     * Create a Dissolve out animation step
     * Use the `duration` value in `options` to define dissolving duration
     * @param {number | OBJ_ElementAnimationStep} durationOrOptions
     * @return {DissolveOutAnimationStep}
     */

  }, {
    key: "dissolveOut",
    value: function dissolveOut() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var optionsToUse;

      if (typeof durationOrOptions === 'number') {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, {
          duration: durationOrOptions
        });
      } else {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, durationOrOptions);
      }

      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["DissolveOutAnimationStep"](optionsToUse);
    }
    /**
     * Create a Dim color animation step
     * Use the `duration` value in `options` to define dimming duration
     * @param {number | OBJ_ElementAnimationStep} durationOrOptions
     * @return {DimAnimationStep}
     */

  }, {
    key: "dim",
    value: function dim() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var optionsToUse;

      if (typeof durationOrOptions === 'number') {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, {
          duration: durationOrOptions
        });
      } else {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, durationOrOptions);
      }

      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["DimAnimationStep"](optionsToUse);
    }
    /**
     * Create a Undim color animation step
     * Use the `duration` value in `options` to define undimming duration
     * @param {number | OBJ_ElementAnimationStep} durationOrOptions
     * @return {UndimAnimationStep}
     */

  }, {
    key: "undim",
    value: function undim() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        element: this.element
      };
      var optionsToUse;

      if (typeof durationOrOptions === 'number') {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, {
          duration: durationOrOptions
        });
      } else {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, durationOrOptions);
      }

      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["UndimAnimationStep"](optionsToUse);
    }
    /**
     * Create a Scenario animation step tied to this element
     * @param {OBJ_ScenarioAnimationStep} options
     * @return {ScenarioAnimationStep}
     */

  }, {
    key: "scenario",
    value: function scenario() {
      for (var _len12 = arguments.length, options = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        options[_key12] = arguments[_key12];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, {
        element: this.element
      }].concat(options));
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["ScenarioAnimationStep"](optionsToUse);
    }
    /**
     * Create a Parallel animation step that animates
     * all child elements with the target scenario name
     * @param {OBJ_ScenariosAnimationStep} options
     * @return {ParallelAnimationStep}
     */

  }, {
    key: "scenarios",
    value: function scenarios() {
      var defaultOptions = {
        element: this.element
      };

      for (var _len13 = arguments.length, options = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        options[_key13] = arguments[_key13];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(options));
      var elements = optionsToUse.element.getAllElementsWithScenario(optionsToUse.target);
      var steps = [];
      var simpleOptions = {};
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["duplicateFromTo"])(optionsToUse, simpleOptions, ['steps', 'element']);
      elements.forEach(function (element) {
        steps.push(element.animations.scenario(simpleOptions));
      });
      return new _Animation__WEBPACK_IMPORTED_MODULE_1__["ParallelAnimationStep"](simpleOptions, {
        steps: steps
      });
    }
  }, {
    key: "_state",
    value: function _state(options) {
      var state = Object(_Recorder_state__WEBPACK_IMPORTED_MODULE_4__["getState"])(this, ['animations', 'state', 'options'], options);

      if (this.element != null) {
        state.element = {
          f1Type: 'de',
          state: this.element.getPath()
        };
      }

      return state;
    } // _finishSetState(figure: Figure) {
    //   for (let i = 0; i < this.animations.length; i += 1) {
    //     const animationStepState = this.animations[i];
    //     let animationStep = {};
    //     if (animationStepState._stepType === 'builder') {
    //       animationStep = new anim.AnimationBuilder();
    //     }
    //     if (animationStepState._stepType === 'position') {
    //       animationStep = new anim.PositionAnimationStep();
    //     }
    //     joinObjects(animationStep, animationStepState);
    //     animationStep._finishSetState(figure);
    //     this.animations[i] = animationStep;
    //   }
    //   // this.animations.forEach((animation) => {
    //   //   let animationStep = {};
    //   //   if (animation.type === 'builder') {
    //   //     animationStep = new anim.AnimationBuilder();
    //   //   }
    //   //   if (animation.type === 'position') {
    //   //     animationStep = new anim.PositionAnimationStep();
    //   //   }
    //   //   joinObjects(animationStep, animation);
    //   //   animation._finishSetState(figure);
    //   //   // }
    //   // });
    // }

  }, {
    key: "setTimeDelta",
    value: function setTimeDelta(delta) {
      this.animations.forEach(function (animation) {
        animation.setTimeDelta(delta);
      });
    }
  }, {
    key: "willStartAnimating",
    value: function willStartAnimating() {
      if (this.state === 'animating') {
        return true;
      }

      var isAnimating = false;
      this.animations.forEach(function (animation) {
        if (animation.state === 'waitingToStart' || animation.state === 'animating') {
          isAnimating = true;
        }
      });
      return isAnimating;
    }
  }, {
    key: "isAnimating",
    value: function isAnimating() {
      if (this.state === 'animating' || this.state === 'waitingToStart') {
        return true;
      }

      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.state === 'waitingToStart' || animation.state === 'animating') {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "nextFrame",
    value: function nextFrame(now) {
      var _this = this;

      // console.log('animation manager', now)
      // console.log(this.element.name, this.state, this.animations)
      var animationsToRemove = [];
      var remaining = null;
      var isAnimating = false;
      this.animations.forEach(function (animation, index) {
        var animationIsAnimating = false; // console.log(this.element.name, animation.state)

        if (animation.state === 'waitingToStart' || animation.state === 'animating') {
          var stepRemaining = animation.nextFrame(now, _this.animationSpeed);

          if (remaining === null) {
            remaining = stepRemaining;
          }

          if (stepRemaining < remaining) {
            remaining = stepRemaining;
          }

          animationIsAnimating = true;
        }

        if (animation.state === 'finished' && animation.removeOnFinish) {
          animationIsAnimating = false;
          animationsToRemove.push(index);
        }

        if (animationIsAnimating) {
          isAnimating = true;
        }
      });
      var callback = null;

      if (isAnimating) {
        this.state = 'animating';
      } else {
        if (this.state === 'animating') {
          this.state = 'idle';
          callback = this.finishedCallback;
          this.subscriptions.publish('finished'); // this.fnMap.exec(this.finishedCallback);
        }

        this.state = 'idle';
      }

      for (var i = animationsToRemove.length - 1; i >= 0; i -= 1) {
        this.animations.splice(animationsToRemove[i], 1);
      } // if (callback != null) {
      //   console.log('finished', this.element.name, callback)
      // }


      this.fnMap.exec(callback);
      return remaining;
    }
  }, {
    key: "cleanAnimations",
    value: function cleanAnimations() {
      var animationsToRemove = [];
      var isAnimating = false;

      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.state === 'finished' && animation.removeOnFinish) {
          animationsToRemove.push(i);
        } else if (animation.state === 'animating' || animation.state === 'waitingToStart') {
          isAnimating = true;
        }
      }

      for (var _i = animationsToRemove.length - 1; _i >= 0; _i -= 1) {
        this.animations.splice(animationsToRemove[_i], 1);
      }

      if (isAnimating) {
        this.state = 'animating';
      } else {
        if (this.state === 'animating') {
          this.state = 'idle'; // console.log('clean finished', this.element.name, this.finishedCallback)

          this.fnMap.exec(this.finishedCallback);
          this.subscriptions.publish('finished');
        }

        this.state = 'idle';
      }
    } // Cancel all primary animations with the name
    // animations will be cleaned up on next frame

    /**
     * Cancel one or all animations managed by this manager (in the `animations`
     * array).
     * @param {null | string} name name of animation or `null` to cancel all
     * (`null`)
     * @param {null | 'complete' | 'freeze'} force force the animation to complete
     * or freeze - `null` will perform the default operation (`null`)
     */

  }, {
    key: "cancel",
    value: function cancel(name) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (name == null) {
        this.cancelAll(force);
      } else {
        for (var i = 0; i < this.animations.length; i += 1) {
          var animation = this.animations[i];

          if (animation.name === name) {
            animation.cancel(force);
          }
        }

        this.cleanAnimations();
      }
    }
  }, {
    key: "cancelAll",
    value: function cancelAll() {
      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      for (var i = 0; i < this.animations.length; i += 1) {
        if (force || !this.animations[i].name.startsWith('_noStop_')) {
          this.animations[i].cancel(how);
        }
      }

      this.cleanAnimations();
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getFrameTime",
    value: function getFrameTime(frame) {
      new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_2__["default"]().getWhen(frame);
    }
    /**
     * Start one or all animations managed by this manager (in the `animations`
     * array).
     *
     * @param {OBJ_AnimationStart} [options]
     */

  }, {
    key: "start",
    value: function start(options) {
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, options, {
        name: null,
        startTime: 'nextFrame'
      });
      var name = optionsToUse.name,
          startTime = optionsToUse.startTime;
      var frameTime = this.getFrameTime(startTime);

      if (name == null) {
        this.startAll(startTime);
      } else {
        for (var i = 0; i < this.animations.length; i += 1) {
          var animation = this.animations[i];

          if (animation.name === name) {
            if (animation.state !== 'animating') {
              animation.start(frameTime);
              animation.finishIfZeroDuration();

              if (animation.state === 'animating') {
                this.state = 'animating';
              }
            }
          }
        }
      }

      if (this.state === 'idle') {
        this.fnMap.exec(this.finishedCallback);
        this.subscriptions.publish('finished');
      }

      if (this.element != null) {
        this.element.animateNextFrame();
      }
    }
  }, {
    key: "startAll",
    value: function startAll(optionsIn) {
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, optionsIn, {
        startTime: 'nextFrame'
      });
      var startTime = options.startTime;
      var frameTime = this.getFrameTime(startTime);

      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.state !== 'animating') {
          animation.start(frameTime);
          animation.finishIfZeroDuration();

          if (animation.state === 'animating') {
            this.state = 'animating';
          }
        }
      }

      if (this.state === 'idle') {
        this.fnMap.exec(this.finishedCallback);
        this.subscriptions.publish('finished');
      }

      if (this.element != null) {
        this.element.animateNextFrame();
      }
    }
  }, {
    key: "getTotalDuration",
    value: function getTotalDuration() {
      var duration = 0;
      this.animations.forEach(function (animation) {
        var animationDuration = animation.getTotalDuration();

        if (animationDuration > duration) {
          duration = animationDuration;
        }
      });
      return duration;
    }
    /**
     * Get remaining duration of all animations
     * @param {number} now define this if you want remaining duration from a
     * custom time
     */

  }, {
    key: "getRemainingTime",
    value: function getRemainingTime() {
      var animationNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_2__["default"]().now() / 1000;
      var remainingTime = 0;
      var names = [];

      if (typeof animationNames === 'string') {
        names = [animationNames];
      } else {
        names = animationNames;
      }

      this.animations.forEach(function (animation) {
        if (names.length > 0 && names.indexOf(animation.name) === -1) {
          return;
        }

        var animationRemainingTime = animation.getRemainingTime(now);

        if (animationRemainingTime > remainingTime) {
          remainingTime = animationRemainingTime;
        }
      }); // console.log(this.element.name, remainingTime, this.animations);

      return remainingTime;
    }
  }, {
    key: "addTo",
    value: function addTo(name) {
      for (var i = 0; i < this.animations.length; i += 1) {
        var animation = this.animations[i];

        if (animation.name === name) {
          return animation;
        }
      }

      return this["new"](name);
    }
  }, {
    key: "newFromStep",
    value: function newFromStep(nameOrStep) {
      this.animations.push(nameOrStep);
      return nameOrStep;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var newManager = new AnimationManager();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["duplicateFromTo"])(this, newManager, ['element']);
      newManager.element = this.element;
      return newManager;
    }
  }]);

  return AnimationManager;
}();



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep.js":
/*!**************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationStep; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Recorder_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Recorder/state */ "./src/js/figure/Recorder/state.js");
/* harmony import */ var _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/FunctionMap */ "./src/js/tools/FunctionMap.js");
/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../webgl/GlobalAnimation */ "./src/js/figure/webgl/GlobalAnimation.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import {
//   Transform, Point,
//   Rotation, getDeltaAngle, getMaxTimeFromVelocity,
// } from '../tools/g2';
// import * as tools from '../tools/math';
// import type { pathOptionsType } from '../tools/g2';
// eslint-disable-next-line import/no-cycle
// import { FigureElement } from './Element';






/**
 * Animation step base class. All animation steps extend this class.
 *
 * @property {number} duration in seconds
 * @property {number} startDelay delay before animation starts in seconds
 * @property {string} name animation name identifier
 * @property {null | (boolean) => void} [onFinish] called when animation is
 * finished - a `true` parameter is passed to the callback if the animation was
 * cancelled
 * @property {null | boolean} [completeOnCancel] `true` to skip to end of
 * animation on cancel
 * @property {boolean} [removeOnFinish] `true` to remove the animation from the
 * animation manager when it is finished (`true`)
 * @property {number} [precision] precision to do calculations to (`8`)
 * @property {'animating' | 'waitingToStart' | 'idle' | 'finished'} state
 */
var AnimationStep = /*#__PURE__*/function () {
  // animations: Array<AnimationStep>;
  // onFinish: ?(boolean) => void;
  function AnimationStep() {
    var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AnimationStep);

    var defaultOptions = {
      onFinish: null,
      completeOnCancel: null,
      removeOnFinish: true,
      name: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["generateRandomString"])(),
      duration: 0,
      delay: 0,
      beforeFrame: null,
      afterFrame: null,
      precision: 8
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])({}, defaultOptions, optionsIn);
    this.onFinish = options.onFinish;
    this.completeOnCancel = options.completeOnCancel;
    this.duration = options.duration;
    this.startTime = null;
    this.state = 'idle';
    this.name = options.name;
    this.afterFrame = options.afterFrame;
    this.beforeFrame = options.beforeFrame;
    this.startDelay = options.delay;
    this.precision = options.precision; // This is only for it this step is a primary path in an Animation Manager

    this.removeOnFinish = options.removeOnFinish; // Each animation frame will typically calculate a percent complete,
    // which is based on the duration, and from the percent complete calculate
    // the position of the current animation.
    // However, if you want to start an animation not from 0 percent, then this
    // value can be used. When startTimeOffset != 0, then the first frame
    // will be calculated at this.progression(startTimeOffset). The animation
    // will still go to 1, but will be reduced in duration by startTimeOffset.
    // When progressions aren't linear, then this time is non-trival.

    this.startTimeOffset = 0;
    this.fnMap = new _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_3__["FunctionMap"]();
    this.fnMap.add('tools.math.easein', _tools_math__WEBPACK_IMPORTED_MODULE_1__["easein"]);
    this.fnMap.add('tools.math.easeout', _tools_math__WEBPACK_IMPORTED_MODULE_1__["easeout"]);
    this.fnMap.add('tools.math.easeinout', _tools_math__WEBPACK_IMPORTED_MODULE_1__["easeinout"]);
    this.fnMap.add('tools.math.linear', _tools_math__WEBPACK_IMPORTED_MODULE_1__["linear"]);
    this.fnMap.add('tools.math.sinusoid', _tools_math__WEBPACK_IMPORTED_MODULE_1__["sinusoid"]);
    return this;
  } // _getStateProperties(): Array<string> {  // eslint-disable-line class-methods-use-this
  //   return Object.keys(this);
  // }
  // _getState() {
  //   const keys = [];
  //   Object.keys(this).forEach((key) => {
  //     if (key !== 'element') {
  //       keys.push(key);
  //     }
  //   });
  //   console.log(keys)
  //   const state = getState(this, keys);
  //   return state;
  // }
  // eslint-disable-next-line no-unused-vars


  _createClass(AnimationStep, [{
    key: "_fromDef",
    value: function _fromDef(definition) {
      var getElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])(this, definition);
      return this;
    }
  }, {
    key: "fnExec",
    value: function fnExec(idOrFn) {
      var _this$fnMap;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_this$fnMap = this.fnMap).exec.apply(_this$fnMap, [idOrFn].concat(args));
    } // _finishSetState(figure: Figure) {
    //   if (this.element != null && typeof this.element === 'string') {
    //     const element = figure.getElement(this.element);
    //     if (element != null) {
    //       this.element = element;
    //     }
    //   }
    //   if (this.steps != null) {
    //     for (let i = 0; i < this.steps.length; i += 1) {
    //       const animationStepState = this.steps[i];
    //       let animationStep = {};
    //       if (animationStepState._stepType === 'builder') {
    //         animationStep = new anim.AnimationBuilder();
    //       }
    //       if (animationStepState._stepType === 'position') {
    //         animationStep = new anim.PositionAnimationStep();
    //       }
    //       joinObjects(animationStep, animationStepState);
    //       animationStep._finishSetState(figure);
    //       this.steps[i] = animationStep;
    //     }
    //   }
    // }
    // eslint-disable-next-line class-methods-use-this, no-unused-vars
    // _finishSetState(figure: Figure) {
    // }
    // execFn(fn: string | Function | null, ...args: Array<any>) {
    //   // if (fn == null) {
    //   //   return null;
    //   // }
    //   // if (typeof fn === 'string') {
    //   //   return this.fnMap.exec(fn, ...args);
    //   // }
    //   // console.log(fn)
    //   // return fn(...args);
    //   return this.fnMap.exec(fn, ...args);
    // }

  }, {
    key: "setTimeDelta",
    value: function setTimeDelta(delta) {
      if (this.startTime != null) {
        this.startTime += delta;
      } // if (this.steps != null) {
      //   this.steps.forEach((step) => {
      //     step.setTimeDelta(delta);
      //   });
      // }

    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      // console.log('animationStep')
      return ['startTime', 'duration', 'onFinish', 'completeOnCancel', 'state', 'startTimeOffset', 'removeOnFinish', 'name', 'startDelay', 'beforeFrame', 'afterFrame', '_stepType'];
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'animationStep';
    }
  }, {
    key: "_state",
    value: function _state(options) {
      return {
        f1Type: this._getStateName(),
        // def: {
        //   startTime: this.startTime,
        //   duration: this.duration,
        //   onFinish: this.onFinish,
        //   completeOnCancel: this.completeOnCancel,
        //   state: this.state,
        //   startTimeOffset: this.startTimeOffset,
        //   removeOnFinish: this.removeOnFinish,
        //   name: this.name,
        //   startDelay: this.startDelay,
        //   beforeFrame: this.beforeFrame,
        //   afterFrame: this.afterFrame,
        //   _stepType: this._stepType,
        // },
        state: Object(_Recorder_state__WEBPACK_IMPORTED_MODULE_2__["getState"])(this, this._getStateProperties(), options)
      };
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "_fromState",
    value: function _fromState(state, getElement) {
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])(this, state);
      return this;
    } // returns remaining time if this step completes
    // Return of 0 means this step is still going

  }, {
    key: "nextFrame",
    value: function nextFrame(now) {
      var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      if (this.startTime == null) {
        // console.log('new Start', this.startTime, now, this.startTimeOffset)
        this.startTime = now - this.startTimeOffset;
      }

      var deltaTime = (now - this.startTime) * speed; // console.log(now, this.startTime, deltaTime, this.startDelay);

      var remainingTime = _tools_math__WEBPACK_IMPORTED_MODULE_1__["round"](-(this.duration + this.startDelay - deltaTime), this.precision);

      if (deltaTime >= this.startDelay) {
        var deltaTimeAfterDelay = deltaTime - this.startDelay;

        if (deltaTimeAfterDelay >= this.duration) {
          remainingTime = deltaTimeAfterDelay - this.duration;
          deltaTimeAfterDelay = this.duration;
        }

        if (this.beforeFrame) {
          this.beforeFrame(deltaTimeAfterDelay / this.duration);
        } // console.log(deltaTimeAfterDelay)


        this.setFrame(deltaTimeAfterDelay);

        if (this.afterFrame) {
          this.afterFrame(deltaTimeAfterDelay / this.duration);
        }

        if (remainingTime >= 0) {
          this.finish();
        }
      }

      return remainingTime;
    }
    /**
     * Get remaining duration of the animation.
     * @param {number} now define this if you want remaining duration from a
     * custom time
     */

  }, {
    key: "getRemainingTime",
    value: function getRemainingTime() {
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_4__["default"]().now() / 1000;
      var totalDuration = this.getTotalDuration();

      if (this.startTime == null) {
        if (this.state === 'animating' || this.state === 'waitingToStart') {
          return totalDuration;
        }

        return 0;
      }

      var deltaTime = now - this.startTime;
      return this.duration + this.startDelay - deltaTime;
    } // getRemainingTime(now: number = performance.now()){
    //   if (this.startTime == null) {
    //     return 0;
    //   }
    //   const deltaTime = now - this.startTime;
    //   return this.duration + this.startDelay - deltaTime;
    // }

  }, {
    key: "getTotalDuration",
    value: function getTotalDuration() {
      return this.duration + this.startDelay;
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {}
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      this.state = 'waitingToStart';
    }
    /**
     * Start animation
     * @param {AnimationStartTime} startTime
     */

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.state = 'animating';

      if (typeof startTime === 'number' || startTime == null) {
        this.startTime = startTime;
        return;
      }

      if (startTime === 'nextFrame') {
        this.startTime = null;
        return;
      }

      var globalAnim = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_4__["default"]();
      this.startTime = globalAnim.getWhen(startTime) / 1000; // if (startTime === 'prev') {
      //   this.startTime = new GlobalAnimation().lastFrame;
      // }
      // this.startTime = new GlobalAnimation().now() / 1000;
    }
  }, {
    key: "finishIfZeroDuration",
    value: function finishIfZeroDuration() {
      if (this.duration === 0 && this.startDelay === 0) {
        this.finish();
      }
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setToEnd",
    value: function setToEnd() {} // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // this.startTime = -2;
      // this.onFinish(false);
      if (this.state === 'idle' || this.state === 'finished') {
        return;
      }

      var oldState = this.state;
      this.state = 'finished';

      if (cancelled) {
        if (force === 'complete') {
          if (oldState === 'waitingToStart') {
            this.start();
          }

          this.setToEnd();
        } else if (force == null && this.completeOnCancel === true) {
          if (oldState === 'waitingToStart') {
            this.start();
          }

          this.setToEnd();
        } else if (oldState === 'waitingToStart') {
          this.cancelledWithNoComplete();
        }
      }

      if (cancelled === false) {
        if (oldState === 'waitingToStart') {
          this.start();
        }

        this.setToEnd();
      }

      if (this.onFinish != null) {
        this.fnExec(this.onFinish, cancelled); // this.onFinish(cancelled);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "cancelledWithNoComplete",
    value: function cancelledWithNoComplete() {}
  }, {
    key: "cancel",
    value: function cancel() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.finish(true, force);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new AnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step);
      return step;
    }
  }, {
    key: "whenFinished",
    value: function whenFinished(callback) {
      this.onFinish = callback;
      return this;
    }
  }, {
    key: "ifCanceledThenComplete",
    value: function ifCanceledThenComplete() {
      this.completeOnCancel = true;
      return this;
    }
  }, {
    key: "ifCancelled",
    value: function ifCancelled() {
      var then = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'freeze';

      if (then === 'complete') {
        this.completeOnCancel = true;
      } else {
        this.completeOnCancel = false;
      }

      return this;
    }
  }, {
    key: "ifCanceledThenStop",
    value: function ifCanceledThenStop() {
      this.completeOnCancel = false;
      return this;
    }
  }]);

  return AnimationStep;
}();



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/CustomStep.js":
/*!*************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/CustomStep.js ***!
  \*************************************************************/
/*! exports provided: CustomAnimationStep, custom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomAnimationStep", function() { return CustomAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "custom", function() { return custom; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/figure/Animation/AnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import * as tools from '../../../tools/math';



/**
 * Custom animation step
 *
 * ![](./apiassets/custom_animation.gif)
 *
 * Custom animation steps are useful for orchestrating complex animations, or
 * performing non-linear animations.
 *
 * This step will execute a custom callback function on each animation frame
 * for the duration of the animation. The callback function will be passed the
 * percentage progress of the animation.
 *
 * The percentage progress can either be linear with time, or non-linear.
 * Built-in non-linear progressions are `'easeinout'`, `'easein`' and
 * `'easeout'` which will slow progress at the start or end of the animation.
 * A function to create a custom non-linear progressor can also be used.
 *
 * @extends AnimationStep
 *
 * @param {OBJ_CustomAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Move an object through a sine wave of wavelength 1 from
 * // x = -1 to x = 1
 * function sine(percentComplete) {
 *   const x = -1 + percentComplete * 2;
 *   const y = 0.5 * Math.sin(Math.PI * 2 * x);
 *   p.setPosition(x, y);
 * }
 *
 * p.animations.new()
 *   .custom({ callback: sine, duration: 5 })
 *   .start();
 */
var CustomAnimationStep = /*#__PURE__*/function (_AnimationStep) {
  _inherits(CustomAnimationStep, _AnimationStep);

  var _super = _createSuper(CustomAnimationStep);

  /**
   * @hideconstructor
   */
  function CustomAnimationStep() {
    var _this;

    _classCallCheck(this, CustomAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var AnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}].concat(optionsIn));
    _this = _super.call(this, AnimationStepOptionsIn);
    var defaultPositionOptions = {
      element: null,
      callback: null,
      startPercent: 0,
      progression: 'linear'
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn));
    _this.element = options.element;
    _this.progression = options.progression;

    if (_this.progression === 'linear') {
      _this.progression = 'tools.math.linear';
    } else if (options.progression === 'easein') {
      _this.progression = 'tools.math.easein';
    } else if (options.progression === 'easeout') {
      _this.progression = 'tools.math.easeout';
    } else if (options.progression === 'easeinout') {
      _this.progression = 'tools.math.easeinout';
    }

    _this.callback = options.callback;
    _this.startPercent = options.startPercent; // if (typeof this.progression === 'function') {
    //   this.startTimeOffset = this.progression(options.startPercent, true) * options.duration;
    // }

    _this.startTimeOffset = _this.getPercentComplete(options.startPercent, true) * options.duration;
    _this.duration = options.duration;
    return _this;
  } // fnExec(idOrFn: string | Function | null, ...args: any) {
  //   const result = this.fnMap.exec(idOrFn, ...args);
  //   if (result == null && this.element != null) {
  //     return this.element.fnMap.exec(idOrFn, ...args);
  //   }
  //   return result;
  // }


  _createClass(CustomAnimationStep, [{
    key: "fnExec",
    value: function fnExec(idOrFn) {
      var _this$fnMap2;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      // const result = this.fnMap.exec(idOrFn, ...args);
      // if (result == null && this.element != null) {
      //   return this.element.fnMap.exec(idOrFn, ...args);
      // }
      // return result;
      if (this.element != null) {
        var _this$fnMap;

        return (_this$fnMap = this.fnMap).execOnMaps.apply(_this$fnMap, [idOrFn, [this.element.fnMap.map]].concat(args));
      }

      return (_this$fnMap2 = this.fnMap).exec.apply(_this$fnMap2, [idOrFn].concat(args));
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(CustomAnimationStep.prototype), "_getStateProperties", this).call(this)), ['callback', 'startPercent', 'progression']);
    }
  }, {
    key: "_fromState",
    value: function _fromState(state, getElement) {
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])(this, state);

      if (this.element != null && typeof this.element === 'string' && getElement != null) {
        this.element = getElement(this.element);
      }

      return this;
    }
  }, {
    key: "_state",
    value: function _state(options) {
      var state = _get(_getPrototypeOf(CustomAnimationStep.prototype), "_state", this).call(this, options);

      if (this.element != null) {
        state.state.element = {
          f1Type: 'de',
          state: this.element.getPath()
        };
      }

      return state;
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'customAnimationStep';
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.getPercentComplete(percentTime);
      this.fnExec(this.callback, percentComplete);
    }
  }, {
    key: "getPercentComplete",
    value: function getPercentComplete(percentTime) {
      var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (typeof this.progression === 'string') {
        var result = this.fnExec(this.progression, percentTime, invert);

        if (result == null) {
          return 0;
        }

        return result;
      }

      if (typeof this.progression === 'function') {
        return this.progression(percentTime);
      }

      return 0;
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      this.fnExec(this.callback, 1);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new CustomAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return CustomAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
function custom() {
  for (var _len3 = arguments.length, optionsIn = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    optionsIn[_key3] = arguments[_key3];
  }

  return _construct(CustomAnimationStep, optionsIn);
}

/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/DelayStep.js":
/*!************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/DelayStep.js ***!
  \************************************************************/
/*! exports provided: DelayAnimationStep, delay */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DelayAnimationStep", function() { return DelayAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "delay", function() { return delay; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/figure/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import * as tools from '../../tools/math';
// import { FigureElement } from '../Element';

 // export type OBJ_AnimationStep = {
//   duration?: number;
// } & OBJ_AnimationStep;

/**
 * Delay animation step
 *
 * While all animations steps accept a delay property,
 * having this step sometimes makes the animation seem
 * more readable.
 *
 * @param {number | OBJ_AnimationStep} delayOrOptions
 * @extends AnimationStep
 */

var DelayAnimationStep = /*#__PURE__*/function (_AnimationStep) {
  _inherits(DelayAnimationStep, _AnimationStep);

  var _super = _createSuper(DelayAnimationStep);

  /**
   * @hideconstructor
   */
  function DelayAnimationStep() {
    var numOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DelayAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 0
    };

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (typeof numOrOptions === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: numOrOptions
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, numOrOptions].concat(args));
    }

    return _super.call(this, options); // this.duration = options.duration;
  }

  _createClass(DelayAnimationStep, [{
    key: "_dup",
    value: function _dup() {
      var dup = new DelayAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, dup);
      return dup;
    } // _getStateProperties() {  // eslint-disable-line class-methods-use-this
    //   return [...super._getStateProperties(),
    //     'callback',
    //     'startPercent',
    //     'progression',
    //   ];
    // }

  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'delayAnimationStep';
    }
  }]);

  return DelayAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function delay() {
  var numOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return _construct(DelayAnimationStep, [numOrOptionsIn].concat(args));
}

/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js":
/*!***********************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ElementAnimationStep; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/figure/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import * as tools from '../../../tools/math';
// import { FigureElement } from '../../Element';



/**
 * Animation Step tied to an element
 *
 * Default values for the animation step will then come from this element.
 *
 * @extends AnimationStep
 */
var ElementAnimationStep = /*#__PURE__*/function (_AnimationStep) {
  _inherits(ElementAnimationStep, _AnimationStep);

  var _super = _createSuper(ElementAnimationStep);

  function ElementAnimationStep() {
    var _this;

    var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ElementAnimationStep);

    _this = _super.call(this, optionsIn);
    var defaultProgression = 'easeinout';

    if (optionsIn.type === 'color' || optionsIn.type === 'custom' || optionsIn.type === 'opacity') {
      defaultProgression = 'linear';
    }

    var defaultOptions = {
      element: null,
      type: 'custom',
      progression: defaultProgression,
      duration: 0
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
    _this.element = options.element;
    _this.type = options.type;
    _this.onFinish = options.onFinish;
    _this.duration = options.duration;
    _this.progression = options.progression;

    if (_this.progression === 'linear') {
      _this.progression = 'tools.math.linear';
    } else if (options.progression === 'easein') {
      _this.progression = 'tools.math.easein';
    } else if (options.progression === 'easeout') {
      _this.progression = 'tools.math.easeout';
    } else if (options.progression === 'easeinout') {
      _this.progression = 'tools.math.easeinout';
    } else {
      _this.progression = options.progression;
    }

    return _this;
  }

  _createClass(ElementAnimationStep, [{
    key: "fnExec",
    value: function fnExec(idOrFn) {
      var _this$fnMap2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // const result = this.fnMap.exec(idOrFn, ...args);
      // if (result == null && this.element != null) {
      //   return this.element.fnMap.exec(idOrFn, ...args);
      // }
      // return result;
      if (this.element != null) {
        var _this$fnMap;

        return (_this$fnMap = this.fnMap).execOnMaps.apply(_this$fnMap, [idOrFn, [this.element.fnMap.map]].concat(args));
      }

      return (_this$fnMap2 = this.fnMap).exec.apply(_this$fnMap2, [idOrFn].concat(args));
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      // console.log('elementstep');
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(ElementAnimationStep.prototype), "_getStateProperties", this).call(this)), [// 'element',
      'type', // 'duration',
      'progression']);
    }
  }, {
    key: "_fromState",
    value: function _fromState(state, getElement) {
      // const obj = new this.constructor();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(this, state);

      if (this.element != null && typeof this.element === 'string' && getElement != null) {
        this.element = getElement(this.element);
      }

      return this;
    }
  }, {
    key: "_state",
    value: function _state(options) {
      var state = _get(_getPrototypeOf(ElementAnimationStep.prototype), "_state", this).call(this, options);

      if (this.element != null) {
        state.state.element = {
          f1Type: 'de',
          state: this.element.getPath()
        };
      } // if (this.element != null) {
      //   definition.state.element = this.element.getPath();
      // }


      return state;
    }
  }, {
    key: "getPercentComplete",
    value: function getPercentComplete(percentTime) {
      if (typeof this.progression === 'string') {
        var result = this.fnExec(this.progression, percentTime);

        if (result == null) {
          return 0;
        }

        return result;
      }

      if (typeof this.progression === 'function') {
        return this.progression(percentTime);
      }

      return 0;
    }
  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(ElementAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.element != null) {
        this.element.animateNextFrame();
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ElementAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ElementAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js":
/*!******************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ColorAnimationStep.js ***!
  \******************************************************************************************/
/*! exports provided: ColorAnimationStep, DimAnimationStep, dim, UndimAnimationStep, undim */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorAnimationStep", function() { return ColorAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DimAnimationStep", function() { return DimAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dim", function() { return dim; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UndimAnimationStep", function() { return UndimAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "undim", function() { return undim; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import {
//   Transform, Point, getMaxTimeFromVelocity,
// } from '../../../../tools/g2';
 // import * as tools from '../../../../tools/math';



var addColors = function addColors(color1, color2) {
  return color1.map(function (c, index) {
    return Math.min(c + color2[index], 1);
  });
};

var subtractColors = function subtractColors(color1, color2) {
  return color1.map(function (c, index) {
    return c - color2[index];
  });
};
/**
 * Color animation Step
 *
 * ![](./apiassets/color_animation.gif)
 *
 * By default, the color will start with the element's current color.
 *
 * Use either `delta` or `target` to define the end color
 *
 * In an interactive figure, it is often useful to highlight elements of the
 * figure by coloring them and greying out, or dimming the elements not of
 * interest. As such, a {@link FigureElement} has several color attributes:
 * - color - current color
 * - dimColor - color to dim to
 * - defaultColor - color to undim to
 *
 * The `target` property can accept `'dim'` and `'undim'` as shortcuts to dim
 * or undim the element.
 *
 * In addition, the {@link DimAnimationStep} and {@link UndimAnimationStep} can
 * be used to do the same, which is especially useful when trying to build
 * easy to read code in a complex animation.
 *
 * @extends ElementAnimationStep
 * @param {OBJ_ColorAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Using duration
 * p.animations.new()
 *   .color({ target: [0, 0, 1, 1], duration: 1 })
 *   .color({ target: [0, 0.8, 0, 1], duration: 1 })
 *   .color({ target: [1, 0, 0, 1], duration: 1 })
 *   .start();
 *
 * @example
 * // dim and undim an element using dim and undim animation steps
 * p.animations.new()
 *   .dim(1)
 *   .delay(1)
 *   .undim(1)
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.color({
 *   target: [0, 0, 1, 1],
 *   duration: 2,
 * });
 * const step2 = new Fig.Animation.ColorAnimationStep({
 *   element: p,
 *   target: [0, 0.8, 0, 1],
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .then(step2)
 *   .start();
 */


var ColorAnimationStep = /*#__PURE__*/function (_ElementAnimationStep) {
  _inherits(ColorAnimationStep, _ElementAnimationStep);

  var _super = _createSuper(ColorAnimationStep);

  /**
   * @hideconstructor
   */
  function ColorAnimationStep() {
    var _this;

    _classCallCheck(this, ColorAnimationStep);

    for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
      options[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}].concat(options, [{
      type: 'color'
    }]));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'dissolve']);
    _this = _super.call(this, ElementAnimationStepOptionsIn);
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      dissolve: null
    };
    var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(options)); // $FlowFixMe

    _this.color = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["copyKeysFromTo"])(optionsToUse, _this.color, ['start', 'delta', 'target', 'dissolve']);

    if (_this.color.target === 'dim') {
      if (_this.element != null) {
        _this.color.target = _this.element.dimColor.slice();
      }

      _this.color.setDefault = false;
    } else if (_this.color.target === 'undim') {
      if (_this.element != null) {
        _this.color.target = _this.element.defaultColor.slice();
      }

      _this.color.setDefault = false;
    } else {
      _this.color.setDefault = true;
    }

    return _this;
  }

  _createClass(ColorAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(ColorAnimationStep.prototype), "_getStateProperties", this).call(this)), ['color']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'colorAnimationStep';
    } // On start, calculate the duration, target and delta if not already present.
    // This is done here in case the start is defined as null meaning it is
    // going to start from present transform.
    // Setting a duration to 0 will effectively skip this animation step

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var element = this.element; // console.log('starting', element)

      if (element != null) {
        _get(_getPrototypeOf(ColorAnimationStep.prototype), "start", this).call(this, startTime);

        if (this.color.start == null) {
          this.color.start = element.color.slice();
        }

        if (this.color.delta == null && this.color.target == null) {
          this.color.target = this.color.start.slice();
        } else if (this.color.delta != null) {
          this.color.target = addColors(this.color.start, this.color.delta);
        }

        this.color.whenComplete = this.color.target.slice();

        if (this.color.dissolve === 'out') {
          this.color.target[3] = 0.001;
        }

        if (this.color.dissolve === 'in') {
          this.color.start[3] = 0.001;
          element.setColor(this.color.start, this.color.setDefault);
          element.showAll();
        }

        this.color.delta = subtractColors(this.color.target, this.color.start);
      } else {
        this.duration = 0;
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var _this2 = this;

      var percentTime = deltaTime / this.duration;
      var percentComplete = this.getPercentComplete(percentTime);
      var p = percentComplete;
      var next = this.color.start.map(function (c, index) {
        var newColor = c + _this2.color.delta[index] * p;

        if (newColor > 1) {
          newColor = 1;
        }

        if (newColor < 0) {
          newColor = 0;
        }

        return newColor;
      });

      if (this.element != null) {
        // console.log(this.element.name, next)
        this.element.setColor(next, this.color.setDefault);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        // console.log(this.name, this.color.whenComplete)
        element.setColor(this.color.whenComplete, this.color.setDefault);

        if (this.color.dissolve === 'out') {
          element.hide();
        }
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ColorAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ColorAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Dim color animation step
 *
 * ![](./apiassets/dim_animation.gif)
 *
 * Animates color of element to the `dimColor` property of {@link FigureElement}
 *
 * @extends ColorAnimationStep
 * @param {number | OBJ_ElementAnimationStep} durationOrOptions
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Simple dim
 * p.animations.new()
 *   .dim(2)
 *   .start();
 *
 * @example
 * // Dim using options object
 * p.animations.new()
 *   .dim({ delay: 1, duration: 2 })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.dim(2);
 * const step2 = new Fig.Animation.DimAnimationStep({
 *   element: p,
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .undim(1)
 *   .then(step2)
 *   .start();
 */

var DimAnimationStep = /*#__PURE__*/function (_ColorAnimationStep) {
  _inherits(DimAnimationStep, _ColorAnimationStep);

  var _super2 = _createSuper(DimAnimationStep);

  /**
   * @hideconstructor
   */
  function DimAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DimAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      target: 'dim',
      completeOnCancel: true
    };

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _super2.call(this, options);
  }

  return DimAnimationStep;
}(ColorAnimationStep);
function dim() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return _construct(DimAnimationStep, [timeOrOptionsIn].concat(args));
}
/**
 * Undim color animation step
 *
 * ![](./apiassets/undim_animation.gif)
 *
 * Animates color of element to the `defaultColor` property of {@link FigureElement}
 *
 * @extends ColorAnimationStep
 * @param {number | OBJ_ElementAnimationStep} durationOrOptions
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Simple undim
 * p.dim();
 * p.animations.new()
 *   .undim(2)
 *   .start();
 *
 * @example
 * // Undim using options object
 * p.dim();
 * p.animations.new()
 *   .undim({ delay: 1, duration: 2 })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.undim(2);
 * const step2 = new Fig.Animation.UndimAnimationStep({
 *   element: p,
 *   duration: 2,
 * });
 *
 * p.dim();
 * p.animations.new()
 *   .then(step1)
 *   .dim(1)
 *   .then(step2)
 *   .start();
 */

var UndimAnimationStep = /*#__PURE__*/function (_ColorAnimationStep2) {
  _inherits(UndimAnimationStep, _ColorAnimationStep2);

  var _super3 = _createSuper(UndimAnimationStep);

  /**
   * @hideconstructor
   */
  function UndimAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, UndimAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      target: 'undim',
      completeOnCancel: true
    };

    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _super3.call(this, options);
  }

  return UndimAnimationStep;
}(ColorAnimationStep);
function undim() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return _construct(UndimAnimationStep, [timeOrOptionsIn].concat(args));
} // export class DissolveInAnimationStep extends ColorAnimationStep {
//   constructor(
//     timeOrOptionsIn: number | OBJ_ElementAnimationStep = {},
//     ...args: Array<OBJ_ElementAnimationStep>
//   ) {
//     let options = {};
//     const defaultOptions = { duration: 1, dissolve: 'in', completeOnCancel: true };
//     if (typeof timeOrOptionsIn === 'number') {
//       options = joinObjects({}, defaultOptions, { duration: timeOrOptionsIn }, ...args);
//     } else {
//       options = joinObjects({}, defaultOptions, timeOrOptionsIn, ...args);
//     }
//     super(options);
//   }
// }
// export function dissolveIn(
//   timeOrOptionsIn: number | OBJ_ColorAnimationStep = {},
//   ...args: Array<OBJ_ColorAnimationStep>
// ) {
//   return new DissolveInAnimationStep(timeOrOptionsIn, ...args);
// }
// export class DissolveOutAnimationStep extends ColorAnimationStep {
//   constructor(
//     timeOrOptionsIn: number | OBJ_ElementAnimationStep = {},
//     ...args: Array<OBJ_ElementAnimationStep>
//   ) {
//     let options = {};
//     const defaultOptions = { duration: 1, dissolve: 'out', completeOnCancel: true };
//     if (typeof timeOrOptionsIn === 'number') {
//       options = joinObjects({}, defaultOptions, { duration: timeOrOptionsIn }, ...args);
//     } else {
//       options = joinObjects({}, defaultOptions, timeOrOptionsIn, ...args);
//     }
//     super(options);
//   }
// }
// export function dissolveOut(
//   timeOrOptionsIn: number | OBJ_ColorAnimationStep = {},
//   ...args: Array<OBJ_ColorAnimationStep>
// ) {
//   return new DissolveOutAnimationStep(timeOrOptionsIn, ...args);
// }

/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js":
/*!********************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/OpacityAnimationStep.js ***!
  \********************************************************************************************/
/*! exports provided: OpacityAnimationStep, DissolveInAnimationStep, dissolveIn, DissolveOutAnimationStep, dissolveOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OpacityAnimationStep", function() { return OpacityAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DissolveInAnimationStep", function() { return DissolveInAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dissolveIn", function() { return dissolveIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DissolveOutAnimationStep", function() { return DissolveOutAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dissolveOut", function() { return dissolveOut; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import {
//   Transform, Point, getMaxTimeFromVelocity,
// } from '../../../../tools/g2';
// import * as tools from '../../../../tools/math';



/**
 * Opacity Animation Step
 *
 * ![](./apiassets/opacity_animation.gif)
 *
 * A {@link FigureElement} has `color` and `opacity` properties. The `color`
 * property has an alpha channel that defines opacity, but it should be used
 * as a base color definition, and not used to dissolve an element in and out.
 *
 * Therefore, to animate an element's opacity or temporarily dissolve in or out
 * an element, use an opacity animation step.
 *
 * The `opacity` is multiplied by the
 * `color` alpha channel to get the final opacity of the element.
 *
 * By default, the opacity will start with the {@link FigureElement}'s current
 * opacity unless dissolving. If dissolving, the opacity will start at `0` if
 * dissolving in, or `1` if dissolving out unless `dissolveFromCurrent` is
 * `true` in which case the opacity will start from the current opacity.
 *
 * The {@link DissolveInAnimationStep} and {@link DissolveOutAnimationStep}
 * extend the `OpacityAnimationStep` to make it even more convenient to
 * dissolve.
 *
 * @extends ElementAnimationStep
 * @param {OBJ_OpacityAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Using numerical values for opacity
 * p.animations.new()
 *   .opacity({ target: 0.4, duration: 2 })
 *   .opacity({ target: 1, duration: 2 })
 *   .start();
 *
 * @example
 * // Dissolve out then in
 * p.animations.new()
 *   .opacity({ dissolve: 'out', duration: 2 })
 *   .opacity({ dissolve: 'in', duration: 2 })
 *   .start();
 *
 * @example
 * // Using the dissolve animation step
 * p.animations.new()
 *   .dissolveOut(2)
 *   .dissolveIn({ delay: 1, duration: 2 })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.opacity({
 *   target: 0,
 *   duration: 2,
 * });
 * const step2 = new Fig.Animation.OpacityAnimationStep({
 *   element: p,
 *   target: 1,
 *   duration: 2,
 * });
 * const step3 = p.animations.dissolveOut({
 *   duration: 2,
 * });
 * const step4 = new Fig.Animation.DissolveInAnimationStep({
 *   element: p,
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .then(step2)
 *   .then(step3)
 *   .then(step4)
 *   .start();
 */
var OpacityAnimationStep = /*#__PURE__*/function (_ElementAnimationStep) {
  _inherits(OpacityAnimationStep, _ElementAnimationStep);

  var _super = _createSuper(OpacityAnimationStep);

  /**
   * @hideconstructor
   */
  function OpacityAnimationStep() {
    var _this;

    _classCallCheck(this, OpacityAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}].concat(optionsIn, [{
      type: 'opacity'
    }]));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'dissolve', 'dissolveFromCurrent']);
    _this = _super.call(this, ElementAnimationStepOptionsIn);
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      dissolve: null,
      dissolveFromCurrent: false
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.opacity = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["copyKeysFromTo"])(options, _this.opacity, ['start', 'delta', 'target', 'dissolve', 'dissolveFromCurrent']);
    return _this;
  }

  _createClass(OpacityAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(OpacityAnimationStep.prototype), "_getStateProperties", this).call(this)), ['opacity']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'opacityAnimationStep';
    } // On start, calculate the duration, target and delta if not already present.
    // This is done here in case the start is defined as null meaning it is
    // going to start from present transform.
    // Setting a duration to 0 will effectively skip this animation step

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var element = this.element;

      if (element != null) {
        _get(_getPrototypeOf(OpacityAnimationStep.prototype), "start", this).call(this, startTime);

        if (this.opacity.start == null) {
          // eslint-disable-next-line prefer-destructuring
          this.opacity.start = element.opacity;
        } else if (startTime === 'now' || startTime === 'prevFrame') {
          element.setOpacity(this.opacity.start);
        }

        if (this.opacity.delta == null && this.opacity.target == null) {
          this.opacity.target = this.opacity.start;
        } else if (this.opacity.delta != null) {
          this.opacity.target = this.opacity.start + this.opacity.delta;
        }

        this.opacity.whenComplete = this.opacity.target;

        if (this.opacity.dissolve === 'out') {
          if (this.opacity.dissolveFromCurrent) {
            if (element.isShown) {
              this.opacity.start = element.opacity;
            } else {
              this.opacity.start = 1;
            }
          } else {
            this.opacity.start = 1;
          }

          this.opacity.target = 0.001;
          this.opacity.whenComplete = 1;
          element.setOpacity(this.opacity.start);
        }

        if (this.opacity.dissolve === 'in') {
          if (this.opacity.dissolveFromCurrent) {
            if (element.isShown) {
              this.opacity.start = element.opacity;
            } else {
              this.opacity.start = 0.001;
            }
          } else {
            this.opacity.start = 0.001;
          } // this.opacity.start = 0.001;


          this.opacity.target = 1;
          this.opacity.whenComplete = 1;
          element.showAll();
          element.setOpacity(this.opacity.start);
        }

        this.opacity.delta = this.opacity.target - this.opacity.start;
      } else {
        this.duration = 0;
      }
    }
  }, {
    key: "cancelledWithNoComplete",
    value: function cancelledWithNoComplete() {
      var element = this.element;

      if (element != null) {
        if (element.opacity === 0.001) {
          element.hide();
          element.opacity = 1;
        }
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.getPercentComplete(percentTime);
      var p = percentComplete;
      var next = this.opacity.start + this.opacity.delta * p;

      if (next > 1) {
        next = 1;
      }

      if (next < 0) {
        next = 0;
      }

      if (this.element != null) {
        this.element.setOpacity(next);
      }
    } // cancelledWithNoComplete() {
    //   const { element } = this;
    //   console.log('cancel with no complete')
    //   if (element != null) {
    //     if (this.color.fullOpacity) {
    //       element.setColor([...element.color.slice(0, 3), 1]);
    //     }
    //   }
    // }

  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        // console.log(this.name, this.color.whenComplete)
        element.setOpacity(this.opacity.whenComplete);

        if (this.opacity.dissolve === 'out') {
          element.hide();
        }
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new OpacityAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return OpacityAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
/**
 * Dissolve in animation step
 *
 * ![](./apiassets/dissolvein_animation.gif)
 *
 * Animates opacity of element to dissolve in.
 *
 * @extends OpacityAnimationStep
 * @param {number | OBJ_ElementAnimationStep} durationOrOptions
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Simple dissolve in
 * p.setOpacity(0)
 * p.animations.new()
 *   .dissolveIn(2)
 *   .start();
 *
 * @example
 * // Dissolve in using options object
 * p.setOpacity(0);
 * p.animations.new()
 *   .dissolveIn({ delay: 1, duration: 2 })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.dissolveIn(2);
 * const step2 = new Fig.Animation.DissolveInAnimationStep({
 *   element: p,
 *   duration: 2,
 * });
 *
 * p.setOpacity(0);
 * p.animations.new()
 *   .then(step1)
 *   .dissolveOut(1)
 *   .then(step2)
 *   .start();
 */

var DissolveInAnimationStep = /*#__PURE__*/function (_OpacityAnimationStep) {
  _inherits(DissolveInAnimationStep, _OpacityAnimationStep);

  var _super2 = _createSuper(DissolveInAnimationStep);

  /**
   * @hideconstructor
   */
  function DissolveInAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DissolveInAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      dissolve: 'in',
      completeOnCancel: true
    };

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _super2.call(this, options);
  }

  return DissolveInAnimationStep;
}(OpacityAnimationStep);
function dissolveIn() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return _construct(DissolveInAnimationStep, [timeOrOptionsIn].concat(args));
}
/**
 * Dissolve out animation step
 *
 * ![](./apiassets/dissolveout_animation.gif)
 *
 * Animates opacity of element to dissolve out.
 *
 * @extends OpacityAnimationStep
 * @param {number | OBJ_ElementAnimationStep} durationOrOptions
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Simple dissolve out
 * p.animations.new()
 *   .dissolveOut(2)
 *   .start();
 *
 * @example
 * // Dissolve out using options object
 * p.animations.new()
 *   .dissolveOut({ delay: 1, duration: 2 })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.dissolveOut(2);
 * const step2 = new Fig.Animation.DissolveOutAnimationStep({
 *   element: p,
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .dissolveIn(1)
 *   .then(step2)
 *   .start();
 */

var DissolveOutAnimationStep = /*#__PURE__*/function (_OpacityAnimationStep2) {
  _inherits(DissolveOutAnimationStep, _OpacityAnimationStep2);

  var _super3 = _createSuper(DissolveOutAnimationStep);

  /**
   * @hideconstructor
   */
  function DissolveOutAnimationStep() {
    var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DissolveOutAnimationStep);

    var options = {};
    var defaultOptions = {
      duration: 1,
      dissolve: 'out',
      completeOnCancel: true
    };

    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }

    if (typeof timeOrOptionsIn === 'number') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, {
        duration: timeOrOptionsIn
      }].concat(args));
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
    }

    return _super3.call(this, options);
  }

  return DissolveOutAnimationStep;
}(OpacityAnimationStep);
function dissolveOut() {
  var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  return _construct(DissolveOutAnimationStep, [timeOrOptionsIn].concat(args));
}

/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js":
/*!*********************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PositionAnimationStep.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PositionAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * Position animation step
 *
 * ![](./apiassets/position_animation.gif)
 *
 * The position animation step animates the first {@link Translation} transform
 * in the {@link FigureElement}'s {@link Transform}.
 *
 * By default, the position will start with the element's current position.
 *
 * Use either `delta` or `target` to define it's end point.
 *
 * The path of travel between `start` and `target` can either be a straight
 * line (`'linear'`) or a quadratic bezier curve (`'curve'`)
 *
 * For custom paths, the {@link CustomAnimationStep} can be used.
 *
 *
 * @extends ElementAnimationStep
 *
 * @param {OBJ_PositionAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Using duration
 * p.animations.new()
 *   .position({ target: [1, 0], duration: 2 })
 *   .start()
 *
 * @example
 * // Using velocity
 * p.animations.new()
 *   .position({ target: [1, 0], velocity: 0.5 })
 *   .start()
 *
 * @example
 * // Linear and curved path
 * p.animations.new()
 *   .delay(1)
 *   .position({ target: [1, 0], duration: 2 })
 *   .position({
 *     target: [0, 0],
 *     duration: 2,
 *     path: {
 *       style: 'curve',
 *       magnitude: 0.8,
 *       direction: 'up',
 *     },
 *   })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.position({ target: [1, 0], duration: 2 });
 * const step2 = new Fig.Animation.PositionAnimationStep({
 *   element: p,
 *   target: [0, 0],
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .then(step2)
 *   .start();
 */
var PositionAnimationStep = /*#__PURE__*/function (_ElementAnimationStep) {
  _inherits(PositionAnimationStep, _ElementAnimationStep);

  var _super = _createSuper(PositionAnimationStep);

  /**
   * @hideconstructor
   */
  function PositionAnimationStep() {
    var _this;

    _classCallCheck(this, PositionAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'position'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'path', 'pathOptions', 'velocity', 'maxDuration']);
    _this = _super.call(this, ElementAnimationStepOptionsIn);
    _this._stepType = 'position';
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      path: {
        style: 'linear',
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: 'positive'
      },
      maxDuration: null,
      velocity: null
    };

    if (_this.element && _this.element.animations.options.translation) {
      var pathOptions = _this.element.animations.options.translation;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultPositionOptions.path, pathOptions);
    }

    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn));

    if (options.start != null) {
      options.start = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.start);
    }

    if (options.target != null) {
      options.target = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.target);
    }

    if (options.delta != null) {
      options.delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.delta);
    } // $FlowFixMe


    _this.position = {
      path: {}
    };
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.position, ['start', 'delta', 'target', 'path', 'velocity', 'maxDuration']); // duplicateFromTo(options.path, this.position.path);

    return _this;
  }

  _createClass(PositionAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(PositionAnimationStep.prototype), "_getStateProperties", this).call(this)), ['position']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'positionAnimationStep';
    } // On start, calculate the duration, target and delta if not already present.
    // This is done here in case the start is defined as null meaning it is
    // going to start from present transform.
    // Setting a duration to 0 will effectively skip this animation step

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(PositionAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.position.start == null) {
        if (this.element != null) {
          this.position.start = this.element.getPosition();
        } else {
          this.duration = 0;
          return;
        }
      } else if (startTime === 'now' || startTime === 'prevFrame') {
        if (this.element != null) {
          this.element.setPosition(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(this.position.start));
        }
      } // if delta is null, then calculate it from start and target


      if (this.position.delta == null && this.position.target != null && this.position.start != null) {
        var delta = this.position.target.sub(this.position.start);
        this.position.delta = delta;
      } else if (this.position.delta != null && this.position.start != null) {
        this.position.target = this.position.start.add(this.position.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var _this$position = this.position,
          target = _this$position.target,
          start = _this$position.start,
          velocity = _this$position.velocity;

      if (velocity != null && start != null && target != null) {
        var velocityToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(velocity);
        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(velocityToUse));
      }

      if (this.position.maxDuration != null) {
        if (this.duration > this.position.maxDuration) {
          this.duration = this.position.maxDuration;
        }
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      // console.log('setFrame', deltaTime);
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.getPercentComplete(percentTime);
      var p = percentComplete;

      if (this.position.delta != null && this.position.start != null) {
        var next = this.position.start.toDelta(this.position.delta, p, this.position.path.style, this.position.path);

        if (this.element != null) {
          this.element.setPosition(next);
        }
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null && this.position.target != null) {
        this.element.setPosition(this.position.target);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new PositionAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return PositionAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js":
/*!******************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PulseAnimationStep.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PulseAnimationStep; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




/**
 * Pulse animation step
 *
 * ![](./apiassets/pulse_animation.gif)
 *
 * The pulse animation step animates a pulse.
 *
 * The options are the same as those in the * <a href="#figureelementpulse">pulse</a> method.
 *
 * @extends ElementAnimationStep
 * @param {OBJ_RotationAnimationStep} options
 *
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Scale pulse, rotation pulse and translation pulse
 * p.animations.new()
 *   .pulse({
 *     scale: 1.5,
 *     duration: 1,
 *   })
 *   .pulse({
 *     duration: 1,
 *     rotation: 0.15,
 *     frequency: 4,
 *   })
 *   .pulse({
 *     duration: 1,
 *     translation: 0.02,
 *     min: -0.02,
 *     frequency: 4,
 *   })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.pulse({
 *   scale: 1.5,
 *   duration: 1,
 * });
 * const step2 = new Fig.Animation.PulseAnimationStep({
 *   element: p,
 *   rotation: 0.15,
 *   frequency: 4,
 * });
 * p.animations.new()
 *   .then(step1)
 *   .then(step2)
 *   .start();
 */
var PulseAnimationStep = /*#__PURE__*/function (_ElementAnimationStep) {
  _inherits(PulseAnimationStep, _ElementAnimationStep);

  var _super = _createSuper(PulseAnimationStep);

  // scale: number;
  // numLines: number;
  // frequency: number;
  function PulseAnimationStep() {
    var _this;

    _classCallCheck(this, PulseAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, {
      type: 'position'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["deleteKeys"])(ElementAnimationStepOptionsIn, ['stopAfterDuration', 'frequency', 'scale', 'rotation', 'translation', 'angle', 'min', 'centerOn', 'x', 'y', 'space', 'done', 'num', 'when', 'stopAfterDuration', 'velocity', 'maxDuration']);
    _this = _super.call(this, ElementAnimationStepOptionsIn);
    _this._stepType = 'pulse'; // const ElementAnimationStepOptionsIn =
    //   joinObjects({}, { type: 'pulse' }, ...optionsIn);
    // super(ElementAnimationStepOptionsIn);

    var defaultOptions = {
      scale: 2,
      rotation: null,
      translation: null,
      angle: 0,
      duration: 1,
      frequency: 0,
      xAlign: 'center',
      yAlign: 'middle',
      // centerOn: this,
      num: 1,
      space: 'figure',
      done: null,
      progression: 'sinusoid',
      when: 'syncNow',
      // scale: 1.5,
      // numLines: 1,
      type: 'pulse',
      // duration: 1,
      // frequency: 0,
      stopAfterDuration: true
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

    if (options.centerOn == null && _this.element != null) {
      options.centerOn = _this.element;
    }

    _this.pulse = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["copyKeysFromTo"])(options, _this.pulse, ['stopAfterDuration', 'frequency', 'scale', 'rotation', 'translation', 'angle', 'min', 'centerOn', 'x', 'y', 'space', 'done', 'num', 'when', 'stopAfterDuration', 'velocity', 'maxDuration', 'duration']);
    _this.pulse.centerOn = options.centerOn;
    _this.duration = options.duration;
    _this.toStart = true;
    return _this;
  }

  _createClass(PulseAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(PulseAnimationStep.prototype), "_getStateProperties", this).call(this)), ['scale', 'numLines', 'frequency', 'stopAfterDuration', 'toStart']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'pulseAnimationStep';
    }
  }, {
    key: "setFrame",
    value: function setFrame() {
      if (this.toStart) {
        var element = this.element;

        if (element != null) {
          element.pulse(this.pulse);
        }

        this.toStart = false;
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        if (this.pulse.stopAfterDuration) {
          this.element.stopPulsing();
        }
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new PulseAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return PulseAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PulseTransformAnimationStep.js":
/*!***************************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/PulseTransformAnimationStep.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PulseTransformAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






// A transform animation unit manages a transform animation on an element.
//
// The start transform can either be defined initially, or null. Null means
// the start transform is whatever the current element transform is when the
// unit is started with start().
//
// The transform target is defined with either the target or delta properties.
// Target is used to predefine the target.
// Delta is used to calculate the target when the unit is started with start()
//
var PulseTransformAnimationStep = /*#__PURE__*/function (_ElementAnimationStep) {
  _inherits(PulseTransformAnimationStep, _ElementAnimationStep);

  var _super = _createSuper(PulseTransformAnimationStep);

  function PulseTransformAnimationStep() {
    var _this;

    _classCallCheck(this, PulseTransformAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'transform'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'rotDirection', 'path', 'velocity', 'clipRotationTo', 'maxDuration', 'zeroDurationThreshold' // 'minDuration',
    ]);
    _this = _super.call(this, ElementAnimationStepOptionsIn);
    var defaultTransformOptions = {
      start: null,
      target: null,
      delta: [],
      path: {
        style: 'linear',
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: 'positive'
      },
      rotDirection: 0,
      velocity: null,
      clipRotationTo: null,
      maxDuration: null,
      // minDuration: 0,
      zeroDurationThreshold: 0
    };

    if (_this.element && _this.element.animations.options.translation) {
      var pathOptions = _this.element.animations.options.translation;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultTransformOptions.path, pathOptions);
    }

    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultTransformOptions].concat(optionsIn)); // $FlowFixMe

    _this.transform = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.transform, ['start', 'delta', 'target', 'path', 'velocity', 'rotDirection', 'clipRotationTo', 'maxDuration', 'zeroDurationThreshold' // 'minDuration',
    ]);
    return _this;
  } // If spreading to more transforms, add transforms to before start and after finish.
  // If adding an odd number, more will be added to before start.
  // If spreading to less transforms, subtract transforms from middle. If all but one
  // is being subtracted, then the start transform will be retained.
  // eslint-disable-next-line class-methods-use-this


  _createClass(PulseTransformAnimationStep, [{
    key: "spread",
    value: function spread(transforms, toNum) {
      if (toNum === transforms.length) {
        return transforms;
      }

      if (toNum <= 1) {
        return [transforms[0]];
      }

      var spreadTransforms = [];

      if (toNum > transforms.length) {
        var _delta = toNum - transforms.length;

        var _startNum = Math.ceil(_delta / 2);

        var _endNum = Math.floor(_delta / 2);

        var startTransform = transforms[0]._dup();

        var endTransform = transforms[transforms.length - 1]._dup();

        for (var i = 0; i < _startNum; i += 1) {
          spreadTransforms.push(startTransform._dup());
        }

        for (var _i = 0; _i < transforms.length; _i += 1) {
          spreadTransforms.push(transforms[_i]._dup());
        }

        for (var _i2 = 0; _i2 < _endNum; _i2 += 1) {
          spreadTransforms.push(endTransform._dup());
        }

        return spreadTransforms;
      }

      var delta = transforms.length - toNum;
      var startNum = Math.ceil((transforms.length - delta) / 2);
      var endNum = Math.floor((transforms.length - delta) / 2);

      for (var _i3 = 0; _i3 < startNum; _i3 += 1) {
        spreadTransforms.push(transforms[_i3]._dup());
      }

      for (var _i4 = transforms.length - endNum; _i4 < transforms.length; _i4 += 1) {
        spreadTransforms.push(transforms[_i4]._dup());
      }

      return spreadTransforms;
    }
  }, {
    key: "setStartAndTarget",
    value: function setStartAndTarget() {
      var _this$transform = this.transform,
          start = _this$transform.start,
          target = _this$transform.target;
      var numTransforms = Math.max(start.length, target.length);
      this.transform.start = this.spread(this.transform.start, numTransforms);
      this.transform.target = this.spread(this.transform.target, numTransforms);
    }
  }, {
    key: "calculateStartTargetDelta",
    value: function calculateStartTargetDelta() {
      var _this2 = this;

      if (this.transform.start.length !== this.transform.target.length) {
        this.transform.delta = [];
        return;
      }

      this.transform.delta = [];

      var _loop = function _loop(i) {
        var start = _this2.transform.start[i];
        var target = _this2.transform.target[i];
        var delta = target.sub(start);
        delta.order.forEach(function (deltaStep, index) {
          var startStep = start.order[index];
          var targetStep = target.order[index];

          if (deltaStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && startStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && targetStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"]) {
            var rotDiff = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getDeltaAngle"])(startStep.r, targetStep.r, _this2.transform.rotDirection); // eslint-disable-next-line no-param-reassign

            deltaStep.r = rotDiff;
          }
        });

        _this2.transform.delta.push(delta);
      };

      for (var i = 0; i < this.transform.start.length; i += 1) {
        _loop(i);
      }
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(PulseTransformAnimationStep.prototype), "_getStateProperties", this).call(this)), ['transform']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'transformAnimationStep';
    }
  }, {
    key: "getVelocityTransform",
    value: function getVelocityTransform() {
      // const { element } = this;
      // if (element == null) {
      //   return new Transform();
      // }
      var velocity = this.transform.velocity;

      if (velocity == null) {
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      }

      if (velocity instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
        return velocity;
      }

      if (typeof velocity === 'number') {
        return this.transform.start[0]._dup().constant(velocity);
      }

      var transformVelocity = this.transform.start[0]._dup().constant(1);

      if (velocity.transform != null) {
        transformVelocity = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(velocity.transform)._dup();
      }

      for (var i = 0; i < transformVelocity.order.length; i += 1) {
        var t = transformVelocity.order[i];

        if (t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Scale"] && velocity.scale != null) {
          var s = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getScale"])(velocity.scale);
          t.x = s.x;
          t.y = s.y;
        }

        if (t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] && velocity.translation != null) {
          var _s = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getScale"])(velocity.translation);

          t.x = _s.x;
          t.y = _s.y;
        }

        if (t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Translation"] && velocity.position != null) {
          var _s2 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getScale"])(velocity.position);

          t.x = _s2.x;
          t.y = _s2.y;
        }

        if (t instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && velocity.rotation != null) {
          t.r = velocity.rotation;
        }
      } // if (velocity.position != null) {
      //   transformVelocity.updateTranslation(getScale(velocity.position));
      // }
      // if (velocity.translation != null) {
      //   transformVelocity.updateTranslation(getScale(velocity.translation));
      // }
      // if (velocity.scale != null) {
      //   transformVelocity.updateScale(getScale(velocity.scale));
      // }
      // if (velocity.rotation != null) {
      //   transformVelocity.updateRotation(velocity.rotation);
      // }


      return transformVelocity;
    } // On start, calculate the duration, target and delta if not already present.
    // This is done here in case the start is defined as null meaning it is
    // going to start from present transform.
    // Setting a duration to 0 will effectively skip this animation step

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(PulseTransformAnimationStep.prototype), "start", this).call(this, startTime); // console.log(this.element.name, this.transform.start[0].order)
      // console.log(this.transform.target[0].order)


      if (this.transform.start == null || this.transform.start.length === 0) {
        if (this.element != null) {
          if (this.element.pulseTransforms.length > 0) {
            this.transform.start = this.element.pulseTransforms.map(function (t) {
              return t._dup();
            });
          } else {
            this.transform.start = [this.transform.target[0].identity()];
          }
        } else {
          this.duration = 0;
          return;
        }
      }

      if (this.transform.start.length === 0 && this.element != null) {
        this.transform.start = [this.element.transform._dup()];
      }

      this.setStartAndTarget(); // if delta is null, then calculate it from start and target

      this.calculateStartTargetDelta();

      if (this.transform.delta.length === 0) {
        this.duration = 0;
      } // console.log(this.transform)
      // If Velocity is defined, then use it to calculate duration


      if (this.transform.velocity != null) {
        var velocity = this.getVelocityTransform();

        for (var i = 0; i < this.transform.start.length; i += 1) {
          var start = this.transform.start[i];
          var target = this.transform.target[i];
          var duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(start, target, velocity, this.transform.rotDirection); // console.log(duration, start, target, velocity)

          if (duration > this.duration) {
            this.duration = duration;
          } // if (duration > 0) {
          //   this.duration = duration;
          // }

        }
      }

      if (this.transform.maxDuration != null) {
        if (this.duration > this.transform.maxDuration) {
          this.duration = this.transform.maxDuration;
        }
      }

      if (this.duration <= this.transform.zeroDurationThreshold) {
        this.duration = 0;
      } // if (this.duration < this.transform.minDuration) {
      //   this.duration = this.transform.minDuration;
      // }


      this.duration = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(this.duration, this.precision);

      if (startTime === 'now' || startTime === 'prevFrame') {
        this.setFrame(0);
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      // const start = phase.startTransform._dup();
      // const delta = phase.deltaTransform._dup();
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.getPercentComplete(percentTime);
      var p = percentComplete; // let next = delta._dup().constant(p);
      // next = start.add(delta.mul(next));

      if (this.element == null) {
        return;
      }

      var element = this.element;
      element.frozenPulseTransforms = [];

      for (var i = 0; i < this.transform.start.length; i += 1) {
        var next = this.transform.start[i].toDelta(this.transform.delta[i], p, this.transform.path.style, this.transform.path);

        if (this.transform.clipRotationTo !== null) {
          next.clipRotation(this.transform.clipRotationTo);
        }

        element.frozenPulseTransforms.push(next);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element == null) {
        return;
      }

      var element = this.element;
      element.frozenPulseTransforms = [];
      this.transform.target.forEach(function (t) {
        element.frozenPulseTransforms.push(t._dup());
      });
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new PulseTransformAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return PulseTransformAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_3__["default"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js":
/*!*********************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/RotationAnimationStep.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RotationAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





// A transform animation unit manages a transform animation on an element.
//
// The start transform can either be defined initially, or null. Null means
// the start transform is whatever the current element transform is when the
// unit is started with start().
//
// The transform target is defined with either the target or delta properties.
// Target is used to predefine the target.
// Delta is used to calculate the target when the unit is started with start()
//

/**
 * Rotation animation step
 *
 * ![](./apiassets/rotation_animation.gif)
 *
 * The rotation animation step animates the first {@link Rotation} transform
 * in the {@link FigureElement}'s {@link Transform}.
 *
 * By default, the rotation will start with the element's current rotation.
 *
 * Use either `delta` or `target` to define it's end point
 *
 * `clipTo` will clip the element's rotation during animation
 *
 * @extends ElementAnimationStep
 * @param {OBJ_RotationAnimationStep} options
 *
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Using duration
 * p.animations.new()
 *   .rotation({ target: Math.PI, duration: 2 })
 *   .start();
 *
 * @example
 * // Using velocity
 * p.animations.new()
 *   .rotation({ target: Math.PI, velocity: Math.PI / 2 })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.rotation({ target: Math.PI, duration: 2 });
 * const step2 = new Fig.Animation.RotationAnimationStep({
 *   element: p,
 *   target: 0,
 *   direction: -1,
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .then(step2)
 *   .start();
 */
var RotationAnimationStep = /*#__PURE__*/function (_ElementAnimationStep) {
  _inherits(RotationAnimationStep, _ElementAnimationStep);

  var _super = _createSuper(RotationAnimationStep);

  /**
   * @hideconstructor
   */
  function RotationAnimationStep() {
    var _this;

    _classCallCheck(this, RotationAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'rotation'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'direction', 'velocity', 'clipTo', 'maxDuration']);
    _this = _super.call(this, ElementAnimationStepOptionsIn);
    var defaultTransformOptions = {
      start: null,
      target: null,
      delta: null,
      direction: 0,
      velocity: null,
      clipTo: null,
      maxDuration: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultTransformOptions].concat(optionsIn)); // $FlowFixMe

    _this.rotation = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.rotation, ['start', 'delta', 'target', 'velocity', 'direction', 'clipTo', 'maxDuration']);
    return _this;
  }

  _createClass(RotationAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      var a = [].concat(_toConsumableArray(_get(_getPrototypeOf(RotationAnimationStep.prototype), "_getStateProperties", this).call(this)), ['rotation']); // console.log('rotationStep')

      return a;
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'rotationAnimationStep';
    } // On start, calculate the duration, target and delta if not already present.
    // This is done here in case the start is defined as null meaning it is
    // going to start from present transform.
    // Setting a duration to 0 will effectively skip this animation step

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(RotationAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.rotation.start === null) {
        if (this.element != null) {
          this.rotation.start = this.element.transform.r() || 0;
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.rotation.delta == null && this.rotation.target != null) {
        var delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getDeltaAngle"])(this.rotation.start, this.rotation.target, this.rotation.direction);
        this.rotation.delta = delta; // this.rotation.delta = this.rotation.target - this.rotation.start;
      } else if (this.rotation.delta != null) {
        this.rotation.target = this.rotation.start + this.rotation.delta;
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var velocity = this.rotation.velocity;

      if (velocity != null) {
        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(this.rotation.start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(this.rotation.target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(velocity), this.rotation.direction);
      }

      if (this.rotation.maxDuration != null) {
        if (this.duration > this.rotation.maxDuration) {
          this.duration = this.rotation.maxDuration;
        }
      }

      if (startTime === 'now' || startTime === 'prevFrame') {
        this.setFrame(0);
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.getPercentComplete(percentTime);
      var p = percentComplete;
      var nextR = this.rotation.start + this.rotation.delta * p;
      nextR = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(nextR, this.rotation.clipTo);
      var element = this.element;

      if (element != null) {
        element.setRotation(nextR);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      var element = this.element;

      if (element != null) {
        element.transform.updateRotation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(this.rotation.target, this.rotation.clipTo));
        this.fnExec(element.setTransformCallback, element.transform);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new RotationAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return RotationAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js":
/*!******************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ScaleAnimationStep.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScaleAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * Scale Animation Step
 *
 * ![](./apiassets/scale_animation.gif)
 *
 * The scale animation step animates the first {@link Scale} transform
 * in the {@link FigureElement}'s {@link Transform}.
 *
 * By default, the scale will start with the element's current scale.
 *
 * Use either `delta` or `target` to define it's end point.
 *
 * Scale can be defined as either a point or number. If number,
 * both x and y scale terms will be the same.
 *
 * @extends ElementAnimationStep
 * @param {OBJ_ScaleAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Using duration
 * p.animations.new()
 *   .scale({ target: 2, duration: 2 })
 *   .start();
 *
 * @example
 * // Using velocity
 * p.animations.new()
 *   .scale({ target: 2, velocity: 0.5 })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.scale({ target: 1.5, duration: 2 });
 * const step2 = new Fig.Animation.ScaleAnimationStep({
 *   element: p,
 *   target: 1,
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .then(step2)
 *   .start();
 */
var ScaleAnimationStep = /*#__PURE__*/function (_ElementAnimationStep) {
  _inherits(ScaleAnimationStep, _ElementAnimationStep);

  var _super = _createSuper(ScaleAnimationStep);

  /**
   * @hideconstructor
   */
  function ScaleAnimationStep() {
    var _this;

    _classCallCheck(this, ScaleAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'position'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'velocity', 'maxDuration']);
    _this = _super.call(this, ElementAnimationStepOptionsIn);
    var defaultPositionOptions = {
      start: null,
      target: null,
      delta: null,
      velocity: null,
      maxDuration: null
    };
    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultPositionOptions].concat(optionsIn)); // $FlowFixMe

    _this.scale = {};

    if (options.start != null) {
      options.start = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.start);
    }

    if (options.target != null) {
      options.target = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.target);
    }

    if (options.delta != null) {
      options.delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.delta);
    }

    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.scale, ['start', 'delta', 'target', 'path', 'velocity', 'maxDuration']);
    return _this;
  }

  _createClass(ScaleAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(ScaleAnimationStep.prototype), "_getStateProperties", this).call(this)), ['scale']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'scaleAnimationStep';
    } // On start, calculate the duration, target and delta if not already present.
    // This is done here in case the start is defined as null meaning it is
    // going to start from present transform.
    // Setting a duration to 0 will effectively skip this animation step

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(ScaleAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.scale.start === null) {
        if (this.element != null) {
          this.scale.start = this.element.getScale();
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.scale.delta == null && this.scale.target != null && this.scale.start != null) {
        var delta = this.scale.target.sub(this.scale.start);
        this.scale.delta = delta;
      } else if (this.scale.delta != null && this.scale.start != null) {
        this.scale.target = this.scale.start.add(this.scale.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      var _this$scale = this.scale,
          target = _this$scale.target,
          start = _this$scale.start,
          velocity = _this$scale.velocity;

      if (velocity != null && target != null && start != null) {
        var velocityToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(velocity); // if (typeof velocity === 'number') {
        //   velocityToUse = new Point(velocity, velocity);
        // }

        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(start), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(target), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(velocityToUse));
      }

      if (this.scale.maxDuration != null) {
        if (this.duration > this.scale.maxDuration) {
          this.duration = this.scale.maxDuration;
        }
      }

      if (startTime === 'now' || startTime === 'prevFrame') {
        this.setFrame(0);
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.getPercentComplete(percentTime);
      var p = percentComplete;

      if (this.scale.start != null && this.scale.delta != null) {
        var next = this.scale.start.toDelta(this.scale.delta, p);

        if (this.element != null) {
          this.element.setScale(next);
        }
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null && this.scale.target != null) {
        this.element.setScale(this.scale.target);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ScaleAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ScaleAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ScenarioAnimationStep.js":
/*!*********************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/ScenarioAnimationStep.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScenarioAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ParallelAnimationStep */ "./src/js/figure/Animation/AnimationStep/ParallelAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



// import ElementAnimationStep from '../ElementAnimationStep';
// import type { FigureElement } from '../../../Element';



/**
 * Scenario Animation Step
 *
 * ![](./apiassets/scenario_animation.gif)
 *
 * A scenario defines an element's transform and color and can be used to make
 * code more readable and reusable.
 *
 * By default, the scenario will start with the element's current transform and
 * color.
 *
 * @extends ElementAnimationStep
 * @param {OBJ_ScenarioAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // NOTE - use these scenario definitions for all examples below
 * p.scenarios['center'] = { position: [0, 0], scale: [1, 1], color: [1, 0, 0, 1] };
 * p.scenarios['right'] = { position: [1, 0], scale: [2, 1], color: [0, 0, 1, 1] };
 * p.scenarios['bottom'] = { position: [0, -0.5], scale: [0.5, 1], color: [0, 0.5, 0, 1] };
 *
 * @example
 * // Using duration
 * p.animations.new()
 *   .scenario({ target: 'right', duration: 2 })
 *   .scenario({ target: 'bottom', duration: 2 })
 *   .scenario({ target: 'center', duration: 2 })
 *   .start();
 *
 * @example
 * // Using velocity
 * p.animations.new()
 *   .scenario({
 *     target: 'right',
 *     velocity: { position: 0.5, scale: 0.2 },
 *   })
 *   .scenario({ target: 'bottom', velocity: { position: 0.5 } })
 *   .scenario({ target: 'center', velocity: { color: 0.2 } })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.scenario({
 *   target: 'right',
 *   duration: 2,
 * });
 * const step2 = new Fig.Animation.ScenarioAnimationStep({
 *   element: p,
 *   target: 'bottom',
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .then(step2)
 *   .start();
 */
var ScenarioAnimationStep = /*#__PURE__*/function (_ParallelAnimationSte) {
  _inherits(ScenarioAnimationStep, _ParallelAnimationSte);

  var _super = _createSuper(ScenarioAnimationStep);

  /**
   * @hideconstructor
   */
  function ScenarioAnimationStep() {
    var _this;

    _classCallCheck(this, ScenarioAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var AnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'scenario'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(AnimationStepOptionsIn, ['start', 'target', 'path', 'velocity', 'maxDuration', 'allDurationsSame', 'rotDirection', 'clipRotationTo', 'element', 'progression' // 'minDuration',
    ]);
    _this = _super.call(this, AnimationStepOptionsIn);
    _this._stepType = 'position';
    var defaultScenarioOptions = {
      element: null,
      start: null,
      target: null,
      path: {
        style: 'linear',
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: 'positive'
      },
      rotDirection: 0,
      clipRotationTo: null,
      velocity: null,
      maxDuration: null,
      allDurationsSame: true,
      zeroDurationThreshold: 0,
      progression: 'tools.math.easeinout' // minDuration: 0,

    };

    if (_this.element && _this.element.animations.options.translation) {
      var pathOptions = _this.element.animations.options.translation;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultScenarioOptions.path, pathOptions);
    }

    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultScenarioOptions].concat(optionsIn));
    _this.element = options.element; // $FlowFixMe

    _this.scenario = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.scenario, ['start', 'target', 'path', 'velocity', 'maxDuration', 'allDurationsSame', 'zeroDurationThreshold', 'rotDirection', 'clipRotationTo', 'progression' // 'minDuration',
    ]);
    return _this;
  }

  _createClass(ScenarioAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(ScenarioAnimationStep.prototype), "_getStateProperties", this).call(this)), ['scenario']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'scenarioAnimationStep';
    }
  }, {
    key: "getDuration",
    value: function getDuration(start, target) {
      var element = this.element;
      var velocity = this.scenario.velocity; // console.log(velocity)
      // console.log(this.duration)
      // console.log(element)

      if (velocity == null || element == null) {
        return [this.duration, this.duration, this.duration];
      }

      var transformVelocity = element.transform._dup().constant(1);

      var colorVelocity = velocity.color == null ? 1 : velocity.color;
      var opacityVelocity = velocity.opacity == null ? 1 : velocity.opacity;

      if (velocity.transform != null) {
        transformVelocity = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(velocity.transform)._dup();
      }

      if (velocity.position != null) {
        transformVelocity.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getScale"])(velocity.position));
      }

      if (velocity.translation != null) {
        transformVelocity.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getScale"])(velocity.translation));
      }

      if (velocity.scale != null) {
        transformVelocity.updateScale(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getScale"])(velocity.scale));
      }

      if (velocity.rotation != null) {
        transformVelocity.updateRotation(velocity.rotation);
      } // if (velocity.color != null) {
      //   colorVelocity = velocity.color;
      // }
      // if (velocity.opacity != null) {
      //   opacityVelocity = velocity.color;
      // }


      var transformDuration = 0;
      var startTransform = start.transform;
      var targetTransform = target.transform;

      if (startTransform != null && targetTransform != null) {
        transformDuration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(startTransform._dup(), targetTransform._dup(), transformVelocity, this.scenario.rotDirection);
      }

      var colorDuration = 0;

      if (start.color != null && target.color != null && !Object(_tools_color__WEBPACK_IMPORTED_MODULE_2__["areColorsSame"])(target.color, start.color)) {
        var deltaColor = Math.max(Math.abs(target.color[0] - start.color[0]), // $FlowFixMe
        Math.abs(target.color[1] - start.color[1]), // $FlowFixMe
        Math.abs(target.color[2] - start.color[2]), // $FlowFixMe
        Math.abs(target.color[3] - start.color[3])); // const deltaColor = Math.abs(target.color - start.color);

        colorDuration = deltaColor / colorVelocity;
      }

      var opacityDuration = 0;

      if (start.isShown != null && target.isShown != null) {
        if (start.opacity != null && target.isShown === true) {
          var opacityDelta = 1 - start.opacity;
          opacityDuration = opacityDelta / opacityVelocity;
        } else if (start.opacity != null && target.isShown === false) {
          opacityDuration = start.opacity / opacityVelocity;
        } else if (start.isShown !== target.isShown) {
          opacityDuration = 1 / opacityVelocity;
        }
      }

      var scenarioMaxTime = this.scenario.maxDuration;

      if (scenarioMaxTime != null) {
        colorDuration = Math.min(colorDuration, scenarioMaxTime);
        opacityDuration = Math.min(opacityDuration, scenarioMaxTime);
        transformDuration = Math.min(transformDuration, scenarioMaxTime);
      }

      if (colorDuration <= this.scenario.zeroDurationThreshold) {
        colorDuration = 0;
      }

      if (colorDuration < this.duration) {
        colorDuration = this.duration;
      }

      if (opacityDuration <= this.scenario.zeroDurationThreshold) {
        opacityDuration = 0;
      }

      if (opacityDuration < this.duration) {
        opacityDuration = this.duration;
      }

      if (transformDuration <= this.scenario.zeroDurationThreshold) {
        transformDuration = 0;
      }

      if (transformDuration < this.duration) {
        transformDuration = this.duration;
      }

      if (this.scenario.allDurationsSame) {
        var maxDuration = Math.max(colorDuration, opacityDuration, transformDuration);
        colorDuration = maxDuration;
        opacityDuration = maxDuration;
        transformDuration = maxDuration;
      }

      return [transformDuration, colorDuration, opacityDuration];
    } // On start, calculate the duration, target and delta if not already present.
    // This is done here in case the start is defined as null meaning it is
    // going to start from present transform.
    // Setting a duration to 0 will effectively skip this animation step

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(ScenarioAnimationStep.prototype), "start", this).call(this, startTime);

      var element = this.element;

      if (element == null) {
        throw new Error('Missing Element in animation');
      }

      var target = element.getScenarioTarget(this.scenario.target);

      if (Object.keys(target).length === 0) {
        target = element.getCurrentScenario();
      }

      var start = {};

      if (this.scenario.start != null) {
        start = element.getScenarioTarget(this.scenario.start);
      }

      if (Object.keys(start).length === 0) {
        start = element.getCurrentScenario();

        if (element.opacity !== 1) {
          start.opacity = element.opacity;
        }
      } // let animateOpacity = false;


      var dissolve = null;
      var dissolveFromCurrent = false;

      if (start.isShown === false && target.isShown === true && start.opacity == null) {
        dissolve = 'in';
      } else if (target.isShown === true && start.opacity != null) {
        dissolve = 'in';
        dissolveFromCurrent = true;
      } else if (start.isShown === true && target.isShown === false && start.opacity == null) {
        dissolve = 'out';
      } else if (target.isShown === false && start.opacity != null) {
        dissolve = 'out';
        dissolveFromCurrent = true;
      } // $FlowFixMe


      var _this$getDuration = this.getDuration(start, target),
          _this$getDuration2 = _slicedToArray(_this$getDuration, 3),
          transformDuration = _this$getDuration2[0],
          colorDuration = _this$getDuration2[1],
          opacityDuration = _this$getDuration2[2]; // console.log(transformDuration, colorDuration, opacityDuration);


      var steps = [];

      if (target.transform != null) {
        steps.push(element.anim.transform({
          start: start.transform,
          target: target.transform,
          duration: transformDuration,
          rotDirection: this.scenario.rotDirection,
          path: this.scenario.path,
          clipRotationTo: this.scenario.clipRotationTo,
          progression: this.scenario.progression
        }));
      }

      if (target.color != null) {
        steps.push(element.anim.color({
          start: start.color,
          target: target.color,
          duration: colorDuration,
          progression: this.scenario.progression
        }));
      }

      if (dissolve != null) {
        steps.push(element.anim.opacity({
          dissolve: dissolve,
          dissolveFromCurrent: dissolveFromCurrent,
          duration: opacityDuration,
          progression: this.scenario.progression
        }));
      }

      this.steps = steps;

      _get(_getPrototypeOf(ScenarioAnimationStep.prototype), "start", this).call(this, startTime); // if (startTime === 'now' || startTime === 'prev') {
      //   this.setFrame(0);
      // }

    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ScenarioAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return ScenarioAnimationStep;
}(_ParallelAnimationStep__WEBPACK_IMPORTED_MODULE_3__["ParallelAnimationStep"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js":
/*!**********************************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ElementAnimationStep/TransformAnimationStep.js ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransformAnimationStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ElementAnimationStep */ "./src/js/figure/Animation/AnimationStep/ElementAnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





// A transform animation unit manages a transform animation on an element.
//
// The start transform can either be defined initially, or null. Null means
// the start transform is whatever the current element transform is when the
// unit is started with start().
//
// The transform target is defined with either the target or delta properties.
// Target is used to predefine the target.
// Delta is used to calculate the target when the unit is started with start()
//

/**
 * Transform Animation Step
 *
 * ![](./apiassets/transform_animation.gif)
 *
 * By default, the transform will start with the element's current transform.
 *
 * A {@link Transform} chains many transform links where each link might be
 * a {@link Rotation}, {@link Scale} or {@link Translation} transform.
 *
 * `start`, `target` and `delta` should have the same order of transform links
 * as the `element`'s transform.
 *
 * The {@link TransformAnimationStep} will animate each of these links with the
 * same duration. If `velocity` is used to calculate the duration, then the link
 * with the longest duration will define the duration of the animation.
 * `velocity` can either be a transform with the same order of transform links
 * as the `element` or it can be a constant value, which will be applied to
 * all transform links. `velocity` cannot be 0.
 *
 * Use either `delta` or `target` to define it's end point of the animation.
 *
 * @extends ElementAnimationStep
 * @param {OBJ_TransformAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Using duration
 * p.animations.new()
 *   .transform({
 *     target: new Fig.Transform().scale(2, 2).rotate(0.5).translate(1, 0),
 *     duration: 2,
 *   })
 *   .start();
 *
 * @example
 * // Using velocity as a transform
 * p.animations.new()
 *   .transform({
 *     target: new Fig.Transform().scale(2, 2).rotate(0.5).translate(1, 0),
 *     velocity: new Fig.Transform().scale(0.5, 0.5).rotate(0.25).translate(0.5, 0.5),
 *   })
 *   .start();
 *
 * @example
 * // Using velocity as a number
 * p.animations.new()
 *   .transform({
 *     target: new Fig.Transform().scale(2, 2).rotate(0.5).translate(1, 0),
 *     velocity: 0.5,
 *   })
 *   .start();
 *
 * @example
 * // Using TypeParsableTransform as transform definition
 * p.animations.new()
 *   .transform({
 *     target: [['s', 1.5, 1.5], ['r', 0.5], ['t', 1, 0]],
 *     duration: 2,
 *   })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.transform({
 *   target: [['s', 1.5, 1.5], ['r', 1], ['t', 1, 0]],
 *   duration: 2,
 * });
 * const step2 = new Fig.Animation.TransformAnimationStep({
 *   element: p,
 *   target: [['s', 1, 1], ['r', 0], ['t', 0, 0]],
 *   duration: 2,
 * });
 *
 * p.animations.new()
 *   .then(step1)
 *   .then(step2)
 *   .start();
 */
var TransformAnimationStep = /*#__PURE__*/function (_ElementAnimationStep) {
  _inherits(TransformAnimationStep, _ElementAnimationStep);

  var _super = _createSuper(TransformAnimationStep);

  /**
   * @hideconstructor
   */
  function TransformAnimationStep() {
    var _this;

    _classCallCheck(this, TransformAnimationStep);

    for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
      optionsIn[_key] = arguments[_key];
    }

    var ElementAnimationStepOptionsIn = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
      type: 'transform'
    }].concat(optionsIn));
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["deleteKeys"])(ElementAnimationStepOptionsIn, ['start', 'delta', 'target', 'rotDirection', 'path', 'velocity', 'clipRotationTo', 'maxDuration']);
    _this = _super.call(this, ElementAnimationStepOptionsIn);
    var defaultTransformOptions = {
      start: null,
      target: null,
      delta: null,
      rotDirection: 0,
      path: {
        style: 'linear',
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null,
        direction: 'positive'
      },
      velocity: null,
      clipRotationTo: null,
      maxDuration: null
    };

    if (_this.element && _this.element.animations.options.translation) {
      var pathOptions = _this.element.animations.options.translation;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultTransformOptions.path, pathOptions);
    }

    var options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultTransformOptions].concat(optionsIn));

    if (options.start != null) {
      options.start = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(options.start);
    }

    if (options.target != null) {
      options.target = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(options.target);
    }

    if (options.delta != null) {
      options.delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(options.delta);
    }

    if (options.velocity != null && typeof options.velocity !== 'number') {
      options.velocity = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(options.velocity);
    } // $FlowFixMe


    _this.transform = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["copyKeysFromTo"])(options, _this.transform, ['start', 'delta', 'target', 'path', 'velocity', 'rotDirection', 'clipRotationTo', 'maxDuration']);
    return _this;
  }

  _createClass(TransformAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(TransformAnimationStep.prototype), "_getStateProperties", this).call(this)), ['transform']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'transformAnimationStep';
    } // On start, calculate the duration, target and delta if not already present.
    // This is done here in case the start is defined as null meaning it is
    // going to start from present transform.
    // Setting a duration to 0 will effectively skip this animation step

  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(TransformAnimationStep.prototype), "start", this).call(this, startTime);

      if (this.transform.start === null) {
        if (this.element != null) {
          this.transform.start = this.element.transform._dup();
        } else {
          this.duration = 0;
          return;
        }
      } // if delta is null, then calculate it from start and target


      if (this.transform.delta == null && this.transform.target != null) {
        var delta = this.transform.target.sub(this.transform.start);
        delta.order.forEach(function (deltaStep, index) {
          var startStep = _this2.transform.start.order[index];
          var targetStep = _this2.transform.target.order[index];

          if (deltaStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && startStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"] && targetStep instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rotation"]) {
            var rotDiff = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getDeltaAngle"])(startStep.r, targetStep.r, _this2.transform.rotDirection); // eslint-disable-next-line no-param-reassign

            deltaStep.r = rotDiff;
          }
        });
        this.transform.delta = delta;
      } else if (this.transform.delta != null) {
        this.transform.target = this.transform.start.add(this.transform.delta);
      } else {
        this.duration = 0;
      } // If Velocity is defined, then use it to calculate duration


      if (this.transform.velocity != null) {
        this.duration = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMaxTimeFromVelocity"])(this.transform.start, this.transform.target, this.transform.velocity, this.transform.rotDirection);
      }

      if (this.transform.maxDuration != null) {
        if (this.duration > this.transform.maxDuration) {
          this.duration = this.transform.maxDuration;
        }
      }

      if (startTime === 'now' || startTime === 'prevFrame') {
        this.setFrame(0);
      }
    }
  }, {
    key: "setFrame",
    value: function setFrame(deltaTime) {
      // const start = phase.startTransform._dup();
      // const delta = phase.deltaTransform._dup();
      var percentTime = deltaTime / this.duration;
      var percentComplete = this.getPercentComplete(percentTime);
      var p = percentComplete; // let next = delta._dup().constant(p);
      // next = start.add(delta.mul(next));

      var next = this.transform.start.toDelta(this.transform.delta, p, this.transform.path.style, this.transform.path);

      if (this.transform.clipRotationTo !== null) {
        next.clipRotation(this.transform.clipRotationTo);
      }

      if (this.element != null) {
        this.element.setTransform(next);
      }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      if (this.element != null) {
        this.element.setTransform(this.transform.target);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new TransformAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step, ['element']);
      step.element = this.element;
      return step;
    }
  }]);

  return TransformAnimationStep;
}(_ElementAnimationStep__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/ParallelAnimationStep.js":
/*!************************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/ParallelAnimationStep.js ***!
  \************************************************************************/
/*! exports provided: ParallelAnimationStep, inParallel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParallelAnimationStep", function() { return ParallelAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inParallel", function() { return inParallel; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/figure/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/GlobalAnimation */ "./src/js/figure/webgl/GlobalAnimation.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import * as tools from '../../tools/math';
// import { FigureElement } from '../Element';




/**
 * Execute an array of `{@link AnimationStep}`s in parallel.
 *
 * ![](./apiassets/parallel_animation.gif)
 *
 * The parallel animation step will not complete till all steps are finished.
 *
 * @param {Array<AnimationStep> | OBJ_SerialAnimationStep} steps
 * animation steps to perform in serial
 * @extends AnimationStep
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * p.animations.new()
 *   .inParallel([
 *     p.animations.position({ target: [1, 0], duration: 2 }),
 *     p.animations.scale({ target: 2, duration: 2 }),
 *   ])
 *   .start();
 *
 * @example
 * // One of the parallel steps is a series of steps
 * p.animations.new()
 *   .delay(1)
 *   .inParallel([
 *     p.animations.builder()
 *       .scale({ target: 0.5, duration: 1 })
 *       .scale({ target: 2, duration: 1 })
 *       .scale({ target: 1, duration: 2 }),
 *     p.animations.color({ target: [0, 0, 1, 1], duration: 4 }),
 *     p.animations.rotation({ target: Math.PI, duration: 4 }),
 *   ])
 *   .start();
 */
// Animations get started from a parent, but finish themselves
var ParallelAnimationStep = /*#__PURE__*/function (_AnimationStep) {
  _inherits(ParallelAnimationStep, _AnimationStep);

  var _super = _createSuper(ParallelAnimationStep);

  /**
   * @hideconstructor
   */
  function ParallelAnimationStep() {
    var _this;

    var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ParallelAnimationStep);

    var defaultOptions = {
      steps: []
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (Array.isArray(stepsOrOptionsIn)) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.steps = stepsOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, stepsOrOptionsIn].concat(optionsIn));
    }

    _this = _super.call(this, options);
    _this.steps = [];
    var steps = [];

    if (!Array.isArray(options.steps) && options.steps != null) {
      steps = [options.steps];
    } else if (options.steps != null) {
      var _options = options;
      steps = _options.steps;
    }

    _this.steps = [];
    steps.forEach(function (step) {
      if (step != null) {
        _this.steps.push(step);
      }
    });
    return _this;
  }

  _createClass(ParallelAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(ParallelAnimationStep.prototype), "_getStateProperties", this).call(this)), ['steps']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'parallelAnimationStep';
    }
  }, {
    key: "setTimeDelta",
    value: function setTimeDelta(delta) {
      _get(_getPrototypeOf(ParallelAnimationStep.prototype), "setTimeDelta", this).call(this, delta);

      if (this.steps != null) {
        this.steps.forEach(function (step) {
          step.setTimeDelta(delta);
        });
      }
    }
  }, {
    key: "with",
    value: function _with(step) {
      if (step != null) {
        this.steps.push(step);
      }

      return this;
    }
  }, {
    key: "nextFrame",
    value: function nextFrame(now, speed) {
      if (this.startTime === null) {
        this.startTime = now - this.startTimeOffset;
      }

      var remaining = null;

      if (this.beforeFrame != null) {
        // $FlowFixMe - as this has been confirmed
        this.beforeFrame(now - this.startTime);
      }

      this.steps.forEach(function (step) {
        // console.log(step.state, step)
        if (step.state === 'animating' || step.state === 'waitingToStart') {
          var stepRemaining = step.nextFrame(now, speed); // console.log(step.element.uid, stepRemaining)

          if (remaining === null) {
            remaining = stepRemaining;
          }

          if (stepRemaining < remaining) {
            remaining = stepRemaining;
          }
        }
      });

      if (this.afterFrame != null) {
        // $FlowFixMe - as this has been confirmed
        this.afterFrame(now - this.startTime);
      }

      if (remaining === null) {
        remaining = 0;
      }

      if (remaining >= 0) {
        this.finish();
      }

      return remaining;
    }
  }, {
    key: "finishIfZeroDuration",
    value: function finishIfZeroDuration() {
      var state = 'finished';
      this.steps.forEach(function (step) {
        if (step.state !== 'finished') {
          state = 'animating';
        }
      });

      if (state === 'finished') {
        this.finish();
      }
    }
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      _get(_getPrototypeOf(ParallelAnimationStep.prototype), "startWaiting", this).call(this);

      this.steps.forEach(function (step) {
        step.startWaiting();
      });
    }
  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.startWaiting();

      _get(_getPrototypeOf(ParallelAnimationStep.prototype), "start", this).call(this, startTime);

      this.steps.forEach(function (step) {
        step.start(startTime);
        step.finishIfZeroDuration();
      });
    }
  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.state === 'idle' || this.state === 'finished') {
        return;
      } // super.finish(cancelled, force);


      this.state = 'finished';
      var forceToUse = null;

      if (this.completeOnCancel === true) {
        forceToUse = 'complete';
      }

      if (this.completeOnCancel === false) {
        forceToUse = 'freeze';
      }

      if (force != null) {
        forceToUse = force;
      }

      this.steps.forEach(function (step) {
        if (step.state !== 'idle' && step.state !== 'finished') {
          step.finish(cancelled, forceToUse);
        }
      });

      if (this.onFinish != null) {
        this.fnExec(this.onFinish, cancelled);
      }
    }
  }, {
    key: "getTotalDuration",
    value: function getTotalDuration() {
      var totalDuration = 0;
      this.steps.forEach(function (step) {
        var stepDuration = step.getTotalDuration();

        if (stepDuration > totalDuration) {
          totalDuration = stepDuration;
        }
      });
      return totalDuration;
    }
  }, {
    key: "getRemainingTime",
    value: function getRemainingTime() {
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_2__["default"]().now() / 1000;
      var totalDuration = this.getTotalDuration();

      if (this.startTime == null) {
        if (this.state === 'animating' || this.state === 'waitingToStart') {
          return totalDuration;
        }

        return 0;
      }

      var deltaTime = now - this.startTime;
      return totalDuration - deltaTime;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new ParallelAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return ParallelAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function inParallel() {
  var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, optionsIn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionsIn[_key2 - 1] = arguments[_key2];
  }

  return _construct(ParallelAnimationStep, [stepsOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/SerialAnimationStep.js":
/*!**********************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/SerialAnimationStep.js ***!
  \**********************************************************************/
/*! exports provided: SerialAnimationStep, inSerial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SerialAnimationStep", function() { return SerialAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inSerial", function() { return inSerial; });
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/figure/Animation/AnimationStep.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/GlobalAnimation */ "./src/js/figure/webgl/GlobalAnimation.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import * as tools from '../../tools/math';
// import { FigureElement } from '../Element';




/**
 * Execute an array of {@link AnimationStep}s in series.
 *
 * ![](./apiassets/serial_animation.gif)
 *
 * Often the {@link AnimationBuilder} class which extends
 * `SerialAnimationStep` can be used to create serial animations
 * in a more clean way.
 *
 * @param {Array<AnimationStep> | OBJ_SerialAnimationStep} steps
 * animation steps to perform in serial
 * @extends AnimationStep
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Using a SerialAnimation step can be cumbersome, but
 * // can be useful if modularizing animations between files
 * const Rot = Fig.Animation.RotationAnimationStep;
 * const Delay = Fig.Animation.DelayAnimationStep;
 * const Pos = Fig.Animation.PositionAnimationStep;
 *
 * const series = new Fig.Animation.SerialAnimationStep([
 *   new Rot({ element: p, target: Math.PI / 2, duration: 2 }),
 *   new Delay({ duration: 0.2 }),
 *   new Rot({ element: p, target: Math.PI, duration: 2 }),
 *   new Delay({ duration: 0.2 }),
 *   new Rot({ element: p, target: 0, direction: -1, duration: 1.3, progression: 'easein' }),
 *   new Pos({ element: p, target: [1, 0], duration: 2, progression: 'easeout' }),
 * ]);
 *
 * p.animations.animations.push(series);
 * p.animations.start()
 *
 * @example
 * // Same animation but with `AnimationBuilder` (which is an extension of
 * // `SerialAnimationStep`)
 * p.animations.new()
 *   .rotation({ target: Math.PI / 2, duration: 2 })
 *   .delay(0.2)
 *   .rotation({ target: Math.PI, duration: 2 })
 *   .delay(0.2)
 *   .rotation({ target: 0, duration: 1, direction: -1, progression: 'easein' })
 *   .position({ target: [1, 0], duration: 2, progression: 'easeout' })
 *   .start();
 */
var SerialAnimationStep = /*#__PURE__*/function (_AnimationStep) {
  _inherits(SerialAnimationStep, _AnimationStep);

  var _super = _createSuper(SerialAnimationStep);

  /**
   * @hideconstructor
   */
  function SerialAnimationStep() {
    var _this;

    var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SerialAnimationStep);

    var defaultOptions = {
      steps: []
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (Array.isArray(stepsOrOptionsIn)) {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.steps = stepsOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, defaultOptions, stepsOrOptionsIn].concat(optionsIn));
    }

    _this = _super.call(this, options);
    _this.index = 0;
    _this.steps = [];

    if (!Array.isArray(options.steps) && options.steps != null) {
      _this.steps = [options.steps];
    } else if (options.steps != null) {
      _this.steps = options.steps;
    }

    return _this;
  }

  _createClass(SerialAnimationStep, [{
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(SerialAnimationStep.prototype), "_getStateProperties", this).call(this)), ['steps', 'index']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'serialAnimationStep';
    } // constructor(optionsIn: OBJ_SerialAnimationStep = {}) {
    //   super(optionsIn);
    //   this.index = 0;
    //   const defaultOptions = {};
    //   const options = joinObjects({}, defaultOptions, optionsIn);
    //   this.steps = [];
    //   if (!Array.isArray(options.steps) && options.steps != null) {
    //     this.steps = [options.steps];
    //   } else if (options.steps != null) {
    //     this.steps = options.steps;
    //   }
    //   return this;
    // }

  }, {
    key: "setTimeDelta",
    value: function setTimeDelta(delta) {
      _get(_getPrototypeOf(SerialAnimationStep.prototype), "setTimeDelta", this).call(this, delta);

      if (this.steps != null) {
        this.steps.forEach(function (step) {
          step.setTimeDelta(delta);
        });
      }
    }
  }, {
    key: "then",
    value: function then(step) {
      if (step != null) {
        this.steps.push(step);
      }

      return this;
    }
  }, {
    key: "startWaiting",
    value: function startWaiting() {
      _get(_getPrototypeOf(SerialAnimationStep.prototype), "startWaiting", this).call(this);

      this.steps.forEach(function (step) {
        step.startWaiting();
      });
    } // $FlowFixMe

  }, {
    key: "start",
    value: function start() {
      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (this.state !== 'animating') {
        this.startWaiting();

        _get(_getPrototypeOf(SerialAnimationStep.prototype), "start", this).call(this, startTime);

        this.index = 0;

        if (this.steps.length > 0) {
          this.steps[0].start(startTime);
          this.steps[0].finishIfZeroDuration();
        }
      }

      this.finishIfZeroDuration();
    }
  }, {
    key: "finishIfZeroDuration",
    value: function finishIfZeroDuration() {
      var i = 0;
      var step = this.steps[0];

      while (i < this.steps.length && step.state === 'finished') {
        i += 1;

        if (i < this.steps.length) {
          this.index = i;
          step = this.steps[i];
          step.start(this.steps[i - 1].startTime);
          step.finishIfZeroDuration();
        }
      }

      if (i === this.steps.length) {
        this.finish();
      }
    }
  }, {
    key: "nextFrame",
    value: function nextFrame(now, speed) {
      if (this.startTime === null) {
        this.startTime = now - this.startTimeOffset;
      }

      var remaining = -1;

      if (this.beforeFrame != null) {
        // $FlowFixMe - as this has been confirmed
        this.beforeFrame(now - this.startTime);
      }

      if (this.index <= this.steps.length - 1) {
        remaining = this.steps[this.index].nextFrame(now, speed);

        if (this.afterFrame != null) {
          // $FlowFixMe - as this has been confirmed
          this.afterFrame(now - this.startTime);
        } // console.log('serial', now, this.index, remaining)


        if (remaining >= 0) {
          if (this.index === this.steps.length - 1) {
            this.finish();
            return remaining;
          }

          this.index += 1;
          this.steps[this.index].start(now - remaining);
          return this.nextFrame(now, speed);
        }
      }

      return remaining;
    }
  }, {
    key: "finish",
    value: function finish() {
      var cancelled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.state === 'idle' || this.state === 'finished') {
        return;
      } // super.finish(cancelled, force);


      this.state = 'finished';
      var forceToUse = null;

      if (this.completeOnCancel === true) {
        forceToUse = 'complete';
      }

      if (this.completeOnCancel === false) {
        forceToUse = 'freeze';
      }

      if (force != null) {
        forceToUse = force;
      }

      this.steps.forEach(function (step) {
        if (step.state !== 'idle' && step.state !== 'finished') {
          step.finish(cancelled, forceToUse);
        }
      });

      if (this.onFinish != null) {
        this.fnExec(this.onFinish, cancelled);
      }
    }
  }, {
    key: "getTotalDuration",
    value: function getTotalDuration() {
      var totalDuration = 0;
      this.steps.forEach(function (step) {
        totalDuration += step.getTotalDuration();
      });
      return totalDuration;
    }
  }, {
    key: "getRemainingTime",
    value: function getRemainingTime() {
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_2__["default"]().now() / 1000;
      var totalDuration = this.getTotalDuration();

      if (this.startTime == null) {
        if (this.state === 'animating' || this.state === 'waitingToStart') {
          return totalDuration;
        }

        return 0;
      }

      var deltaTime = now - this.startTime;
      return totalDuration - deltaTime;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new SerialAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, step);
      return step;
    }
  }]);

  return SerialAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_0__["default"]);
function inSerial() {
  var stepsOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len2 = arguments.length, optionsIn = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    optionsIn[_key2 - 1] = arguments[_key2];
  }

  return _construct(SerialAnimationStep, [stepsOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/figure/Animation/AnimationStep/TriggerStep.js":
/*!**************************************************************!*\
  !*** ./src/js/figure/Animation/AnimationStep/TriggerStep.js ***!
  \**************************************************************/
/*! exports provided: TriggerAnimationStep, trigger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriggerAnimationStep", function() { return TriggerAnimationStep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return trigger; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _AnimationStep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AnimationStep */ "./src/js/figure/Animation/AnimationStep.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




/**
 * Trigger Animation Step
 *
 * ![](./apiassets/trigger_animation.gif)
 *
 * A trigger step executes a custom function
 *
 * A `delay` will delay the triggering of the custom function
 * while `duration` will pad time at the end of the trigger before
 * the animation step finishes.
 *
 * @extends AnimationStep
 * @param {OBJ_TriggerAnimationStep | function(): void} options
 *
 * @see To test examples, append them to the
 * <a href="#animation-boilerplate">boilerplate</a>
 *
 * @example
 * // Simple trigger
 * p.animations.new()
 *   .position({ target: [1, 0], duration: 2 })
 *   .trigger(() => { console.log('arrived at (1, 0)') })
 *   .position({ target: [0, 0], duration: 2 })
 *   .trigger(() => { console.log('arrived at (0, 0)') })
 *   .start();
 *
 * @example
 * // Trigger with delay, duration and payload
 * const printPosition = (pos) => {
 *   console.log(`arrived at ${pos}`);
 * };
 *
 * p.animations.new()
 *   .position({ target: [1, 0], duration: 2 })
 *   .trigger({
 *     delay: 1,
 *     callback: printPosition,
 *     payload: '(1, 0)',
 *     duration: 1,
 *   })
 *   .position({ target: [0, 0], duration: 2 })
 *   .trigger({ callback: printPosition, payload: '(0, 0)' })
 *   .start();
 *
 * @example
 * // Different ways to create a stand-alone step
 * const step1 = p.animations.trigger({
 *   callback: () => { console.log('arrived at (1, 0)') },
 * });
 * const step2 = new Fig.Animation.TriggerAnimationStep({
 *   callback: () => { console.log('arrived at (0, 0)') },
 * });
 *
 * p.animations.new()
 *   .position({ target: [1, 0], duration: 2 })
 *   .then(step1)
 *   .position({ target: [0, 0], duration: 2 })
 *   .then(step2)
 *   .start();
 */
var TriggerAnimationStep = /*#__PURE__*/function (_AnimationStep) {
  _inherits(TriggerAnimationStep, _AnimationStep);

  var _super = _createSuper(TriggerAnimationStep);

  /**
   * @hideconstructor
   */
  function TriggerAnimationStep() {
    var _this;

    var triggerOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TriggerAnimationStep);

    var defaultOptions = {
      payload: null,
      duration: 0
    };
    var options;

    for (var _len = arguments.length, optionsIn = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      optionsIn[_key - 1] = arguments[_key];
    }

    if (typeof triggerOrOptionsIn === 'function' || typeof triggerOrOptionsIn === 'string') {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.callback = triggerOrOptionsIn;
    } else {
      options = _tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"].apply(void 0, [{}, defaultOptions, triggerOrOptionsIn].concat(optionsIn));
    }

    _this = _super.call(this, options);
    _this.element = options.element;
    _this.callback = options.callback;
    _this.payload = options.payload;
    _this.duration = options.duration;
    return _this;
  } // fnExec(idOrFn: string | Function | null, ...args: any) {
  //   const result = this.fnMap.exec(idOrFn, ...args);
  //   if (result == null && this.element != null) {
  //     return this.element.fnMap.exec(idOrFn, ...args);
  //   }
  //   return result;
  // }


  _createClass(TriggerAnimationStep, [{
    key: "fnExec",
    value: function fnExec(idOrFn) {
      var _this$fnMap2;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      // const result = this.fnMap.exec(idOrFn, ...args);
      // if (result == null && this.element != null) {
      //   return this.element.fnMap.exec(idOrFn, ...args);
      // }
      // return result;
      if (this.element != null) {
        var _this$fnMap;

        return (_this$fnMap = this.fnMap).execOnMaps.apply(_this$fnMap, [idOrFn, [this.element.fnMap.map]].concat(args));
      }

      return (_this$fnMap2 = this.fnMap).exec.apply(_this$fnMap2, [idOrFn].concat(args));
    }
  }, {
    key: "_fromState",
    value: function _fromState(state, getElement) {
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])(this, state);

      if (this.element != null && typeof this.element === 'string' && getElement != null) {
        this.element = getElement(this.element);
      }

      return this;
    }
  }, {
    key: "_state",
    value: function _state(options) {
      var state = _get(_getPrototypeOf(TriggerAnimationStep.prototype), "_state", this).call(this, options);

      if (this.element != null) {
        state.state.element = {
          f1Type: 'de',
          state: this.element.getPath()
        };
      }

      return state;
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(TriggerAnimationStep.prototype), "_getStateProperties", this).call(this)), ['callback', 'payload']);
    }
  }, {
    key: "_getStateName",
    value: function _getStateName() {
      // eslint-disable-line class-methods-use-this
      return 'triggerAnimationStep';
    }
  }, {
    key: "setFrame",
    value: function setFrame() {
      // if (this.callback != null && this.payload != null) {
      //   console.log(this.payload)
      // }
      var remainingTime = this.fnExec(this.callback, this.payload);

      if (remainingTime != null && typeof remainingTime === 'number') {
        this.duration = remainingTime;
      }

      this.callback = null; // if (this.callback != null) {
      //   this.callback(this.payload);
      //   this.callback = null;
      // }
    }
  }, {
    key: "setToEnd",
    value: function setToEnd() {
      // if (this.callback != null) {
      //   this.callback(this.payload);
      //   this.callback = null;
      // }
      this.fnExec(this.callback, this.payload);
      this.callback = null;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var step = new TriggerAnimationStep();
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["duplicateFromTo"])(this, step, ['element']);
      return step;
    }
  }]);

  return TriggerAnimationStep;
}(_AnimationStep__WEBPACK_IMPORTED_MODULE_1__["default"]);
function trigger() {
  var triggerOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var _len3 = arguments.length, optionsIn = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    optionsIn[_key3 - 1] = arguments[_key3];
  }

  return _construct(TriggerAnimationStep, [triggerOrOptionsIn].concat(optionsIn));
}

/***/ }),

/***/ "./src/js/figure/DrawContext2D.js":
/*!****************************************!*\
  !*** ./src/js/figure/DrawContext2D.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DrawContext2D = /*#__PURE__*/function () {
  function DrawContext2D(canvas) {
    _classCallCheck(this, DrawContext2D);

    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    /* $FlowFixMe */

    var bsr = this.ctx.webkitBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.mozBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.msBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.oBackingStorePixelRatio
    /* $FlowFixMe */
    || this.ctx.backingStorePixelRatio || 1;
    var dpr = window.devicePixelRatio || 1;

    if (dpr === 1) {
      dpr = 2;
    }

    if (typeof bsr === 'number') {
      this.ratio = dpr / bsr;
    } else {
      this.ratio = 1;
    }

    this.resize();
  }

  _createClass(DrawContext2D, [{
    key: "resize",
    value: function resize() {
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.canvas.width = this.canvas.clientWidth * this.ratio;
      this.canvas.height = this.canvas.clientHeight * this.ratio;
      this.ctx.scale(this.ratio, this.ratio);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return this;
    }
  }]);

  return DrawContext2D;
}();

/* harmony default export */ __webpack_exports__["default"] = (DrawContext2D);

/***/ }),

/***/ "./src/js/figure/DrawingObjects/DrawingObject.js":
/*!*******************************************************!*\
  !*** ./src/js/figure/DrawingObjects/DrawingObject.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Recorder_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Recorder/state */ "./src/js/figure/Recorder/state.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // import type {
//   TypeParsablePoint
// } from '../../tools/g2';



// A Drawing object can be:
//  - GL primitive vertices
//  - Text object for 2D drawing contexts
//  - HTML Object in the figure_html div
//
// It must have:
//
//   Properties:
//     - location     A reference location where relative boundaries are
//                    calculated from
//     - border       Array of borders in Figure Units
//
//   Methods:
//     - drawWithTransformMatrix(transformMatrix)
//     - calcBorder(lastDrawTransformMatrix, glToFigureTransform)
//
// function getBounds(borderIn: null | Array<Array<Point>>, transformMatrix: Array<number> | null) {
//   if (transformMatrix == null) {
//     return borderIn;
//   }
//   if (
//     borderIn == null
//     || (borderIn.length === 1 && borderIn[0].length === 0)
//     || borderIn.length === 0
//   ) {
//     return [];
//   }
//   const boundaries = [];
//   borderIn.forEach((boundary) => {
//     const border = [];
//     boundary.forEach((point) => {
//       border.push(point.transformBy(transformMatrix));
//     });
//     boundaries.push(border);
//   });
//   return boundaries;
// }

/**
 * Drawing Object
 *
 * Manages drawing an element to a WebGL or Context 2D canvas. Can also
 * be used to manage a HTML element on the screen.
 *
 * @property {Array<Array<Point>>} border each array of points defines a
 * closed boundary or border of the element. An element may have multiple
 * closed borders. A border defines where a shape can be touched, or how it
 * bounces of figure boundaries
 * @property {Array<Array<Point>>} holeBorder areas where a shape cannot be
 * touched
 * @see {@link FigureElementPrimitive}
 */
var DrawingObject = /*#__PURE__*/function () {
  // numPoints: number;           // Number of primative vertices
  // Border vertices
  // Border vertices
  // touchBorder: Array<Array<Point>>;
  // hole: Array<Array<Point>>;  // Border of any holes inside of main border
  // +change: (any, any, any) => void;
  // onLoad: Function | null;   // Only used for drawing objects with asynchronous
  //                            loading (like textures)
  function DrawingObject() {
    _classCallCheck(this, DrawingObject);

    // this.numPoints = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0); // this.border = [[]];
    // this.touchBorder = [[]];
    // this.hole = [[]];
    // this.onLoad = null;

    this.type = 'drawingObject'; // this.state = 'loading';
  }

  _createClass(DrawingObject, [{
    key: "_dup",
    value: function _dup() {
      return this;
    } // // Helper function hack used in TextObject
    // // eslint-disable-next-line class-methods-use-this, no-unused-vars
    // transformBorder(
    //   borderIn: null | Array<Array<Point>>,
    //   transformMatrix: Array<number> | null,
    // ) {
    //   return getBounds(borderIn, transformMatrix);
    // }
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "setText",
    value: function setText(textOrOptions) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "update",
    value: function update(options) {} // getBoundaries(transformMatrix: null | Array<number> = null): Array<Array<Point>> {
    //   return getBounds(this.border, transformMatrix);
    // }
    // getTouchBoundaries(transformMatrix: null | Array<number> = null): Array<Array<Point>> {
    //   return getBounds(this.touchBorder, transformMatrix);
    // }
    // getBoundaryHoles(transformMatrix: null | Array<number> = null): Array<Array<Point>> {
    //   return getBounds(this.hole, transformMatrix);
    // }

    /* eslint-enable */

    /* eslint-disable class-methods-use-this, no-unused-vars */

  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix, color, canvasIndex, numPoints) {}
    /* eslint-enable */
    // getBoundingRect(transformMatrix: Array<number> | null = null): Rect {
    //   const boundaries = this.getBoundaries(transformMatrix);
    //   return getBoundingRect(boundaries);
    // }

  }, {
    key: "getLocation",
    value: function getLocation() {
      var transformMatrix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (transformMatrix == null) {
        return this.location;
      }

      return this.getLocation().transformBy(transformMatrix);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      return 0;
    } // getRelativeBoundingRect(transformMatrix: Array<number> | null = null): Rect {
    //   const location = this.getLocation(transformMatrix);
    //   const absoluteBoundaries =
    //     this.getBoundingRect(transformMatrix);
    //   const relativeBoundaries = new Rect(
    //     absoluteBoundaries.left - location.x,
    //     absoluteBoundaries.bottom - location.y,
    //     absoluteBoundaries.width,
    //     absoluteBoundaries.height,
    //   );
    //   return relativeBoundaries;
    // }
    // getRelativeVertexSpaceBoundingRect() {
    //   const absoluteBoundaries =
    //     this.getVertexSpaceBoundingRect();
    //   const relativeBoundaries = new Rect(
    //     absoluteBoundaries.left - this.location.x,
    //     absoluteBoundaries.bottom - this.location.y,
    //     absoluteBoundaries.width,
    //     absoluteBoundaries.height,
    //   );
    //   return relativeBoundaries;
    // }

    /* eslint-disable no-unused-vars, class-methods-use-this */

  }, {
    key: "change",
    value: function change(drawingPrimitive) {
      var copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    }
    /* eslint-enable no-unused-vars, class-methods-use-this */

  }, {
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return [];
    }
  }, {
    key: "_state",
    value: function _state(options) {
      return Object(_Recorder_state__WEBPACK_IMPORTED_MODULE_1__["getState"])(this, this._getStateProperties(), options);
    }
  }]);

  return DrawingObject;
}();

/* harmony default export */ __webpack_exports__["default"] = (DrawingObject);

/***/ }),

/***/ "./src/js/figure/DrawingObjects/HTMLObject/HTMLObject.js":
/*!***************************************************************!*\
  !*** ./src/js/figure/DrawingObjects/HTMLObject/HTMLObject.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/figure/DrawingObjects/DrawingObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import * as m2 from '../tools/m2';




var HTMLObject = /*#__PURE__*/function (_DrawingObject) {
  _inherits(HTMLObject, _DrawingObject);

  var _super = _createSuper(HTMLObject);

  // figureLimits: Rect;
  // +change: (string | HTMLElement, Array<number>) => void;
  function HTMLObject(parentDiv, id, location) {
    var _this;

    var yAlign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'middle';
    var xAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'center';

    _classCallCheck(this, HTMLObject);

    _this = _super.call(this);
    var element = document.getElementById(id);

    if (element) {
      _this.element = element;
    }

    _this.id = id;
    _this.location = location;
    _this.yAlign = yAlign;
    _this.xAlign = xAlign;
    _this.parentDiv = parentDiv;
    _this.show = true;

    _this.setBorder();

    _this.lastMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    _this.lastColor = [-1, -1, -1, -1];
    return _this;
  }

  _createClass(HTMLObject, [{
    key: "_dup",
    value: function _dup() {
      var c = new HTMLObject(this.parentDiv, this.id, this.location._dup(), this.yAlign, this.xAlign);
      c.show = this.show;
      c.border = this.border.map(function (b) {
        return b.map(function (p) {
          return p._dup();
        });
      });
      return c;
    }
  }, {
    key: "setBorder",
    value: function setBorder() {
      var parentRect = this.parentDiv.getBoundingClientRect();
      var elementRect = this.element.getBoundingClientRect();
      var left = elementRect.left - parentRect.left;
      var right = left + elementRect.width;
      var top = elementRect.top - parentRect.top;
      var bottom = top + elementRect.height;
      var boundary = [];
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, bottom));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, bottom));
      this.border = [];
      this.border.push(boundary);
    }
  }, {
    key: "getBoundaries",
    value: function getBoundaries() {
      var parentRect = this.parentDiv.getBoundingClientRect();
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var pixelSpace = {
        x: {
          bottomLeft: 0,
          width: parentRect.width
        },
        y: {
          bottomLeft: parentRect.height,
          height: -parentRect.height
        }
      };
      var pixelToGLTransform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(pixelSpace, glSpace);
      var elementRect = this.element.getBoundingClientRect();
      var left = elementRect.left - parentRect.left;
      var right = left + elementRect.width;
      var top = elementRect.top - parentRect.top;
      var bottom = top + elementRect.height;
      var boundary = [];
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, top));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](right, bottom));
      boundary.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](left, bottom));
      return [boundary.map(function (p) {
        return p.transformBy(pixelToGLTransform.matrix());
      })];
    }
  }, {
    key: "glToPixelSpace",
    value: function glToPixelSpace(p) {
      var x = (p.x - -1) / 2 * this.parentDiv.clientWidth;
      var y = (1 - p.y) / 2 * this.parentDiv.clientHeight;
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x, y);
    } // $FlowFixMe

  }, {
    key: "change",
    value: function change(newHtml, lastDrawTransformMatrix) {
      var element = newHtml;

      if (typeof newHtml === 'string') {
        element = document.createElement('div');
        element.innerHTML = newHtml;
      }

      if (element instanceof HTMLElement) {
        this.element.innerHTML = '';
        this.element.appendChild(element);
        this.transformHtml(lastDrawTransformMatrix);
      }
    }
  }, {
    key: "transformHtml",
    value: function transformHtml(transformMatrix) {
      var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      if (this.show) {
        // this.element.style.visibility = 'visible';
        var glLocation = this.location.transformBy(transformMatrix);
        var pixelLocation = this.glToPixelSpace(glLocation);
        var w = this.element.clientWidth;
        var h = this.element.clientHeight; // console.log(w, h, this.element.id)

        var left = 0;
        var top = 0;

        if (this.xAlign === 'center') {
          left = -w / 2;
        } else if (this.xAlign === 'right') {
          left = -w;
        }

        if (this.yAlign === 'middle') {
          top = -h / 2;
        } else if (this.yAlign === 'bottom') {
          top = -h;
        }

        var x = pixelLocation.x + left;
        var y = pixelLocation.y + top; // this.element.style.position = 'absolute';
        // this.element.style.left = `${x}px`;
        // this.element.style.top = `${y}px`;
        // this.element.style.visibility = 'visible';
        // this.element.style.opacity = opacity;

        var style = "position: absolute; left: ".concat(x, "px; top: ").concat(y, "px; visibility: visible; opacity: ").concat(opacity, ";");
        var currentStyle = this.element.getAttribute('style');

        if (style !== currentStyle) {
          this.element.setAttribute('style', style);
        } // this.element.classList.remove('figure__hidden');

      } else {
        this.element.setAttribute('style', "position: absolute; left: -10000px; top: -10000px; visibility: hidden; opacity: ".concat(opacity, ";")); // this.element.style.position = 'absolute';
        // this.element.style.left = '-10000px';
        // this.element.style.top = '-10000px';
        // // this.element.classList.add('figure__hidden');
        // this.element.style.visibility = 'hidden';
        // // this.element.style.visibility = 'hidden';
        // // console.trace()
      }
    }
  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix, color) {
      var isDifferent = false;

      for (var i = 0; i < transformMatrix.length; i += 1) {
        if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(transformMatrix[i], 8) !== this.lastMatrix[i]) {
          isDifferent = true;
        }
      }

      if (isDifferent || this.lastColor[3] !== Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(color[3], 8)) {
        this.transformHtml(transformMatrix, color[3]);
        this.lastMatrix = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(transformMatrix, 8);
        this.lastColor = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(color, 8);
      }
    }
  }]);

  return HTMLObject;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (HTMLObject); // Transform -1 to 1 space to 0 to width/height space

/***/ }),

/***/ "./src/js/figure/DrawingObjects/TextObject/TextObject.js":
/*!***************************************************************!*\
  !*** ./src/js/figure/DrawingObjects/TextObject/TextObject.js ***!
  \***************************************************************/
/*! exports provided: FigureFont, FigureText, TextObject, TextLineObject, TextLinesObject, TextObjectBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FigureFont", function() { return FigureFont; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FigureText", function() { return FigureText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextObject", function() { return TextObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextLineObject", function() { return TextLineObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextLinesObject", function() { return TextLinesObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextObjectBase", function() { return TextObjectBase; });
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/figure/DrawingObjects/DrawingObject.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../DrawContext2D */ "./src/js/figure/DrawContext2D.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../tools/color */ "./src/js/tools/color.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }








/* eslint-enable max-len */
// FigureFont defines the font properties to be used in a TextObject
var FigureFont = /*#__PURE__*/function () {
  function FigureFont() {
    var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FigureFont);

    if (optionsIn instanceof FigureFont) {
      this.family = optionsIn.family;
      this.style = optionsIn.style;
      this.size = optionsIn.size;
      this.weight = optionsIn.weight;
      this.opacity = optionsIn.opacity;
      this.setColor(optionsIn.color);
      return;
    }

    var defaultOptions = {
      family: 'Times New Roman',
      style: 'normal',
      size: 1,
      weight: '200',
      color: null,
      opacity: 1
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, optionsIn);
    this.family = options.family;
    this.style = options.style;
    this.size = options.size;
    this.weight = options.weight;
    this.opacity = options.opacity;
    this.setColor(options.color);
  }

  _createClass(FigureFont, [{
    key: "setColor",
    value: function setColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (color == null) {
        this.color = color;
      } else {
        this.color = color.slice();
      }
    }
  }, {
    key: "definition",
    value: function definition() {
      var color = this.color;
      var colorToUse;

      if (color == null) {
        colorToUse = color;
      } else {
        colorToUse = color.slice();
      }

      return {
        family: this.family,
        style: this.style,
        size: this.size,
        weight: this.weight,
        color: colorToUse,
        opacity: this.opacity
      };
    }
  }, {
    key: "setFontInContext",
    value: function setFontInContext(ctx) {
      var scalingFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(this.size * scalingFactor, "px ").concat(this.family);
    }
  }, {
    key: "setColorInContext",
    value: function setColorInContext(ctx, color) {
      var thisColor = this.color;
      var opacity = this.opacity;

      if (color != null) {
        opacity *= color[3];
      }

      if (thisColor != null) {
        var c = [].concat(_toConsumableArray(thisColor.slice(0, 3)), [thisColor[3] * opacity]);
        ctx.fillStyle = Object(_tools_color__WEBPACK_IMPORTED_MODULE_5__["colorArrayToRGBA"])(c);
      } else if (color != null) {
        ctx.fillStyle = Object(_tools_color__WEBPACK_IMPORTED_MODULE_5__["colorArrayToRGBA"])(color);
      }
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new FigureFont({
        family: this.family,
        style: this.style,
        size: this.size,
        weight: this.weight,
        color: this.color,
        opacity: this.opacity
      });
    }
  }]);

  return FigureFont;
}(); // FigureText is a single text element of the figure that is drawn at
// once and referenced to the same location


var FigureTextBase = /*#__PURE__*/function () {
  // borderSetup: 'rect' | Array<Point>;
  // touchBorder: number | Array<Point>;
  // touchBorderSetup: 'rect' | number | 'border' | Array<Point>;
  // touchBorderSetup: 'rect'
  function FigureTextBase(drawContext2D) // runUpdate: boolean = true,
  {
    var location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var font = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FigureFont().definition();
    var xAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'left';
    var yAlign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'baseline';
    var touchBorder = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var onClick = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

    _classCallCheck(this, FigureTextBase);

    this.location = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(location)._dup();
    this.locationAligned = this.location._dup();
    this.text = text.slice();
    this.font = new FigureFont(font);
    this.xAlign = xAlign;
    this.yAlign = yAlign;
    this.lastDraw = null;
    this.lastDrawRect = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](0, 0, 1, 1);

    if (Array.isArray(drawContext2D)) {
      this.drawContext2D = drawContext2D;
    } else {
      this.drawContext2D = [drawContext2D];
    } // this.touchBorderSetup = touchBorder;


    this.touchBorder = touchBorder; // this.borderSetup = border;

    this.onClick = onClick;
  }

  _createClass(FigureTextBase, [{
    key: "measureAndAlignText",
    value: function measureAndAlignText() {
      this.measureText();
      this.alignText();
    }
  }, {
    key: "calcBorderAndBounds",
    value: function calcBorderAndBounds() {
      this.calcBounds();
      this.calcBorder();
      this.calcTouchBorder();
    }
  }, {
    key: "setText",
    value: function setText(options) {
      if (typeof options === 'string') {
        this.text = options.slice();
      } else {
        if (options.location != null) {
          // eslint-disable-next-line no-param-reassign
          options.location = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(options.location);
        }

        Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])(this, options);
      }

      this.measureAndAlignText();
      this.calcBorderAndBounds();
    } // deprecated
    // setText(text: string) {
    //   this.text = text.slice();
    //   this.measureAndAlignText();
    //   this.calcBorderAndBounds();
    // }

  }, {
    key: "setFont",
    value: function setFont(font) {
      var newFont = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, this.font.definition(), font);
      this.font = new FigureFont(newFont);
      this.measureAndAlignText();
    } // // deprecated
    // setXAlign(xAlign: 'left' | 'center' | 'right') {
    //   this.xAlign = xAlign;
    //   this.alignText();
    //   this.calcBounds();
    //   this.calcBorder();
    //   this.calcTouchBorder();
    // }
    // // deprecated
    // setYAlign(yAlign: 'top' | 'bottom' | 'middle' | 'alphabetic' | 'baseline') {
    //   this.yAlign = yAlign;
    //   this.alignText();
    //   this.calcBounds();
    //   this.calcBorder();
    //   this.calcTouchBorder();
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      return new this.constructor(this.drawContext2D, this.location, this.text, this.font.definition(), this.xAlign, this.yAlign);
    } // This method is used instead of the actual ctx.measureText because
    // Firefox and Chrome don't yet support it's collections features.
    // Estimates are made for height based on width.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "measureText",
    value: function measureText() {
      var ctx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.drawContext2D[0].ctx;
      var scalingFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20 / this.font.size;
      this.font.setFontInContext(ctx, scalingFactor);
      var fontHeight = ctx.font.match(/[^ ]*px/);
      var aWidth;

      if (fontHeight != null) {
        aWidth = parseFloat(fontHeight[0]) / 2;
      } else {
        aWidth = ctx.measureText('a').width;
      } // console.log(aWidth)
      // Estimations of FONT ascent and descent for a baseline of "alphabetic"


      var ascent = aWidth * 1.4;
      var descent = aWidth * 0.08; // Uncomment below and change above consts to lets if more resolution on
      // actual text boundaries is needed
      // const maxAscentRe =
      //   /[ABCDEFGHIJKLMNOPRSTUVWXYZ1234567890!#%^&()@$Qbdtfhiklj]/g;

      var midAscentRe = /[acemnorsuvwxz*gyqp]/g;
      var midDecentRe = /[;,$]/g;
      var maxDescentRe = /[gjyqp@Q(){}[\]|]/g;

      if (this.font.family === 'Times New Roman') {
        if (this.font.style === 'italic') {
          maxDescentRe = /[gjyqp@Q(){}[\]|f]/g;
        }
      }

      var midAscentMatches = this.text.match(midAscentRe);

      if (Array.isArray(midAscentMatches)) {
        if (midAscentMatches.length === this.text.length) {
          ascent = aWidth * 0.95;
        }
      }

      var midDescentMatches = this.text.match(midDecentRe);

      if (Array.isArray(midDescentMatches)) {
        if (midDescentMatches.length > 0) {
          descent = aWidth * 0.2;
        }
      }

      var maxDescentMatches = this.text.match(maxDescentRe);

      if (Array.isArray(maxDescentMatches)) {
        if (maxDescentMatches.length > 0) {
          descent = aWidth * 0.5;
        }
      } // const height = ascent + descent;


      var _ctx$measureText = ctx.measureText(this.text),
          width = _ctx$measureText.width;

      this.measure = {
        ascent: ascent / scalingFactor,
        descent: descent / scalingFactor,
        width: width / scalingFactor
      };
      return this.measure;
    }
  }, {
    key: "alignText",
    value: function alignText() {
      var location = this.location._dup();

      if (this.xAlign === 'center') {
        location.x -= this.measure.width / 2;
      } else if (this.xAlign === 'right') {
        location.x -= this.measure.width;
      }

      if (this.yAlign === 'bottom') {
        location.y += this.measure.descent;
      } else if (this.yAlign === 'middle') {
        location.y += this.measure.descent - (this.measure.ascent + this.measure.descent) / 2;
      } else if (this.yAlign === 'top') {
        location.y -= this.measure.ascent;
      }

      this.locationAligned = location._dup();
    }
  }, {
    key: "calcBounds",
    value: function calcBounds() {
      this.bounds = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](this.locationAligned.x, this.locationAligned.y - this.measure.descent, this.measure.width, this.measure.ascent + this.measure.descent);
    }
  }, {
    key: "getBoundary",
    value: function getBoundary(transformMatrix) {
      if (transformMatrix == null) {
        return this.textBorder;
      }

      var boundary = [];
      this.textBorder.forEach(function (p) {
        boundary.push(p.transformBy(transformMatrix));
      });
      return boundary;
    }
  }, {
    key: "calcBorder",
    value: function calcBorder() {
      // if (this.borderSetup === 'rect') {
      this.textBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](this.bounds.left, this.bounds.bottom), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](this.bounds.right, this.bounds.bottom), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](this.bounds.right, this.bounds.top), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](this.bounds.left, this.bounds.top)]; // } else {
      //   this.border = this.borderSetup;
      // }
    }
  }, {
    key: "calcTouchBorder",
    value: function calcTouchBorder() {
      if (Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["isBuffer"])(this.touchBorder)) {
        // $FlowFixMe
        this.textBorderBuffer = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBoundingBorder"])(this.textBorder, this.touchBorder); // }
        // if (
        //   typeof this.touchBorder === 'number'
        //   || (
        //     Array.isArray(this.touchBorder)
        //     && typeof (this.touchBorder[0]) === 'number'
        //   )
        // ) {
        //   this.textBorderBuffer = getBoundingBorder(this.textBorder, this.touchBorder);
      } else {
        // $FlowFixMe
        this.textBorderBuffer = this.touchBorder;
      }
    }
  }]);

  return FigureTextBase;
}(); // FigureText is a single text element of the figure that is drawn at
// once and referenced to the same location


var FigureText = /*#__PURE__*/function (_FigureTextBase) {
  _inherits(FigureText, _FigureTextBase);

  var _super = _createSuper(FigureText);

  function FigureText(drawContext2D) // runUpdate: boolean = true,
  {
    var _this;

    var location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var font = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FigureFont().definition();
    var xAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'left';
    var yAlign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'baseline';
    var touchBorder = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var onClick = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;

    _classCallCheck(this, FigureText);

    _this = _super.call(this, drawContext2D, location, text, font, xAlign, yAlign, touchBorder, onClick);

    _this.measureAndAlignText();

    _this.calcBorderAndBounds();

    return _this;
  }

  return FigureText;
}(FigureTextBase);

var FigureTextLine = /*#__PURE__*/function (_FigureTextBase2) {
  _inherits(FigureTextLine, _FigureTextBase2);

  var _super2 = _createSuper(FigureTextLine);

  function FigureTextLine(drawContext2D) {
    var _this2;

    var location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var font = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FigureFont().definition();
    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    var inLine = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var touchBorder = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var onClick = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
    var followOffsetY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
    var lSpace = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var rSpace = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;

    _classCallCheck(this, FigureTextLine);

    _this2 = _super2.call(this, drawContext2D, location, text, font, 'left', 'baseline', touchBorder, onClick);
    _this2.offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(offset);
    _this2.inLine = inLine;
    _this2.followOffsetY = followOffsetY;
    _this2.lSpace = lSpace;
    _this2.rSpace = rSpace;

    _this2.measureAndAlignText();

    _this2.calcBorderAndBounds();

    return _this2;
  }

  _createClass(FigureTextLine, [{
    key: "alignText",
    value: function alignText() {
      var location = this.location._dup();

      this.locationAligned = location.add(this.offset);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new FigureTextLine(this.drawContext2D, this.location, this.text, this.font.definition(), this.offset, this.inLine, this.touchBorder, this.onClick, this.followOffsetY, this.rSpace, this.lSpace);
    }
  }]);

  return FigureTextLine;
}(FigureTextBase);

var FigureTextLines = /*#__PURE__*/function (_FigureTextLine) {
  _inherits(FigureTextLines, _FigureTextLine);

  var _super3 = _createSuper(FigureTextLines);

  function FigureTextLines(drawContext2D) {
    var _this3;

    var location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    var text = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var font = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FigureFont().definition();
    var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    var inLine = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    var line = arguments.length > 6 ? arguments[6] : undefined;
    var touchBorder = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var onClick = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
    var followOffsetY = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
    var lSpace = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var rSpace = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;

    _classCallCheck(this, FigureTextLines);

    _this3 = _super3.call(this, drawContext2D, location, text, font, offset, inLine, touchBorder, onClick, followOffsetY, lSpace, rSpace);
    _this3.line = line; // this.update();

    return _this3;
  }

  _createClass(FigureTextLines, [{
    key: "_dup",
    value: function _dup() {
      return new FigureTextLines(this.drawContext2D, this.location, this.text, this.font.definition(), this.offset, this.inLine, this.line, this.touchBorder, this.onClick, this.followOffsetY, this.lSpace, this.rSpace);
    }
  }]);

  return FigureTextLines;
}(FigureTextLine); // Order of definition:
// * Constructor - setup empty structures
// * loadText
//    - calculateScalingFactor
//    - setTextLocations - lays out text from location property or in line
//    - calcBoundsAndBorder


var TextObjectBase = /*#__PURE__*/function (_DrawingObject) {
  _inherits(TextObjectBase, _DrawingObject);

  var _super4 = _createSuper(TextObjectBase);

  // borderSetup: 'text' | 'rect' | Array<Point>;
  // touchBorderSetup: 'text' | 'rect' | 'border' | number | Array<Point>;
  function TextObjectBase(drawContext2D) {
    var _this4;

    _classCallCheck(this, TextObjectBase);

    _this4 = _super4.call(this);

    if (Array.isArray(drawContext2D)) {
      _this4.drawContext2D = drawContext2D;
    } else {
      _this4.drawContext2D = [drawContext2D];
    }

    _this4.lastDrawTransform = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    _this4.text = []; // this.state = 'loaded';

    return _this4;
  } // eslint-disable-next-line no-unused-vars


  _createClass(TextObjectBase, [{
    key: "loadText",
    value: function loadText(options) {
      // Assign text to this.text here
      // this.text = options.text
      // Calculate Scaling Factor
      this.calcScalingFactor(); // Layout text and calculat boundaries

      this.layoutText();
    } // calcTextBounds() {
    //   this.text.forEach((t) => {
    //     t.calcBorderAndBounds();
    //   });
    // }
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "setTextLocations",
    value: function setTextLocations() {}
  }, {
    key: "click",
    value: function click(p, fnMap) {
      this.text.forEach(function (text) {
        if (text.onClick != null) {
          // console.log(text.touchBorder, lastDrawTransformMatrix)
          // const glBorder = this.transformBorder([text.touchBorder], lastDrawTransformMatrix);
          // console.log(glBorder)
          if (p.isInPolygon(text.textBorderBuffer)) {
            fnMap.exec(text.onClick, fnMap);
          }
        }
      });
    }
  }, {
    key: "calcScalingFactor",
    value: function calcScalingFactor() {
      var scalingFactor = 1;

      if (this.text.length > 0) {
        var minSize = this.text[0].font.size;
        this.text.forEach(function (t) {
          if (t.font.size > 0 && t.font.size < minSize) {
            minSize = t.font.size;
          }
        });
        scalingFactor = 20 / minSize;
      }

      this.scalingFactor = scalingFactor;
    }
  }, {
    key: "setText",
    value: function setText(textOrOptions) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.clear();
      this.text[index].setText(textOrOptions);
      this.setBorder();
      this.setTouchBorder(); // this.layoutText();
    } // setText(text: string, index: number = 0) {
    //   this.text[index].setText(text);
    //   this.setBorder();
    //   this.setTouchBorder();
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var c = new TextObjectBase(this.drawContext2D);
      return c;
    }
  }, {
    key: "setFont",
    value: function setFont(font) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.clear();

      if (index === null) {
        for (var i = 0; i < this.text.length; i += 1) {
          this.text[i].setFont(font);
        }
      } else {
        this.text[index].setFont(font);
      }

      this.layoutText();
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.clear();

      if (index === null) {
        for (var i = 0; i < this.text.length; i += 1) {
          this.setFont({
            opacity: opacity
          }, i);
        }
      } else {
        this.setFont({
          opacity: opacity
        }, index);
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (index === null) {
        for (var i = 0; i < this.text.length; i += 1) {
          this.text[i].font.color = color.slice();
        }
      } else {
        this.text[index].font.color = color.slice();
      }
    }
  }, {
    key: "layoutText",
    value: function layoutText() {
      this.setTextLocations();
      this.text.forEach(function (t) {
        t.calcBorderAndBounds();
      });
      this.setBorder();
      this.setTouchBorder();
    } // setGenericBorder(name: string) {
    //   // $FlowFixMe
    //   if (Array.isArray(this[`${name}Setup`])) {  // $FlowFixMe
    //     this[name] = this[`${name}Setup`];
    //     return;
    //   }
    //   const border = [];
    //   this.text.forEach((text) => {
    //     border.push(  // $FlowFixMe
    //       text[name],
    //     );
    //   }); // $FlowFixMe
    //   if (this[`${name}Setup`] === 'text') {  // $FlowFixMe
    //     this[name] = border;
    //     return;
    //   }  // $FlowFixMe
    //   const bounds = getBoundingRect(border);  // $FlowFixMe
    //   if (this[`${name}Setup`] === 'rect') {  // $FlowFixMe
    //     this[name] = [[
    //       new Point(bounds.left, bounds.bottom),
    //       new Point(bounds.right, bounds.bottom),
    //       new Point(bounds.right, bounds.top),
    //       new Point(bounds.left, bounds.top),
    //     ]];
    //     return;
    //   }  // $FlowFixMe
    //   const buffer = this[`${name}Setup`];  // $FlowFixMe
    //   this[name] = [[
    //     new Point(bounds.left - buffer, bounds.bottom - buffer),
    //     new Point(bounds.right + buffer, bounds.bottom - buffer),
    //     new Point(bounds.right + buffer, bounds.top + buffer),
    //     new Point(bounds.left - buffer, bounds.top + buffer),
    //   ]];
    // }

  }, {
    key: "setBorder",
    value: function setBorder() {
      var _this5 = this;

      // this.setGenericBorder('border');
      this.textBorder = [];
      this.text.forEach(function (text) {
        _this5.textBorder.push(text.textBorder);
      });
    }
  }, {
    key: "setTouchBorder",
    value: function setTouchBorder() {
      var _this6 = this;

      this.textBorderBuffer = [];
      this.text.forEach(function (text) {
        _this6.textBorderBuffer.push(text.textBorderBuffer);
      }); // if (this.touchBorderSetup === 'border') {
      //   this.touchBorder = this.border;
      //   return;
      // }
      // this.setGenericBorder('touchBorder');
      // console.log(this.touchBorderSetup, this.touchBorder)
    } // getBoundaries(
    //   transformMatrix: Array<number>,
    // ): Array<Array<Point>> {
    //   const boundaries: Array<Array<Point>> = [];
    //   this.text.forEach((t) => {
    //     boundaries.push(t.getBoundary(transformMatrix));
    //   });
    //   return boundaries;
    // }
    // Text is drawn in pixel space which is 0, 0 in the left hand top corner on
    // a canvas of size canvas.offsetWidth x canvas.offsetHeight.
    //
    // Font size and text location is therefore defined in pixels in Context2D.
    //
    // However, in a Figure, the text canvas is overlaid on the figure GL
    // canvas and we want to think about the size and location of text in
    // Figure Space or Element Space (if the element has a specific transform).
    //
    // For example, if we have a figure with limits: min: (0, 0), max(2, 1)
    // with a canvas of 1000 x 500 then:
    //    1) Transform pixel space (1000 x 500) to be GL Space (2 x 2). i.e.
    //         - Magnify pixel space by 500 so one unit in the 2D drawing
    //           context is equivalent to 1 unit in GL Space.
    //         - Translate pixel space so 0, 0 is in the middle of the canvas
    //    2) Transform GL Space to Element Space
    //         - The transform matrix in the input parameters includes the
    //           transform to Figure Space and then Element Space.
    //         - Now one unit in the 2D drawing context is equivalent to 1 unit
    //           in Element Space - i.e. the canvas will have limits of min(0, 0)
    //           and max(2, 1).
    //    3) Plot out all text
    //
    // However, when font size is defined in Element Space, and ends up being
    // <1 Element Space units, we have a problem. This is because font size is
    // still in pixels (just now it's super scaled up). Therefore, a scaling
    // factor is needed to make sure the font size can stay well above 1. This
    // scaling factor scales the final space, so a larger font size can be used.
    // Then all locations defined in Element Space also need to be scaled by
    // this scaling factor.
    //
    // The scaling factor can be number that is large enough to make it so the
    // font size is >>1. In the TextObject constructor, the scaling factor is
    // designed to ensure drawn text always is >20px.
    //
    // Therefore the different spaces are:
    //   - pixelSpace - original space of the 2D canvas
    //   - elementSpace - space of the FigureElementPrimitive that holds text
    //   - scaledPixelSpace
    //

  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix) {
      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1, 1];
      var contextIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var drawContext2D = this.drawContext2D[contextIndex];
      var ctx = this.drawContext2D[contextIndex].ctx;
      ctx.save(); // Scaling factor used to ensure font size is >> 1 pixel

      var scalingFactor = this.scalingFactor; // Find the scaling factor between GL space (width 2, height 2) and canvas
      // pixel space (width offsetWidth, height offsetHeight)
      // This is how much we will zoom in on our ctx so one GL unit is
      // one pixel unit

      var sx = drawContext2D.canvas.offsetWidth / 2;
      var sy = drawContext2D.canvas.offsetHeight / 2; // GL space (0, 0) is the center of the canvas, and Pixel Space (0, 0)
      // is the top left of the canvas. Therefore, translate pixel space so
      // if we put in (0, 0) we actually draw to the center of the canvas

      var tx = drawContext2D.canvas.offsetWidth / 2;
      var ty = drawContext2D.canvas.offsetHeight / 2; // So our GL to Pixel Space matrix is now:

      var glToPixelSpaceMatrix = [sx, 0, tx, 0, sy, ty, 0, 0, 1]; // The incoming transform matrix transforms elementSpace to glSpace.
      // Modify the incoming transformMatrix to be compatible with
      // pixel space
      //   - Flip the y translation
      //   - Reverse rotation

      var tm = transformMatrix;
      var elementToGLMatrix = [tm[0], -tm[1], tm[2], -tm[3], tm[4], tm[5] * -1, 0, 0, 1]; // Combine the elementToGL transform and glToPixel transforms
      // A X B is apply B then apply A, so apply element to GL, then GL to Pixel

      var elementToPixelMatrix = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["mul"](glToPixelSpaceMatrix, elementToGLMatrix); // At this point in time the ctx will be zoomed in such that every 1 unit
      // of element space is 1 pixel/unit in ctx space. But because font sizes
      // need to be >1px, we are going to scale out so we can use a font size of
      // ~20px.

      var pixelToScaledPixelMatrix = [1 / scalingFactor, 0, 0, 0, 1 / scalingFactor, 0, 0, 0, 1];
      var elementToScaledPixelMatrix = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["mul"](elementToPixelMatrix, pixelToScaledPixelMatrix); // The ctx transform is defined in a different order:

      var cA = elementToScaledPixelMatrix[0];
      var cB = elementToScaledPixelMatrix[3];
      var cC = elementToScaledPixelMatrix[1];
      var cD = elementToScaledPixelMatrix[4];
      var cE = elementToScaledPixelMatrix[2];
      var cF = elementToScaledPixelMatrix[5]; // Apply the transform to the ctx. We are now in Scaled

      ctx.transform(cA, cB, cC, cD, cE, cF);
      this.lastDrawTransform = elementToScaledPixelMatrix.slice(); // Some bug I don't understand in webgl is effectively cubing the alph
      // channel. So make the same here to fade-ins happen at same rate

      var c = color.slice();
      c[3] *= c[3] * c[3]; // Fill in all the text

      this.text.forEach(function (figureText) {
        // eslint-disable-next-line no-param-reassign
        figureText.lastDraw = {
          x: figureText.locationAligned.x * scalingFactor,
          y: figureText.locationAligned.y * -scalingFactor,
          width: figureText.bounds.width * scalingFactor,
          height: figureText.bounds.height * scalingFactor
        };
        figureText.font.setFontInContext(ctx, scalingFactor);
        figureText.font.setColorInContext(ctx, c);
        ctx.fillText(figureText.text, figureText.locationAligned.x * scalingFactor, figureText.locationAligned.y * -scalingFactor);
      });
      ctx.restore();
    }
  }, {
    key: "clear",
    value: function clear() {
      var contextIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var ctx = this.drawContext2D[contextIndex].ctx;
      var t = this.lastDrawTransform;
      ctx.save();
      ctx.transform(t[0], t[3], t[1], t[4], t[2], t[5]); // console.log('start clear');

      this.text.forEach(function (figureText) {
        // const x = figureText.locationAligned.x * this.scalingFactor;
        // const y = figureText.locationAligned.y * -this.scalingFactor;
        // const width = figureText.bounds.width * this.scalingFactor;
        // const height = figureText.bounds.height * this.scalingFactor;
        if (figureText.lastDraw != null) {
          var _figureText$lastDraw = figureText.lastDraw,
              x = _figureText$lastDraw.x,
              y = _figureText$lastDraw.y,
              width = _figureText$lastDraw.width,
              height = _figureText$lastDraw.height;
          ctx.clearRect(x - width * 0.5, y + height * 0.5, width * 2, -height * 2 // x - width * 1,
          // y + height * 1,
          // width * 3,
          // -height * 3,\
          ); // ctx.rect(
          //   x - width * 0.5, y + height * 0.5, width * 2, -height * 2,
          //   // (figureText.locationAligned.x) * scalingFactor,
          //   // (figureText.locationAligned.y) * -scalingFactor,
          // );
          // ctx.fill();
          // eslint-disable-next-line no-param-reassign

          figureText.lastDraw = null;
        }
      });
      ctx.restore();
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return _toConsumableArray(_get(_getPrototypeOf(TextObjectBase.prototype), "_getStateProperties", this).call(this));
    }
  }]);

  return TextObjectBase;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_2__["default"]); // TextObject is the DrawingObject used in the FigureElementPrimitive.
// TextObject will draw an array of FigureText objects.


var TextObject = /*#__PURE__*/function (_TextObjectBase) {
  _inherits(TextObject, _TextObjectBase);

  var _super5 = _createSuper(TextObject);

  function TextObject() {
    _classCallCheck(this, TextObject);

    return _super5.apply(this, arguments);
  }

  _createClass(TextObject, [{
    key: "loadText",
    value: function loadText(options) {
      var _this7 = this;

      var textArray = options.text;

      if (!Array.isArray(textArray)) {
        textArray = [textArray];
      }

      var figureTextArray = [];
      textArray.forEach(function (textDefinition) {
        var font;
        var location;
        var xAlign;
        var yAlign;
        var textToUse; // let border;

        var touchBorder;
        var onClick;

        if (typeof textDefinition === 'string') {
          textToUse = textDefinition;
        } else {
          font = textDefinition.font;
          location = textDefinition.location;
          xAlign = textDefinition.xAlign;
          yAlign = textDefinition.yAlign;
          touchBorder = textDefinition.touchBorder;
          onClick = textDefinition.onClick;
          textToUse = textDefinition.text; // if (Array.isArray(border)) {  // $FlowFixMe
          //   border = getPoints(border);
          // }
          // if (Array.isArray(touchBorder)) {  // $FlowFixMe
          //   touchBorder = getPoints(touchBorder);
          // }
        }

        var locationToUse;

        if (location == null) {
          locationToUse = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
        } else {
          locationToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(location);
        }

        var fontToUse = options.font;

        if (font != null) {
          fontToUse = font;
        }

        if (touchBorder != null && Array.isArray(touchBorder) && !Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["isBuffer"])(touchBorder)) {
          // $FlowFixMe
          var _getBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBorder"])(touchBorder);

          var _getBorder2 = _slicedToArray(_getBorder, 1);

          touchBorder = _getBorder2[0];
        }

        var fontDefinition = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, options.font, fontToUse);
        figureTextArray.push(new FigureText(_this7.drawContext2D, locationToUse, // $FlowFixMe
        textToUse, fontDefinition, xAlign || options.xAlign, yAlign || options.yAlign, // $FlowFixMe
        touchBorder || options.defaultTextTouchBorder, onClick));
      });
      this.text = figureTextArray; // super.loadText();

      this.calcScalingFactor(); // this.borderSetup = options.border || [];
      // this.touchBorderSetup = options.touchBorder || [];

      this.layoutText();
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var c = new TextObject(this.drawContext2D); // $FlowFixMe

      c.text = this.text.map(function (t) {
        return t._dup();
      });
      c.scalingFactor = this.scalingFactor;
      c.layoutText();
      return c;
    }
  }]);

  return TextObject;
}(TextObjectBase);

function createLine(textArray) {
  var initialLocation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
  var lastRight = initialLocation;
  var maxY = 0;
  var minY = 0;
  textArray.forEach(function (text) {
    // eslint-disable-next-line no-param-reassign
    text.location = lastRight.add(text.offset).add(text.lSpace);

    if (text.inLine) {
      if (text.followOffsetY) {
        lastRight = text.location.add(text.measure.width + text.rSpace, 0);
      } else {
        lastRight = text.location.add(text.measure.width + text.rSpace, -text.offset.y);
      }

      var textMaxY = text.location.y + text.measure.ascent;
      var textMinY = text.location.y - text.measure.descent;

      if (textMaxY > maxY) {
        maxY = textMaxY;
      }

      if (textMinY < minY) {
        minY = textMinY;
      }
    }
  });
  var width = lastRight.x - 0;
  return {
    width: width,
    minY: minY,
    maxY: maxY
  };
}

function align(textArray, xAlign, yAlign, width, minY, maxY) // useLocation: boolean = false,
{
  var locationAlignOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);

  if (xAlign === 'center') {
    locationAlignOffset.x -= width / 2;
  } else if (xAlign === 'right') {
    locationAlignOffset.x -= width;
  }

  if (yAlign === 'bottom') {
    locationAlignOffset.y -= minY;
  } else if (yAlign === 'middle') {
    locationAlignOffset.y += -minY - (maxY - minY) / 2;
  } else if (yAlign === 'top') {
    locationAlignOffset.y -= maxY;
  }

  textArray.forEach(function (text) {
    // eslint-disable-next-line no-param-reassign
    text.locationAligned = text.location.add(locationAlignOffset);
  });
}

var TextLineObject = /*#__PURE__*/function (_TextObjectBase2) {
  _inherits(TextLineObject, _TextObjectBase2);

  var _super6 = _createSuper(TextLineObject);

  function TextLineObject() {
    _classCallCheck(this, TextLineObject);

    return _super6.apply(this, arguments);
  }

  _createClass(TextLineObject, [{
    key: "loadText",
    // $FlowFixMe
    // default xAlign
    // default yAlign
    // $FlowFixMe
    value: function loadText(options) {
      var _this8 = this;

      var textArray = options.text;

      if (!Array.isArray(textArray)) {
        textArray = [textArray];
      }

      var figureTextArray = [];
      textArray.forEach(function (textDefinition) {
        var font;
        var offset;
        var inLine;
        var followOffsetY;
        var textToUse; // let border;

        var touchBorder;
        var onClick;
        var lSpace;
        var rSpace;

        if (typeof textDefinition === 'string') {
          textToUse = textDefinition;
        } else {
          font = textDefinition.font;
          offset = textDefinition.offset;
          inLine = textDefinition.inLine;
          touchBorder = textDefinition.touchBorder;
          onClick = textDefinition.onClick;
          followOffsetY = textDefinition.followOffsetY;
          lSpace = textDefinition.lSpace;
          rSpace = textDefinition.rSpace;
          textToUse = textDefinition.text; // if (Array.isArray(border)) {  // $FlowFixMe
          //   border = getPoints(border);
          // }
          // if (Array.isArray(touchBorder)) {  // $FlowFixMe
          //   touchBorder = getBorder(touchBorder);
          // }

          if (touchBorder != null && Array.isArray(touchBorder) && !Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["isBuffer"])(touchBorder)) {
            // $FlowFixMe
            var _getBorder3 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBorder"])(touchBorder);

            var _getBorder4 = _slicedToArray(_getBorder3, 1);

            touchBorder = _getBorder4[0];
          }
        }

        var offsetToUse;

        if (offset == null) {
          offsetToUse = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
        } else {
          offsetToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(offset);
        }

        var fontToUse = options.font;

        if (font != null) {
          fontToUse = font;
        }

        var fontDefinition = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, options.font, fontToUse);

        if (fontDefinition.color == null && options.color != null) {
          fontDefinition.color = options.color;
        }

        figureTextArray.push(new FigureTextLine(_this8.drawContext2D, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), textToUse, fontDefinition, offsetToUse, inLine, // $FlowFixMe
        touchBorder || options.defaultTextTouchBorder, onClick, followOffsetY, lSpace, rSpace));
      });
      this.text = figureTextArray;
      this.xAlign = options.xAlign;
      this.yAlign = options.yAlign;
      this.calcScalingFactor(); // this.borderSetup = options.border || [];
      // this.touchBorderSetup = options.touchBorder || [];

      this.layoutText();
    }
  }, {
    key: "setText",
    value: function setText(textOrOptions) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      // if (textOrOptions.text.startsWith('abc')) {
      // }
      this.text[index].setText(textOrOptions);
      this.layoutText(); // this.setBorder();
      // this.setTouchBorder();
    }
  }, {
    key: "setTextLocations",
    value: function setTextLocations() {
      var _createLine = createLine(this.text),
          width = _createLine.width,
          minY = _createLine.minY,
          maxY = _createLine.maxY;

      align(this.text, this.xAlign, this.yAlign, width, minY, maxY);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var c = new TextLineObject(this.drawContext2D);
      c.text = this.text.map(function (t) {
        return t._dup();
      });
      c.scalingFactor = this.scalingFactor;
      c.xAlign = this.xAlign;
      c.yAlign = this.yAlign;
      c.layoutText();
      return c;
    }
  }]);

  return TextLineObject;
}(TextObjectBase);

var TextLinesObject = /*#__PURE__*/function (_TextObjectBase3) {
  _inherits(TextLinesObject, _TextObjectBase3);

  var _super7 = _createSuper(TextLinesObject);

  function TextLinesObject() {
    _classCallCheck(this, TextLinesObject);

    return _super7.apply(this, arguments);
  }

  _createClass(TextLinesObject, [{
    key: "loadText",
    // $FlowFixMe
    // default xAlign
    // default yAlign
    // $FlowFixMe
    value: function loadText(options) {
      var _this9 = this;

      // console.log('asdfasdf')
      // let { lines } = options;
      var textLines = options.text;

      if (typeof textLines === 'string') {
        textLines = [textLines];
      }

      this.modifiers = options.modifiers || {};
      this.lines = [];
      var figureTextArray = [];
      textLines.forEach(function (lineDefinition, lineIndex) {
        var lineJustification = options.justify;
        var lineLineSpace = options.lineSpace;
        var lineToUse;
        var lineFont = options.font;

        if (typeof lineDefinition !== 'string') {
          var font = lineDefinition.font,
              justify = lineDefinition.justify,
              lineSpace = lineDefinition.lineSpace;
          lineToUse = lineDefinition.text;

          if (font != null) {
            lineFont = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, options.font, font);
          }

          if (lineSpace != null) {
            lineLineSpace = lineSpace;
          }

          if (justify != null) {
            lineJustification = justify;
          }
        } else {
          lineToUse = lineDefinition;
        }

        var line = [];
        var split = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["splitString"])(lineToUse, '|', '/');
        split.forEach(function (s) {
          var text = s;
          var textFont = lineFont;
          var offset = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
          var inLine = true; // let border;

          var touchBorder;
          var onClick;
          var followOffsetY = false;
          var rSpace = 0;
          var lSpace = 0;

          if (_this9.modifiers[s] != null) {
            var mod = _this9.modifiers[s];

            if (mod.text != null) {
              text = mod.text;
            }

            if (mod.font != null) {
              textFont = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, lineFont, mod.font);
            }

            if (mod.inLine != null) {
              inLine = mod.inLine;
            }

            if (mod.offset != null) {
              offset = mod.offset;
            } // if (mod.border != null) {
            //   border = mod.border;
            // }


            if (mod.touchBorder != null) {
              touchBorder = mod.touchBorder;

              if (touchBorder != null && Array.isArray(touchBorder) && !Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["isBuffer"])(touchBorder)) {
                // $FlowFixMe
                var _getBorder5 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBorder"])(touchBorder);

                var _getBorder6 = _slicedToArray(_getBorder5, 1);

                touchBorder = _getBorder6[0];
              }
            }

            if (mod.onClick != null) {
              onClick = mod.onClick;
            }

            if (mod.followOffsetY != null) {
              followOffsetY = mod.followOffsetY;
            }

            if (mod.lSpace != null) {
              lSpace = mod.lSpace;
            }

            if (mod.rSpace != null) {
              rSpace = mod.rSpace;
            } // if (Array.isArray(border)) {  // $FlowFixMe
            //   border = getPoints(border);
            // }
            // if (Array.isArray(touchBorder)) {  // $FlowFixMe
            //   touchBorder = getBorder(touchBorder);
            // }

          }

          var t = new FigureTextLines(_this9.drawContext2D, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), text, textFont, offset, inLine, lineIndex, // $FlowFixMe
          touchBorder || options.defaultTextTouchBorder, onClick, followOffsetY, lSpace, rSpace);
          figureTextArray.push(t);
          line.push(t);
        });

        _this9.lines.push({
          justify: lineJustification,
          space: lineLineSpace,
          text: line,
          width: 0
        });
      });
      this.text = figureTextArray;
      this.xAlign = options.xAlign;
      this.yAlign = options.yAlign; // super.super.loadText();

      this.calcScalingFactor(); // this.borderSetup = options.border || [];
      // this.touchBorderSetup = options.touchBorder || [];

      this.layoutText();
    }
  }, {
    key: "setText",
    value: function setText(textOrOptions) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.text[index].setText(textOrOptions);
      this.layoutText();
    }
  }, {
    key: "setTextLocations",
    value: function setTextLocations() {
      var _this$createLines = this.createLines(),
          width = _this$createLines.width,
          minY = _this$createLines.minY,
          maxY = _this$createLines.maxY; // $FlowFixMe


      align(this.text, this.xAlign, this.yAlign, width, minY, maxY);
    }
  }, {
    key: "createLines",
    value: function createLines() {
      var maxLinesY = 0;
      var minLinesY = 0;
      var maxLinesWidth = 0;
      var y = 0;
      this.lines.forEach(function (line, index) {
        if (index > 0 && line.text.length > 0) {
          y -= line.space;
        } else if (index > 0 && line.text.length === 0) {
          y -= line.space / 3;
        }

        var _createLine2 = createLine(line.text, new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, y)),
            width = _createLine2.width,
            minY = _createLine2.minY,
            maxY = _createLine2.maxY;

        minLinesY = minY < minLinesY ? minY : minLinesY;
        maxLinesY = maxY > maxLinesY ? maxY : maxLinesY;
        maxLinesWidth = width > maxLinesWidth ? width : maxLinesWidth;
        line.width = width; // eslint-disable-line no-param-reassign
      }); // justify lines

      this.lines.forEach(function (line) {
        var locationAlignOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);

        if (line.justify === 'center') {
          locationAlignOffset.x += maxLinesWidth / 2 - line.width / 2;
        } else if (line.justify === 'right') {
          locationAlignOffset.x += maxLinesWidth - line.width;
        }

        line.text.forEach(function (text) {
          // eslint-disable-next-line no-param-reassign
          text.location = text.location.add(locationAlignOffset);
        });
      });
      return {
        width: maxLinesWidth,
        minY: minLinesY,
        maxY: maxLinesY
      };
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var c = new TextLineObject(this.drawContext2D);
      c.text = this.text.map(function (t) {
        return t._dup();
      });
      c.scalingFactor = this.scalingFactor;
      c.xAlign = this.xAlign;
      c.yAlign = this.yAlign;
      c.layoutText();
      return c;
    }
  }]);

  return TextLinesObject;
}(TextObjectBase);



/***/ }),

/***/ "./src/js/figure/DrawingObjects/VertexObject/VertexGeneric.js":
/*!********************************************************************!*\
  !*** ./src/js/figure/DrawingObjects/VertexObject/VertexGeneric.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VertexObject */ "./src/js/figure/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _geometries_copy_copy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geometries/copy/copy */ "./src/js/figure/geometries/copy/copy.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

 // import type { TypeParsablePoint } from '../../../tools/g2';






var VertexGeneric = /*#__PURE__*/function (_VertexObject) {
  _inherits(VertexGeneric, _VertexObject);

  var _super = _createSuper(VertexGeneric);

  // borderToPoint: TypeBorderToPoint;
  function VertexGeneric(webgl) {
    var _this;

    var textureLocation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var textureVertexSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var textureCoords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1);
    var textureRepeat = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    _classCallCheck(this, VertexGeneric);

    if (textureLocation !== '') {
      _this = _super.call(this, webgl, 'withTexture', 'withTexture');
    } else {
      _this = _super.call(this, webgl);
    }

    _this.vertices = [];
    _this.copy = []; // this.change({
    //   points: vertices,
    //   copy,
    //   drawType,
    // });
    // this.setupTexture(textureLocation, textureVertexSpace, textureCoords, textureRepeat);

    if (textureLocation !== '') {
      _this.texOptions = {
        location: textureLocation,
        mapTo: textureVertexSpace,
        mapFrom: textureCoords,
        repeat: textureRepeat
      };
      _this.texture = {
        id: _this.texOptions.location,
        src: _this.texOptions.location,
        type: 'image',
        points: [],
        repeat: _this.texOptions.repeat
      };

      _this.setupTexture();
    }

    _this.setupBuffer();

    return _possibleConstructorReturn(_this);
  } // $FlowFixMe


  _createClass(VertexGeneric, [{
    key: "change",
    value: function change(options) {
      var _this2 = this;

      var points = options.points,
          drawType = options.drawType,
          copy = options.copy,
          texture = options.texture;

      if (points != null) {
        this.vertices = points;
      }

      if (drawType != null) {
        if (drawType === 'lines') {
          this.glPrimitive = this.gl[0].LINES;
        } else if (drawType === 'strip') {
          this.glPrimitive = this.gl[0].TRIANGLE_STRIP;
        } else if (drawType === 'fan') {
          this.glPrimitive = this.gl[0].TRIANGLE_FAN;
        } else {
          this.glPrimitive = this.gl[0].TRIANGLES;
        }
      }

      if (copy != null) {
        this.copy = copy;
      }

      var newVerts = Object(_geometries_copy_copy__WEBPACK_IMPORTED_MODULE_4__["copyPoints"])(this.vertices, this.copy);
      this.points = [];
      newVerts.forEach(function (v) {
        _this2.points.push(v.x);

        _this2.points.push(v.y);
      });

      if (texture != null) {
        if (texture.mapTo != null) {
          texture.mapTo = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getRect"])(texture.mapTo);
        }

        if (texture.mapFrom != null) {
          texture.mapFrom = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getRect"])(texture.mapFrom);
        }

        this.texOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.texOptions, texture);
        this.setupTexture();
      }

      this.resetBuffer();
    }
  }, {
    key: "setupTexture",
    value: function setupTexture() // textureLocation: string = '',
    // textureVertexSpace: Rect = new Rect(-1, -1, 2, 2),
    // textureCoords: Rect = new Rect(0, 0, 1, 1),
    // textureRepeat: boolean = false,
    {
      if (this.texOptions.location) {
        // this.texture = {
        //   id: textureLocation,
        //   src: textureLocation,
        //   type: 'image',
        //   points: [],
        //   repeat: textureRepeat,
        // };
        this.createTextureMap(this.texOptions.mapTo.left, this.texOptions.mapTo.right, this.texOptions.mapTo.bottom, this.texOptions.mapTo.top, this.texOptions.mapFrom.left, this.texOptions.mapFrom.right, this.texOptions.mapFrom.bottom, this.texOptions.mapFrom.top);
      }
    } // setupPoints(
    // ) {
    //   const newVerts = copyPoints(this.vertices, this.copy);
    //   this.points = [];
    //   newVerts.forEach((v) => {
    //     this.points.push(v.x);
    //     this.points.push(v.y);
    //   });
    //   // let bounds;
    //   // if (border === 'rect' || touchBorder === 'rect') {
    //   //   const boundingRect = getBoundingRect(newVerts);
    //   //   bounds = [
    //   //     new Point(boundingRect.left, boundingRect.bottom),
    //   //     new Point(boundingRect.right, boundingRect.bottom),
    //   //     new Point(boundingRect.right, boundingRect.top),
    //   //     new Point(boundingRect.left, boundingRect.top),
    //   //   ];
    //   // }
    //   // if (border === 'rect') {  // $FlowFixMe
    //   //   this.border = [bounds];
    //   // } else if (border === 'points') {
    //   //   this.border = [newVerts];
    //   // } else {
    //   //   this.border = border;
    //   // }
    //   // if (touchBorder === 'none') {
    //   //   this.touchBorder = [];
    //   // } else if (touchBorder === 'rect') {   // $FlowFixMe
    //   //   this.touchBorder = [bounds];
    //   // } else if (touchBorder === 'border') {  // $FlowFixMe
    //   //   this.touchBorder = this.border;
    //   // } else {
    //   //   this.touchBorder = touchBorder;
    //   // }
    //   // if (holeBorder === 'none') {
    //   //   this.hole = [];
    //   // } else {
    //   //   this.hole = holeBorder;
    //   // }
    // }

  }]);

  return VertexGeneric;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexGeneric);

/***/ }),

/***/ "./src/js/figure/DrawingObjects/VertexObject/VertexObject.js":
/*!*******************************************************************!*\
  !*** ./src/js/figure/DrawingObjects/VertexObject/VertexObject.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _DrawingObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DrawingObject */ "./src/js/figure/DrawingObjects/DrawingObject.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import * as g2 from '../g2';


 // import type { TypeParsablePoint } from '../../../tools/g2';



// Base clase of all shape objects made from verteces for webgl.
// The job of a VertexObject is to:
//  - Have the points of a object/shape
//  - Have the shape's border (used to determine whether a location is
//    within the shape)
//  - Setup the webgl buffer
//  - Draw the shape
var VertexObject = /*#__PURE__*/function (_DrawingObject) {
  _inherits(VertexObject, _DrawingObject);

  var _super = _createSuper(VertexObject);

  // shortcut for the webgl context
  // webgl instance for a html canvas
  // primitive tyle (e.g. TRIANGLE_STRIP)
  // Vertex buffer
  // textureBuffer: WebGLBuffer;
  // Primitive vertices of shape
  // Number of primative vertices
  // border: Array<Array<Point>>; // Border vertices
  // +change: (Array<Point>) => void;
  function VertexObject(webgl) {
    var _this;

    var vertexShader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'simple';
    var fragmentShader = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'simple';

    _classCallCheck(this, VertexObject);

    _this = _super.call(this);
    _this.numPoints = 0;
    var webglArray;

    if (Array.isArray(webgl)) {
      webglArray = webgl;
    } else {
      webglArray = [webgl];
    }

    _this.gl = webglArray.map(function (w) {
      return w.gl;
    });
    _this.webgl = webglArray;
    _this.glPrimitive = webglArray[0].gl.TRIANGLES;
    _this.points = [];
    _this.z = 0;
    _this.buffer = webglArray.map(function () {
      return null;
    }); // this.textureLocation = '';
    // this.texturePoints = [];

    _this.texture = null;
    _this.programIndex = webglArray.map(function (w) {
      return w.getProgram(vertexShader, fragmentShader);
    });
    _this.type = 'vertexPrimitive';
    return _this;
  }

  _createClass(VertexObject, [{
    key: "addTextureToBuffer",
    value: function addTextureToBuffer(glIndex, glTexture, image, // image data
    repeat) {
      function isPowerOf2(value) {
        // eslint-disable-next-line no-bitwise
        return (value & value - 1) === 0;
      }

      var gl = this.gl[glIndex];
      var webgl = this.webgl[glIndex];
      var texture = this.texture;

      if (texture != null) {
        var index = webgl.textures[texture.id].index;
        gl.activeTexture(gl.TEXTURE0 + index);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); // Check if the image is a power of 2 in both dimensions.

        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
          // Yes, it's a power of 2. Generate mips.
          gl.generateMipmap(gl.TEXTURE_2D);

          if (repeat != null && repeat === true) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
          } else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          }
        } else {
          // No, it's not a power of 2. Turn off mips and set wrapping to clamp to edge
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        }
      }
    }
  }, {
    key: "setupBuffer",
    value: function setupBuffer() {
      var _this2 = this;

      var numPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var _loop = function _loop(glIndex) {
        // console.log(glIndex)
        var gl = _this2.gl[glIndex];
        var webgl = _this2.webgl[glIndex]; // const texture = this.texture[glIndex];
        // const buffer = this.buffer[glIndex];

        _this2.state = 'loaded';

        if (numPoints === 0) {
          _this2.numPoints = _this2.points.length / 2.0;
        } else {
          _this2.numPoints = numPoints;
        } // if (this.texture && this.texture.points == null) {
        //   this.texture.points = [];
        //   this.createTextureMap();
        // }


        var texture = _this2.texture;

        if (texture != null) {
          if (texture.points == null) {
            texture.points = [];
          }

          if (texture.points.length === 0) {
            _this2.createTextureMap();
          }

          if (texture.buffer == null) {
            texture.buffer = _this2.gl.map(function () {
              return null;
            });
          } // $FlowFixMe


          texture.buffer[glIndex] = gl.createBuffer(); // $FlowFixMe

          gl.bindBuffer(gl.ARRAY_BUFFER, texture.buffer[glIndex]);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texture.points), gl.STATIC_DRAW);

          if (!(texture.id in webgl.textures) || texture.id in webgl.textures && webgl.textures[texture.id].glTexture == null) {
            var glTexture = gl.createTexture();
            webgl.addTexture(texture.id, glTexture, texture.type);
            gl.activeTexture(gl.TEXTURE0 + webgl.textures[texture.id].index);
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            var src = texture.src;

            if (src && texture.data == null) {
              // Fill the texture with a 1x1 blue pixel.
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 100]));
              var image = new Image();
              image.src = src;
              _this2.state = 'loading';
              webgl.textures[texture.id].state = 'loading';
              webgl.textures[texture.id].onLoad.push(_this2.executeOnLoad.bind(_this2));
              image.addEventListener('load', function () {
                // Now that the image has loaded make copy it to the texture.
                texture.data = image;

                _this2.addTextureToBuffer(glIndex, glTexture, texture.data, texture.repeat); // if (this.onLoad != null) {


                webgl.onLoad(texture.id); // this.onLoad();
                // }

                _this2.state = 'loaded';
                webgl.textures[texture.id].state = 'loaded';
              });
            } else if (texture.data != null) {
              _this2.addTextureToBuffer(glIndex, glTexture, texture.data, texture.repeat);
            }
          } else if (texture.id in webgl.textures) {
            if (webgl.textures[texture.id].state === 'loading') {
              _this2.state = 'loading';
              webgl.textures[texture.id].onLoad.push(_this2.executeOnLoad.bind(_this2));
            } else {
              _this2.state = 'loaded';
            }
          }
        }

        _this2.buffer[glIndex] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, _this2.buffer[glIndex]);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(_this2.points), gl.STATIC_DRAW);
      };

      for (var glIndex = 0; glIndex < this.webgl.length; glIndex += 1) {
        _loop(glIndex);
      }
    }
  }, {
    key: "executeOnLoad",
    value: function executeOnLoad() {
      if (this.onLoad != null) {
        this.onLoad();
      }
    }
  }, {
    key: "resetBuffer",
    value: function resetBuffer() {
      var numPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      for (var glIndex = 0; glIndex < this.webgl.length; glIndex += 1) {
        var gl = this.gl[glIndex];
        var webgl = this.webgl[glIndex];
        var texture = this.texture;

        if (texture) {
          // this.gl.activeTexture(this.gl.TEXTURE0 + texture.index);
          // this.gl.bindTexture(this.gl.TEXTURE_2D, null);
          if (webgl.textures[texture.id].glTexture != null) {
            gl.activeTexture(gl.TEXTURE0 + webgl.textures[texture.id].index);
            gl.bindTexture(gl.TEXTURE_2D, null); // gl.deleteTexture(webgl.textures[texture.id].glTexture);

            webgl.textures[texture.id].glTexture = null;
          }

          if (texture.buffer != null) {
            gl.deleteBuffer(texture.buffer[glIndex]); // $FlowFixMe

            texture.buffer[glIndex] = null;
          } // texture.glTexture = null;

        } // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);


        gl.deleteBuffer(this.buffer[glIndex]);
        this.setupBuffer(numPoints);
      }
    }
    /* eslint-disable no-unused-vars */

  }, {
    key: "change",
    value: function change(options) {
      this.resetBuffer();
    }
    /* eslint-enable no-unused-vars */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "update",
    value: function update(options) {
      this.resetBuffer();
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties() {
      // eslint-disable-line class-methods-use-this
      return _toConsumableArray(_get(_getPrototypeOf(VertexObject.prototype), "_getStateProperties", this).call(this));
    } // Abstract method - should be reimplemented for any vertexObjects that
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "getPointCountForAngle",
    value: function getPointCountForAngle() {
      var drawAngle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI * 2;
      // return this.numPoints * drawAngle / (Math.PI * 2);
      return this.numPoints;
    } // Abstract method - should be reimplemented for any vertexObjects that
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "getPointCountForLength",
    value: function getPointCountForLength(drawLength) {
      return this.numPoints;
    } // A texture map is a texture coords point that lines up with the texture
    // vertex point. So, if the vertex shape is rectangular, centered at the
    // origin and wants to incorporate the entire texture, then the map would
    // be:
    // vertex space            texture space
    // this.points         this.texture.points
    //    -1,  -1,                  0,  0
    //    -1,   1,                  0,  1
    //     1,   1,                  1,  1
    //     1,  -1,                  1,  0

  }, {
    key: "createTextureMap",
    value: function createTextureMap() {
      var xMinGL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      var xMaxGL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var yMinGL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var yMaxGL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var xMinTex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var xMaxTex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      var yMinTex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var yMaxTex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
      var glWidth = xMaxGL - xMinGL;
      var glHeight = yMaxGL - yMinGL;
      var texWidth = xMaxTex - xMinTex;
      var texHeight = yMaxTex - yMinTex;
      var texture = this.texture;

      if (texture != null) {
        texture.points = [];

        for (var i = 0; i < this.points.length; i += 2) {
          var x = this.points[i];
          var y = this.points[i + 1];
          var texNormX = (x - xMinGL) / glWidth;
          var texNormY = (y - yMinGL) / glHeight;
          texture.points.push(texNormX * texWidth + xMinTex);
          texture.points.push(texNormY * texHeight + yMinTex);
        }
      }
    }
  }, {
    key: "draw",
    value: function draw(translation, rotation, scale, count, color) // webGLInstance: WebGLInstance = this.webgl,
    {
      var glIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["identity"]();
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["translate"](transformation, translation.x, translation.y);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["rotate"](transformation, rotation);
      transformation = _tools_m2__WEBPACK_IMPORTED_MODULE_0__["scale"](transformation, scale.x, scale.y);
      this.drawWithTransformMatrix(_tools_m2__WEBPACK_IMPORTED_MODULE_0__["t"](transformation), color, glIndex, count);
    }
  }, {
    key: "drawWithTransformMatrix",
    value: function drawWithTransformMatrix(transformMatrix, color, glIndex, count) // webglInstance: WebGLInstance = this.webgl,
    {
      // if (window.asdf) {
      //   console.log(transformMatrix, color, glIndex, count);
      // }
      var gl = this.gl[glIndex];
      var webglInstance = this.webgl[glIndex];
      var size = 2; // 2 components per iteration

      var type = gl.FLOAT; // the data is 32bit floats

      var normalize = false; // don't normalize the data
      // 0 = move forward size * sizeof(type) each iteration to get
      // the next position

      var stride = 0;
      var offset = 0; // start at the beginning of the buffer

      var locations = webglInstance.useProgram(this.programIndex[glIndex]);

      if (this.texture && webglInstance.textures[this.texture.id].type === 'canvasText') {
        // this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        // this.gl.blendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      } // Turn on the attribute


      gl.enableVertexAttribArray(locations.a_position); // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)

      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer[glIndex]); // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)

      gl.vertexAttribPointer(locations.a_position, size, type, normalize, stride, offset);
      gl.uniformMatrix3fv(locations.u_matrix, false, _tools_m2__WEBPACK_IMPORTED_MODULE_0__["t"](transformMatrix)); // Translate

      gl.uniform1f(locations.u_z, this.z);
      gl.uniform4f(locations.u_color, color[0], color[1], color[2], color[3]); // Translate

      var texture = this.texture;

      if (texture != null) {
        // Textures
        // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        var texSize = 2; // 2 components per iteration

        var texType = gl.FLOAT; // the data is 32bit floats

        var texNormalize = false; // don't normalize the data

        var texStride = 0; // 0 = move forward size * sizeof(type) each iteration to get
        // the next position

        var texOffset = 0; // start at the beginning of the buffer

        gl.enableVertexAttribArray(locations.a_texcoord); // $FlowFixMe

        gl.bindBuffer(gl.ARRAY_BUFFER, texture.buffer[glIndex]);
        gl.vertexAttribPointer(locations.a_texcoord, texSize, texType, texNormalize, texStride, texOffset);
      }

      if (texture) {
        gl.uniform1i(locations.u_use_texture, 1);
        var index = webglInstance.textures[texture.id].index; // console.log(texture.id, index, webglInstance.textures)

        gl.uniform1i(locations.u_texture, index);
      } else {
        gl.uniform1i(locations.u_use_texture, 0);
      }

      gl.drawArrays(this.glPrimitive, offset, count);

      if (texture) {
        gl.disableVertexAttribArray(locations.a_texcoord);
      }
    }
  }, {
    key: "transform",
    value: function transform(transformMatrix) {
      for (var i = 0; i < this.points.length; i += 2) {
        var p = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](this.points[i], this.points[i + 1]);
        p = p.transformBy(transformMatrix);
        this.points[i] = p.x;
        this.points[i + 1] = p.y;
      }

      for (var b = 0; b < this.border.length; b += 1) {
        for (var _p = 0; _p < this.border[b].length; _p += 1) {
          this.border[b][_p] = this.border[b][_p].transformBy(transformMatrix);
        }
      }
    } // calcBorder(lastDrawTransformMatrix: Array<number>) {
    //   const glBorders = [];
    //   this.border.forEach(border => {
    //     const glBorder = [];
    //     border.forEach(p => {
    //       glBorder.push(p.transformBy(lastDrawTransformMatrix));
    //     })
    //     glBorders.push(glBorder);
    //   });
    //   return glBorders;
    // }

  }]);

  return VertexObject;
}(_DrawingObject__WEBPACK_IMPORTED_MODULE_3__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexObject);

/***/ }),

/***/ "./src/js/figure/DrawingObjects/VertexObject/VertexText.js":
/*!*****************************************************************!*\
  !*** ./src/js/figure/DrawingObjects/VertexObject/VertexText.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _VertexObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VertexObject */ "./src/js/figure/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





 // import { identity } from '../../../tools/m2';

// type TypeTextOptions = {
//   text: string;
//   size: number;
//   family: string;
//   weight: number;
//   style: 'normal' | 'italic',
//   xAlign: 'left' | 'center' | 'right',
//   yAlign: 'top' | 'bottom' | 'middle' | 'baseline',
// };
var VertexText = /*#__PURE__*/function (_VertexObject) {
  _inherits(VertexText, _VertexObject);

  var _super = _createSuper(VertexText);

  // WebGL primitive used
  // radius from center to outside of polygon
  // center point
  // angle between adjacent verteces to center lines
  function VertexText(webgl, textOptions) {
    var _this;

    _classCallCheck(this, VertexText);

    _this = _super.call(this, webgl, 'withTexture', 'text');
    _this.glPrimitive = webgl[0].gl.TRIANGLE_FAN;
    var defaultTextOptions = {
      text: 'DEFAULT_TEXT',
      size: '20px',
      // Text in pixels, or in vertex space units.
      family: 'Helvetica',
      style: 'normal',
      weight: 400,
      xAlign: 'center',
      yAlign: 'alphabetic',
      id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["generateUniqueId"])('vertexText')
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultTextOptions, textOptions);
    _this.size = options.size;
    _this.text = options.text;
    _this.family = options.family;
    _this.xAlign = options.xAlign;
    _this.yAlign = options.yAlign;
    _this.style = options.style;
    _this.weight = options.weight;
    _this.canvas = document.createElement('canvas');
    _this.canvas.id = options.id;
    _this.ctx = _this.canvas.getContext('2d');
    _this.texture = {
      id: options.id,
      points: [],
      type: 'canvasText'
    };
    _this.type = 'vertexText';

    _this.drawTextIntoBuffer();

    return _this;
  } // Text is positioned such that the text baseline will be at
  // vertex space y = 0.
  // The border will then cover the ascent and descent of the text.


  _createClass(VertexText, [{
    key: "resizeText",
    value: function resizeText() {
      var _this2 = this;

      var pixelToVertexSpaceScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);
      var width = this.canvas.width * pixelToVertexSpaceScale.x;
      var height = this.canvas.height * pixelToVertexSpaceScale.y;
      var start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (this.xAlign === 'center') {
        start.x = -width / 2;
      } else if (this.xAlign === 'right') {
        start.x = -width;
      }

      if (this.yAlign === 'baseline') {
        start.y = -height * 0.25;
      } else if (this.yAlign === 'top') {
        start.y = -height;
      } else if (this.yAlign === 'middle') {
        start.y = -height / 2;
      }

      var points = [start, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, start.y + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, start.y + height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, start.y)];
      this.width = width;
      this.height = height;
      this.calcAscentDescent();
      this.points = [];
      points.forEach(function (point) {
        _this2.points.push(point.x);

        _this2.points.push(point.y);
      });
      this.border = [[new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, -this.descent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x, this.ascent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, this.ascent), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](start.x + width, -this.descent)]];
      var texture = this.texture;

      if (texture != null) {
        texture.points = [0, 0, 0, 1, 1, 1, 1, 0];
        texture.data = this.ctx.canvas;

        if (texture.buffer) {
          this.resetBuffer();
        } else {
          this.setupBuffer();
        }
      }
    }
  }, {
    key: "calcAscentDescent",
    value: function calcAscentDescent() {
      // const aWidth = this.ctx.measureText('a').width;
      // Estimations of FONT ascent and descent for a baseline of "alphabetic"
      var ascent = 0.75;
      var descent = 0;
      var lowAscentRe = /[,.]/g;
      var midAscentRe = /[acemnorsuvwxz*gyq:><;p=]/g;
      var midDecentRe = /[;,$]/g;
      var maxDescentRe = /[gjyqp@Q(){}[\]|]/g;
      var lowAscentMatches = this.text.match(lowAscentRe);

      if (Array.isArray(lowAscentMatches)) {
        if (lowAscentMatches.length === this.text.length) {
          ascent = 0.1;
        }
      }

      var midAscentMatches = this.text.match(midAscentRe);

      if (Array.isArray(midAscentMatches)) {
        if (midAscentMatches.length === this.text.length) {
          ascent = 0.5;
        }
      }

      var midDescentMatches = this.text.match(midDecentRe);

      if (Array.isArray(midDescentMatches)) {
        if (midDescentMatches.length > 0) {
          descent = 0.1;
        }
      }

      var maxDescentMatches = this.text.match(maxDescentRe);

      if (Array.isArray(maxDescentMatches)) {
        if (maxDescentMatches.length > 0) {
          descent = 0.25;
        }
      }

      this.ascent = ascent * this.height;
      this.descent = descent * this.height;
    } // If font size is defined in pixels, then the size will always be the size
    // in pixels independent of how the figure window or scaling changes
    // If the font size is defined in vertex space units, then the font size
    // will always be scaled to look like the vertex space size, but a new canvas
    // will be drawn each time to minimize aliasing.

  }, {
    key: "drawTextIntoBuffer",
    value: function drawTextIntoBuffer() {
      var pixelToVertexSpaceScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);
      var pixelFontSize = 20;

      if (typeof this.size === 'string' && this.size.endsWith('px')) {
        pixelFontSize = parseInt(this.size, 10);
      } else {
        var figureFontSize;

        if (typeof this.size === 'string') {
          figureFontSize = parseFloat(this.size);
        } else {
          figureFontSize = this.size;
        }

        pixelFontSize = Object(_tools_math__WEBPACK_IMPORTED_MODULE_4__["round"])(figureFontSize / pixelToVertexSpaceScale.x, 0);
      }

      if (pixelFontSize < 1) {
        pixelFontSize = 1;
      }

      this.ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(pixelFontSize, "px ").concat(this.family);
      var hBuffer = 0.3;
      var width = this.ctx.measureText(this.text).width + pixelFontSize * hBuffer;
      var height = pixelFontSize * 1.15;
      this.canvas.width = Math.max(width, 1);
      this.canvas.height = Math.max(height, 1);
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); // need to reset font after a canvas resize

      this.ctx.font = "".concat(this.style, " ").concat(this.weight, " ").concat(pixelFontSize, "px ").concat(this.family);
      this.ctx.textAlign = 'left';
      this.ctx.textBaseline = 'alphabetic'; // this.ctx.fillStyle = 'white';

      this.ctx.fillStyle = 'white'; // this.ctx.fillStyle = 'rgba(200,200,200,255)';   // debug only
      // this.ctx.fillStyle = 'blue';

      var startX = pixelFontSize * hBuffer / 2;
      var baselineHeightFromBottom = 0.25;
      var startY = this.canvas.height * (1 - baselineHeightFromBottom);
      this.ctx.fillText(this.text, startX, startY);
      this.resizeText(pixelToVertexSpaceScale);
    }
  }]);

  return VertexText;
}(_VertexObject__WEBPACK_IMPORTED_MODULE_2__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (VertexText);

/***/ }),

/***/ "./src/js/figure/Element.js":
/*!**********************************!*\
  !*** ./src/js/figure/Element.js ***!
  \**********************************/
/*! exports provided: FigureElementPrimitive, FigureElementCollection, FigureElement */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FigureElementPrimitive", function() { return FigureElementPrimitive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FigureElementCollection", function() { return FigureElementCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FigureElement", function() { return FigureElement; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Recorder_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Recorder/state */ "./src/js/figure/Recorder/state.js");
/* harmony import */ var _Recorder_Recorder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Recorder/Recorder */ "./src/js/figure/Recorder/Recorder.js");
/* harmony import */ var _tools_m2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tools/m2 */ "./src/js/tools/m2.js");
/* harmony import */ var _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawingObjects/HTMLObject/HTMLObject */ "./src/js/figure/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DrawingObjects/DrawingObject */ "./src/js/figure/DrawingObjects/DrawingObject.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DrawingObjects/VertexObject/VertexObject */ "./src/js/figure/DrawingObjects/VertexObject/VertexObject.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DrawingObjects/TextObject/TextObject */ "./src/js/figure/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../tools/color */ "./src/js/tools/color.js");
/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./webgl/GlobalAnimation */ "./src/js/figure/webgl/GlobalAnimation.js");
/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Animation/Animation */ "./src/js/figure/Animation/Animation.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../tools/FunctionMap */ "./src/js/tools/FunctionMap.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


 // import { areColorsSame } from '../tools/color';



 // import type { pathOptionsType, TypeRotationDirection } from '../tools/g2';





 // import type { OBJ_Font } from './DrawingObjects/TextObject/TextObject';




// eslint-disable-next-line import/no-cycle

 // import type Figure from './Figure';



/* eslint-enable no-use-before-define */
var transformBy = function transformBy(inputTransforms, copyTransforms) {
  var newTransforms = [];

  if (copyTransforms.length === 0) {
    return inputTransforms.map(function (t) {
      return t._dup();
    });
  }

  inputTransforms.forEach(function (it) {
    copyTransforms.forEach(function (t) {
      newTransforms.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(it).transform(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(t)));
    });
  });

  if (newTransforms.length > 0) {
    // TODO Test without duping this
    return newTransforms.map(function (t) {
      return t._dup();
    }); // return newTransforms;
  }

  return inputTransforms.map(function (t) {
    return t._dup();
  });
};
/* eslint-disable no-use-before-define */

/**
 * Pulse options object
 *
 * ![](./apiassets/pulse.gif)
 *
 * Pulsing can be useful to highlight a figure element to a user, without
 * changing its underlying properties.
 *
 * When an element is pulsed, it will be scaled, translated or rotated from
 * a start value (1 for scale, 0 for rotation and translation),
 * to a maximum value (`scale`, `translate` or `rotate`),
 * to a `min` value, and then back to the `start` value. An element can
 * be pulsed through this cycle `frequency` times per second, over some
 * `duration`.
 *
 * The pulse does not change the {@link FigureElement}.transform property, and
 * only changes the draw transform.
 *
 * By default, a scale or rotation pulse will scale or rotate around the the
 * center of the rectangle encompassing the border of the element. `centerOn`
 * can be used to define a different {@link FigureElement} or point to center
 * on. If centering on a {@link FigureElement}, `xAlign` and `yAlign` can be
 * used to center on a point aligned within it. For instance, `xAlign: 'left'`
 * will center on a point on the left edte of the {@link FigureElement}.
 *
 * The pulse can also draw multiple copies of the element with pulse transforms
 * distributed between the `min` and maximum pulse values. This is particularly
 * useful for shapes with outlines that have a regular spacing from a center
 * point (such as regular polygons) as it will look like the thickness of the
 * outlines are becomming thicker.
 *
 * @property {number} [duration] pulse duration in seconds (`1`)
 * @property {number} [frequency] pulse frequency in Hz - a frequency of zero
 * will set the frequency so just one cycle will be performed in the duration
 * (`0`)
 * @property {number} [scale] maximum scale value to pulse to (`1.5`)
 * @property {number} [rotation] maximum rotation value to pulse to
 * @property {number} [translation] maximum translation displacment value to
 * pulse to (`1.5`)
 * @property {number} [angle] translation angle (`0`)
 * @property {number} [min] minimum value to pulse to
 * @property {null | FigureElement | TypeParsablePoint | string} [centerOn] center
 * of scale or rotation pulse. By default, the element calling the pulse
 * will be the default `centerOn`.
 * @property {'left' | 'center' | 'right' | 'location' | number} [xAlign]
 * if `centerOn` is a {@link FigureElement} then this property can be used to
 * horizontally align the pulse center with the element. `'location'` is the
 * (0, 0) draw space coordinate of the element. `number` defines the percent
 * width from the left of the element (`'center'`)
 * @property {'bottom' | 'middle' | 'top' | 'location' | number} [yAlign]
 * if `centerOn` is a {@link FigureElement} then this property can be used to
 * vertically align the pulse center with the element. `'location'` is the
 * (0, 0) draw space coordinate of the element. `number` defines the percent
 * width from the left of the element (`'center'`)
 * @property {'figure' | 'gl' | 'local' | 'draw' | 'pixel'} [space]
 * if `centerOn` is a point, use this to define the space the point is in
 * (`'figure'`)
 * @property {number} [num] the number of draw copies of the pulse to make (`1`)
 * @property {null | string | function(): void} [done] callback when pulse is
 * finished. If `string` then the element's {@link FunctionMap} `fnMap` will be
 * used (`null`)
 * @property {TypeWhen} [when] when to start the pulse (`'syncNow'`)
 * @property {'sinusoid' | 'triangle'} [progression] function that defines
 * how the scale should progress over time (`sinusoid`)
 *
 * @example
 * // For all examples below, use this to add an element to the figure
 * figure.add({
 *   name: 'p',
 *   method: 'polygon',
 *   options: {
 *     radius: 0.3,
 *     line: { width: 0.05, },
 *   },
 * });
 *
 * const p = figure.getElement('p');
 *
 * @example
 * // Scale pulse
 * p.pulse({
 *   duration: 1,
 *   scale: 1.3
 * });
 *
 * @example
 * // Rotation pulse
 * p.pulse({
 *   duration: 1,
 *   rotation: 0.15,
 *   frequency: 4,
 * });
 *
 * @example
 * // Translation pulse
 * p.pulse({
 *   duration: 1,
 *   translation: 0.02,
 *   min: -0.02,
 *   frequency: 4,
 * });
 *
 * @example
 * // Thick pulse
 * p.pulse({
 *   duration: 1,
 *   scale: 1.1,
 *   min: 0.9,
 *   num: 7,
 * });
 */


/**
 * Figure Element base class
 *
 * The set of properties and methods shared by all figure elements
 *
 * A figure element has several color related properties. Color is
 * defined as an RGBA array with values between 0 and 1. The alpha
 * channel defines the transparency or opacity of the color where
 * 1 is fully opaque and 0 is fully transparent.
 *
 * The `color` property stores the element's current color, while the
 * `defaultColor` property stores the element's color when not dimmed or
 * dissolving. Color should only be set using the `setColor` method.
 *
 * An element can be "dimmed" or "undimmed". For instance,
 * a red element might turn grey when dimmed. The property
 * `dimColor` stores the desired color to dim to and should be set with
 * `setDimColor()`
 *
 * An element can be dissolved in or out with animation. Dissolving
 * an element out transitions its opacity from its current value to 0.
 * The `opacity` property is used when dissolving. The opacity is multiplied by
 * the alpha channel of `color` to net a final opacity. Opacity should not be
 * set directly as it will be overwritten by dissolve animations.
 * @class
 * @property {string} name reference name of element
 * @property {boolean} isShown if `false` then element will not be processed on
 * next draw
 * @property {Transform} transform transform to apply element
 * @property {Transform} lastDrawTransform transform last used for drawing -
 * includes cascade or all parent transforms
 * @property {FigureElement | null} parent parent figure element - `null` if
 * at top level of figure
 * @property {boolean} isTouchable must be `true` to move or execute `onClick`
 * @property {boolean} isMovable must be `true` to move
 * @property {string | () => void} onClick callback if touched or clicked
 * @property {[number, number, number, number]} color element's current
 * color defined as red, green, blue, alpha with range 0 to 1
 * @property {[number, number, number, number]} dimColor color to use when
 * dimming element
 * @property {number} opacity number between 0 and 1 that is multiplied with
 * `color` alpha channel to get final opacity
 * @property {OBJ_ElementMove} move movement parameters
 * @property {Scenarios} scenarios scenario presets
 * @property {AnimationManager} animations element animation manager
 * @property {SubscriptionManager} subscriptions subscription manager for
 * element
 */
var FigureElement = /*#__PURE__*/function () {
  // Transform matrix used in last draw
  // Transform matrix used in last draw
  // lastDrawParentTransform: Transform;
  // lastDrawElementTransform: Transform;
  // lastDrawPulseTransform: Transform;
  // True if should be shown in figure
  // Used to reference element in a collection
  // Element is able to be moved
  // Element can be touched
  // Touch event is not processed by Figure
  // touchInBoundingRect: boolean | number;
  // Callbacks
  // element.transform is updated
  // redrawElements: Array<FigureElement>;
  // For the future when collections use color
  // noRotationFromParent: boolean;
  // this is in vertex space
  // recorder: Recorder;
  // move: {
  //   bounds: TransformBounds,
  //   transformClip: string | (?(Transform) => Transform);
  //   maxVelocity: TypeTransformValue;            // Maximum velocity allowed
  //   // When moving freely, the velocity decelerates until it reaches a threshold,
  // // then it is considered 0 - at which point moving freely ends.
  //   freely: {                 // Moving Freely properties
  //     zeroVelocityThreshold: TypeTransformValue,  // Velocity considered 0
  //     deceleration: TypeTransformValue,           // Deceleration
  //     bounceLoss: TypeTransformValue,
  //     callback: ?(string | ((boolean) => void)),
  //   };
  //   // bounce: boolean;
  //   canBeMovedAfterLosingTouch: boolean;
  //   type: 'rotation' | 'translation' | 'scaleX' | 'scaleY' | 'scale';
  //   // eslint-disable-next-line no-use-before-define
  //   element: FigureElementCollection | FigureElementPrimitive | null;
  // };
  // scenarios: {
  //   [scenarioName: string]: OBJ_Scenario;
  // };
  // Current animation/movement state of element
  // pulse: Object;                  // Pulse animation state
  // Rename to animate in future
  // pulse: (mixed) => void;
  // pulse: (?Array<string | FigureElement> | mixed) => void;
  // +pulse: (Array<string | FigureElement>) => void;
  // This will scale and position this element such that the center of the
  // figure limits will will look like it is centered on a html element
  // when this figurone element is drawn.
  // Scale can be:
  //  1em: figure units will be scaled so 0.2 figure units (default
  //       font size) looks like 1em of the element font size in pixels
  //  100px: figure units will be scaled so that the max figure limit
  //         with be the pixel count
  //  stretch: figure units be stretched so figure limits extend to
  //           element dimensions independently in x and y
  //  max: -1 to 1 figure units will be scaled to max dimension of element
  //  fit: figure units will be scaled so that figure limits aspect ratio
  //       fits within the element aspect ratio
  //  '': defaults to fit keeping aspect ratio.
  // isPaused: boolean;
  // finishAnimationOnPause: boolean;
  // pauseSettings: TypePauseSettings;
  // scenarioSet: {
  //   quiz1: [
  //     { element: xyz, position: (), scale: (), rotation: (), length: () }
  //     { element: abc, position: (), }
  //   ],
  // };
  //  element1.scenarioSet['quiz'] = [
  //     { element: abc, position: [1, 2], scale: 2 },
  //     { element: xyz, position: [2, 2]},
  //  ];
  //  element.setScenarios('center', evenIfNotShown
  //  element.moveToScenarios('center', 1, callback))
  // element.animations.new()
  //    .parallel()
  //

  /**
   * @hideconstructor
   */
  function FigureElement() {
    var _this = this;

    var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var figureLimitsOrFigure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["generateUniqueId"])('element_');

    _classCallCheck(this, FigureElement);

    // This may be updated if element is added to a collection with a different
    // name
    this.name = name;
    this.uid = (Math.random() * 1e18).toString(36);
    this.isShown = true;
    this.transform = transform._dup();
    this.dependantTransform = false;
    this.fnMap = new _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_14__["FunctionMap"]();
    this.subscriptions = new _tools_tools__WEBPACK_IMPORTED_MODULE_9__["SubscriptionManager"](this.fnMap);
    this.isMovable = false;
    this.isTouchable = false;
    this.touchPriority = false; // this.touchInBoundingRect = false;

    this.isInteractive = undefined;
    this.hasTouchableElements = false;
    this.color = [1, 1, 1, 1];
    this.lastDrawOpacity = 1;
    this.dimColor = [0.5, 0.5, 0.5, 1];
    this.defaultColor = this.color.slice();
    this.opacity = 1;
    this.setTransformCallback = null;
    this.beforeDrawCallback = null;
    this.afterDrawCallback = null;
    this.internalSetTransformCallback = null;
    this.lastDrawTransform = this.transform._dup();
    this.parentTransform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    this.lastDrawPulseTransform = this.transform._dup();
    this.onClick = null;
    this.lastDrawElementTransformPosition = {
      parentCount: 0,
      elementCount: 0
    }; // this.redrawElements = [];
    // this.figure = null;

    this.recorder = new _Recorder_Recorder__WEBPACK_IMPORTED_MODULE_3__["Recorder"](true);
    this.custom = {};
    this.parent = parent;
    this.drawPriority = 1;
    this.stateProperties = []; // this.finishAnimationOnPause = false;

    this.lastDrawTime = 0;
    this.cancelSetTransform = false;
    this.onAdd = null; // this.border = 'draw';
    // this.touchBorder = 'border';
    // this.holeBorder = [[]];
    // this.drawBorder = [[]];
    // this.drawBorderBuffer = [[]];
    // this.drawRect = [];
    // this.noRotationFromParent = false;
    // this.pulseDefault = (callback: ?() => void = null) => {
    //   this.pulseScaleNow(1, 2, 0, callback);
    // };

    this.pulseDefault = {
      scale: 2,
      rotation: null,
      translation: null,
      angle: 0,
      duration: 1,
      frequency: 0,
      xAlign: 'center',
      yAlign: 'middle',
      centerOn: 'this',
      num: 1,
      space: 'figure',
      done: null,
      progression: 'sinusoid',
      when: 'syncNow'
    }; // this.isPaused = false;
    // this.copies = [];
    // this.pauseSettings = {};
    // Rename to animate in future

    this.anim = {
      rotation: function rotation() {
        for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
          optionsIn[_key] = arguments[_key];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["RotationAnimationStep"](options);
      },
      scale: function scale() {
        for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          optionsIn[_key2] = arguments[_key2];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["ScaleAnimationStep"](options);
      },
      trigger: function trigger() {
        for (var _len3 = arguments.length, optionsIn = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          optionsIn[_key3] = arguments[_key3];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["TriggerAnimationStep"](options);
      },
      delay: function delay() {
        for (var _len4 = arguments.length, optionsIn = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          optionsIn[_key4] = arguments[_key4];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["DelayAnimationStep"](options);
      },
      translation: function translation() {
        for (var _len5 = arguments.length, optionsIn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          optionsIn[_key5] = arguments[_key5];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["PositionAnimationStep"](options);
      },
      position: function position() {
        for (var _len6 = arguments.length, optionsIn = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          optionsIn[_key6] = arguments[_key6];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["PositionAnimationStep"](options);
      },
      color: function color() {
        for (var _len7 = arguments.length, optionsIn = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          optionsIn[_key7] = arguments[_key7];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["ColorAnimationStep"](options);
      },
      opacity: function opacity() {
        for (var _len8 = arguments.length, optionsIn = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          optionsIn[_key8] = arguments[_key8];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["OpacityAnimationStep"](options);
      },
      transform: function transform() {
        for (var _len9 = arguments.length, optionsIn = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
          optionsIn[_key9] = arguments[_key9];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["TransformAnimationStep"](options);
      },
      pulseTransform: function pulseTransform() {
        for (var _len10 = arguments.length, optionsIn = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
          optionsIn[_key10] = arguments[_key10];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["PulseTransformAnimationStep"](options);
      },
      pulse: function pulse() {
        for (var _len11 = arguments.length, optionsIn = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
          optionsIn[_key11] = arguments[_key11];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["PulseAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      dissolveIn: function dissolveIn() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
          args[_key12 - 1] = arguments[_key12];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["DissolveInAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      dissolveOut: function dissolveOut() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
          args[_key13 - 1] = arguments[_key13];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["DissolveOutAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      dim: function dim() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len14 = arguments.length, args = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
          args[_key14 - 1] = arguments[_key14];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["DimAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      undim: function undim() {
        var timeOrOptionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var defaultOptions = {
          element: _this
        };
        var options;

        for (var _len15 = arguments.length, args = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
          args[_key15 - 1] = arguments[_key15];
        }

        if (typeof timeOrOptionsIn === 'number') {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions, {
            duration: timeOrOptionsIn
          }].concat(args));
        } else {
          options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions, timeOrOptionsIn].concat(args));
        }

        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["UndimAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      builder: function builder() {
        for (var _len16 = arguments.length, optionsIn = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
          optionsIn[_key16] = arguments[_key16];
        }

        return _construct(_Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["AnimationBuilder"], [_this].concat(optionsIn));
      },
      scenario: function scenario() {
        for (var _len17 = arguments.length, optionsIn = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {
          optionsIn[_key17] = arguments[_key17];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, {
          element: _this
        }].concat(optionsIn));
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["ScenarioAnimationStep"](options);
      },
      // eslint-disable-next-line max-len
      // scenario: (...optionsIn: Array<OBJ_TransformAnimationStep
      //                             & {
      //                                 start?: OBJ_Scenario,
      //                                 target: OBJ_Scenario,
      //                                }>) => {
      //   const defaultOptions = { element: this, delay: 0 };
      //   const options = joinObjects({}, defaultOptions, ...optionsIn);
      //   // Retrieve the target scenario
      //   if (options.target != null) {
      //     const target = options.element.getScenarioTarget(options.target);
      //     if (Object.keys(target).length > 0) {
      //       options.target = target;
      //     }
      //   }
      //   // Retrieve the start scenario (if it doesn't exist, then the element's values
      //   // at the time the animation starts will be used).
      //   if (options.start != null) {
      //     const start = options.element.getScenarioTarget(options.start);
      //     if (Object.keys(start).length > 0) {
      //       options.start = start;
      //     }
      //   }
      //   const { start, target, element } = options;
      //   const steps = [];
      //   const duration = this.getTimeToMoveToScenario(target, options, start || '');
      //   options.duration = duration;
      //   const timeOptions = { delay: options.delay, duration: options.duration };
      //   options.delay = 0;
      //   options.velocity = undefined;
      //   let startColor;
      //   let startTransform;
      //   let startIsShown;
      //   if (start != null) {
      //     if (start.color != null) {
      //       startColor = start.color.slice();
      //     }
      //     if (start.transform != null) {
      //       startTransform = start.transform._dup();
      //     }
      //     if (start.isShown != null) {
      //       startIsShown = start.isShown;
      //     }
      //   }
      //   if (target.color != null) {
      //     steps.push(element.anim.color({
      //       start: startColor,
      //       target: target.color,
      //       duration: options.duration,
      //     }));
      //   }
      //   if (target.transform != null) {
      //     steps.push(element.anim.transform(options, {
      //       start: startTransform,
      //       target: target.transform,
      //     }));
      //   }
      //   if (target.isShown != null) {
      //     if (startIsShown != null) {
      //       if (target.isShown === true && startIsShown === true) {
      //         steps.push(element.anim.dissolveIn({ duration: 0 }));
      //       }
      //       if (target.isShown === false && startIsShown === false) {
      //         steps.push(element.anim.dissolveOut({ duration: 0 }));
      //       }
      //       if (target.isShown === false && startIsShown === true) {
      //         steps.push(element.anim.dissolveOut({ duration: options.duration }));
      //       }
      //       if (target.isShown === true && startIsShown === false) {
      //         steps.push(element.anim.dissolveIn({ duration: options.duration }));
      //       }
      //     } else {
      //       let dissolveFromCurrent = true;
      //       if (options.dissolveFromCurrent != null && options.dissolveFromCurrent === false) {
      //         dissolveFromCurrent = false;
      //       }
      //       if (target.isShown) {
      //         steps.push(element.anim.opacity({
      //           duration: options.duration,
      //           dissolve: 'in',
      //           dissolveFromCurrent,
      //         }));
      //       } else {
      //         steps.push(element.anim.opacity({
      //           duration: options.duration,
      //           dissolve: 'out',
      //           dissolveFromCurrent,
      //         }));
      //       }
      //     }
      //   }
      //   return new animations.ParallelAnimationStep(timeOptions, { steps });
      // },
      // scenarioLegacy: (...optionsIn: Array<OBJ_TransformAnimationStep
      //                          & { scenario: string }>) => {
      //   const defaultOptions = { element: this };
      //   const options = joinObjects({}, defaultOptions, ...optionsIn);
      //   if (options.target != null
      //     && options.target in options.element.scenarios
      //   ) {
      //     const target = options.element.getScenarioTargetLegacy(options.target);
      //     options.target = target;
      //   }
      //   if (options.start != null
      //     && options.start in options.element.scenarios
      //   ) {
      //     const start = options.element.getScenarioTargetLegacy(options.start);
      //     options.start = start;
      //   }
      //   if (options.delta != null
      //     && options.delta in options.element.scenarios
      //   ) {
      //     const delta = options.element.getScenarioTargetLegacy(options.delta);
      //     options.delta = delta;
      //   }
      //   return new animations.TransformAnimationStep(options);
      // },
      // eslint-disable-next-line max-len
      scenarios: function scenarios() {
        var defaultOptions = {};

        for (var _len18 = arguments.length, optionsIn = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
          optionsIn[_key18] = arguments[_key18];
        }

        var options = _tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));

        var elements = _this.getAllElementsWithScenario(options.target);

        var steps = [];
        var simpleOptions = {};
        Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["duplicateFromTo"])(options, simpleOptions, ['steps', 'element']);
        elements.forEach(function (element) {
          steps.push(element.anim.scenario(simpleOptions));
        });
        return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["ParallelAnimationStep"](simpleOptions, {
          steps: steps
        });
      }
    };

    if (figureLimitsOrFigure instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"]) {
      this.figureLimits = figureLimitsOrFigure;
    } else if (figureLimitsOrFigure != null) {
      this.figureLimits = this.figure.limits._dup();
    }

    this.move = {
      // maxTransform: this.transform.constant(1000),
      // minTransform: this.transform.constant(-1000),
      bounds: 'none',
      sizeInBounds: false,
      // boundsToUse: new TransformBounds(this.transform),
      // bounds: { scale: null, rotation: null, position: null },
      // boundary: null,
      maxVelocity: 5,
      // maxVelocity: new TransformLimit(5, 5, 5),
      freely: {
        zeroVelocityThreshold: 0.0001,
        deceleration: 5,
        callback: null,
        bounceLoss: 0.5
      },
      // bounce: true, // deprecate
      canBeMovedAfterLosingTouch: true,
      type: 'translation',
      element: null,
      // limitLine: null,
      transformClip: null
    };
    this.scenarios = {};

    var pulseTransformMethod = function pulseTransformMethod(mag, d, type) {
      // if (type === 'scale' && (d == null || (d.x === 0 && d.y === 0))) {
      // if (type === 'scale' && d == null) {
      //   return new Transform().scale(mag, mag);
      // }
      if (type === 'scale') {
        if (d == null) {
          return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, 0).scale(mag, mag).translate(0, 0);
        }

        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(-d.x, -d.y).scale(mag, mag).translate(d.x, d.y);
      }

      if (type === 'rotation') {
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(-d.x, -d.y).rotate(mag).translate(d.x, d.y);
      }

      var x = mag * Math.cos(type);
      var y = mag * Math.sin(type); // const s = this.getScale();

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(x, y);
    };

    this.fnMap.add('_elementPulseSettingsTransformMethod', pulseTransformMethod);
    this.fnMap.add('tools.math.easeinout', _tools_math__WEBPACK_IMPORTED_MODULE_1__["easeinout"]);
    this.fnMap.add('tools.math.linear', _tools_math__WEBPACK_IMPORTED_MODULE_1__["linear"]);
    this.fnMap.add('tools.math.sinusoid', _tools_math__WEBPACK_IMPORTED_MODULE_1__["sinusoid"]);
    this.fnMap.add('tools.math.sinusoidAbs', _tools_math__WEBPACK_IMPORTED_MODULE_1__["sinusoidAbs"]);
    this.fnMap.add('tools.math.triangle', _tools_math__WEBPACK_IMPORTED_MODULE_1__["triangle"]);
    this.pulseSettings = {
      time: 1,
      frequency: 0.5,
      A: 1,
      B: 0.5,
      C: 0,
      progression: 'tools.math.sinusoid',
      num: 1,
      delta: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      transformMethod: '_elementPulseSettingsTransformMethod',
      callback: function callback() {},
      allowFreezeOnStop: false,
      type: 'scale'
    };
    this.state = {
      isBeingMoved: false,
      isMovingFreely: false,
      movement: {
        previousTime: null,
        previousTransform: this.transform._dup(),
        velocity: this.transform.zero()
      },
      isPulsing: false,
      pulse: {
        startTime: null
      },
      preparingToStop: false
    };
    this.interactiveLocation = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.animationFinishedCallback = null;
    this.animations = new _Animation_Animation__WEBPACK_IMPORTED_MODULE_12__["AnimationManager"]({
      element: this,
      finishedCallback: this.animationFinished.bind(this)
    });
    this.tieToHTML = {
      element: null,
      scale: 'fit',
      window: this.figureLimits,
      updateOnResize: true
    };
    this.isRenderedAsImage = false;
    this.unrenderNextDraw = false;
    this.renderedOnNextDraw = false;
    this.pulseTransforms = [];
    this.frozenPulseTransforms = [];
    this.copyTransforms = [];
    this.drawTransforms = [];
  }

  _createClass(FigureElement, [{
    key: "animationFinished",
    value: function animationFinished() {
      var typeOfAnimation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'animation';
      // console.log('element', this.name, this.animationFinishedCallback)
      this.fnMap.exec(this.animationFinishedCallback);
      this.subscriptions.publish('animationFinished', typeOfAnimation);
    } // animationsFinishedCallback(element: FigureElement) {
    //   if (this.parent != null) {
    //     this.parent.animationsFinishedCallback(element);
    //   }
    // }

  }, {
    key: "animateNextFrame",
    value: function animateNextFrame() {
      if (this.figure != null) {
        this.figure.animateNextFrame();
      }
    }
  }, {
    key: "setProperties",
    value: function setProperties(properties) {
      var _this2 = this;

      var exceptIn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var except = exceptIn;

      if (properties.move != null) {
        var cleanBounds = function cleanBounds(key) {
          if (typeof except === 'string') {
            except = [except, "move.".concat(key)];
          } else {
            except.push("move.".concat(key));
          }

          var bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBounds"])(properties.move[key], 'transform', _this2.transform);

          if (bounds instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformBounds"]) {
            for (var i = 0; i < bounds.boundary.length; i += 1) {
              var bound = bounds.boundary[i];
              var order = bounds.order[i];

              if (bounds.boundary[i] != null && bound instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["RangeBounds"] && (order === 't' || order === 's')) {
                bounds.boundary[i] = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["RectBounds"]({
                  left: bound.boundary.min,
                  bottom: bound.boundary.min,
                  right: bound.boundary.max,
                  top: bound.boundary.max
                });
              }
            }

            _this2.move[key] = bounds;
          }
        }; // if (properties.move.boundsToUse != null) {
        //   cleanBounds('boundsToUse');
        // }


        if (properties.move.bounds != null && properties.move.bounds !== 'figure' && properties.move.bounds !== 'none') {
          cleanBounds('bounds');
        }
      }

      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjectsWithOptions"])({
        except: except
      }, this, properties);
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties(options) {
      var ignoreShown = options.ignoreShown;

      if (ignoreShown == null) {
        ignoreShown = false;
      }

      if (this.isShown || ignoreShown) {
        return ['animations', 'color', 'opacity', 'dimColor', 'defaultColor', 'transform', 'isShown', 'isMovable', 'isTouchable', 'state', 'pulseSettings', 'setTransformCallback', 'move', 'subscriptions', // 'finishAnimationOnPause',
        'pulseTransforms', 'frozenPulseTransforms'].concat(_toConsumableArray(this.stateProperties));
      }

      return ['isShown', 'transform'];
    }
  }, {
    key: "_getStatePropertiesMin",
    value: function _getStatePropertiesMin() {
      if (this.isShown) {
        return ['color', 'transform', 'isShown'];
      }

      return ['isShown'];
    }
  }, {
    key: "_state",
    value: function _state() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.min) {
        return Object(_Recorder_state__WEBPACK_IMPORTED_MODULE_2__["getState"])(this, this._getStatePropertiesMin(), options);
      }

      return Object(_Recorder_state__WEBPACK_IMPORTED_MODULE_2__["getState"])(this, this._getStateProperties(options), options);
    } // execFn(fn: string | Function | null, ...args: Array<any>) {
    //   if (fn == null) {
    //     return null;
    //   }
    //   if (typeof fn === 'string') {
    //     return this.fnMap.exec(fn, ...args);
    //   }
    //   return fn(...args);
    // }

  }, {
    key: "setFigure",
    value: function setFigure(figure) {
      this.figure = figure;

      if (figure != null) {
        this.recorder = figure.recorder;
        this.animationFinishedCallback = figure.animationFinished;
      }

      if (this.isTouchable) {
        this.setTouchable();
      }

      if (this.isMovable) {
        this.setMovable();
      }
    }
  }, {
    key: "setTimeDelta",
    value: function setTimeDelta(delta) {
      if (this.animations.state === 'animating') {
        this.animations.setTimeDelta(delta);
      }

      if (this.state.isPulsing && this.state.pulse.startTime != null) {
        this.state.pulse.startTime += delta;
      }

      if (this.state.movement.previousTime != null) {
        this.state.movement.previousTime += delta;
      }
    } // Space definition:
    //   * Pixel space: css pixels
    //   * GL Space: x,y = -1 to 1
    //   * Figure Space: x,y = figure limits
    //   * Element space: Combination of element transform and its
    //     parent transform's
    // A figure element primitive vertex object lives in GL SPACE.
    //
    // A figure element has its own FIGURE ELEMENT SPACE, which is
    // the GL space transformed by `this.transform`.
    //
    // A figure element is drawn in the FIGURE SPACE, by transforming
    // the FIGURE ELEMENT SPACE by an incoming transformation matrix in the draw
    // method. This incoming transformation matrix originates in the figure
    // and waterfalls through each parent figure collection element to the
    // current figure element.
    //
    // this.lastDrawTransformationMatrix captures how a vertex was drawn in
    // the last frame, in FIGURE space as:
    //   vertex
    //     transformed by: FIGURE ELEMENT SPACE
    //     transfromed by: FIGURE SPACE transform
    //
    // By default, webgl clip space is a unit space from (-1, 1) to (1, 1)
    // independent of the aspect ratio of the canvas it is drawn on.
    //
    // A figure object can have its own clip space with arbitrary limits. e.g.:
    //    * (-1, -1) to (1, 1)    similar to gl clip space
    //    * (0, 0) to (2, 2)      similar to gl clip space but offset
    //    * (0, 0) to (4, 2)      for rectangular aspect ratio figure
    //
    // The figure object clip space definition is stored in this.figureLimits.
    //
    // To therefore transform a vertex (from GL SPACE) to FIGURE CLIP SPACE:
    //   * Take the vertex
    //   * Transform it to FIGURE SPACE (by transforming it with the
    //     lastDrawTransformMatrix)
    //   * Transform it to FIGURE CLIP SPACE by scaling and offsetting it
    //     to the clip space.
    //
    // Each figure element holds a FIGURE ELMENT CLIP space

  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie(figureCanvas) {
      var tieToElement;

      if (typeof this.tieToHTML.element === 'string') {
        tieToElement = document.getElementById(this.tieToHTML.element);
      }

      if (tieToElement != null) {
        var tie = tieToElement.getBoundingClientRect();
        var canvas = figureCanvas.getBoundingClientRect();
        var figure = this.figureLimits;
        var dWindow = this.tieToHTML.window;
        var cAspectRatio = canvas.width / canvas.height;
        var dAspectRatio = figure.width / figure.height;
        var tAspectRatio = tie.width / tie.height;
        var wAspectRatio = dWindow.width / dWindow.height;
        var topLeftPixels = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.left - canvas.left, tie.top - canvas.top);
        var bottomRightPixels = topLeftPixels.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.width, tie.height));
        var pixelToFigure = this.figureTransforms.pixelToFigure;
        var topLeft = topLeftPixels.transformBy(pixelToFigure.m());
        var bottomRight = bottomRightPixels.transformBy(pixelToFigure.m());
        var width = bottomRight.x - topLeft.x;
        var height = topLeft.y - bottomRight.y;
        var center = topLeft.add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, -height / 2));
        var scaleString = this.tieToHTML.scale.trim().toLowerCase();
        var scaleX = 1;
        var scaleY = 1;
        var figureToWindowScaleX = figure.width / dWindow.width;
        var figureToWindowScaleY = figure.height / dWindow.height; // Window has no scaling impact on em, it only has impact on translation

        if (scaleString.endsWith('em')) {
          var scale = parseFloat(scaleString);
          var em = parseFloat(getComputedStyle(tieToElement).fontSize); // 0.2 is default font size in figure units

          var defaultFontScale = figure.width / 0.2;
          scaleX = scale * em * defaultFontScale / canvas.width;
          scaleY = scale * em * defaultFontScale / dAspectRatio / canvas.height;
        } // Scale the maximum dimension of the window to the pixel value


        if (scaleString.endsWith('px')) {
          var maxPixels = parseFloat(scaleString);

          if (wAspectRatio > 1) {
            var _scale = maxPixels / canvas.width;

            scaleX = _scale * figureToWindowScaleX;
            scaleY = _scale * cAspectRatio / dAspectRatio * figureToWindowScaleX;
          } else {
            var _scale2 = maxPixels / canvas.height;

            scaleX = _scale2 / cAspectRatio * dAspectRatio * figureToWindowScaleY;
            scaleY = _scale2 * figureToWindowScaleY;
          }
        } // Scale the window x to tie x, and window y to tie y


        if (scaleString === 'stretch') {
          scaleX = tie.width / canvas.width * figureToWindowScaleX;
          scaleY = tie.height / canvas.height * figureToWindowScaleY;
        } // Scale so window either fits within the tie element, or fits only
        // within the max dimension of the tie element


        if (scaleString === 'max' || scaleString === 'fit') {
          var fitHeightScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.height / canvas.height / cAspectRatio * dAspectRatio * figureToWindowScaleY, tie.height / canvas.height * figureToWindowScaleY);
          var fitWidthScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tie.width / canvas.width * figureToWindowScaleX, tie.width / canvas.width * cAspectRatio / dAspectRatio * figureToWindowScaleX);

          if (scaleString === 'max' && tAspectRatio > wAspectRatio || scaleString === 'fit' && tAspectRatio < wAspectRatio) {
            scaleX = fitWidthScale.x;
            scaleY = fitWidthScale.y;
          } else {
            scaleX = fitHeightScale.x;
            scaleY = fitHeightScale.y;
          }
        }

        this.setScale(scaleX, scaleY); // Offset the element relative to the tie

        this.setPosition(center.x - scaleX * (this.tieToHTML.window.left + this.tieToHTML.window.width / 2), center.y - scaleY * (this.tieToHTML.window.bottom + this.tieToHTML.window.height / 2));
        this.setFirstTransform(this.getParentLastDrawTransform());
      }
    } // eslint-disable-next-line no-unused-vars, class-methods-use-this

  }, {
    key: "setFirstTransform",
    value: function setFirstTransform(parentTransform) {} // animateToPulseTransforms(pulseTranforms: Array<Transform>) {
    //   let startTransforms = this.pulseTransforms;
    //   if (pulseTransforms.length != this.startTransforms.length) {
    //     startTransforms = [];
    //     for (let i = 0; i < pulseTranforms.length; i += 1) {
    //       startTransforms.push(this.transform._dup());
    //     }
    //   }
    // }

  }, {
    key: "clearFrozenPulseTransforms",
    value: function clearFrozenPulseTransforms() {
      this.frozenPulseTransforms = [];
    }
  }, {
    key: "freezePulseTransforms",
    value: function freezePulseTransforms() {
      var forceOverwrite = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (forceOverwrite && this.pulseTransforms.length === 0 || !forceOverwrite && this.pulseTransforms.length > 0) {
        this.frozenPulseTransforms = this.pulseTransforms.map(function (t) {
          return t._dup();
        });
      }
    }
  }, {
    key: "animateToState",
    value: function animateToState(state, options) {
      var independentOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var startTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // if (this.name === 'a') {
      //   console.log(this.frozenPulseTransforms)
      // }
      var target = {};

      if (this.isShown !== state.isShown && this.opacity === 1 || this.opacity !== 1) {
        // console.log('shown animation', this.getPath(), this.isShown, state.isShown)
        target.isShown = state.isShown;
      }

      if (!Object(_tools_color__WEBPACK_IMPORTED_MODULE_10__["areColorsWithinDelta"])(this.color, state.color, 0.001)) {
        target.color = state.color;
      }

      var stateTransform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(state.transform);

      if (!this.transform.isWithinDelta(stateTransform, 0.001) && (this.dependantTransform === false || independentOnly === false)) {
        target.transform = stateTransform;
      }

      var scenarioAnimation = null;
      var duration = 0;

      if (Object.keys(target).length > 0) {
        var scenarioOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, options, {
          target: target
        });
        scenarioAnimation = this.anim.scenario(scenarioOptions);
      } // let pulseTrigger = null;
      // let pulseDelay = null;
      // let delay = 0;


      var pulseAnimation = null;

      if (!this.arePulseTransformsSame(state, 0.001)) {
        var startPulseTransforms = this.pulseTransforms.map(function (t) {
          return t._dup();
        });

        if (this.pulseTransforms.length === 0) {
          startPulseTransforms = this.frozenPulseTransforms.map(function (t) {
            return t._dup();
          });
        }

        var targetPulseTransforms = state.pulseTransforms.map(function (t) {
          return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(t);
        });

        if (targetPulseTransforms.length === 0 && state.frozenPulseTransforms.length > 0) {
          targetPulseTransforms = state.frozenPulseTransforms.map(function (t) {
            return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(t);
          });
        }

        if (targetPulseTransforms.length === 0 && startPulseTransforms.length > 0) {
          targetPulseTransforms = [startPulseTransforms[0].identity()];
        }

        pulseAnimation = this.anim.pulseTransform(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, options, {
          start: startPulseTransforms,
          target: targetPulseTransforms
        }));
      }

      if (scenarioAnimation != null || pulseAnimation != null) {
        this.animations["new"]().inParallel([scenarioAnimation, pulseAnimation]) // .then(scenarioAnimation)
        // .then(pulseTrigger)
        // .then(pulseDelay)
        .start(startTime);
      } // if (this.animations.animations.length > 0) {
      //   console.log(this.getPath(), this.animations.animations[0]._dup());
      // }


      if (scenarioAnimation != null) {
        duration = Math.max(duration, scenarioAnimation.getTotalDuration());
      }

      if (pulseAnimation != null) {
        duration = Math.max(duration, pulseAnimation.getTotalDuration());
      } // if (this.name === 'a') {
      //   console.log(this.frozenPulseTransforms)
      // }


      return duration;
    }
  }, {
    key: "dissolveInToState",
    value: function dissolveInToState(state) {
      var _this3 = this;

      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.8;
      var startTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (state.isShown === false) {
        return 0;
      } // const target = {};


      this.transform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(state.transform);
      this.color = state.color.slice();
      this.frozenPulseTransforms = [];
      state.pulseTransforms.forEach(function (t) {
        return _this3.frozenPulseTransforms.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(t));
      });
      this.show();
      this.animations["new"]().opacity({
        target: state.opacity,
        start: 0.001,
        duration: duration
      }).trigger({
        callback: function callback() {
          _this3.frozenPulseTransforms = [];
        }
      }).start(startTime);
      return duration;
    }
  }, {
    key: "isStateSame",
    value: function isStateSame(state) {
      var mergePulseTransforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var exceptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var p = this.getPath();

      if (exceptions.indexOf(p) > -1) {
        return true;
      }

      if (this.isShown !== state.isShown || Math.abs(this.opacity - state.opacity) > 0.001) {
        return false;
      }

      if (!Object(_tools_color__WEBPACK_IMPORTED_MODULE_10__["areColorsWithinDelta"])(this.color, state.color, 0.001)) {
        return false;
      }

      if (!this.transform.isWithinDelta(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(state.transform), 0.001)) {
        return false;
      }

      if (mergePulseTransforms) {
        if (!this.arePulseTransformsSame(state, 0.001)) {
          return false;
        }

        return true;
      }

      if (state.pulseTransforms.length !== this.pulseTransforms.length) {
        return false;
      }

      for (var i = 0; i < this.pulseTransforms.length; i += 1) {
        if (!this.pulseTransforms[i].isWithinDelta(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(state.pulseTransforms[i]), 0.001)) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "arePulseTransformsSame",
    value: function arePulseTransformsSame(state) {
      var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.001;
      var statePulseTransforms = [];
      var pulseTransforms = [];
      statePulseTransforms = transformBy([this.transform._dup()], state.pulseTransforms);
      statePulseTransforms = transformBy(statePulseTransforms, state.frozenPulseTransforms);
      pulseTransforms = transformBy([this.transform._dup()], this.pulseTransforms);
      pulseTransforms = transformBy(pulseTransforms, this.frozenPulseTransforms);

      if (pulseTransforms.length !== statePulseTransforms.length) {
        return false;
      }

      for (var i = 0; i < pulseTransforms.length; i += 1) {
        if (!pulseTransforms[i].isWithinDelta(statePulseTransforms[i], delta)) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "getDrawTransforms",
    value: function getDrawTransforms(initialTransforms) {
      // let drawTransforms = [transform];
      var drawTransforms = transformBy(initialTransforms, this.copyTransforms);
      drawTransforms = transformBy(drawTransforms, this.pulseTransforms);
      drawTransforms = transformBy(drawTransforms, this.frozenPulseTransforms);
      return drawTransforms;
    }
  }, {
    key: "exec",
    value: function exec(execFunctionAndArgs) {
      // if (elementsToExec == null || typeof elementsToExec === 'function') {
      var execFunc;
      var args;

      if (Array.isArray(execFunctionAndArgs)) {
        var _execFunctionAndArgs = _toArray(execFunctionAndArgs);

        execFunc = _execFunctionAndArgs[0];
        args = _execFunctionAndArgs.slice(1);
      } else {
        execFunc = execFunctionAndArgs;
      } // $FlowFixMe


      if (this[execFunc] != null && typeof this[execFunc] === 'function') {
        if (args === undefined) {
          // $FlowFixMe
          this[execFunc]();
        } else {
          // $FlowFixMe
          this[execFunc].apply(this, _toConsumableArray(args));
        }
      }
    } // pulseScaleRelativeTo(
    //   e: FigureElement | TypeParsablePoint | null,
    //   x: 'left' | 'center' | 'right' | 'origin' | number,
    //   y: 'bottom' | 'middle' | 'top' | 'origin' | number,
    //   space: 'figure' | 'gl' | 'draw' | 'local',
    //   time: number,
    //   scale: number,
    //   frequency: number = 0,
    //   callback: ?(?mixed) => void = null,
    // ) {
    //   if (e == null || e instanceof FigureElement) {
    //     this.pulseScaleRelativeToElement(e, x, y, space, time, scale, frequency, callback);
    //   } else {
    //     this.pulseScaleRelativeToPoint(e, space, time, scale, frequency, callback)
    //   }
    // }
    // pulseLegacy(done: ?(mixed) => void = null) {
    //   if (
    //     typeof this.pulseDefault === 'function'
    //     || typeof this.pulseDefault === 'string'
    //   ) {
    //     this.execFn(this.pulseDefault, done);
    //   } else {
    //     const { frequency, time, scale } = this.pulseDefault;
    //     this.pulseScaleNow(time, scale, frequency, done);
    //   }
    // }

  }, {
    key: "getElement",
    value: function getElement() {
      return this;
    }
  }, {
    key: "getElements",
    value: function getElements() {
      return [this];
    } // eslint-disable-next-line no-unused-vars, class-methods-use-this

  }, {
    key: "highlight",
    value: function highlight() {
      this.undim();
    }
    /**
     * Conveniently set the first `translation` of the element's `transform`.
     * @param {TypeParsablePoint | number} pointOrX x coordinate or full point
     * definition
     * @param {number} y y coordinate if `pointOrX` is just the x coordinate (`0`)
     */

  }, {
    key: "setPosition",
    value: function setPosition(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var position;

      if (typeof pointOrX === 'number') {
        position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](pointOrX, y);
      } else {
        position = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(pointOrX);
      } // let position = getPoint(pointOrX);
      // if (typeof pointOrX === 'number') {
      //   position = new Point(pointOrX, y);
      // }


      var currentTransform = this.transform._dup();

      currentTransform.updateTranslation(position);
      this.setTransform(currentTransform);
    }
    /**
     * Conveniently set the first `rotation` of the element's `transform`.
     * @param {number} rotation
     */

  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      var currentTransform = this.transform._dup();

      currentTransform.updateRotation(rotation);
      this.setTransform(currentTransform);
    }
    /**
     * Conveniently set the first `scale` of the element's `transform`.
     * @param {TypeParsablePoint | number} scaleOrX horizontal scale - either
     * define as full x-y point, or as a number. If scaleOrX is a `number` and
     * `y` is null, then both `x` and `y` will be equally scaled
     * @param {number | null} y y coordinate if `scaleOrX` is a `number` (`null`)
     */

  }, {
    key: "setScale",
    value: function setScale(scaleOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var scale;

      if (typeof scaleOrX === 'number') {
        if (typeof y === 'number') {
          scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleOrX, y);
        } else {
          scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleOrX, scaleOrX);
        }
      } else {
        scale = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(scaleOrX);
      } // let scale = getPoint(scaleOrX);
      // if (typeof scaleOrX === 'number') {
      //   if (y == null) {
      //     scale = new Point(scaleOrX, scaleOrX);
      //   } else {
      //     scale = new Point(scaleOrX, y);
      //   }
      // }


      var currentTransform = this.transform._dup();

      currentTransform.updateScale(scale);
      this.setTransform(currentTransform);
    } // Use this method to set the element's transform in case a callback has been
    // connected that is tied to an update of the transform.

    /**
     * Set transform of element. Setting through this method will ensure
     * `setTransfrom` subscription will publish, and transform will be
     * appropriately clipped.
     * @param {Transform} transform
     */

  }, {
    key: "setTransform",
    value: function setTransform(transform) {
      if (this.move.transformClip != null) {
        var clip = this.fnMap.exec(this.move.transformClip, transform);

        if (clip instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
          this.subscriptions.publish('beforeSetTransform', [clip]);

          if (this.cancelSetTransform === false) {
            this.transform = clip;
          } else {
            this.cancelSetTransform = false;
          }
        }
      } else {
        // this.checkMoveBounds();
        var bounds = this.getMoveBounds(); // console.log(bounds)
        // if (this.move.bounds instanceof TransformBounds) {
        // this.subscriptions.publish('beforeSetTransform', [clip]);
        // $FlowFixMe

        var _clip = bounds.clip(transform);

        this.subscriptions.publish('beforeSetTransform', [_clip]);

        if (this.cancelSetTransform === false) {
          this.transform = _clip;
        } else {
          this.cancelSetTransform = false;
        } // } else {
        //   this.transform = transform._dup();
        // }
        // }

      }

      if (this.internalSetTransformCallback) {
        this.fnMap.exec(this.internalSetTransformCallback, this.transform);
      }

      this.subscriptions.publish('setTransform', [this.transform]);
      this.fnMap.exec(this.setTransformCallback, this.transform);
      this.animateNextFrame();
    } // Set the next transform (and velocity if moving freely) for the next
    // animation frame.
    //
    // If animating, this transform will be the next frame determined by
    // the currently executing animation phase. If time exceeds the current
    // phase, then either the next phase will be started, or if there are no
    // more phases, the animation will complete.
    //
    // If moving freely, this method will set the next velocity and transform
    // based on the current velocity, current transform, elapsed time,
    // deceleration (in freelyProperties) and zeroVelocityThreshold.
    // Once the velocity goes to zero, this metho will stop the element moving
    // freely.

  }, {
    key: "nextMovingFreelyFrame",
    value: function nextMovingFreelyFrame(now) {
      // If the element is moving freely, then calc it's next velocity and
      // transform. Save the new velocity into state.movement and return the
      // transform.
      if (this.state.isMovingFreely) {
        // If this is the first frame of moving freely, then record the current
        // time so can calculate velocity on next frame
        if (this.state.movement.previousTime == null) {
          this.state.movement.previousTime = now;
          return;
        } // If got here, then we are now after the first frame, so calculate
        // the delta time from this frame to the previous


        var deltaTime = now - this.state.movement.previousTime; // Calculate the new velocity and position

        var next = this.decelerate(deltaTime);
        this.state.movement.velocity = next.velocity;
        this.state.movement.previousTime = now; // If the velocity is 0, then stop moving freely and return the current
        // transform

        if (this.state.movement.velocity.isZero()) {
          this.state.movement.velocity = this.state.movement.velocity.zero();
          this.stopMovingFreely('complete');
        }

        this.setTransform(next.transform);
      }
    } // Used only to clear 2D context
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "clear",
    value: function clear() {}
  }, {
    key: "willStartAnimating",
    value: function willStartAnimating() {
      if (this.animations.willStartAnimating()) {
        return true;
      }

      return false;
    }
    /**
     Set element color.
     @param {[number, number, number, number]} color RGBA color from 0 to 1
     @param {boolean} [setDefault] also set the default color to this color
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      var setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.color = color != null ? color.slice() : [0, 0, 0, 0];

      if (setDefault) {
        this.defaultColor = this.color.slice();
      }

      this.animateNextFrame();
    }
    /**
     * Set element color to `dimColor`
     */

  }, {
    key: "dim",
    value: function dim() {
      this.setColor(this.dimColor, false);
    }
    /**
     * Set `dimColor` property
     */

  }, {
    key: "setDimColor",
    value: function setDimColor(color) {
      this.dimColor = color != null ? color.slice() : [0, 0, 0, 0];
    }
    /**
     * Set element color to `defaultColor`
     */

  }, {
    key: "undim",
    value: function undim() {
      this.setColor(this.defaultColor, true);
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      // this.color[3] = opacity;
      this.opacity = opacity;
      this.animateNextFrame();
    } // getScenarioTargetLegacy(
    //   scenarioName: string,
    // ) {
    //   let target = this.transform._dup();
    //   if (scenarioName in this.scenarios) {
    //     const scenario = this.scenarios[scenarioName];
    //     if (scenario.transform != null) {
    //       target = getTransform(scenario.transform);
    //     }
    //     if (scenario.position != null) {
    //       target.updateTranslation(getPoint(scenario.position));
    //     }
    //     if (scenario.rotation != null) {
    //       target.updateRotation(scenario.rotation);
    //     }
    //     if (scenario.scale != null) {
    //       target.updateScale(getScale(scenario.scale));
    //     }
    //   }
    //   return target;
    // }
    // retrieve a scenario

  }, {
    key: "getScenarioTarget",
    value: function getScenarioTarget(scenarioIn) {
      var transform;
      var color;
      var isShown;
      var scenario;

      if (scenarioIn == null) {
        return {};
      }

      if (typeof scenarioIn === 'string') {
        if (scenarioIn in this.scenarios) {
          scenario = this.scenarios[scenarioIn];
        } else {
          scenario = {};
        }
      } else {
        scenario = scenarioIn;
      }

      if (scenario.transform != null) {
        transform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(scenario.transform);
      }

      if (scenario.position != null) {
        if (transform == null) {
          transform = this.transform._dup();
        }

        transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(scenario.position));
      }

      if (scenario.translation != null) {
        if (transform == null) {
          transform = this.transform._dup();
        }

        transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(scenario.translation));
      }

      if (scenario.rotation != null) {
        if (transform == null) {
          transform = this.transform._dup();
        }

        transform.updateRotation(scenario.rotation);
      }

      if (scenario.scale != null) {
        if (transform == null) {
          transform = this.transform._dup();
        }

        transform.updateScale(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getScale"])(scenario.scale));
      }

      if (scenario.color) {
        color = scenario.color.slice();
      }

      if (scenario.isShown != null) {
        var _scenario = scenario;
        isShown = _scenario.isShown;
      }

      return {
        transform: transform,
        color: color,
        isShown: isShown
      };
    }
    /**
     * Set transform, color and/or visibility to a predefined scenario.
     *
     * @param {string | Array<string>} [scenarioName] name of the scenario to
     * set. Use an array of names to set multiple scenarios in the array's order.
     * @param {boolean} [onlyIfVisible] `true` to only set scenario if element is
     * visible
     */

  }, {
    key: "setScenario",
    value: function setScenario(scenario) {
      var target = this.getScenarioTarget(scenario);

      if (target.transform != null) {
        this.setTransform(target.transform._dup());
      } // this.setColor(target.color.slice());


      if (target.isShown != null) {
        if (target.isShown) {
          this.show();
        } else {
          this.hide();
        }
      }

      if (target.color != null) {
        this.setColor(target.color);
      }
    }
  }, {
    key: "setScenarios",
    value: function setScenarios(scenarioName) {
      var _this4 = this;

      var scenarios = scenarioName;

      if (!Array.isArray(scenarios)) {
        scenarios = [scenarios];
      }

      scenarios.forEach(function (scenario) {
        if (_this4.scenarios[scenario] != null) {
          _this4.setScenario(scenario);
        }
      });
    }
    /**
     * Save the current transform, color and/or visibility to a scenario.
     */

  }, {
    key: "saveScenario",
    value: function saveScenario(scenarioName) {
      var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['transform', 'color', 'isShown'];
      var scenario = this.getCurrentScenario(keys);

      if (Object.keys(scenario).length > 0) {
        this.scenarios[scenarioName] = scenario;
      }
    }
  }, {
    key: "getCurrentScenario",
    value: function getCurrentScenario() {
      var _this5 = this;

      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['transform', 'color', 'isShown'];
      var scenario = {};
      keys.forEach(function (key) {
        if (key === 'transform') {
          scenario.transform = _this5.transform._dup();
        } else if (key === 'position') {
          scenario.position = _this5.getPosition();
        } else if (key === 'rotation') {
          scenario.rotation = _this5.getRotation();
        } else if (key === 'scale') {
          scenario.scale = _this5.getScale();
        } else if (key === 'color') {
          scenario.color = _this5.color.slice();
        } else if (key === 'isShown') {
          scenario.isShown = _this5.isShown;
        }
      });
      return scenario;
    }
  }, {
    key: "saveScenarios",
    value: function saveScenarios(scenarioName, keys) {
      this.saveScenario(scenarioName, keys);
    } // animateToScenario() {
    // }

  }, {
    key: "getAllElementsWithScenario",
    value: function getAllElementsWithScenario(scenarioName) {
      if (this.scenarios[scenarioName] != null) {
        return [this];
      }

      return [];
    }
  }, {
    key: "getMovingFreelyEnd",
    value: function getMovingFreelyEnd() {
      return this.decelerate(null);
    }
  }, {
    key: "getRemainingMovingFreelyTime",
    value: function getRemainingMovingFreelyTime() {
      if (this.state.isMovingFreely) {
        return this.decelerate(null).duration;
      }

      return 0;
    } // Decelerate over some time when moving freely to get a new element
    // transform and movement velocity

  }, {
    key: "decelerate",
    value: function decelerate() {
      var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // let bounds;
      // if (!this.move.bounds instanceof TransformBounds) {
      //   this.setMoveBounds();
      // }
      // if (!this.move.bounds instanceof TransformBounds) {
      //   bounds = new TransformBounds(this.transform);
      // } else {
      //   ({ bounds } = this.move);
      // }
      // this.checkMoveBounds();
      // const { bounds } = this.move;
      var bounds = this.getMoveBounds();
      var next = this.transform.decelerate(this.state.movement.velocity, this.move.freely.deceleration, deltaTime, // $FlowFixMe
      bounds, this.move.freely.bounceLoss, this.move.freely.zeroVelocityThreshold);
      return {
        velocity: next.velocity,
        transform: next.transform,
        duration: next.duration
      };
    } // getMoveBoundsRelativeToSize() {
    //   if (this.move.includeSizeInBounds) {
    //     const size = this.getBoundingRect('figure');
    //     //asdfasdf
    //   }
    //   return this.move.bound
    // }

  }, {
    key: "updateLastDrawTransform",
    value: function updateLastDrawTransform() {
      var _this6 = this;

      var parentCount = this.lastDrawElementTransformPosition.parentCount;
      var pLength = this.lastDrawTransform.order.length;
      var transform = this.getTransform();
      transform.order.forEach(function (t, index) {
        _this6.lastDrawTransform.order[pLength - parentCount - index - 1] = t._dup();
      });
      this.lastDrawTransform.calcAndSetMatrix();
    }
  }, {
    key: "getParentLastDrawTransform",
    value: function getParentLastDrawTransform() {
      var parentCount = this.lastDrawElementTransformPosition.parentCount;
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(-parentCount));
    }
    /**
     * Return figure path of element
     * @return {string} path of element relative to figure
     */

  }, {
    key: "getPath",
    value: function getPath() {
      if (this.parent == null) {
        return this.name;
      }

      if (this.parent.name === 'figureRoot' || this.parent.parent == null) {
        return this.name;
      }

      return "".concat(this.parent.getPath(), ".").concat(this.name);
    } // getPause() {
    //   return this.state.pause;
    // }
    // Being Moved

  }, {
    key: "startBeingMoved",
    value: function startBeingMoved() {
      // this.stopAnimating();
      this.animations.cancelAll('freeze');
      this.stopMovingFreely('freeze');
      this.state.movement.velocity = this.transform.zero();
      this.state.movement.previousTransform = this.transform._dup();
      this.state.movement.previousTime = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_11__["default"]().now() / 1000;
      this.state.isBeingMoved = true;
      this.unrender();
      this.subscriptions.publish('startBeingMoved');

      if (this.recorder.state === 'recording') {
        this.recorder.recordEvent('startBeingMoved', [this.getPath()]);
      }
    }
  }, {
    key: "moved",
    value: function moved(newTransform) {
      var prevTransform = this.transform._dup();

      this.setTransform(newTransform._dup());
      var tBounds;

      if (this.move.bounds != null) {
        // $FlowFixMe
        tBounds = this.move.bounds.getTranslation();
      } // In a finite rect bounds, if we calculate the velocity from the clipped
      // transform, the object will skip along the wall if the user lets the
      // object go after intersecting with the wall


      if (tBounds instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["RectBounds"] && tBounds.boundary.right > tBounds.boundary.left && tBounds.boundary.top > tBounds.boundary.bottom) {
        this.calcVelocity(prevTransform, newTransform);
      } else {
        this.calcVelocity(prevTransform, this.transform);
      } // if (
      //   this.move.bounds.getTranslation instanceof LineBounds
      //   || this.move.bounds.getTranslation()
      // ) {
      //   this.calcVelocity(prevTransform, this.transform);
      // } else {
      //   this.calcVelocity(prevTransform, newTransform);
      // }


      if (this.recorder.state === 'recording') {
        this.recorder.recordEvent('moved', [this.getPath(), this.transform.round(this.recorder.precision)._state()] // this.state.movement.velocity.toString(),
        );
      }
    }
  }, {
    key: "stopBeingMoved",
    value: function stopBeingMoved() {
      if (!this.state.isBeingMoved) {
        return;
      }

      var currentTime = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_11__["default"]().now() / 1000; // Check wether last movement was a long time ago, if it was, then make
      // velocity 0 as the user has stopped moving before releasing touch/click

      if (this.state.movement.previousTime != null) {
        if (currentTime - this.state.movement.previousTime > 0.05) {
          this.state.movement.velocity = this.transform.zero();
        }
      }

      this.subscriptions.publish('stopBeingMoved');

      if (this.recorder.state === 'recording' && this.state.isBeingMoved) {
        this.recorder.recordEvent('stopBeingMoved', [this.getPath(), this.transform._state(), this.state.movement.velocity._state()] // this.state.movement.velocity.toString(),
        );
      }

      this.state.isBeingMoved = false;
      this.state.movement.previousTime = null;
    }
  }, {
    key: "calcVelocity",
    value: function calcVelocity(prevTransform, nextTransform) {
      var currentTime = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_11__["default"]().now() / 1000;

      if (this.state.movement.previousTime == null) {
        this.state.movement.previousTime = currentTime;
        return;
      } // console.log(currentTime, this.state.movement.previousTime)


      var deltaTime = currentTime - this.state.movement.previousTime; // If the time is too small, weird calculations may happen

      if (deltaTime < 0.0001) {
        return;
      }

      this.state.movement.velocity = nextTransform.velocity(prevTransform, deltaTime, this.move.freely.zeroVelocityThreshold, this.move.maxVelocity);
      this.state.movement.previousTime = currentTime;
    }
  }, {
    key: "simulateStartMovingFreely",
    value: function simulateStartMovingFreely(transform, velocity) {
      this.transform = transform;
      this.state.movement.velocity = velocity;
      this.startMovingFreely();
    } // Moving Freely

  }, {
    key: "startMovingFreely",
    value: function startMovingFreely() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // this.stopAnimating();
      this.animations.cancelAll('freeze');
      this.stopBeingMoved();

      if (callback) {
        // this.animate.transform.callback = callback;
        this.move.freely.callback = callback;
      }

      this.state.isMovingFreely = true; // this.state.movement.previousTime = null;

      this.state.movement.previousTime = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_11__["default"]().now() / 1000;
      this.state.movement.velocity = this.state.movement.velocity.clipMag(this.move.freely.zeroVelocityThreshold, this.move.maxVelocity);

      if (this.recorder.state === 'recording') {
        this.recorder.recordEvent('startMovingFreely', [this.getPath(), this.transform._state(), this.state.movement.velocity._state()] // this.state.movement.velocity.toString(),
        );
      }
    }
  }, {
    key: "stopMovingFreely",
    value: function stopMovingFreely() {
      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';

      if (how === 'animateToComplete') {
        return;
      } // console.log(how)


      var wasMovingFreely = false;

      if (this.state.isMovingFreely === true) {
        wasMovingFreely = true;
      }

      if (how === 'complete' && wasMovingFreely) {
        var result = this.getMovingFreelyEnd();
        this.setTransform(result.transform);
      }

      this.state.isMovingFreely = false;
      this.state.movement.previousTime = null;

      if (this.move.freely.callback) {
        this.fnMap.exec(this.move.freely.callback, how);
        this.move.freely.callback = null;
      }

      if (wasMovingFreely) {
        this.fnMap.exec(this.animationFinishedCallback);
        this.animationFinished('movingFreely');
        this.subscriptions.publish('stopMovingFreely');
      }
    }
  }, {
    key: "getRemainingPulseTime",
    value: function getRemainingPulseTime() {
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_11__["default"]().now() / 1000;

      if (this.state.isPulsing === false) {
        return 0;
      }

      if (this.state.pulse.startTime == null) {
        return this.pulseSettings.time;
      }

      return this.pulseSettings.time - (now - this.state.pulse.startTime);
    } // Take an input transform matrix, and output a list of transform matrices
    // that have been transformed by a pulse. The first matrix in the list
    // will be the largest, so when saving lastDrawTransformMatrix it can be
    // used to determine if a touch has occured in the object.
    //
    // When an object is animated or moved, it's new transform is saved as the
    // new transform of the object. In contrast, pulsing is not saved as the
    // current transform of the object, and is used only in the current draw
    // of the element.

  }, {
    key: "getPulseTransforms",
    value: function getPulseTransforms(now) {
      var pulseTransforms = []; // To output list of transform matrices
      // If the figure element is currently pulsing, the calculate the current
      // pulse magnitude, and transform the input matrix by the pulse

      if (this.state.isPulsing) {
        // If this is the first pulse frame, then set the startTime
        if (this.state.pulse.startTime == null) {
          this.state.pulse.startTime = now;
        } // Calculate how much time has elapsed between this frame and the first
        // pulse frame


        var deltaTime = now - this.state.pulse.startTime; // If the elapsed time is larger than the planned pulse time, then
        // clip the elapsed time to the pulse time, and end pulsing (after this
        // draw). If the pulse time is 0, that means pulsing will loop
        // indefinitely.

        if (deltaTime >= this.pulseSettings.time && this.pulseSettings.time !== 0) {
          // this.state.isPulsing = false;
          this.stopPulsing('complete');
          deltaTime = this.pulseSettings.time;
        } // Go through each pulse matrix planned, and transform the input matrix
        // with the pulse.


        for (var i = 0; i < this.pulseSettings.num; i += 1) {
          // Get the current pulse magnitude
          var pulseMag = this.fnMap.exec(this.pulseSettings.progression, deltaTime, this.pulseSettings.frequency, this.pulseSettings.A instanceof Array ? this.pulseSettings.A[i] : this.pulseSettings.A, this.pulseSettings.B instanceof Array ? this.pulseSettings.B[i] : this.pulseSettings.B, this.pulseSettings.C instanceof Array ? this.pulseSettings.C[i] : this.pulseSettings.C); // Use the pulse magnitude to get the current pulse transform

          var pTransform = this.fnMap.exec(this.pulseSettings.transformMethod, pulseMag, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(this.pulseSettings.delta), this.pulseSettings.type); // console.log(this.name, this.transform._dup(), pTransform.matrix());
          // if (this.name === 'p2') {
          //   console.log(pTransform._dup(), pulseMag)
          // }
          // if(this.name === '_radius') {
          // }
          // Transform the current transformMatrix by the pulse transform matrix
          // const pMatrix = m2.mul(m2.copy(transform), pTransform.matrix());
          // Push the pulse transformed matrix to the array of pulse matrices\

          if (pTransform != null) {
            pulseTransforms.push(pTransform);
          }
        } // If not pulsing, then make no changes to the transformMatrix.

      }

      return pulseTransforms;
    }
    /**
     * Pulse element.
     *
     * An element can be pulsed in scale, a rotation or a translation.
     *
     * The scale pulse can either be a single pulse, or a number of copies with a
     * range of scales - which has the effect of making regular polygons thick.
     *
     * Either pass in a callback, or an options object defining the pulse and
     * callback.
     *
     * @param {null | OBJ_Pulse | () => void} optionsOrDone
     */

  }, {
    key: "pulse",
    value: function pulse() {
      var optionsOrDone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (typeof this.pulseDefault === 'function' || typeof this.pulseDefault === 'string') {
        var _done = null;

        if (typeof optionsOrDone === 'function') {
          _done = optionsOrDone;
        } else if (optionsOrDone != null && optionsOrDone.done != null) {
          _done = optionsOrDone.done;
        }

        this.fnMap.exec(this.pulseDefault, _done);
        return;
      }

      var defaultOptions = this.pulseDefault;
      var done = null;
      var options;

      if (typeof optionsOrDone === 'function' || typeof optionsOrDone === 'string') {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, defaultOptions);
        done = optionsOrDone;
      } else if (optionsOrDone == null) {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, defaultOptions);
        done = null;
      } else {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, defaultOptions, optionsOrDone);
        var _options = options;
        done = _options.done;
      }

      if (options.progression === 'sinusoid') {
        options.progression = 'tools.math.sinusoid';
      } else if (options.progression === 'sinusoidAbs') {
        options.progression = 'tools.math.sinusoidAbs';
      } else if (options.progression === 'triangle') {
        options.progression = 'tools.math.triangle';
      }

      var _options2 = options,
          centerOn = _options2.centerOn,
          xAlign = _options2.xAlign,
          yAlign = _options2.yAlign,
          space = _options2.space;
      var delta;

      if (centerOn == null) {
        delta = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      } else if (centerOn === 'this') {
        delta = this.getPositionInBounds('figure', xAlign, yAlign).transformBy(this.spaceTransformMatrix('figure', 'draw'));
      } else if (centerOn instanceof FigureElement) {
        delta = centerOn.getPositionInBounds('figure', xAlign, yAlign).transformBy(this.spaceTransformMatrix('figure', 'draw'));
      } else {
        delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(centerOn).transformBy(this.spaceTransformMatrix(space, 'draw'));
      }

      var _options3 = options,
          duration = _options3.duration,
          scale = _options3.scale,
          progression = _options3.progression,
          when = _options3.when,
          num = _options3.num,
          rotation = _options3.rotation,
          angle = _options3.angle,
          translation = _options3.translation;
      var _options4 = options,
          min = _options4.min,
          start = _options4.start,
          frequency = _options4.frequency;

      if (frequency === 0 || frequency == null) {
        frequency = duration === 0 ? 1 : 1 / duration;
      }

      var max;

      if (translation != null) {
        start = start == null ? 0 : start;
        max = translation;
      } else if (rotation != null) {
        start = start == null ? 0 : start;
        max = rotation;
      } else {
        start = start == null ? 1 : start;
        max = scale;
      }

      min = min == null ? start : min;
      var range = max - min;

      if (num > 1) {
        var bStep = range / (num - 1);
        var BArray = [];
        var CArray = [];
        var AArray = [];

        for (var i = 0; i < num; i += 1) {
          var minMax = max - i * bStep;

          if (minMax < start) {
            var r = start - minMax;
            CArray.push(Math.PI / 2);
            AArray.push(start - r / 2);
            BArray.push(r / 2);
          } else {
            var _r = minMax - start;

            CArray.push(-Math.PI / 2);
            AArray.push(start + _r / 2);
            BArray.push(_r / 2);
          }
        }

        this.pulseSettings.A = AArray;
        this.pulseSettings.B = BArray;
        this.pulseSettings.C = CArray;
      } else {
        var mid = range / 2 + min;
        var startNormalized = range !== 0 ? (start - mid) / (range / 2) : start;
        this.pulseSettings.A = mid;
        this.pulseSettings.B = range / 2;
        this.pulseSettings.C = Math.asin(Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(startNormalized, 10)); // console.log(this.name, this.pulseSettings, range, min, mid, start, startNormalized)
      }

      this.pulseSettings.time = duration;
      this.pulseSettings.frequency = frequency;
      this.pulseSettings.num = num;
      this.pulseSettings.delta = delta;
      this.pulseSettings.callback = done;
      this.pulseSettings.progression = progression;
      this.pulseSettings.type = 'scale';

      if (rotation != null) {
        this.pulseSettings.type = 'rotation';
      }

      if (translation != null) {
        this.pulseSettings.type = angle;
      }

      this.startPulsing(when); // console.log(this.figure)
      // this.figure.animateNextFrame();
    } // deprecate

  }, {
    key: "pulseScaleNow",
    value: function pulseScaleNow(time, scale) {
      var frequency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var delta = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var progression = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'tools.math.sinusoid';
      this.pulseScale({
        duration: time,
        scale: scale,
        frequency: frequency,
        callback: callback,
        delta: delta,
        progression: progression,
        when: 'nextFrame'
      });
    } // deprecate

  }, {
    key: "pulseScale",
    value: function pulseScale(optionsIn) {
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, {
        duration: 1,
        scale: 2,
        callback: null,
        delta: [0, 0],
        when: 'syncNow',
        progression: 'tools.math.sinusoid'
      }, optionsIn);

      if (options.frequency == null || options.frequency === 0 && options.duration !== 0) {
        options.frequency = 1 / (options.duration * 2);
      }

      if (options.frequency === 0 && options.duration === 0) {
        options.frequency = 1;
      }

      this.pulseSettings.time = options.duration;
      this.pulseSettings.frequency = options.frequency;
      this.pulseSettings.A = 1;
      this.pulseSettings.B = options.scale - 1;
      this.pulseSettings.C = 0;
      this.pulseSettings.num = 1;
      this.pulseSettings.delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.delta); // this.pulseSettings.transformMethod = s => new Transform().scale(s, s);

      this.pulseSettings.callback = options.callback;
      this.pulseSettings.progression = options.progression;
      this.startPulsing(options.when);
    } // deprecate

  }, {
    key: "pulseScaleRelativeToPoint",
    value: function pulseScaleRelativeToPoint(p, space, time, scale) {
      var frequency = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var progression = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'tools.math.sinusoid';
      var currentPosition = this.getPosition(space);
      var delta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p).sub(currentPosition);
      this.pulseScaleNow(time, scale, frequency, callback, delta, progression);
    } // deprecate

  }, {
    key: "pulseScaleRelativeToElement",
    value: function pulseScaleRelativeToElement(e, x, y, space, time, scale) {
      var frequency = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var callback = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
      var progression = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 'tools.math.sinusoid';
      var p;

      if (e == null) {
        p = this.getPositionInBounds(space, x, y);
      } else {
        p = e.getPositionInBounds(space, x, y);
      }

      this.pulseScaleRelativeToPoint(p, space, time, scale, frequency, callback, progression);
    } // deprecate

  }, {
    key: "pulseScaleRelativeTo",
    value: function pulseScaleRelativeTo(e, x, y, space, time, scale) {
      var frequency = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var callback = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
      var progression = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 'tools.math.sinusoid';

      if (e == null || e instanceof FigureElement) {
        this.pulseScaleRelativeToElement( // $FlowFixMe
        e, x, y, space, time, scale, frequency, callback, progression);
      } else {
        this.pulseScaleRelativeToPoint(e, space, time, scale, frequency, callback, progression);
      }
    } // deprecate

  }, {
    key: "pulseThickNow",
    value: function pulseThickNow(time, scale) {
      var num = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var bArray = [scale];
      this.pulseSettings.num = num;

      if (this.pulseSettings.num > 1) {
        var b = Math.abs(1 - scale);
        var bMax = b;
        var bMin = -b;
        var range = bMax - bMin;
        var bStep = range / (this.pulseSettings.num - 1);
        bArray = [];

        for (var i = 0; i < this.pulseSettings.num; i += 1) {
          bArray.push(bMax - i * bStep);
        }
      }

      this.pulseSettings.time = time;
      this.pulseSettings.frequency = 1 / (time * 2);
      this.pulseSettings.A = 1;
      this.pulseSettings.B = bArray;
      this.pulseSettings.C = 0;
      this.pulseSettings.callback = callback;
      this.startPulsing();
    } // deprecate

  }, {
    key: "pulseThick",
    value: function pulseThick(optionsIn) {
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, {
        duration: 1,
        scale: 2,
        callback: null,
        // delta: [0, 0],
        when: 'syncNow',
        num: 3
      }, optionsIn);
      var bArray = [options.scale];
      this.pulseSettings.num = options.num;

      if (this.pulseSettings.num > 1) {
        var b = Math.abs(1 - options.scale);
        var bMax = b;
        var bMin = -b;
        var range = bMax - bMin;
        var bStep = range / (this.pulseSettings.num - 1);
        bArray = [];

        for (var i = 0; i < this.pulseSettings.num; i += 1) {
          bArray.push(bMax - i * bStep);
        }
      }

      this.pulseSettings.time = options.duration;
      this.pulseSettings.frequency = 1 / (options.duration * 2);
      this.pulseSettings.A = 1;
      this.pulseSettings.B = bArray;
      this.pulseSettings.C = 0;
      this.pulseSettings.callback = options.callback;
      this.startPulsing(options.when);
    }
  }, {
    key: "startPulsing",
    value: function startPulsing() {
      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'nextFrame';
      this.state.isPulsing = true;
      var time = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_11__["default"]().getWhen(when);
      this.state.pulse.startTime = time == null ? time : time / 1000;
      this.unrender();
      this.frozenPulseTransforms = [];
      this.animateNextFrame();
    }
  }, {
    key: "stopPulsing",
    value: function stopPulsing() {
      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';
      var wasPulsing = this.state.isPulsing;

      if (how === 'animateToComplete') {
        return;
      }

      if (how === 'freeze' && this.state.isPulsing) {
        this.frozenPulseTransforms = this.pulseTransforms.map(function (t) {
          return t._dup();
        });
        this.pulseTransforms = [];
      }

      if (how === 'cancel' || how === 'complete') {
        this.pulseTransforms = [];
      }

      this.state.isPulsing = false;
      this.pulseSettings.num = 1;

      if (this.pulseSettings.callback) {
        var callback = this.pulseSettings.callback;
        this.pulseSettings.callback = null;
        this.fnMap.exec(callback, how);
      }

      if (wasPulsing) {
        // this.subscriptions.publish('animationFinished', )
        this.animationFinished('pulse');
        this.subscriptions.publish('stopPulsing');
      }
    } // isAnimating() {
    //   if (this.state.isPulsing) {
    //     return true;
    //   }
    //   if (this.state.isMovingFreely) {
    //     return true;
    //   }
    //   if (this.animations.isAnimating()) {
    //     return true;
    //   }
    //   return false;
    // }

  }, {
    key: "stop",
    value: function stop() {
      var _this7 = this;

      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';
      var toComplete = 0;

      var checkStop = function checkStop() {
        toComplete -= 1;

        if (toComplete <= 0) {
          _this7.state.preparingToStop = false;

          _this7.subscriptions.publish('stopped');
        }
      };

      if (how === 'animateToComplete' || how === 'dissolveToComplete') {
        if (this.animations.isAnimating()) {
          this.state.preparingToStop = true;
          toComplete += 1;
          this.animations.subscriptions.add('finished', checkStop, 1);
        }

        if (this.state.isPulsing) {
          this.state.preparingToStop = true;
          toComplete += 1;
          this.subscriptions.add('stopPulsing', checkStop, 1);
        }

        if (this.state.isMovingFreely) {
          this.state.preparingToStop = true;
          toComplete += 1;
          this.subscriptions.add('stopMovingFreely', checkStop, 1);
        }
      }

      if (this.state.preparingToStop) {
        this.subscriptions.publish('preparingToStop');
      }

      this.stopAnimating(how);
      this.stopMovingFreely(how);
      this.stopBeingMoved();
      this.stopPulsing(how);
    }
  }, {
    key: "stopAnimating",
    value: function stopAnimating() {
      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (how === 'freeze') {
        this.animations.cancel(name, 'freeze');
      } else if (how === 'cancel') {
        this.animations.cancel(name, null);
      } else if (how === 'complete') {
        this.animations.cancel(name, 'complete');
      }
    }
  }, {
    key: "getRemainingAnimationTime",
    value: function getRemainingAnimationTime() {
      var animationNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return this.animations.getRemainingTime(animationNames);
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits) {
      var transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.figureTransforms;
      this.figureLimits = limits;
      this.figureTransforms = transforms;
    }
  }, {
    key: "resize",
    value: function resize() {
      var figureHTMLElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (figureHTMLElement && this.tieToHTML.updateOnResize) {
        this.updateHTMLElementTie(figureHTMLElement);
      }
    }
  }, {
    key: "getPixelToVertexSpaceScale",
    value: function getPixelToVertexSpaceScale() {
      var pixelToFigure = this.figureTransforms.pixelToFigure.matrix();
      var figureToVertex = this.spaceTransformMatrix('figure', 'draw');
      var scaleX = pixelToFigure[0] * figureToVertex[0];
      var scaleY = pixelToFigure[4] * figureToVertex[4];
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](scaleX, scaleY);
    }
  }, {
    key: "getVertexToPixelSpaceScale",
    value: function getVertexToPixelSpaceScale() {
      var pixelToVertexSpaceScale = this.getPixelToVertexSpaceScale();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1 / pixelToVertexSpaceScale.x, 1 / pixelToVertexSpaceScale.y);
    }
  }, {
    key: "spaceTransformMatrix",
    value: function spaceTransformMatrix(from, to) {
      // All Vertex related conversions
      if (from === to) {
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().identity().matrix();
      }

      if (from === 'draw' && to === 'pixel') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["mul"](this.figure.spaceTransforms.glToPixel.matrix(), this.lastDrawTransform.matrix());
      }

      if (from === 'draw' && to === 'gl') {
        return this.lastDrawTransform.matrix();
      }

      if (from === 'draw' && to === 'figure') {
        return this.lastDrawTransform.calcMatrix(0, -3);
      }

      if (from === 'draw' && to === 'local') {
        return this.getTransform().matrix();
      }

      if (from === 'pixel' && to === 'draw') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["mul"](_tools_m2__WEBPACK_IMPORTED_MODULE_4__["inverse"](this.lastDrawTransform.matrix()), this.figure.spaceTransforms.pixelToGL.matrix());
      }

      if (from === 'gl' && to === 'draw') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["inverse"](this.lastDrawTransform.matrix());
      }

      if (from === 'figure' && to === 'draw') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["inverse"](this.lastDrawTransform.calcMatrix(0, -3));
      }

      if (from === 'local' && to === 'draw') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["inverse"](this.getTransform().matrix());
      } // Remaining Local related conversions


      if (from === 'local' && to === 'pixel') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["mul"](this.figure.spaceTransforms.glToPixel.matrix(), this.lastDrawTransform.calcMatrix(this.transform.order.length));
      }

      if (from === 'local' && to === 'gl') {
        return this.lastDrawTransform.calcMatrix(this.transform.order.length);
      }

      if (from === 'local' && to === 'figure') {
        return this.lastDrawTransform.calcMatrix(this.transform.order.length, -3);
      }

      if (from === 'pixel' && to === 'local') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["mul"](_tools_m2__WEBPACK_IMPORTED_MODULE_4__["inverse"](this.lastDrawTransform.calcMatrix(this.transform.order.length)), this.figure.spaceTransforms.pixelToGL.matrix());
      }

      if (from === 'gl' && to === 'local') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["inverse"](this.lastDrawTransform.calcMatrix(this.transform.order.length));
      }

      if (from === 'figure' && to === 'local') {
        return _tools_m2__WEBPACK_IMPORTED_MODULE_4__["inverse"](this.lastDrawTransform.calcMatrix(this.transform.order.length, -3));
      } // Remaining Figure related conversions


      if (from === 'figure' && to === 'gl') {
        return this.figure.spaceTransforms.figureToGL.matrix();
      }

      if (from === 'figure' && to === 'pixel') {
        return this.figure.spaceTransforms.figureToPixel.matrix();
      }

      if (from === 'gl' && to === 'figure') {
        return this.figure.spaceTransforms.glToFigure.matrix();
      }

      if (from === 'pixel' && to === 'figure') {
        return this.figure.spaceTransforms.pixelToFigure.matrix();
      } // Remaining GL related conversions


      if (from === 'gl' && to === 'pixel') {
        return this.figure.spaceTransforms.glToPixel.matrix();
      }

      if (from === 'pixel' && to === 'gl') {
        return this.figure.spaceTransforms.pixelToGL.matrix();
      }

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().identity().matrix();
    }
  }, {
    key: "pointFromSpaceToSpace",
    value: function pointFromSpaceToSpace(point, fromSpace, toSpace) {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(point).transformBy(this.spaceTransformMatrix(fromSpace, toSpace));
    }
    /* eslint-disable class-methods-use-this, no-unused-vars */

  }, {
    key: "getBorderPoints",
    value: function getBorderPoints() {
      var border = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'border';
      return [[]];
    }
    /* eslint-enable class-methods-use-this, no-unused-vars */
    // A DrawingObject has borders, touchBorders and and holeBorders
    //
    // A FigureElement's border is then the DrawingObject's border transformed by
    // the element's transform
    //
    // Something can have borders, bounds and a boundingRect
    // * Borders: the points defining the enclosing border
    // * Bounds: The expanse of the object from a drawingSpace of 0, 0
    // * BoundingRect: The rectangle enclosing all the border points
    // * BoundingRectBorder: The perimeter of the boundingRect

    /* eslint-disable class-methods-use-this, no-unused-vars */

  }, {
    key: "getBorder",
    value: function getBorder() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'border';
      // if (this.name === 'c' && border === 'touchBorder') {
      //   debugger;
      // }
      var borderPoints = this.getBorderPoints(border);

      if (space === 'draw') {
        return borderPoints;
      }

      var transformedBorders = [];
      var matrix;

      if (Array.isArray(space)) {
        matrix = _tools_m2__WEBPACK_IMPORTED_MODULE_4__["mul"](space, this.getTransform().matrix());
      } else {
        matrix = this.spaceTransformMatrix('draw', space);
      }

      borderPoints.forEach(function (b) {
        transformedBorders.push(b.map(function (p) {
          return p.transformBy(matrix);
        }));
      });
      return transformedBorders;
    }
    /* eslint-enable class-methods-use-this, no-unused-vars */

  }, {
    key: "getBoundingRect",
    value: function getBoundingRect() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'border';
      var transformedBorder = this.getBorder(space, border); // $FlowFixMe

      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(transformedBorder);
    } // ***************************************************************
    // Size
    // ***************************************************************

  }, {
    key: "getRelativeBoundingRect",
    value: function getRelativeBoundingRect() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'border';
      var rect = this.getBoundingRect(space, border);
      var position = this.getPosition(space);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](rect.left - position.x, rect.bottom - position.y, rect.width, rect.height);
    }
  }, {
    key: "getCenterFigurePosition",
    value: function getCenterFigurePosition() {
      var rect = this.getBoundingRect('figure', 'border'); // const rect = this.getFigureBoundingRect();

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rect.left + rect.width / 2, rect.bottom + rect.height / 2);
    }
    /**
     * Return the first scale in the element's transform. Will return
     * `[1, 1]` if element's transform doesn't have a scale.
     *
     * @return {Point} scale
     */

  }, {
    key: "getScale",
    value: function getScale() {
      var s = this.transform.s();
      var scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 1);

      if (s != null) {
        scale = s._dup();
      }

      return scale;
    }
    /**
     * Return the first rotation in the element's transform. Will return
     * `0` if the element's transform doesn't have a rotation.
     *
     * @param {'0to360' | '-180to180' | ''} normalize how to normalize the
     * returned angle where `''` returns the raw angle
     * @return {Point} scale
     */

  }, {
    key: "getRotation",
    value: function getRotation() {
      var normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var r = this.transform.r();
      var rotation = 0;

      if (r != null) {
        rotation = r;
      }

      if (normalize !== '' && r != null) {
        rotation = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(r, normalize);
      }

      return rotation;
    } // /**
    //  * Get position relative to bounding rect.
    //  *
    //  * @return {Point} position
    //  */

  }, {
    key: "getPositionInBounds",
    value: function getPositionInBounds() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var xAlign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'location';
      var yAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'location';
      var border = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'border';
      var bounds = this.getBoundingRect(space, border);
      var p = this.getPosition(space);

      if (xAlign === 'left') {
        p.x = bounds.left;
      } else if (xAlign === 'right') {
        p.x = bounds.right;
      } else if (xAlign === 'center') {
        p.x = bounds.left + bounds.width / 2;
      } else if (typeof xAlign === 'number') {
        p.x = bounds.left + bounds.width * xAlign;
      }

      if (yAlign === 'top') {
        p.y = bounds.top;
      } else if (yAlign === 'bottom') {
        p.y = bounds.bottom;
      } else if (yAlign === 'middle') {
        p.y = bounds.bottom + bounds.height / 2;
      } else if (typeof yAlign === 'number') {
        p.y = bounds.bottom + bounds.height * yAlign;
      }

      return p;
    }
    /**
     * Get position of element
     *
     * By default the first translation of the element's transform is returned.
     * This is effectively the element's location in 'local' coordinates.
     *
     * The position of the element relative to its horizontal and vertical bounds
     * can also be returned. Use `xAlign` to find the x coordinate of the left,
     * center, right or percentage width from left of the element. Use `yAlign`
     * to find the bottom, middle, top or percentage height from bottom of the
     * element.
     *
     * @param {'local' | 'figure' | 'gl' | 'draw'} space the space to return
     * the position in
     * @param {'center' | 'left' | 'right' | 'location' | number} xAlign
     * horizontal alignment of position. Use a `number` to define the horizontal
     * position in percentage width from the left.
     * @param {'middle' | 'top' | 'bottom' | 'location' | number} yAlign
     * vertical alignment of position. Use a `number` to define the vertical
     * position in percentage height from the bottom.
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var xAlign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'location';
      var yAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'location';

      if (xAlign !== 'location' || yAlign !== 'location') {
        return this.getPositionInBounds(space, xAlign, yAlign);
      } // vertex space position doesn't mean much as it will always be 0, 0


      if (space === 'draw') {
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      }

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0).transformBy(this.spaceTransformMatrix('draw', space));
    }
  }, {
    key: "setFigurePosition",
    value: function setFigurePosition(figurePosition) {
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var figureSpace = {
        x: {
          bottomLeft: this.figureLimits.left,
          width: this.figureLimits.width
        },
        y: {
          bottomLeft: this.figureLimits.bottom,
          height: this.figureLimits.height
        }
      };
      var figureToGLSpace = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["spaceToSpaceTransform"])(figureSpace, glSpace);
      var glLocation = figurePosition.transformBy(figureToGLSpace.matrix());
      var t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](this.lastDrawTransform.order.slice(this.transform.order.length));
      var newLocation = glLocation.transformBy(_tools_m2__WEBPACK_IMPORTED_MODULE_4__["inverse"](t.matrix()));
      this.setPosition(newLocation._dup());
    }
  }, {
    key: "setFigurePositionToElement",
    value: function setFigurePositionToElement(element) {
      var p = element.getPosition('figure');
      this.setFigurePosition(p._dup());
    }
  }, {
    key: "setPositionToElement",
    value: function setPositionToElement(element) // space: 'local' | 'figure' = 'figure',
    {
      if (element.parent === this.parent) {
        // if (space === 'local') {
        var p = element.transform.t();

        if (p != null) {
          this.setPosition(p._dup());
        }

        return;
      }

      var figurePosition = element.getPosition('figure');
      var local = figurePosition.transformBy(this.spaceTransformMatrix('figure', 'local')); // const figure = this.getPosition('figure');
      // const local = this.getPosition('local');
      // const p = element.getPosition('figure');
      // const deltaFigure = p.sub(figure);
      // this.setPosition(local.add(deltaFigure));

      this.setPosition(local);
    }
  }, {
    key: "checkMoveBounds",
    value: function checkMoveBounds() {
      if (this.move.bounds === 'figure') {
        this.setMoveBounds('figure');
        return;
      }

      if (this.move.bounds === 'none' || this.move.bounds === null) {
        this.setMoveBounds('none');
        return;
      }

      if (!(this.move.bounds instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformBounds"])) {
        this.setMoveBounds(this.move.bounds);
      } // if (!(this.move.bounds instanceof TransformBounds)) {
      //   bounds = new TransformBounds(this.transform);
      // } else {
      //   ({ bounds } = this.move);
      // }

    }
  }, {
    key: "setMoveBounds",
    value: function setMoveBounds() {
      var boundaryIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'none';

      if (boundaryIn instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformBounds"]) {
        this.move.bounds = boundaryIn;
        return;
      }

      if (boundaryIn === null || boundaryIn === 'none') {
        this.move.bounds = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformBounds"](this.transform);
        return;
      } // console.log(boundaryIn)


      if (boundaryIn === 'figure') {
        if (!(this.move.bounds instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformBounds"])) {
          this.move.bounds = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformBounds"](this.transform);
        }

        this.move.sizeInBounds = true;
        var m = this.spaceTransformMatrix('figure', 'local');
        var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.figureLimits.left, this.figureLimits.bottom).transformBy(m); // const p1 = new Point(this.figureLimits.right, p0.y).transformBy(m);

        var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.figureLimits.right, this.figureLimits.top).transformBy(m); // $FlowFixMe

        this.move.bounds.updateTranslation(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["RectBounds"]({
          // left: this.figureLimits.left,
          // bottom: this.figureLimits.bottom,
          // right: this.figureLimits.right,
          // top: this.figureLimits.top,
          left: p0.x,
          bottom: p0.y,
          right: p1.x,
          top: p1.y
        }));
        return;
      }

      var bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBounds"])(boundaryIn, 'transform', this.transform);

      if (bounds instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["TransformBounds"]) {
        this.move.bounds = bounds;
      } // if (includeSize) {
      //   const rect = this.getRelativeBoundingRect('figure');
      //   const b = this.move.bounds.getTranslation();
      //   if (b != null) {
      //     b.boundary.left -= rect.left;
      //     b.boundary.bottom -= rect.bottom;
      //     b.boundary.right -= rect.right;
      //     b.boundary.top -= rect.top;
      //     this.move.bounds.updateTranslation(b);
      //   }
      // }

    }
  }, {
    key: "getMoveBounds",
    value: function getMoveBounds() {
      this.checkMoveBounds(); // $FlowFixMe

      if (this.move.bounds.isUnbounded()) {
        return this.move.bounds;
      }

      if (this.move.sizeInBounds) {
        var rect = this.getRelativeBoundingRect('local'); // $FlowFixMe

        var dup = this.move.bounds._dup();

        var b = dup.getTranslation(); // console.log(rect)

        if (b != null) {
          b.boundary.left -= rect.left;
          b.boundary.bottom -= rect.bottom;
          b.boundary.right -= rect.right;
          b.boundary.top -= rect.top;
          dup.updateTranslation(b);
          return dup;
        }
      }

      return this.move.bounds;
    }
    /**
     * Show element
     */

  }, {
    key: "show",
    value: function show() {
      this.isShown = true;
      this.setOpacity(1);

      if (this.parent != null) {
        if (!this.parent.isShown) {
          this.parent.show();
        }
      }

      this.animateNextFrame();
    } // /**
    //  * `true` set this element as touchable and configures all parent elements
    //  * to accept touches for their children
    //  *
    //  * `false` makes this element not touchable.
    //  */
    // setTouchable(touchable: boolean) {
    //   if (touchable === false) {
    //     this.isTouchable = false;
    //     return;
    //   }
    //   this.setTouchable();
    // }
    // /**
    //  * Make the touchable border of this element a rect encompassing it
    //  * plus some `touchable` buffer on all sides.
    //  */
    // // eslint-disable-next-line no-unused-vars
    // setTouchableRect(touchable: number = 0) {
    //   // this.touchInBoundingRect = touchable;
    //   this.setTouchable();
    // }

    /**
     * `true` set this element as touchable and configures all parent elements
     * to accept touches for their children
     *
     * `false` makes this element not touchable.
     */

  }, {
    key: "setTouchable",
    value: function setTouchable() {
      var makeThisElementTouchable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (makeThisElementTouchable) {
        this.isTouchable = true;
      } else {
        this.hasTouchableElements = true;
      }

      if (this.parent != null) {
        this.parent.setTouchable(false);
      }
    }
    /**
     * Configure all parents to make this element touchable, and
     * make this element touchable and movable
     * @param {boolean} movable `true` to make movable, `false` to not
     */

  }, {
    key: "setMovable",
    value: function setMovable() {
      var movable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (movable) {
        this.isMovable = true;
        this.setTouchable(true);
      } else {
        this.isMovable = false;
        this.isTouchable = false;
      }
    }
  }, {
    key: "clearRender",
    value: function clearRender() {
      var tieToElement;
      var elementId = '';

      if (typeof this.tieToHTML.element === 'string') {
        elementId = this.tieToHTML.element;
        tieToElement = document.getElementById(this.tieToHTML.element);
      }

      if (tieToElement) {
        var w = document.getElementById("".concat(elementId, "_webgl"));

        if (w != null) {
          // w.style.visibility = 'hidden';
          w.style.display = 'none';
        }

        var d = document.getElementById("".concat(elementId, "_2d"));

        if (d != null) {
          // d.style.visibility = 'hidden';
          d.style.display = 'none';
        }
      }
    }
  }, {
    key: "setRenderedOnNextDraw",
    value: function setRenderedOnNextDraw() {
      this.renderedOnNextDraw = true;
    }
  }, {
    key: "unrender",
    value: function unrender() {
      if (this.isRenderedAsImage) {
        this.unrenderNextDraw = true;
        this.isRenderedAsImage = false;
      }

      if (this.parent != null) {
        this.parent.unrender();
      }
    }
  }, {
    key: "showAll",
    value: function showAll() {
      this.show();
    }
    /**
     * Hide element
     */

  }, {
    key: "hide",
    value: function hide() {
      this.isShown = false;
      this.animateNextFrame();
    }
  }, {
    key: "hideAll",
    value: function hideAll() {
      this.hide();
    }
    /**
     * Toggle hide/show of element
     */

  }, {
    key: "toggleShow",
    value: function toggleShow() {
      if (this.isShown) {
        this.hide();
      } else {
        this.show();
      }
    } // eslint-disable-next-line no-unused-vars

  }, {
    key: "click",
    value: function click(glPoint) {
      if (this.onClick != null) {
        if (this.recorder.state === 'recording') {
          this.recorder.recordEvent('elementClick', [this.getPath()]);
        }

        this.fnMap.exec(this.onClick, this);
      }

      this.subscriptions.publish('onClick');
    } // setMovable(movable: boolean = true) {
    //   if (movable) {
    //     this.isTouchable = true;
    //     this.isMovable = true;
    //   }
    // }

    /**
     * Get current transform of element.
     * @return {Transform}
     */

  }, {
    key: "getTransform",
    value: function getTransform() {
      return this.transform;
    } // isAnimating(): boolean {
    //   // console.log(this.name, this.isShown, this.animations.isAnimating())
    //   if (this.isShown === false) {
    //     return false;
    //   }
    //   return this.animations.isAnimating();
    // }

    /**
     * @return {boolean} `true` if element is moving
     */

  }, {
    key: "isMoving",
    value: function isMoving() {
      if (this.isShown === false) {
        return false;
      }

      if (this.isAnimating()) {
        return true;
      }

      if (this.state.isBeingMoved) {
        return true;
      }

      return false;
    }
    /**
     * @return {boolean} `true` if element is animating
     */

  }, {
    key: "isAnimating",
    value: function isAnimating() {
      if (this.isShown === false) {
        return false;
      }

      if (this.state.isMovingFreely || this.state.isPulsing || this.animations.isAnimating()) {
        return true;
      }

      return false;
    } // isAnyElementAnimating() {
    //   return this.isAnimating();
    // }

  }, {
    key: "isAnyElementMoving",
    value: function isAnyElementMoving() {
      return this.isMoving();
    }
  }, {
    key: "isBeingTouched",
    value: function isBeingTouched(glLocation) {
      if (!this.isTouchable) {
        return false;
      } // if (this.drawingObject.touchBorder == null) {
      //   return false;
      // }


      var vertexLocation = glLocation.transformBy(this.spaceTransformMatrix('gl', 'draw'));
      var borders = this.getBorder('draw', 'touchBorder'); // if (this.touchInBoundingRect !== false) {
      //   let buffer = 0;
      //   if (typeof this.touchInBoundingRect === 'number') {
      //     buffer = this.touchInBoundingRect;
      //   }
      //   const boundingRect = getBoundingRect(borders, buffer);
      //   const {
      //     left, bottom, right, top,
      //   } = boundingRect;
      //   borders = [[
      //     new Point(left, bottom),
      //     new Point(right, bottom),
      //     new Point(right, top),
      //     new Point(left, top),
      //   ]];
      // }
      // console.log(this.name, this.parent)
      // console.log(vertexLocation)
      // console.log(borders)

      var holeBorders = this.getBorder('draw', 'holeBorder');

      for (var i = 0; i < borders.length; i += 1) {
        var border = borders[i];

        if (border.length > 2) {
          if (vertexLocation.isInPolygon(border)) {
            var isTouched = true; // $FlowFixMe

            if (this.cannotTouchHole) {
              for (var j = 0; j < holeBorders.length; j += 1) {
                var holeBorder = holeBorders[j];

                if (holeBorder.length > 2) {
                  if (Array.isArray(holeBorder) && holeBorder.length > 2) {
                    if (vertexLocation.isInPolygon(holeBorder)) {
                      isTouched = false;
                      j = holeBorders.length;
                    }
                  }
                }
              }
            }

            if (isTouched) {
              return true;
            }
          }
        }
      }

      return false;
    }
  }, {
    key: "getTouched",
    value: function getTouched(glLocation) {
      if (!this.isTouchable) {
        return [];
      }

      if (this.isBeingTouched(glLocation)) {
        return [this];
      }

      return [];
    }
  }]);

  return FigureElement;
}();
/*
..........########..########..####.##.....##
..........##.....##.##.....##..##..###...###
..........##.....##.##.....##..##..####.####
..........########..########...##..##.###.##
..........##........##...##....##..##.....##
..........##........##....##...##..##.....##
..........##........##.....##.####.##.....##
*/
// ***************************************************************
// Geometry Object
// ***************************************************************

/**
 * Primitive figure element
 *
 * A primitive figure element is one that handles an object (`drawingObject`)
 * that draws to the screen. This object may be a {@link VertexObject}, a
 * {@link TextObject} or a {@link {HTMLObject}}.
 *
 * @class
 * @extends FigureElement
 */


var FigureElementPrimitive = /*#__PURE__*/function (_FigureElement) {
  _inherits(FigureElementPrimitive, _FigureElement);

  var _super = _createSuper(FigureElementPrimitive);

  // color: TypeColor;
  // opacity: number;
  // +pulse: (?(mixed) => void) => void;

  /**
   * Primitive figure element.
   *
   * This type of element is responsible for drawing something
   * to the screen, or managing a HTML element in the DOM
   *
   * @param {DrawingObject} drawingObject an object that handles drawing
   * to the screen or manages a HTML element
   * @param {Transform} transform initial transform to set
   * @param {[number, number, number, number]} color color to set
   * @param {Rect} figureLimits limits of figure
   * @param {FigureElement | null} parent parent element
   * @param
   */
  function FigureElementPrimitive(drawingObject) {
    var _this8;

    var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
    var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0.5, 0.5, 0.5, 1];
    var figureLimits = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2);
    var parent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var name = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["generateUniqueId"])('element_');

    _classCallCheck(this, FigureElementPrimitive);

    _this8 = _super.call(this, transform, figureLimits, parent, name);
    _this8.drawingObject = drawingObject;
    _this8.color = color != null ? color.slice() : [0, 0, 0, 0];
    _this8.defaultColor = _this8.color.slice();
    _this8.dimColor = [0.5, 0.5, 0.5, 1];
    _this8.pointsToDraw = -1;
    _this8.angleToDraw = -1;
    _this8.lengthToDraw = -1;
    _this8.cannotTouchHole = false;
    _this8.type = 'primitive';
    _this8.pointsDefinition = {};
    _this8.setPointsFromDefinition = null;
    _this8.border = 'draw';
    _this8.touchBorder = 'draw';
    _this8.holeBorder = [[]]; // this.setMoveBounds();

    return _this8;
  }

  _createClass(FigureElementPrimitive, [{
    key: "_getStateProperties",
    value: function _getStateProperties(options) {
      var ignoreShown = options.ignoreShown;

      if (ignoreShown == null) {
        ignoreShown = false;
      }

      if (this.isShown || ignoreShown) {
        return [].concat(_toConsumableArray(_get(_getPrototypeOf(FigureElementPrimitive.prototype), "_getStateProperties", this).call(this, options)), ['pointsToDraw', 'angleToDraw', 'lengthToDraw', 'cannotTouchHole', 'drawingObject', 'pointsDefinition']);
      }

      return _get(_getPrototypeOf(FigureElementPrimitive.prototype), "_getStateProperties", this).call(this, options);
    }
    /**
     * Set angle to draw.
     *
     * Some primitive elements can be partially drawn to some angle.
     *
     * An angle of -1 represents the maximum angle allowed by the primitive.
     *
     * @param {number} angle Angle to draw
     */

  }, {
    key: "setAngleToDraw",
    value: function setAngleToDraw() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.angleToDraw = angle;
    } // setScenario(scenarioName: string) {
    //   super.setScenario(scenarioName);
    //   if (this.scenarios[scenarioName] != null) {
    //     const target = this.getScenarioTarget(scenarioName);
    //     if (target.color != null) {
    //       this.setColor(target.color.slice());
    //     }
    //   }
    // }

  }, {
    key: "click",
    value: function click(glPoint) {
      _get(_getPrototypeOf(FigureElementPrimitive.prototype), "click", this).call(this, glPoint);

      if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_8__["TextObjectBase"]) {
        this.drawingObject.click(glPoint.transformBy(this.spaceTransformMatrix('gl', 'draw')), // this.lastDrawTransform.matrix(),
        this.fnMap);

        if (this.recorder.state === 'recording') {
          this.recorder.recordEvent('elementTextClick', [this.getPath()]);
        }
      }
    } // updateContext(context: DrawContext2D) {
    //   if (this.drawingObject instanceof TextObject) {
    //     this.drawingObject.drawContext2D = context;
    //   }
    // }

  }, {
    key: "_dup",
    value: function _dup() {
      var transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // const vertices = this.drawingObject._dup();
      var primitive = new FigureElementPrimitive(this.drawingObject._dup()); // const primitive = new FigureElementPrimitive(
      //   vertices,
      //   transform,
      //   color,
      //   this.figureLimits._dup(),
      // );
      // primitive.pointsToDraw = this.pointsToDraw;
      // primitive.angleToDraw = this.angleToDraw;
      // primitive.copyFrom(this);

      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["duplicateFromTo"])(this, primitive, ['parent', 'figure', 'recorder', 'pulseDefault.centerOn']);

      if (transform != null) {
        primitive.transform = transform._dup();
      } // primitive.pulseDefault = {};
      // duplicateFromTo(primitive.pulseDefault, this.pulseDefault, ['centerOn']);


      if (typeof this.pulseDefault !== 'string' && typeof this.pulseDefault !== 'function') {
        // $FlowFixMe
        primitive.pulseDefault.centerOn = this.pulseDefault.centerOn;
      } else {
        primitive.pulseDefault = this.pulseDefault;
      }

      primitive.recorder = this.recorder;
      return primitive;
    }
  }, {
    key: "clear",
    value: function clear() {
      var canvasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_8__["TextObjectBase"]) {
        // $FlowFixMe
        this.drawingObject.clear(canvasIndex, this.pulseTransforms);
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      var figureHTMLElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.resizeHtmlObject();

      _get(_getPrototypeOf(FigureElementPrimitive.prototype), "resize", this).call(this, figureHTMLElement); // If gl canvas is resized, webgl text will need to be updated.


      if (this.drawingObject.type === 'vertexText') {
        var pixelToVertexScale = this.getPixelToVertexSpaceScale(); // $FlowFixMe

        this.drawingObject.drawTextIntoBuffer(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](pixelToVertexScale.x, Math.abs(pixelToVertexScale.y)));
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      var setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.color = color != null ? color.slice() : [0, 0, 0, 0];

      if (setDefault) {
        this.defaultColor = this.color.slice();
      }

      if (this instanceof FigureElementPrimitive) {
        if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_8__["TextObjectBase"]) {
          this.drawingObject.setColor(this.color);
        }

        if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
          // $FlowFixMe
          this.drawingObject.element.style.color = Object(_tools_color__WEBPACK_IMPORTED_MODULE_10__["colorArrayToRGBA"])(this.color);
        }
      }
    }
  }, {
    key: "setOpacity",
    value: function setOpacity(opacity) {
      // this.color[3] = opacity;
      this.opacity = opacity;

      if (this instanceof FigureElementPrimitive) {
        if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_8__["TextObjectBase"]) {
          this.drawingObject.setOpacity(opacity);
        }

        if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
          // this.drawingObject.element.style.color =
          // colorArrayToRGBA([...this.color.slice(0, 2), opacity]);
          // console.log(this.drawingObject.element)
          this.drawingObject.element.style.opacity = "".concat(opacity);
        }
      }

      this.animateNextFrame();
    }
  }, {
    key: "show",
    value: function show() {
      _get(_getPrototypeOf(FigureElementPrimitive.prototype), "show", this).call(this);

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
        this.drawingObject.show = true; // This line is a challenge.
        // It will show a html element immediately before the next draw frame
        // meaning the draw matrix will be old.
        // If this line is removed, it causes a blanking between lesson pages
        // for html elements that are always on screen
        // Therefore, should use figure.setFirstTransform before using this,
        // or in the future remove this line, and the line in hide(), and
        // somehow do the hide in the draw call

        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    } // showAll() {
    //   this.show();
    // }

  }, {
    key: "hide",
    value: function hide() {
      _get(_getPrototypeOf(FigureElementPrimitive.prototype), "hide", this).call(this);

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
        this.drawingObject.show = false;
        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    } // hideAll() {
    //   this.hide();
    // }
    // getBorder(
    //   space: TypeSpace | Array<number> = 'local',
    //   border: 'touchBorder' | 'border' | 'holeBorder' = 'border',
    // ) {
    //   let bordersToUse = this.drawingObject.border;
    //   // if (border === 'border') {
    //   //   if (this.border !== 'draw') {
    //   //     bordersToUse = this.border;
    //   // } else if (border === 'touchBorder') {
    //   // }
    //   if (border === 'touchBorder') {
    //     bordersToUse = this.drawingObject.touchBorder;
    //   }
    //   if (border === 'holeBorder') {
    //     bordersToUse = this.drawingObject.hole;
    //   }
    //   if (space === 'draw') {
    //     return bordersToUse;
    //   }
    //   const transformedBorders = [];
    //   let matrix;
    //   if (Array.isArray(space)) {
    //     matrix = m2.mul(space, this.getTransform().matrix());
    //   } else {
    //     matrix = this.spaceTransformMatrix('draw', space);
    //   }
    //   bordersToUse.forEach((b) => {
    //     transformedBorders.push(
    //       b.map(p => p.transformBy(matrix)),
    //     );
    //   });
    //   return transformedBorders;
    // }

  }, {
    key: "setFont",
    value: function setFont(font) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (this.drawingObject instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_8__["TextObjectBase"]) {
        this.drawingObject.setFont(font, index);
      }
    }
  }, {
    key: "resizeHtmlObject",
    value: function resizeHtmlObject() {
      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
        this.drawingObject.transformHtml(this.lastDrawTransform.matrix());
      }
    }
  }, {
    key: "getBorderPoints",
    value: function getBorderPoints() {
      var border = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'border';

      if (border === 'border') {
        if (this.border === 'draw') {
          return this.drawBorder;
        }

        if (this.border === 'buffer') {
          return this.drawBorderBuffer;
        }

        if (this.border === 'rect') {
          return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(this.drawBorder)];
        }

        if (Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["isBuffer"])(this.border)) {
          // if (typeof this.border === 'number') {
          // $FlowFixMe
          return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(this.drawBorder, this.border)];
        } // $FlowFixMe


        return this.border;
      }

      if (border === 'touchBorder') {
        if (this.touchBorder === 'draw') {
          return this.drawBorder;
        }

        if (this.touchBorder === 'buffer') {
          return this.drawBorderBuffer;
        }

        if (this.touchBorder === 'border') {
          return this.getBorderPoints('border');
        }

        if (this.touchBorder === 'rect') {
          var b = this.getBorderPoints('border');
          return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(b)];
        } // if (typeof this.touchBorder === 'number') {


        if (Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["isBuffer"])(this.touchBorder)) {
          var _b = this.getBorderPoints('border'); // $FlowFixMe


          return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(_b, this.touchBorder)];
        } // $FlowFixMe


        return this.touchBorder;
      }

      return this.holeBorder;
    }
  }, {
    key: "setupDraw",
    value: function setupDraw() {
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.isShown) {
        this.lastDrawTime = now;

        if (this.isRenderedAsImage === true) {
          if (this.willStartAnimating()) {
            this.unrender();
          } else {
            return;
          }
        }

        this.subscriptions.publish('beforeDraw', [now]);

        if (this.beforeDrawCallback != null) {
          this.fnMap.exec(this.beforeDrawCallback, now);
        }

        this.animations.nextFrame(now);
        this.nextMovingFreelyFrame(now);
      }
    }
  }, {
    key: "draw",
    value: function draw(now) {
      var _this9 = this;

      var parentTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]()];
      var parentOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var canvasIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (this.isShown) {
        var ttt = performance.now();
        var pointCount = -1;

        if (this.drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_7__["default"]) {
          pointCount = this.drawingObject.numPoints;

          if (this.angleToDraw !== -1) {
            pointCount = this.drawingObject.getPointCountForAngle(this.angleToDraw);
          }

          if (this.lengthToDraw !== -1) {
            pointCount = this.drawingObject.getPointCountForLength(this.lengthToDraw);
          }

          if (this.pointsToDraw !== -1) {
            pointCount = this.pointsToDraw;
          }
        } else {
          pointCount = 1;
        }

        var colorToUse = [].concat(_toConsumableArray(this.color.slice(0, 3)), [this.color[3] * this.opacity * parentOpacity]); // eslint-disable-next-line prefer-destructuring

        this.lastDrawOpacity = colorToUse[3]; // if (this.getPath().endsWith('eqn.elements._1')) {
        // console.log(this.getPath(), this.opacity, colorToUse);
        // colorToUse = [1, 0, 0, 1];
        // }

        var transform = this.getTransform();
        var newTransforms = transformBy(parentTransform, [transform]);
        this.lastDrawElementTransformPosition = {
          parentCount: parentTransform[0].order.length,
          elementCount: this.transform.order.length
        }; // const newTransform = parentTransform.transform(this.getTransform());
        // this.parentTransform = parentTransform._dup();
        // const newTransform = parentTransform.transform(this.getTransform());

        this.pulseTransforms = this.getPulseTransforms(now);
        this.drawTransforms = this.getDrawTransforms(newTransforms);
        this.lastDrawTransform = parentTransform[0].transform(transform)._dup(); // eslint-disable-next-line prefer-destructuring

        this.lastDrawPulseTransform = this.drawTransforms[0];

        if (pointCount > 0) {
          // console.log(this.pulseTransforms, pointCount)
          this.drawTransforms.forEach(function (t) {
            // let t = t2;
            // console.log(t.matrix().slice(), t._dup().matrix().slice())
            // const m = t._dup().matrix();
            // if (this.getPath() === 'circle.line1.line') {
            //   // colorToUse = [1, 0, 0, 1];
            //   // t = t2._dup();
            //   console.log(t.matrix().slice(), t._dup().matrix().slice())
            // }
            // console.log(t.matrix(), colorToUse, canvasIndex, pointCount)
            _this9.drawingObject.drawWithTransformMatrix( // m, colorToUse, canvasIndex, pointCount,
            t.matrix(), colorToUse, canvasIndex, pointCount); // window.asdf = false;

          });
        }

        if (this.unrenderNextDraw) {
          this.clearRender();
          this.unrenderNextDraw = false;
        }

        if (this.renderedOnNextDraw) {
          this.isRenderedAsImage = true;
          this.renderedOnNextDraw = false;
        } // this.redrawElements.forEach((element) => {
        //   element.draw(element.getParentLastDrawTransform(), now);
        // })


        this.subscriptions.publish('afterDrawDraw', [now]);

        if (this.afterDrawCallback != null) {
          this.fnMap.exec(this.afterDrawCallback, now);
        }

        window.timeData.push([this.name, Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(performance.now() - ttt, 2)]);
      }
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      this.lastDrawElementTransformPosition = {
        parentCount: parentTransform.order.length,
        elementCount: this.transform.order.length
      }; // const finalParentTransform = this.processParentTransform(parentTransform);

      var firstTransform = parentTransform.transform(this.getTransform());
      this.lastDrawTransform = firstTransform._dup();

      if (this.drawingObject instanceof _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_5__["default"]) {
        this.drawingObject.transformHtml(firstTransform.matrix());
      } // this.setMoveBounds();


      this.checkMoveBounds();
    }
  }, {
    key: "increaseBorderSize",
    value: function increaseBorderSize() {
      var xMultiplierOrPoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var yMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var xMulToUse;
      var yMulToUse;

      if (xMultiplierOrPoint instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        xMulToUse = xMultiplierOrPoint.x;
        yMulToUse = xMultiplierOrPoint.y;
      } else {
        xMulToUse = xMultiplierOrPoint;

        if (yMultiplier == null) {
          yMulToUse = xMulToUse;
        } else {
          yMulToUse = yMultiplier;
        }
      }

      if (this.drawingObject instanceof _DrawingObjects_VertexObject_VertexObject__WEBPACK_IMPORTED_MODULE_7__["default"]) {
        for (var b = 0; b < this.drawingObject.border.length; b += 1) {
          var border = this.drawingObject.border[b];

          for (var i = 0; i < border.length; i += 1) {
            border[i].x *= xMulToUse;
            border[i].y *= yMulToUse;
          }
        }
      }
    }
  }]);

  return FigureElementPrimitive;
}(FigureElement);
/*
...........######...#######..##.......##......
..........##....##.##.....##.##.......##......
..........##.......##.....##.##.......##......
..........##.......##.....##.##.......##......
..........##.......##.....##.##.......##......
..........##....##.##.....##.##.......##......
...........######...#######..########.########
*/
// ***************************************************************
// Collection of Geometry Objects or Collections
// ***************************************************************

/**
 * {@link FigureElementCollection} options object.
 * @property {TypeParsableTransform} [transform]
 * @property {TypeParsablePoint} [position] if defined, will overwrite first
 * translation of `transform`
 * @property {Rect} [limits] figure limits
 * @property {TypeColor} [color] default color
 * @property {FigureElement | null} [parent] parent of collection
 * @property {TypeBorder | 'children' | 'rect' | number} [border]
 * @property {TypeBorder | 'border' | number | 'rect'} [touchBorder]
 * @property {TypeBorder} [holeBorder]
 */


/**
 * Collection figure element
 *
 * A collection manages a number of children {@link FigureElements}, be they
 * primitives or collections.
 *
 * A collection's transform will be passed onto all the children elements.
 *
 * @class
 * @extends FigureElement
 */
var FigureElementCollection = /*#__PURE__*/function (_FigureElement2) {
  _inherits(FigureElementCollection, _FigureElement2);

  var _super2 = _createSuper(FigureElementCollection);

  // touchInBoundingRect: boolean;
  // $FlowFixMe
  // border is whatever border is
  // children is touch borders of children
  // rect is rect of children touchBorder
  // number is buffer of rect of children touch border
  // $FlowFixMe
  // +pulse: (?({
  //     x?: 'left' | 'center' | 'right' | 'origin' | number,
  //     y?: 'bottom' | 'middle' | 'top' | 'origin' | number,
  //     space?: TypeSpace,
  //     centerOn?: null | FigureElement | TypeParsablePoint,
  //     frequency?: number,
  //     time?: number,
  //     scale?: number,
  //     done?: ?(mixed) => void,
  //     elements?: Array<string | FigureElement>
  //   } | Array<string | FigureElement> | ((mixed) => void)), ?(mixed) => void) => void;
  // primitives: FigurePrimitives;

  /**
   * @param {OBJ_FigureElementCollection} options
   */
  function FigureElementCollection() {
    var _this10;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FigureElementCollection);

    var defaultOptions = {
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](),
      // position: [0, 0],
      limits: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, 1, 2, 2),
      parent: null,
      border: 'children',
      touchBorder: 'children',
      holeBorder: [[]],
      color: [0, 0, 0, 1],
      name: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["generateUniqueId"])('collection_')
    };
    var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, defaultOptions, options); // console.log(o)

    _this10 = _super2.call(this, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(o.transform), o.limits, o.parent, o.name);

    if (o.position != null) {
      _this10.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.position));
    }

    _this10.elements = {};
    _this10.drawOrder = []; // this.touchInBoundingRect = false;

    _this10.eqns = {};
    _this10.type = 'collection'; // this.border = o.border;
    // this.touchBorder = o.touchBorder;
    // this.holeBorder = o.holeBorder;

    _this10.setColor(o.color); // if (transformOrPointOrOptions instanceof Point) {
    //   defaultOptions.transform.updateTranslation(transformOrPointOrOptions);
    //   optionsToUse = joinObjects({}, defaultOptions, ...moreOptions);
    // } else if (transformOrPointOrOptions instanceof Transform) {
    //   defaultOptions.transform = transformOrPointOrOptions._dup();
    //   optionsToUse = joinObjects({}, defaultOptions, ...moreOptions);
    // } else {
    //   optionsToUse = joinObjects({}, defaultOptions, transformOrPointOrOptions, ...moreOptions);
    // }


    if (o.border != null) {
      if (!Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["isBuffer"])(o.border)) {
        // $FlowFixMe
        _this10.border = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.border);
      } else {
        _this10.border = o.border;
      }
    }

    if (o.touchBorder != null) {
      if (!Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["isBuffer"])(o.touchBorder)) {
        // $FlowFixMe
        _this10.touchBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.touchBorder);
      } else {
        _this10.touchBorder = o.touchBorder;
      }
    }

    if (o.holeBorder != null) {
      // $FlowFixMe
      _this10.holeBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.holeBorder);
    }

    return _this10;
  }

  _createClass(FigureElementCollection, [{
    key: "_getStateProperties",
    value: function _getStateProperties(options) {
      var ignoreShown = options.ignoreShown;

      if (ignoreShown == null) {
        ignoreShown = false;
      }

      if (this.isShown || ignoreShown) {
        return [].concat(_toConsumableArray(_get(_getPrototypeOf(FigureElementCollection.prototype), "_getStateProperties", this).call(this, options)), [// 'touchInBoundingRect',
        'elements', 'hasTouchableElements']);
      }

      return [].concat(_toConsumableArray(_get(_getPrototypeOf(FigureElementCollection.prototype), "_getStateProperties", this).call(this, options)), ['elements']);
    }
  }, {
    key: "_getStatePropertiesMin",
    value: function _getStatePropertiesMin() {
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(FigureElementCollection.prototype), "_getStatePropertiesMin", this).call(this)), ['elements']);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var exceptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var collection = new FigureElementCollection({}); // collection.touchInBoundingRect = this.touchInBoundingRect;
      // collection.copyFrom(this);

      var doNotDuplicate = this.drawOrder.map(function (e) {
        return "_".concat(e);
      });
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["duplicateFromTo"])(this, collection, ['elements', 'drawOrder', 'parent', 'recorder', 'figure', 'collections', 'pulseDefault.centerOn'].concat(_toConsumableArray(doNotDuplicate), _toConsumableArray(exceptions)));

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var _name = this.drawOrder[i];
        collection.add(_name, this.elements[_name]._dup());
      }

      collection.recorder = this.recorder; // collection.pulseDefault = {};
      // duplicateFromTo(collection.pulseDefault, this.pulseDefault, ['centerOn']);

      if (typeof this.pulseDefault !== 'string' && typeof this.pulseDefault !== 'function') {
        // $FlowFixMe
        collection.pulseDefault.centerOn = this.pulseDefault.centerOn;
      } else {
        collection.pulseDefault = this.pulseDefault;
      }

      return collection;
    }
    /**
     * Move child elements to end of draw order - effectively moving to the start
     * of the drawn collection. Later elements in the array will be further forward.
     * @param {Array<string | FigureElement> | string | FigureElement} elements
     */

  }, {
    key: "toFront",
    value: function toFront(elementsIn) {
      var elements = elementsIn;

      if (!Array.isArray(elementsIn) || typeof elementsIn === 'string') {
        elements = [elementsIn];
      }

      var names = []; // $FlowFixMe

      elements.forEach(function (element) {
        if (typeof element === 'string') {
          names.push(element);
        } else {
          names.push(element.name);
        }
      });
      var newOrder = [];
      this.drawOrder.forEach(function (element) {
        if (names.indexOf(element) === -1) {
          newOrder.push(element);
        }
      });
      this.drawOrder = [].concat(newOrder, names);
    }
    /**
     * Move child elements to start of draw order - effectively moving them to
     * the back of the drawn collection. Later elements in the `elements` array
     * will be drawn further back.
     * @param {Array<string | FigureElement> | string | FigureElement} elements
     */

  }, {
    key: "toBack",
    value: function toBack(elementsIn) {
      var elements = elementsIn;

      if (typeof elementsIn === 'string' || !Array.isArray(elementsIn)) {
        elements = [elementsIn];
      }

      var names = []; // $FlowFixMe

      elements.forEach(function (element) {
        if (typeof element === 'string') {
          names.push(element);
        } else {
          names.push(element.name);
        }
      });
      var newOrder = [];
      this.drawOrder.forEach(function (element) {
        if (names.indexOf(element) === -1) {
          newOrder.push(element);
        }
      });
      this.drawOrder = [].concat(_toConsumableArray(names.reverse()), newOrder);
    }
  }, {
    key: "isAnyElementMoving",
    value: function isAnyElementMoving() {
      if (this.isShown === false) {
        return false;
      }

      if (this.isMoving()) {
        return true;
      }

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isAnyElementMoving()) {
          return true;
        }
      }

      return false;
    }
    /**
     * Add a figure element to the collection.
     *
     * @param {string} name reference name of element
     * @param {FigureElement} element element to add
     * @param {number} index index to add in the `drawOrder` where -1 appends the
     * element to the end of the draw order,
     */

  }, {
    key: "addLegacy",
    value: function addLegacy(name, element) {
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      // eslint-disable-next-line no-param-reassign
      element.parent = this;
      this.elements[name] = element;
      this.elements[name].name = name; // $FlowFixMe

      this["_".concat(name)] = this.elements[name];

      if (index !== -1) {
        this.drawOrder = [].concat(_toConsumableArray(this.drawOrder.slice(0, index)), [name], _toConsumableArray(this.drawOrder.slice(index)));
      } else {
        this.drawOrder.push(name);
      }

      if (this.figure != null) {
        element.setFigure(this.figure);
      }

      element.setFirstTransform(this.lastDrawTransform);
      this.animateNextFrame();
    }
  }, {
    key: "addElementWithName",
    value: function addElementWithName(name, element) {
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      // eslint-disable-next-line no-param-reassign
      element.parent = this;
      this.elements[name] = element;
      this.elements[name].name = name; // $FlowFixMe

      this["_".concat(name)] = this.elements[name];

      if (index !== -1) {
        this.drawOrder = [].concat(_toConsumableArray(this.drawOrder.slice(0, index)), [name], _toConsumableArray(this.drawOrder.slice(index)));
      } else {
        this.drawOrder.push(name);
      }

      if (this.figure != null) {
        element.setFigure(this.figure);
      }

      element.setFirstTransform(this.lastDrawTransform);
      this.animateNextFrame();
    }
    /**
     * Add a figure element to the collection.
     *
     * @param {string} name reference name of element
     * @param {FigureElement} element element to add
     * @param {number} index index to add in the `drawOrder` where -1 appends the
     * element to the end of the draw order,
     */

  }, {
    key: "add",
    value: function add(nameOrElementOrElementDefinition, elementToAdd) {
      var _this11 = this;

      if (typeof nameOrElementOrElementDefinition === 'string') {
        this.addElementWithName(nameOrElementOrElementDefinition, elementToAdd);
        return;
      }

      var elements;

      if (!Array.isArray(nameOrElementOrElementDefinition)) {
        elements = [nameOrElementOrElementDefinition];
      } else {
        elements = nameOrElementOrElementDefinition;
      }

      var rootCollection = this;
      elements.forEach(function (elementDefinition, index) {
        if (elementDefinition instanceof FigureElement) {
          _this11.add(elementDefinition.name, elementDefinition);

          return;
        } // Extract the parameters from the layout object


        if (elementDefinition == null) {
          throw Error("Add elements index ".concat(index, " does not exist in layout"));
        }

        var addElementsKey = 'elements';
        var nameToUse = elementDefinition.name;
        var pathToUse = elementDefinition.path;
        var optionsToUse = elementDefinition.options;
        var addElementsToUse = elementDefinition[addElementsKey];
        var methodPathToUse = elementDefinition.method;
        var elementModsToUse = elementDefinition.mods;
        var firstScenario = elementDefinition.scenario;
        var collectionPath;

        if (pathToUse == null || pathToUse === '') {
          collectionPath = rootCollection;
        } else {
          collectionPath = rootCollection.getElement(pathToUse);
        } // Check for critical errors


        if (nameToUse == null || nameToUse === '') {
          // $FlowFixMe
          throw new Error("Figure addElement ERROR  at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing name property in ").concat(elementDefinition));
        }

        if (methodPathToUse == null || methodPathToUse === '') {
          // $FlowFixMe
          throw new Error("Figure addElement ERROR  at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing method property in ").concat(elementDefinition));
        }

        if (!(collectionPath instanceof FigureElementCollection)) {
          // $FlowFixMe
          throw new Error("Figure addElement ERROR at index ".concat(index, " in collection ").concat(rootCollection.name, ": missing or incorrect path property in ").concat(elementDefinition));
        }

        var methodPath = methodPathToUse.split('/');

        var method = _this11.getMethod(methodPathToUse);

        if (typeof method !== 'function') {
          return;
        }

        if (typeof method !== 'function') {
          throw new Error("Layout addElement at index ".concat(index, " in collection ").concat(rootCollection.name, ": incorrect method property"));
        }

        var newElement;

        if (methodPath.slice(-1)[0].startsWith('add')) {
          newElement = method(collectionPath, nameToUse, optionsToUse);

          if (newElement == null) {
            return;
          }

          if (elementModsToUse != null && elementModsToUse !== {}) {
            newElement.setProperties(elementModsToUse);
          }
        } else {
          if (Array.isArray(optionsToUse)) {
            newElement = method.apply(void 0, _toConsumableArray(optionsToUse));
          } else {
            newElement = method(optionsToUse);
          }

          if (newElement == null) {
            return;
          }

          if (elementModsToUse != null && elementModsToUse !== {}) {
            newElement.setProperties(elementModsToUse);
          }

          if (collectionPath instanceof FigureElementCollection) {
            collectionPath.add(nameToUse, newElement);
          }
        } // element.setProperties(elementDefinition, [
        //   'mods', 'name', 'method', 'scenario', 'addElementsKey', 'options', 'path',
        // ]);


        if (firstScenario != null && firstScenario in newElement.scenarios) {
          newElement.setScenario(firstScenario);
        }

        if ("_".concat(nameToUse) in rootCollection && addElementsToUse != null && addElementsToUse !== {}) {
          newElement.add(addElementsToUse);
        }
      });
    }
  }, {
    key: "getMethod",
    value: function getMethod(method) {
      var getPath = function getPath(e, remainingPath) {
        if (!(remainingPath[0] in e)) {
          return null;
        }

        if (remainingPath.length === 1) {
          // $FlowFixMe
          return e[remainingPath[0]];
        } // $FlowFixMe


        return getPath(e[remainingPath[0]], remainingPath.slice(1));
      };

      var collections = this.collections;
      var shapes = collections.primitives;
      var methods = {
        collection: collections.collection.bind(collections),
        polyline: shapes.polyline.bind(shapes),
        polygon: shapes.polygon.bind(shapes),
        rectangle: shapes.rectangle.bind(shapes),
        ellipse: shapes.ellipse.bind(shapes),
        triangle: shapes.triangle.bind(shapes),
        generic: shapes.generic.bind(shapes),
        grid: shapes.grid.bind(shapes),
        arrow: shapes.arrow.bind(shapes),
        line: shapes.line.bind(shapes),
        star: shapes.star.bind(shapes),
        //
        text: shapes.text.bind(shapes),
        textLine: shapes.textLine.bind(shapes),
        textLines: shapes.textLines.bind(shapes),
        'text.line': shapes.textLine.bind(shapes),
        'text.lines': shapes.textLines.bind(shapes),
        //
        textGL: shapes.textGL.bind(shapes),
        textHTML: shapes.htmlText.bind(shapes),
        htmlImage: shapes.htmlImage.bind(shapes),
        //
        opolyline: collections.polyline.bind(collections),
        oline: collections.line.bind(collections),
        angle: collections.angle.bind(collections),
        //
        addEquation: collections.addEquation.bind(collections),
        equation: collections.equation.bind(collections),
        addNavigator: collections.addNavigator.bind(collections)
      };

      if (method in methods) {
        return methods[method];
      }

      var figure = {
        primitives: shapes,
        shapes: shapes,
        collections: collections
      };
      var splitMethod = method.split('.');
      var methodToUse = getPath(figure, splitMethod);

      if (methodToUse == null) {
        return null;
      }

      methodToUse = methodToUse.bind(getPath(figure, splitMethod.slice(0, -1)));
      return methodToUse;
    }
  }, {
    key: "setFigure",
    value: function setFigure(figure) {
      _get(_getPrototypeOf(FigureElementCollection.prototype), "setFigure", this).call(this, figure);

      if (this.onAdd != null) {
        this.fnMap.exec(this.onAdd);
      }

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setFigure(figure);

        if (element.onAdd != null) {
          this.fnMap.exec(element.onAdd);
        }
      }
    }
  }, {
    key: "willStartAnimating",
    value: function willStartAnimating() {
      var result = _get(_getPrototypeOf(FigureElementCollection.prototype), "willStartAnimating", this).call(this);

      if (result) {
        return true;
      }

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        if (this.elements[this.drawOrder[i]].willStartAnimating()) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "setupDraw",
    value: function setupDraw() {
      var now = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var canvasIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      // console.log('draw', this.name)
      if (this.isShown) {
        this.lastDrawTime = now; // if (this.pulseSettings.clearFrozenTransforms) {
        //   this.frozenPulseTransforms = [];
        //   this.pulseSettings.clearFrozenTransforms = false;
        // }

        if (this.isRenderedAsImage === true) {
          if (this.willStartAnimating()) {
            this.unrender();
          } else {
            return;
          }
        }

        if (this.beforeDrawCallback != null) {
          this.fnMap.exec(this.beforeDrawCallback, now);
        } // console.l^ *consoleog(this.name, now);


        this.animations.nextFrame(now);
        this.nextMovingFreelyFrame(now); // set next color can end up hiding an element when disolving out

        if (!this.isShown) {
          return;
        } // this.lastDrawElementTransformPosition = {
        //   parentCount: parentTransform.order.length,
        //   elementCount: this.transform.order.length,
        // };
        // const newTransform = parentTransform.transform(this.getTransform());
        // this.lastDrawTransform = newTransform._dup();
        // this.pulseTransforms = this.getPulseTransforms(now);
        // this.drawTransforms = this.getDrawTransforms(newTransform);
        // // this.pulseTransforms
        // // eslint-disable-next-line prefer-destructuring
        // this.lastDrawPulseTransform = this.drawTransforms[0];
        // this.lastDrawTransform = pulseTransforms[0];
        // this.lastDrawPulseTransform = pulseTransforms[0]._dup();
        // for (let k = 0; k < this.drawTransforms.length; k += 1) {


        for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
          this.elements[this.drawOrder[i]].setupDraw(now, canvasIndex);
        } // }
        // if (this.unrenderNextDraw) {
        //   this.clearRender();
        //   this.unrenderNextDraw = false;
        // }
        // if (this.renderedOnNextDraw) {
        //   this.isRenderedAsImage = true;
        //   this.renderedOnNextDraw = false;
        // }
        // // this.redrawElements.forEach((element) => {
        // //   element.draw(element.getParentLastDrawTransform(), now);
        // // })
        // if (this.afterDrawCallback != null) {
        //   // this.afterDrawCallback(now);
        //   this.fnMap.exec(this.afterDrawCallback, now);
        // }

      }
    }
  }, {
    key: "draw",
    value: function draw(now) {
      var parentTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]()];
      var parentOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var canvasIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (this.isShown) {
        var ttt = performance.now(); // if (this.name === 'eqn') {
        //   console.log('start eqn')
        // }
        // for (let k = 0; k < this.pulseTransforms.length; k += 1) {

        this.lastDrawElementTransformPosition = {
          parentCount: parentTransform[0].order.length,
          elementCount: this.transform.order.length
        };
        var transform = this.getTransform();
        var newTransforms = transformBy(parentTransform, [transform]); // this.lastDrawTransform = transform._dup();

        this.lastDrawTransform = parentTransform[0].transform(transform)._dup();
        this.pulseTransforms = this.getPulseTransforms(now);
        this.drawTransforms = this.getDrawTransforms(newTransforms); // this.pulseTransforms
        // eslint-disable-next-line prefer-destructuring

        this.lastDrawPulseTransform = this.drawTransforms[0];
        var opacityToUse = this.color[3] * this.opacity * parentOpacity;
        this.lastDrawOpacity = opacityToUse; // console.log()
        // let cum = performance.now() - ttt;
        // console.log('cum start', round(cum, 2))

        var ttt1 = performance.now();
        var tArray = [];

        for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
          var tttt = performance.now();
          this.elements[this.drawOrder[i]].draw(now, this.drawTransforms, opacityToUse, canvasIndex);
          tArray.push([this.elements[this.drawOrder[i]].name, performance.now() - tttt]); // const delta = performance.now() - tttt;
          // cum += delta;
          // console.log('---', this.elements[this.drawOrder[i]].name, round(delta, 2))
        }

        var ttt2 = performance.now(); // console.log(round(performance.now() - ttt, 2), round(cum, 2))
        // }

        if (this.unrenderNextDraw) {
          this.clearRender();
          this.unrenderNextDraw = false;
        }

        if (this.renderedOnNextDraw) {
          this.isRenderedAsImage = true;
          this.renderedOnNextDraw = false;
        } // this.redrawElements.forEach((element) => {
        //   element.draw(element.getParentLastDrawTransform(), now);
        // })


        if (this.afterDrawCallback != null) {
          // this.afterDrawCallback(now);
          this.fnMap.exec(this.afterDrawCallback, now);
        } // console.log('>>', this.name, round(performance.now() - ttt, 2),
        //   round(ttt1 - ttt, 2), round(ttt2 - ttt1, 2), round(performance.now() - ttt2, 2), tArray
        // )


        window.timeData.push(['>>', this.name, Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(performance.now() - ttt, 2), Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(ttt1 - ttt, 2), Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(ttt2 - ttt1, 2), Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(performance.now() - ttt2, 2), tArray]);
      }
    }
  }, {
    key: "exec",
    value: function exec(execFunctionAndArgs) {
      var _this12 = this;

      var elementsToExec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (elementsToExec == null) {
        _get(_getPrototypeOf(FigureElementCollection.prototype), "exec", this).call(this, execFunctionAndArgs);

        return;
      }

      if (Array.isArray(elementsToExec) && elementsToExec.length === 0) {
        return;
      }

      elementsToExec.forEach(function (elementToExec) {
        var element;

        if (typeof elementToExec === 'string') {
          element = _this12.getElement(elementToExec);
        } else {
          element = elementToExec;
        }

        if (element != null) {
          element.exec(execFunctionAndArgs);
        }
      });
    }
  }, {
    key: "pulse",
    value: function pulse() {
      var _this13 = this;

      var optionsOrElementsOrDone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (optionsOrElementsOrDone == null || typeof optionsOrElementsOrDone === 'function' || typeof optionsOrElementsOrDone === 'string') {
        _get(_getPrototypeOf(FigureElementCollection.prototype), "pulse", this).call(this, optionsOrElementsOrDone);

        return;
      }

      if (!Array.isArray(optionsOrElementsOrDone) && optionsOrElementsOrDone.centerOn != null && typeof optionsOrElementsOrDone.centerOn === 'string') {
        var e = this.getElement(optionsOrElementsOrDone.centerOn);

        if (e != null) {
          // eslint-disable-next-line no-param-reassign
          optionsOrElementsOrDone.centerOn = e;
        }
      }

      if (!Array.isArray(optionsOrElementsOrDone) && (optionsOrElementsOrDone.elements == null || optionsOrElementsOrDone.elements.length === 0)) {
        _get(_getPrototypeOf(FigureElementCollection.prototype), "pulse", this).call(this, optionsOrElementsOrDone);

        return;
      } // const defaultOptions = this.pulseDefault;


      var doneToUse;
      var options;
      var elements;

      if (Array.isArray(optionsOrElementsOrDone)) {
        options = {};
        doneToUse = done;
        elements = optionsOrElementsOrDone;
      } else {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_9__["joinObjects"])({}, optionsOrElementsOrDone);
        var _options5 = options;
        elements = _options5.elements;
        doneToUse = options.done;

        if (optionsOrElementsOrDone.scale == null) {
          options.scale = undefined;
        }

        if (optionsOrElementsOrDone.frequency == null) {
          options.frequency = undefined;
        }

        if (optionsOrElementsOrDone.duration == null) {
          options.duration = undefined;
        }
      }

      options.elements = null; // if (elements == null || elements.length === 0) {
      //   super.pulse(optionsOrElementsOrDone);
      //   return;
      // }

      var counter = 0;

      var combinedCallback = function combinedCallback() {
        counter += 1;

        if (counter === elements.length) {
          if (doneToUse != null) {
            doneToUse();
          }
        }
      }; // $FlowFixMe


      options.done = combinedCallback; // let doneToUse = done;

      elements.forEach(function (elementToPulse) {
        var element;

        if (typeof elementToPulse === 'string') {
          element = _this13.getElement(elementToPulse);
        } else {
          element = elementToPulse;
        }

        if (element != null) {
          // element.pulseDefault(doneToUse);
          element.pulse(options); // doneToUse = null;
        }
      }); // if (doneToUse != null) {
      //   doneToUse();
      // }
      // if (typeof this.pulseDefault === 'function') {
      //   this.pulseDefault(done);
      // } else {
      //   // const { frequency, time, scale } = this.pulseDefault;
      //   // this.pulseScaleNow(time, scale, frequency, done);
      //   this.pulseScaleRelativeTo(
      //     options.centeredOn,
      //     options.x,
      //     options.y,
      //     options.space,
      //     options.time,
      //     options.scale,
      //     options.frequency,
      //     done,
      //   );
      // }
    }
    /**
     * Get element from an element path with '.' separators.
     *
     * For instance, if a collection has a child collection 'a', which
     * has a child primitive 'b', then the path would be: 'a.b'.
     *
     * @see <a href="#figureelementcollectiongetelement">element.getElement</a>
     *
     * @param {null | string} elementPath
     * @return {FigureElement | null } element at path. If `elementPath`
     * is `null`, then this element is returned. If `elementPath` is invalid
     * then `null` is returned.
     *
     * @example
     * // Get all the elements from a figure
     * figure.add(
     *   {
     *     name: 'c',
     *     method: 'collection',
     *     elements: [
     *       {
     *         name: 'tri',
     *         method: 'triangle',
     *         options: {
     *           height: 0.4,
     *           width: 0.4,
     *         },
     *       },
     *       {
     *         name: 'text',
     *         method: 'text',
     *         options: {
     *           text: 'triangle',
     *           position: [0, -0.4],
     *           xAlign: 'center',
     *         },
     *       },
     *     ],
     *   },
     * );
     *
     * const c = figure.getElement('c');
     * // Elements within collections can be found with dot notation
     * const tri = figure.getElement('c.tri');
     * // Or the collection can be queried directly
     * const text = c.getElement('text');
     */

  }, {
    key: "getElement",
    value: function getElement() {
      var elementPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (elementPath == null) {
        return this;
      }

      if (typeof elementPath !== 'string') {
        return elementPath;
      }

      if (elementPath instanceof FigureElement) {
        return elementPath;
      }

      var getElement = function getElement(inputElementPath, parent) {
        var ep = inputElementPath.split('.');
        var newParent = parent.elements[ep[0]];

        if (newParent == null) {
          // $FlowFixMe
          newParent = parent[ep[0]];
        }

        if (newParent == null) {
          return undefined;
        }

        if (ep.length > 1) {
          return getElement(ep.slice(1).join('.'), newParent);
        }

        return newParent;
      };

      return getElement(elementPath, this);
    }
    /**
     * Returns an array of result from
     * [getElement](#figureelementcollectiongetelement) calls on an
     * array of paths.
     *
     * @param {TypeElementPath} children
     * @return {Array<FigureElement>} Array of
     * [getElement](#figureelementcollectiongetelement) results
     */

  }, {
    key: "getElements",
    value: function getElements(children) {
      var _this14 = this;

      // const paths = [];
      var processPath = function processPath(path) {
        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        if (typeof path === 'string') {
          return ["".concat(prefix).concat(path)];
        }

        if (path instanceof FigureElement) {
          return [path];
        }

        if (Array.isArray(path)) {
          var _out = [];
          path.forEach(function (p) {
            _out.push.apply(_out, _toConsumableArray(processPath(p, prefix)));
          });
          return _out;
        }

        var out = [];
        Object.keys(path).forEach(function (p) {
          out.push.apply(out, _toConsumableArray(processPath(path[p], "".concat(prefix).concat(p, "."))));
        });
        return out;
      };

      var paths = processPath(children);
      var elements = [];
      paths.forEach(function (child) {
        var element = _this14.getElement(child);

        if (element != null) {
          elements.push(element);
        }
      });
      return elements;
    }
    /**
     * Show collection or specific elements within the collection
     */

  }, {
    key: "show",
    value: function show() {
      var toShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _get(_getPrototypeOf(FigureElementCollection.prototype), "show", this).call(this);

      this.getElements(toShow).forEach(function (element) {
        element.showAll();
      }); // // if (toShow == null) {
      // //   this.showAll();
      // //   return;
      // // }
      // let listToShow = toShow;
      // if (!Array.isArray(listToShow)) {
      //   listToShow = [toShow];
      // }
      // listToShow.forEach((elementOrName) => {
      //   let element = elementOrName;
      //   if (typeof elementOrName === 'string') {
      //     element = this.getElement(elementOrName);
      //   }
      //   element.showAll();
      //   // if (element instanceof FigureElementCollection) {
      //   //   element.showAll();
      //   // } else {
      //   //   element.show();
      //   // }
      // });
    }
  }, {
    key: "showOnly",
    value: function showOnly() {
      var toShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.hideAll();
      this.show(toShow);
    }
  }, {
    key: "showAll",
    value: function showAll() {
      _get(_getPrototypeOf(FigureElementCollection.prototype), "show", this).call(this);

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.showAll();
      }
    }
    /**
     * Hide collection or specific elements within the collection
     */

  }, {
    key: "hide",
    value: function hide() {
      var toHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (toHide == null) {
        _get(_getPrototypeOf(FigureElementCollection.prototype), "hide", this).call(this);

        return;
      }

      this.getElements(toHide).forEach(function (element) {
        element.hide();
      }); // let listToHide = toHide;
      // if (!Array.isArray(listToHide)) {
      //   listToHide = [toHide];
      // }
      // if (listToHide.length === 0) {
      //   super.hide();
      //   return;
      // }
      // listToHide.forEach((elementOrName) => {
      //   let element = elementOrName;
      //   if (typeof elementOrName === 'string') {
      //     element = this.getElement(elementOrName);
      //   }
      //   if (element instanceof FigureElementCollection) {
      //     element.hideAll();
      //   } else {
      //     element.hide();
      //   }
      // });
    }
  }, {
    key: "hideAll",
    value: function hideAll() {
      this.hide();

      for (var i = 0, j = this.drawOrder.length; i < j; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.hide();

        if (typeof element.hideAll === 'function') {
          element.hideAll();
        }
      }
    }
  }, {
    key: "hideOnly",
    value: function hideOnly(listToHide) {
      this.showAll();
      this.hide(listToHide); // for (let i = 0, j = listToHide.length; i < j; i += 1) {
      //   const element = listToHide[i];
      //   element.hide();
      // }
    } // // This will only search elements within the collection for a touch
    // // if the collection is touchable. Note, the elements can be queried
    // // directly still, and will return if they are touched if they themselves
    // // are touchable.
    // isBeingTouched(glLocation: Point) {
    //   if (!this.isTouchable) {
    //     return false;
    //   }
    //   const vertexLocation = glLocation.transformBy(this.spaceTransformMatrix('gl', 'draw'));
    //   if (this.touchInBoundingRect !== false) {
    //     let buffer = 0;
    //     if (typeof this.touchInBoundingRect === 'number') {
    //       buffer = this.touchInBoundingRect;
    //     }
    //     const boundingRect = this.getBoundingRect('draw');
    //     if (vertexLocation.x >= boundingRect.left - buffer
    //       && vertexLocation.x <= boundingRect.right + buffer
    //       && vertexLocation.y <= boundingRect.top + buffer
    //       && vertexLocation.y >= boundingRect.bottom - buffer
    //     ) {
    //       return true;
    //     }
    //   }
    //   for (let i = 0, j = this.drawOrder.length; i < j; i += 1) {
    //     const element = this.elements[this.drawOrder[i]];
    //     if (element.isShown === true) {
    //       if (element.isBeingTouched(glLocation)) {
    //         return true;
    //       }
    //     }
    //   }
    //   return false;
    // }

  }, {
    key: "resizeHtmlObject",
    value: function resizeHtmlObject() {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.resizeHtmlObject();
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      var figureHTMLElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _get(_getPrototypeOf(FigureElementCollection.prototype), "resize", this).call(this, figureHTMLElement);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.resize(figureHTMLElement);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      var canvasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.clear(canvasIndex);
      }
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      var parentTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      // const finalParentTransform = this.processParentTransform(parentTransform);
      var firstTransform = parentTransform.transform(this.getTransform());
      this.lastDrawTransform = firstTransform._dup();

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setFirstTransform(firstTransform);
      }

      this.checkMoveBounds();
    } // border is whatever border is
    // children is touch borders of children
    // rect is rect of children touchBorder
    // number is buffer of rect of children touch border

  }, {
    key: "getBorderPoints",
    value: function getBorderPoints() {
      var _this15 = this;

      var border = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'border';
      var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var shownOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var getBorderFromChildren = function getBorderFromChildren(b) {
        var childrenBorder = [];
        var childrenToUse = children;

        if (childrenToUse == null) {
          childrenToUse = Object.keys(_this15.elements);
        }

        if (childrenToUse.length === 0) {
          return [[]];
        }

        childrenToUse.forEach(function (child) {
          var e = _this15.getElement(child);

          if (e == null || shownOnly && e.isShown === false) {
            return;
          } // $FlowFixMe


          childrenBorder.push.apply(childrenBorder, _toConsumableArray(e.getBorder('local', b, null, shownOnly)));
        });
        return childrenBorder;
      };

      if (border === 'border') {
        if (this.border === 'children') {
          return getBorderFromChildren('border');
        }

        if (this.border === 'rect') {
          // $FlowFixMe
          return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(getBorderFromChildren('border'))];
        }

        if (Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["isBuffer"])(this.border)) {
          // $FlowFixMe
          return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(getBorderFromChildren('border'), this.border)];
        } // $FlowFixMe


        return this.border;
      }

      if (border === 'touchBorder') {
        if (this.touchBorder === 'border') {
          return this.getBorderPoints('border', children, shownOnly);
        }

        if (this.touchBorder === 'children') {
          return getBorderFromChildren('touchBorder');
        }

        if (this.touchBorder === 'rect') {
          // $FlowFixMe
          return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(getBorderFromChildren('touchBorder'))];
        }

        if (Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["isBuffer"])(this.touchBorder)) {
          // $FlowFixMe
          return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(getBorderFromChildren('touchBorder'), this.touchBorder)];
        } // $FlowFixMe


        return this.touchBorder;
      }

      if (this.holeBorder === 'children') {
        return getBorderFromChildren('holeBorder');
      }

      return this.holeBorder;
    }
  }, {
    key: "getBorder",
    value: function getBorder() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'border';
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var shownOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (shownOnly && this.isShown === false) {
        return [[]];
      }

      var matrix;

      if (Array.isArray(space)) {
        matrix = _tools_m2__WEBPACK_IMPORTED_MODULE_4__["mul"](space, this.getTransform().matrix());
      } else {
        matrix = this.spaceTransformMatrix('draw', space);
      }

      var borderPoints = this.getBorderPoints(border, children, shownOnly);
      return borderPoints.map(function (b) {
        return b.map(function (p) {
          return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p).transformBy(matrix);
        });
      });
    }
  }, {
    key: "getBoundingRect",
    value: function getBoundingRect() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'border';
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var shownOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var transformedBorder = this.getBorder(space, border, children, shownOnly); // console.log(space, border, children, shownOnly)
      // console.log(transformedBorder)
      // $FlowFixMe

      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(transformedBorder);
    }
  }, {
    key: "getRelativeBoundingRect",
    value: function getRelativeBoundingRect() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'border';
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var shownOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var rect = this.getBoundingRect(space, border, children, shownOnly);
      var position = this.getPosition(space);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](rect.left - position.x, rect.bottom - position.y, rect.width, rect.height);
    }
  }, {
    key: "getPositionInBounds",
    value: function getPositionInBounds() {
      var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'local';
      var xAlign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'location';
      var yAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'location';
      var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var border = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'border';
      var shownOnly = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var bounds = this.getBoundingRect(space, border, children, shownOnly);
      var p = this.getPosition(space);

      if (xAlign === 'left') {
        p.x = bounds.left;
      } else if (xAlign === 'right') {
        p.x = bounds.right;
      } else if (xAlign === 'center') {
        p.x = bounds.left + bounds.width / 2;
      } else if (typeof xAlign === 'number') {
        p.x = bounds.left + bounds.width * xAlign;
      }

      if (yAlign === 'top') {
        p.y = bounds.top;
      } else if (yAlign === 'bottom') {
        p.y = bounds.bottom;
      } else if (yAlign === 'middle') {
        p.y = bounds.bottom + bounds.height / 2;
      } else if (typeof yAlign === 'number') {
        p.y = bounds.bottom + bounds.height * yAlign;
      }

      return p;
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits) {
      var transforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.figureTransforms;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.updateLimits(limits, transforms);
      }

      this.figureLimits = limits;
      this.figureTransforms = transforms;
    }
  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie(container) {
      _get(_getPrototypeOf(FigureElementCollection.prototype), "updateHTMLElementTie", this).call(this, container);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.updateHTMLElementTie(container);
      }
    } // Returns an array of touched elements.
    // In a collection, elements defined later in the collection.order
    // array are on top of earlier elements. The touched array
    // is sorted to have elements on top first, where the collection containing
    // the elements will be before it's elements. For example, the array
    // would be ordered as:
    //  0: top collection
    //  1 to n: n top elements in collection
    //  n+1: second top collection
    //  n+2 to m: top elements in second top colleciton.

  }, {
    key: "getTouched",
    value: function getTouched(glLocation) {
      if (!this.isTouchable && !this.hasTouchableElements) {
        return [];
      }

      var touched = []; // if (this.touchInBoundingRect !== false || this.isTouchable) {
      //   if (this.isBeingTouched(glLocation)) {
      //     touched.push(this);
      //   }
      // }

      if (this.isTouchable) {
        return _get(_getPrototypeOf(FigureElementCollection.prototype), "getTouched", this).call(this, glLocation);
      }

      for (var i = this.drawOrder.length - 1; i >= 0; i -= 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isShown === true) {
          touched = touched.concat(element.getTouched(glLocation));
        } // If there is an element that is touched, then this collection should
        // also be touched.
        // if (touched.length > 0 && this.isTouchable) {
        //   touched = [this].concat(touched);
        // }

      }

      return touched;
    }
  }, {
    key: "stop",
    value: function stop() {
      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';
      var elementOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _get(_getPrototypeOf(FigureElementCollection.prototype), "stop", this).call(this, how);

      if (elementOnly) {
        return;
      }

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.stop(how, elementOnly); // element.cancel(forceSetToEndOfPlan);
      }
    }
  }, {
    key: "setFont",
    value: function setFont(fontSize) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setFont(fontSize);
      }
    }
  }, {
    key: "setColor",
    value: function setColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 1];
      var setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var nonNullColor = color != null ? color : [0, 0, 0, 0];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setColor(nonNullColor, setDefault);
      }

      this.color = nonNullColor.slice();

      if (setDefault) {
        this.defaultColor = this.color.slice();
      } // this.color = [color[0], color[1], color[2], color[3]];

    }
  }, {
    key: "setDimColor",
    value: function setDimColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0, 1];
      var nonNullColor = color != null ? color : [0, 0, 0, 0];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setDimColor(nonNullColor);
      }

      this.dimColor = nonNullColor.slice();
    }
  }, {
    key: "undim",
    value: function undim() {
      this.color = this.defaultColor.slice();

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.undim();
      }
    }
  }, {
    key: "dim",
    value: function dim(elementsToDim) {
      if (elementsToDim == null || Array.isArray(elementsToDim) && elementsToDim.length === 0) {
        // super.dim();
        this.color = this.dimColor.slice();

        for (var i = 0; i < this.drawOrder.length; i += 1) {
          var element = this.elements[this.drawOrder[i]];
          element.dim();
        }

        return;
      }

      this.exec('dim', elementsToDim);
    }
  }, {
    key: "highlight",
    value: function highlight() {
      var elementsToHighlight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (elementsToHighlight == null) {
        this.undim();
        return;
      }

      if (Array.isArray(elementsToHighlight) && elementsToHighlight.length === 0) {
        return;
      }

      this.dim();
      this.exec('undim', elementsToHighlight);
    } // setOpacity(opacity: number) {
    //   // for (let i = 0; i < this.drawOrder.length; i += 1) {
    //   //   const element = this.elements[this.drawOrder[i]];
    //   //   element.setOpacity(opacity);
    //   // }
    //   // this.color[3] = opacity;
    //   this.opacity = opacity;
    // }

  }, {
    key: "getElementTransforms",
    value: function getElementTransforms() {
      var out = {};

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        out[element.name] = element.transform._dup();
      }

      return out;
    }
  }, {
    key: "setElementTransforms",
    value: function setElementTransforms(elementTransforms) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.name in elementTransforms) {
          element.transform = elementTransforms[element.name];

          if (element.internalSetTransformCallback) {
            this.fnMap.exec(element.internalSetTransformCallback, element.transform);
          }
        }
      }
    }
  }, {
    key: "reorder",
    value: function reorder() {
      var _this16 = this;

      this.drawOrder.sort(function (a, b) {
        var elemA = _this16.elements[a];
        var elemB = _this16.elements[b];
        return elemB.drawPriority - elemA.drawPriority;
      }); // this.elements.sort((a, b) => {
      //   const elemA
      //   b.z - a.z});

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof FigureElementCollection) {
          element.reorder();
        }
      }
    } // }

  }, {
    key: "animateToTransforms",
    value: function animateToTransforms(elementTransforms) // translationPath: (Point, Point, number) => Point = linearPath,
    {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var name = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '';
      var easeFunction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'tools.math.easeinout';
      var callbackMethod = callback;
      var timeToAnimate = 0;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.name in elementTransforms) {
          if (element.isShown) {
            if (!elementTransforms[element.name].isEqualTo(element.transform)) {
              element.animations["new"](name).delay(delay).transform({
                target: elementTransforms[element.name],
                duration: time,
                rotDirection: rotDirection,
                progression: easeFunction,
                onFinish: callbackMethod
              }).start(); // only want to send callback once

              callbackMethod = null;
              timeToAnimate = time + delay;
            }
          } else {
            element.transform = elementTransforms[element.name]._dup();

            if (element.internalSetTransformCallback) {
              this.fnMap.exec(element.internalSetTransformCallback, element.transform);
            }
          }
        }
      }

      if (timeToAnimate === 0 && callbackMethod != null) {
        this.fnMap.exec(callbackMethod, true); // callbackMethod(true);
      }

      return timeToAnimate;
    }
    /**
     * Get all elements within the collection that are primitives, including
     * any primitives that are children of this element, and any primitives that
     * are children of this element's children and so forth.
     *
     * @return {Array<FigureElement>}
     */

  }, {
    key: "getAllPrimitives",
    value: function getAllPrimitives() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof FigureElementCollection) {
          elements = [].concat(_toConsumableArray(elements), _toConsumableArray(element.getAllPrimitives()));
        } else {
          elements.push(element);
        }
      }

      return elements;
    }
    /**
     * Get an array of all elements of in this collection, including this element,
     * children, children of children and so forth.
     *
     * @return {Array<FigureElement>}
     */

  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [this];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]]; // elements.push(element);

        if (element instanceof FigureElementCollection) {
          elements.push.apply(elements, _toConsumableArray(element.getAllElements()));
        } else {
          elements.push(element);
        }
      }

      return elements;
    }
    /**
     * Get array of all children elements.
     *
     * @return {Array<FigureElement>}
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        elements.push(element);
      }

      return elements;
    }
  }, {
    key: "getAllElementsWithScenario",
    value: function getAllElementsWithScenario(scenario) {
      var elements = _get(_getPrototypeOf(FigureElementCollection.prototype), "getAllElementsWithScenario", this).call(this, scenario);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.scenarios[scenario] != null) {
          elements.push(element);
        }

        if (element instanceof FigureElementCollection) {
          elements = [].concat(_toConsumableArray(elements), _toConsumableArray(element.getAllElementsWithScenario(scenario)));
        }
      }

      return elements;
    }
  }, {
    key: "getRemainingAnimationTime",
    value: function getRemainingAnimationTime() {
      var animationNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var elements = this.getAllElements();

      var remainingTime = _get(_getPrototypeOf(FigureElementCollection.prototype), "getRemainingAnimationTime", this).call(this, animationNames);

      elements.forEach(function (element) {
        var duration = element.animations.getRemainingTime(animationNames);

        if (duration > remainingTime) {
          remainingTime = duration;
        }
      });
      return remainingTime;
    } // // Get all ineractive elemnts, but only go as deep as a
    // // FigureElementColleciton if it is touchable or movable
    // getAllCurrentlyInteractiveElements() {
    //   let elements = [];
    //   for (let i = 0; i < this.drawOrder.length; i += 1) {
    //     const element = this.elements[this.drawOrder[i]];
    //     // if (element.isShown) {
    //     if (element instanceof FigureElementCollection) {
    //       if (!element.isTouchable
    //         && !element.isMovable
    //         && element.hasTouchableElements
    //         && (!element.isInteractive || element.isInteractive == null)
    //       ) {
    //         elements = [...elements, ...element.getAllCurrentlyInteractiveElements()];
    //       }
    //     }
    //     if (element.isInteractive !== false
    //       && (element.isTouchable || element.isMovable || element.isInteractive)) {
    //       elements.push(element);
    //     }
    //     // }
    //   }
    //   return elements;
    // }
    // Get all ineractive elemnts, but only go as deep as a
    // FigureElementColleciton if it is touchable or movable

  }, {
    key: "getAllPossiblyInteractiveElements",
    value: function getAllPossiblyInteractiveElements() {
      var elements = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]]; // if (element.isShown) {

        if (element instanceof FigureElementCollection) {
          if (!element.isTouchable && !element.isMovable && element.hasTouchableElements && (!element.isInteractive || element.isInteractive == null)) {
            elements = [].concat(_toConsumableArray(elements), _toConsumableArray(element.getAllPossiblyInteractiveElements()));
          }
        }

        if (element.isInteractive !== undefined || element.isTouchable || element.isMovable) {
          elements.push(element);
        }
      }

      return elements;
    } // This method is here as a convenience method for content item selectors
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "goToStep",
    value: function goToStep(step) {
      var elem = document.getElementById('id__figureone_item_selector_0');
      var elems = [];

      if (elem != null) {
        if (elem.children.length > 0) {
          for (var i = 0; i < elem.children.length; i += 1) {
            elems.push(elem.children[i]);
          }
        }
      }

      elems.forEach(function (e, index) {
        if (index === step) {
          e.classList.add('figureone__item_selector_selected');
        } else {
          e.classList.remove('figureone__item_selector_selected');
        }
      });
    }
  }, {
    key: "setMovable",
    value: function setMovable() {
      var movable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      _get(_getPrototypeOf(FigureElementCollection.prototype), "setMovable", this).call(this, movable);

      if (movable) {
        this.hasTouchableElements = true; // this.isMovable = true;
      }
    } // updateContext(context: DrawContext2D) {
    //   for (let i = 0; i < this.drawOrder.length; i += 1) {
    //     const element = this.elements[this.drawOrder[i]];
    //     element.updateContext(context);
    //   }
    // }

  }, {
    key: "setupWebGLBuffers",
    value: function setupWebGLBuffers(newWebgl) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setupWebGLBuffers(newWebgl);
      }
    }
  }, {
    key: "changeWebGLInstance",
    value: function changeWebGLInstance(newWebgl) {
      var oldInstance;

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        oldInstance = element.changeWebGLInstance(newWebgl);
      }

      return oldInstance;
    }
  }, {
    key: "getLoadingElements",
    value: function getLoadingElements() {
      var elems = [];

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof FigureElementPrimitive) {
          if (element.drawingObject.state === 'loading') {
            elems.push(element);
          }
        } else {
          elems = [].concat(_toConsumableArray(elems), _toConsumableArray(element.getLoadingElements()));
        }
      }

      return elems;
    }
  }, {
    key: "setPointsFromDefinition",
    value: function setPointsFromDefinition() {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.setPointsFromDefinition != null) {
          element.setPointsFromDefinition();
        }
      }
    }
  }, {
    key: "setPrimitiveColors",
    value: function setPrimitiveColors() {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof FigureElementPrimitive) {
          element.setColor(element.color);
          element.setOpacity(element.opacity);
        } else {
          element.setPrimitiveColors();
        } // if (element.setPointsFromDefinition != null) {
        //   element.setPointsFromDefinition();
        // }

      }
    }
  }, {
    key: "unrenderAll",
    value: function unrenderAll() {
      this.unrender();

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element instanceof FigureElementPrimitive) {
          element.unrender();
        } else {
          element.unrenderAll();
        }
      }
    } // setScenario(scenarioName: string) {
    //   super.setScenario(scenarioName);
    //   if (this.scenarios[scenarioName] != null) {
    //     const target = this.getScenarioTarget(scenarioName);
    //     this.color = target.color.slice();
    //   }
    // }

    /**
     * Set transform, color and/or visibility to a predefined scenario.
     *
     * @param {string | Array<string>} [scenarioName] name of the scenario to
     * set. Use an array of names to set multiple scenarios in the array's order.
     * @param {boolean} [onlyIfVisible] `true` to only set scenario if element is
     * visible
     */

  }, {
    key: "setScenarios",
    value: function setScenarios(scenarioName) {
      var onlyIfVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _get(_getPrototypeOf(FigureElementCollection.prototype), "setScenarios", this).call(this, scenarioName);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (onlyIfVisible && element.isShown || onlyIfVisible === false) {
          element.setScenarios(scenarioName, onlyIfVisible);
        }
      }
    }
  }, {
    key: "saveScenarios",
    value: function saveScenarios(scenarioName, keys) {
      _get(_getPrototypeOf(FigureElementCollection.prototype), "saveScenarios", this).call(this, scenarioName, keys);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.saveScenarios(scenarioName, keys);
      }
    }
  }, {
    key: "animateToState",
    value: function animateToState(state, options) // lastDrawTime: number,
    // countStart: () => void,
    // countEnd: () => void,
    {
      var independentOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var startTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var duration = 0;
      duration = _get(_getPrototypeOf(FigureElementCollection.prototype), "animateToState", this).call(this, state, options, independentOnly, startTime);

      if (this.dependantTransform === false || independentOnly === false) {
        for (var i = 0; i < this.drawOrder.length; i += 1) {
          var element = this.elements[this.drawOrder[i]];

          if (state.elements != null && state.elements[this.drawOrder[i]] != null) {
            var elementDuration = element.animateToState(state.elements[this.drawOrder[i]], options, independentOnly, // countStart, countEnd,
            startTime);

            if (elementDuration > duration) {
              duration = elementDuration;
            }
          }
        }
      }

      return duration;
    }
  }, {
    key: "dissolveInToState",
    value: function dissolveInToState(state) {
      var durationIn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.8;
      var startTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var duration = 0;
      duration = _get(_getPrototypeOf(FigureElementCollection.prototype), "dissolveInToState", this).call(this, state, durationIn, startTime);

      if (duration === 0) {
        return 0;
      }

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (state.elements != null && state.elements[this.drawOrder[i]] != null) {
          var elementDuration = element.dissolveInToState(state.elements[this.drawOrder[i]], durationIn, startTime);

          if (elementDuration > duration) {
            duration = elementDuration;
          }
        }
      }

      return duration;
    } // _finishSetState(figure: Figure) {
    //   super._finishSetState(figure);
    //   for (let i = 0; i < this.drawOrder.length; i += 1) {
    //     const element = this.elements[this.drawOrder[i]];
    //     element._finishSetState(figure);
    //   }
    // }

  }, {
    key: "setTimeDelta",
    value: function setTimeDelta(delta) {
      _get(_getPrototypeOf(FigureElementCollection.prototype), "setTimeDelta", this).call(this, delta);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.setTimeDelta(delta);
      }
    }
  }, {
    key: "isStateSame",
    value: function isStateSame(state) {
      var mergePulseTransforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var exceptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      var thisElementResult = _get(_getPrototypeOf(FigureElementCollection.prototype), "isStateSame", this).call(this, state, mergePulseTransforms, exceptions);

      if (thisElementResult === false) {
        return false;
      }

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (state.elements != null && state.elements[this.drawOrder[i]] != null) {
          var elementResult = element.isStateSame(state.elements[this.drawOrder[i]], mergePulseTransforms, exceptions);

          if (elementResult === false) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: "clearFrozenPulseTransforms",
    value: function clearFrozenPulseTransforms() {
      _get(_getPrototypeOf(FigureElementCollection.prototype), "clearFrozenPulseTransforms", this).call(this);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.clearFrozenPulseTransforms();
      }
    }
  }, {
    key: "freezePulseTransforms",
    value: function freezePulseTransforms() {
      var forceOverwrite = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      _get(_getPrototypeOf(FigureElementCollection.prototype), "freezePulseTransforms", this).call(this, forceOverwrite);

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        element.freezePulseTransforms(forceOverwrite);
      }
    }
  }, {
    key: "isAnimating",
    value: function isAnimating() {
      // const result = super.isAnimating();
      // if (result) {
      //   return true;
      // }
      // for (let i = 0; i < this.drawOrder.length; i += 1) {
      //   const element = this.elements[this.drawOrder[i]];
      //   const r = element.isAnimating();
      //   if (r) {
      //     return true;
      //   }
      // }
      // return false;
      if (this.isShown === false) {
        return false;
      }

      if (_get(_getPrototypeOf(FigureElementCollection.prototype), "isAnimating", this).call(this)) {
        return true;
      }

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.isAnimating()) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "remove",
    value: function remove(elementName) {
      if (this.elements[elementName] == null) {
        return;
      }

      var element = this.elements[elementName];
      element.animations.cancelAll('freeze', true);
      element.stop();
      element.parent = null;
      element.animations = null;
      element.move.element = null;
      element.recorder = null;
      element.figure = null;
      delete this.elements["_".concat(elementName)];
      delete this.elements[elementName];
      var index = this.drawOrder.indexOf(elementName);

      if (index !== -1) {
        this.drawOrder.splice(index, 1);
      }
    }
  }, {
    key: "stopAnimating",
    value: function stopAnimating() {
      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var includeChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      _get(_getPrototypeOf(FigureElementCollection.prototype), "stopAnimating", this).call(this, how, name);

      if (includeChildren) {
        for (var i = 0; i < this.drawOrder.length; i += 1) {
          var element = this.elements[this.drawOrder[i]];
          element.stopAnimating(how, name, includeChildren);
        }
      }
    }
  }, {
    key: "align",
    value: function align(xAlign, yAlign) {
      var bounds = this.getBoundingRect('draw');
      var offset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (xAlign === 'left') {
        offset.x = -bounds.left;
      } else if (xAlign === 'center') {
        offset.x = -bounds.left + bounds.width / 2;
      } else if (xAlign === 'right') {
        offset.x = -bounds.right;
      } else {
        offset.x = -bounds.left + bounds.width * xAlign;
      }

      if (yAlign === 'bottom') {
        offset.y = -bounds.bottom;
      } else if (yAlign === 'middle') {
        offset.y = -bounds.bottom + bounds.height / 2;
      } else if (yAlign === 'top') {
        offset.y = -bounds.top;
      } else {
        offset.y = -bounds.bottom + bounds.height * yAlign;
      }

      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];
        var p = element.transform.t();
        element.transform.updateTranslation(p.add(offset));
      }
    }
  }]);

  return FigureElementCollection;
}(FigureElement);



/***/ }),

/***/ "./src/js/figure/Equation/Elements/BaseAnnotationFunction.js":
/*!*******************************************************************!*\
  !*** ./src/js/figure/Equation/Elements/BaseAnnotationFunction.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseAnnotationFunction; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Symbols_SymbolNew__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Symbols/SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
/* harmony import */ var _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/FunctionMap */ "./src/js/tools/FunctionMap.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

 // import { Elements } from './Element';

 // import BaseEquationFunction from './BaseEquationFunction';
// import type { TypeParsablePoint } from '../../../../tools/g2';
// import type {EQN_Annotation } from './Base'
// import {
//   FigureElementPrimitive, FigureElementCollection,
// } from '../../../Element';

 // import { Element, Elements } from './Element';

// import Symbol from '../Symbols/Symbol';

 // eslint-disable-next-line import/no-cycle
// import type { TypeEquationPhrase } from '../EquationFunctions';

// export type EQN_GlyphsIn = {
//   left?: TypeAnnotatedGlyph;
//   right?: TypeAnnotatedGlyph;
//   top?: TypeAnnotatedGlyph;
//   bottom?: TypeAnnotatedGlyph;
//   encompass?: EQN_EncompassGlyphIn;
// };
function copyAnnotation(annotation, namedCollection) {
  return {
    xPosition: annotation.xPosition,
    yPosition: annotation.yPosition,
    xAlign: annotation.xAlign,
    yAlign: annotation.yAlign,
    offset: annotation.offset._dup(),
    scale: annotation.scale,
    content: annotation.content._dup(namedCollection),
    inSize: annotation.inSize,
    fullContentBounds: annotation.fullContentBounds
  };
}

function copyAnnotations(annotations, namedCollection) {
  var copy = [];
  annotations.forEach(function (annotation) {
    copy.push(copyAnnotation(annotation, namedCollection));
  });
  return copy;
}

function copyGlyphs(glyphs, namedCollection) {
  var copy = {};
  Object.keys(glyphs).forEach(function (key) {
    if (glyphs[key] == null) {
      return;
    }

    var glyph = glyphs[key];
    var copyGlyph = {};
    Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(glyph, copyGlyph, ['glyph', 'annotations']);

    if (namedCollection != null) {
      copyGlyph.glyph = namedCollection[glyph.glyph.name];
    } else {
      copyGlyph.glyph = glyph.glyph;
    }

    copyGlyph.annotations = copyAnnotations(glyph.annotations, namedCollection);
    copy[key] = copyGlyph;
  });
  return copy;
}

function getAllElementsFromAnnotations(annotations) {
  var elements = [];
  annotations.forEach(function (annotation) {
    elements = [].concat(_toConsumableArray(elements), _toConsumableArray(annotation.content.getAllElements()));
  });
  return elements;
}

function getAllElementsFromGlyphs(glyphs) {
  var elements = [];
  Object.keys(glyphs).forEach(function (key) {
    var glyph = glyphs[key];

    if (glyph == null) {
      return;
    }

    elements = [].concat(_toConsumableArray(elements), [glyph.glyph], _toConsumableArray(getAllElementsFromAnnotations(glyph.annotations)));
  });
  return elements;
}

function setPositionsForAnnotations(annotations) {
  annotations.forEach(function (annotation) {
    annotation.content.setPositions();
  });
}

function offsetLocationForAnnotations(annotations, offset) {
  annotations.forEach(function (annotation) {
    annotation.content.offsetLocation(offset);
  });
}

function setPositionsForGlyphs(glyphs) {
  Object.keys(glyphs).forEach(function (key) {
    if (glyphs[key] == null) {
      return;
    }

    var glyph = glyphs[key];

    var t = glyph.glyph.transform._dup();

    t.updateScale(glyph.width, glyph.height);
    t.updateTranslation(glyph.location.x, glyph.location.y);
    glyph.glyph.setTransform(t);
    setPositionsForAnnotations(glyph.annotations);
  });
}

function offsetLocationForGlyphs(glyphs, offset) {
  Object.keys(glyphs).forEach(function (key) {
    if (glyphs[key] == null) {
      return;
    }

    var glyph = glyphs[key];
    glyph.location = glyph.location.add(offset);
    offsetLocationForAnnotations(glyph.annotations, offset);
  });
}

var BaseAnnotationFunction = /*#__PURE__*/function () {
  function BaseAnnotationFunction(content, annotations, glyphs, options) {
    _classCallCheck(this, BaseAnnotationFunction);

    this.glyphs = glyphs;
    this.content = content;
    this.annotations = annotations;
    this.options = options;
    this.fnMap = new _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_4__["FunctionMap"]();
  }

  _createClass(BaseAnnotationFunction, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var contentCopy = this.content._dup(namedCollection);

      var glyphsCopy = copyGlyphs(this.glyphs);
      var annotationsCopy = copyAnnotations(this.annotations);
      var copy = new this.constructor( // $FlowFixMe
      contentCopy, annotationsCopy, glyphsCopy, this.options);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicateFromTo"])(this, copy, ['content', 'glyphs', 'annotations']);
      return copy;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      return [].concat(_toConsumableArray(this.content.getAllElements()), _toConsumableArray(getAllElementsFromAnnotations(this.annotations)), _toConsumableArray(getAllElementsFromGlyphs(this.glyphs)));
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.content.setPositions();
      setPositionsForAnnotations(this.annotations);
      setPositionsForGlyphs(this.glyphs);
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.content.offsetLocation(offset);
      offsetLocationForAnnotations(this.annotations, offset);
      offsetLocationForGlyphs(this.glyphs, offset);
    } //                               Top Glyph
    //                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
    //                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG     Encompassing Glyph
    //                                                      /
    //                                                    /
    //        GGG       GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG        GGG
    //        GGG       GGG                           GGG        GGG
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    // Left   GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG   Right
    // Glyph  GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG   Glyph
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    //        GGG       GGG     CCCCCCCCCCCCCCCCC     GGG        GGG
    //        GGG       GGG                           GGG        GGG
    //        GGG       GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG        GGG
    //
    //
    //                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
    //                  GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
    //                            Bottom Glyph
    //
    //
    //
    //
    // |                          GGGGGGGGGGGGGGGGGGGGGGGG
    // |                          GGGGGGGGGGGGGGGGGGGGGGGG
    // |                          GGG                  GGG
    // |                          GGG                  GGG
    // |        GGG               GGG   CCCCCCCCCCCC   GGG               GGG
    // |        GGG               GGG   CCCCCCCCCCCC   GGG               GGG
    // |        GGG               GGG   CCCCCCCCCCCC   GGG               GGG
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // |  AAA   GGG   AAA   AAA   GGG   CCCCCCCCCCCC   GGG   AAA   AAA   GGG   AAA
    // | |   |  GGG  |   | |   |  GGG   CCCCCCCCCCCC   GGG               GGG
    // | |   |  GGG  |   | |   |  GGG   CCCCCCCCCCCC   GGG               GGG
    // | |   |  GGG  |   | |   |  GGG   CCCCCCCCCCCC   GGG               GGG
    // | |   |  |  | |   | |   |  GGG   |              GGG
    // | |   |  |  | |   | |   |  GGG   |              GGG
    // | |   |  |  | |   | |   |  GGGGGGGGGGGGGGGGGGGGGGGG
    // | |   |  |  | |   | |   |  GGGGGGGGGGGGGGGGGGGGGGGG
    // | |   |  |  | |   | |   |  |  |  |
    // | |   |  |  | |   | |   |  |  |--|<----  contentEncompassGlyph Space
    // | |   |  |  | |   | |   |  |
    // | |   |  |  | |   | |   |--|<----- EncompassGlyphAnnotation Space
    // | |   |  |  | |   | |
    // | |   |  |  | |   |-|<----- ContentAnnotationGlyphInsideAnnotation Space
    // | |   |  |  | |
    // | |   |  |  |-|<------- GlyphInsideAnnotationGlyph Space
    // | |   |  |
    // | |  >|--|<------ GlypgGlyphOutsideAnnotation Space
    // | |
    // |-|<------ Outside Space

  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {
      var _this = this;

      this.location = location._dup();

      var loc = location._dup(); // const [encompassGlyph, leftGlyph, bottomGlyph, rightGlyph, topGlyph] = this.glyphs;


      var content = this.content,
          annotations = this.annotations;
      var _this$options = this.options,
          inSize = _this$options.inSize,
          space = _this$options.space,
          topSpace = _this$options.topSpace,
          bottomSpace = _this$options.bottomSpace,
          leftSpace = _this$options.leftSpace,
          rightSpace = _this$options.rightSpace,
          contentScale = _this$options.contentScale,
          useFullBounds = _this$options.useFullBounds,
          fullContentBounds = _this$options.fullContentBounds;
      var inSizeBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      content.calcSize(loc._dup(), scale * contentScale);
      contentBounds.copyFrom(content.getBounds(fullContentBounds));
      inSizeBounds.copyFrom(contentBounds);
      fullBounds.copyFrom(contentBounds);
      annotations.forEach(function (annotation, index) {
        annotation.content.calcSize(loc, scale * annotation.scale);

        _this.setAnnotationPosition(contentBounds, annotation, scale);

        var annotationBounds = annotation.content.getBounds();
        inSizeBounds.growWithSameBaseline(annotationBounds);
        var fullSizeAnnotationBounds = annotation.content.getBounds(true);
        fullBounds.growWithSameBaseline(fullSizeAnnotationBounds);

        if (_this.glyphs.line != null && _this.glyphs.line.annotationIndex === index) {
          _this.setLineGlyph(annotationBounds, contentBounds); // inSizeBounds.growWithSameBaseline(encompassBounds);
          // fullBounds.growWithSameBaseline(encompassFullBounds);

        }
      });

      var _this$setEncompassGly = this.setEncompassGlyph(scale, contentBounds),
          _this$setEncompassGly2 = _slicedToArray(_this$setEncompassGly, 2),
          encompassBounds = _this$setEncompassGly2[0],
          encompassFullBounds = _this$setEncompassGly2[1];

      inSizeBounds.growWithSameBaseline(encompassBounds);
      fullBounds.growWithSameBaseline(encompassFullBounds);

      var _this$setVerticalGlyp = this.setVerticalGlyph(scale, contentBounds, 'left'),
          _this$setVerticalGlyp2 = _slicedToArray(_this$setVerticalGlyp, 2),
          leftBounds = _this$setVerticalGlyp2[0],
          leftFullBounds = _this$setVerticalGlyp2[1];

      inSizeBounds.growWithSameBaseline(leftBounds);
      fullBounds.growWithSameBaseline(leftFullBounds);

      var _this$setVerticalGlyp3 = this.setVerticalGlyph(scale, contentBounds, 'right'),
          _this$setVerticalGlyp4 = _slicedToArray(_this$setVerticalGlyp3, 2),
          rightBounds = _this$setVerticalGlyp4[0],
          rightFullBounds = _this$setVerticalGlyp4[1];

      inSizeBounds.growWithSameBaseline(rightBounds);
      fullBounds.growWithSameBaseline(rightFullBounds);

      var _this$setHorizontalGl = this.setHorizontalGlyph(scale, contentBounds, 'top'),
          _this$setHorizontalGl2 = _slicedToArray(_this$setHorizontalGl, 2),
          topBounds = _this$setHorizontalGl2[0],
          topFullBounds = _this$setHorizontalGl2[1];

      inSizeBounds.growWithSameBaseline(topBounds);
      fullBounds.growWithSameBaseline(topFullBounds);

      var _this$setHorizontalGl3 = this.setHorizontalGlyph(scale, contentBounds, 'bottom'),
          _this$setHorizontalGl4 = _slicedToArray(_this$setHorizontalGl3, 2),
          bottomBounds = _this$setHorizontalGl4[0],
          bottomFullBounds = _this$setHorizontalGl4[1];

      inSizeBounds.growWithSameBaseline(bottomBounds);
      fullBounds.growWithSameBaseline(bottomFullBounds);
      var xLocationOffset = 0;
      var topSpaceToUse = (topSpace != null ? topSpace : space || 0) * scale;
      var bottomSpaceToUse = (bottomSpace != null ? bottomSpace : space || 0) * scale;
      var leftSpaceToUse = (leftSpace != null ? leftSpace : space || 0) * scale;
      var rightSpaceToUse = (rightSpace != null ? rightSpace : space || 0) * scale;
      inSizeBounds.offset(topSpaceToUse, rightSpaceToUse, -bottomSpaceToUse, -leftSpaceToUse);
      fullBounds.growWithSameBaseline(inSizeBounds);

      if (useFullBounds) {
        inSizeBounds.copyFrom(fullBounds);
      }

      if (inSize) {
        this.width = inSizeBounds.width;
        this.ascent = inSizeBounds.ascent;
        this.descent = inSizeBounds.descent;
        this.height = inSizeBounds.height;
        xLocationOffset = loc.x - inSizeBounds.left;
      } else {
        this.width = contentBounds.width;
        this.ascent = contentBounds.ascent;
        this.descent = contentBounds.descent;
        this.height = contentBounds.height;
      }

      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };

      if (xLocationOffset !== 0 && content != null) {
        var locationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xLocationOffset, 0);
        content.offsetLocation(locationOffset);
        annotations.forEach(function (annotation) {
          annotation.content.offsetLocation(locationOffset);
        });
        Object.keys(this.glyphs).forEach(function (key) {
          var glyph = _this.glyphs[key];

          if (glyph == null) {
            return;
          }

          glyph.location = glyph.location.add(locationOffset);
          glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
          glyph.annotations.forEach(function (annotation) {
            annotation.content.offsetLocation(locationOffset);
          });
        });
      }
    }
  }, {
    key: "setEncompassGlyph",
    value: function setEncompassGlyph(scale, contentBoundsIn) {
      var _this2 = this;

      if (this.glyphs.encompass == null) {
        var _fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

        _fullBounds.copyFrom(contentBoundsIn);

        return [contentBoundsIn, _fullBounds];
      }

      var _this$glyphs$encompas = this.glyphs.encompass,
          leftSpace = _this$glyphs$encompas.leftSpace,
          rightSpace = _this$glyphs$encompas.rightSpace,
          bottomSpace = _this$glyphs$encompas.bottomSpace,
          topSpace = _this$glyphs$encompas.topSpace,
          space = _this$glyphs$encompas.space;
      var glyph = this.glyphs.encompass;
      var spaceToUse = space != null ? space : 0;
      var left = leftSpace != null ? leftSpace : spaceToUse;
      var right = rightSpace != null ? rightSpace : spaceToUse;
      var top = topSpace != null ? topSpace : spaceToUse;
      var bottom = bottomSpace != null ? bottomSpace : spaceToUse;
      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      contentBounds.copyFrom(contentBoundsIn);
      contentBounds.offset(top * scale, right * scale, -bottom * scale, -left * scale);
      var glyphBounds = glyph.glyph.getBounds(glyph.glyph.custom.options, contentBounds.left, contentBounds.bottom, contentBounds.width, contentBounds.height);
      var inSizeBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      inSizeBounds.copyFrom(contentBounds);
      inSizeBounds.growWithSameBaseline(glyphBounds);
      fullBounds.copyFrom(inSizeBounds);
      glyph.width = glyphBounds.width;
      glyph.height = glyphBounds.height;
      glyph.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](glyphBounds.left, glyphBounds.bottom);
      glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
      glyph.annotations.forEach(function (annotation) {
        annotation.content.calcSize(glyph.location, scale * annotation.scale);

        _this2.setAnnotationPosition(glyphBounds, annotation, scale);

        var annotationBounds = annotation.content.getBounds();
        inSizeBounds.growWithSameBaseline(annotationBounds);
        var fullAnnotationBounds = annotation.content.getBounds(true);
        fullBounds.growWithSameBaseline(fullAnnotationBounds);
      });
      return [inSizeBounds, fullBounds];
    }
  }, {
    key: "setLineGlyph",
    value: function setLineGlyph(annotationBounds, contentBounds) {
      if (this.glyphs.line == null) {
        return;
      }

      var _this$glyphs$line = this.glyphs.line,
          content = _this$glyphs$line.content,
          annotation = _this$glyphs$line.annotation;
      var glyph = this.glyphs.line;
      var pStart = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPositionInRect"])( // $FlowFixMe
      contentBounds.toRect(), content.xAlign, content.yAlign);
      var pEnd = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPositionInRect"])( // $FlowFixMe
      annotationBounds.toRect(), annotation.xAlign, annotation.yAlign);
      var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](pStart, pEnd);
      var spacedLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](line.pointAtLength(content.space), line.pointAtLength(line.length() - annotation.space)); // console.log(spacedLine)

      glyph.width = spacedLine.angle();
      glyph.height = spacedLine.length();
      glyph.location = spacedLine.p1._dup();
      glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height); // glyph.glyph.custom.options.spacedLine = spacedLine._dup();
      // glyph.location = new Point(0, 0);
      // const sp1 = spacedLine.p1._dup();
      // const sp2 = spacedLine.p2._dup();
      // const glyphBounds = new Bounds({
      //   left: Math.min(sp1.x, sp2.x),
      //   bottom: Math.min(sp1.y, sp2.y),
      //   width: Math.abs(sp1.x - sp2.x),
      //   height: Math.abs(sp1.y - sp2.y),
      // });
      // glyph.width = glyphBounds.width;
      // glyph.height = glyphBounds.height;
      // glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
    }
  }, {
    key: "setVerticalGlyph",
    value: function setVerticalGlyph(scale, contentBounds, glyphName) {
      var _this3 = this;

      if (this.glyphs[glyphName] == null) {
        var _fullBounds2 = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

        _fullBounds2.copyFrom(contentBounds);

        return [contentBounds, _fullBounds2];
      }

      var _this$glyphs$glyphNam = this.glyphs[glyphName],
          space = _this$glyphs$glyphNam.space,
          overhang = _this$glyphs$glyphNam.overhang,
          topSpace = _this$glyphs$glyphNam.topSpace,
          bottomSpace = _this$glyphs$glyphNam.bottomSpace,
          minContentHeight = _this$glyphs$glyphNam.minContentHeight,
          minContentDescent = _this$glyphs$glyphNam.minContentDescent,
          minContentAscent = _this$glyphs$glyphNam.minContentAscent,
          descent = _this$glyphs$glyphNam.descent,
          height = _this$glyphs$glyphNam.height,
          yOffset = _this$glyphs$glyphNam.yOffset,
          annotationsOverContent = _this$glyphs$glyphNam.annotationsOverContent;
      var glyph = this.glyphs[glyphName]; // const contentBounds = new Bounds();
      // contentBounds.copyFrom(contentBounds);

      var glyphHeight = contentBounds.height;
      var contentX = contentBounds.left;
      var glyphBottom = contentBounds.bottom; // let glyphTop = contentBounds.top;

      var glyphDescent = contentBounds.descent;
      var glyphAscent = contentBounds.ascent;

      if (minContentDescent != null) {
        glyphDescent = Math.max(minContentDescent, glyphDescent);
        glyphHeight = contentBounds.ascent + glyphDescent;
      }

      if (minContentAscent != null) {
        glyphAscent = Math.max(minContentAscent, glyphAscent);
        glyphHeight = glyphAscent + glyphDescent;
      }

      if (minContentHeight != null) {
        glyphAscent = -glyphDescent + Math.max(minContentHeight, glyphHeight);
      }

      var topSpaceToUse = topSpace != null ? topSpace : overhang;
      var bottomSpaceToUse = bottomSpace != null ? bottomSpace : overhang;
      glyphDescent += scale * bottomSpaceToUse;

      if (descent != null) {
        glyphDescent = descent;
      }

      glyphAscent += scale * topSpaceToUse;
      glyphHeight = glyphDescent + glyphAscent;

      if (height != null) {
        glyphHeight = height;
        glyphAscent = glyphHeight - glyphDescent;
      }

      glyphBottom = contentBounds.bottom - (glyphDescent - contentBounds.descent); // glyphTop = contentBoundsIn.top + (glyphAscent - contentBoundsIn.ascent);
      // glyphLeft = contentBounds.left;

      if (glyphName === 'left') {
        contentX -= space * scale;
      } else {
        contentX = contentBounds.left + contentBounds.width + space * scale;
      } // let glyphBottom = contentBounds.bottom;


      if (descent == null && bottomSpace == null && height != null) {
        glyphBottom = contentBounds.bottom + contentBounds.height / 2 - height / 2;
      }

      var glyphBounds = glyph.glyph.getBounds(glyph.glyph.custom.options, contentX, glyphBottom + yOffset, // $FlowFixMe
      null, glyphHeight, glyphName); // const totalBounds = new Bounds();

      var inSizeBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      inSizeBounds.copyFrom(contentBounds);
      inSizeBounds.growWithSameBaseline(glyphBounds);
      fullBounds.copyFrom(inSizeBounds);
      var glyphAndAnnotationBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      glyphAndAnnotationBounds.copyFrom(glyphBounds);
      glyph.width = glyphBounds.width;
      glyph.height = glyphBounds.height;
      glyph.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](glyphBounds.left, glyphBounds.bottom);
      glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
      glyph.annotations.forEach(function (annotation) {
        annotation.content.calcSize(glyph.location, scale * annotation.scale);

        _this3.setAnnotationPosition(glyphBounds, annotation, scale);

        var annotationBounds = annotation.content.getBounds();
        inSizeBounds.growWithSameBaseline(annotationBounds);
        glyphAndAnnotationBounds.growWithSameBaseline(annotationBounds);
        var fullAnnotationBounds = annotation.content.getBounds(true);
        fullBounds.growWithSameBaseline(fullAnnotationBounds);
      });
      var xOffset = 0;

      if (glyphName === 'left' && glyphAndAnnotationBounds.right > contentX && annotationsOverContent === false) {
        xOffset = contentX - glyphAndAnnotationBounds.right;
      }

      if (glyphName === 'right' && glyphAndAnnotationBounds.left < contentX && annotationsOverContent === false) {
        xOffset = contentX - glyphAndAnnotationBounds.left;
      }

      if (xOffset !== 0) {
        var locationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xOffset, 0);
        glyph.location = glyph.location.add(locationOffset);
        glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
        glyph.annotations.forEach(function (annotation) {
          annotation.content.offsetLocation(locationOffset);
        });
        inSizeBounds.left += xOffset;
        inSizeBounds.right = Math.max(inSizeBounds.right + xOffset, contentBounds.right);
        fullBounds.left += xOffset;
        fullBounds.right = Math.max(inSizeBounds.right + xOffset, contentBounds.right);
      } // console.log(inSizeBounds.left, inSizeBounds.width)


      return [inSizeBounds, fullBounds];
    }
  }, {
    key: "setHorizontalGlyph",
    value: function setHorizontalGlyph(scale, contentBoundsIn, glyphName) {
      var _this4 = this;

      if (this.glyphs[glyphName] == null) {
        var _fullBounds3 = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

        _fullBounds3.copyFrom(contentBoundsIn);

        return [contentBoundsIn, _fullBounds3];
      }

      var _this$glyphs$glyphNam2 = this.glyphs[glyphName],
          space = _this$glyphs$glyphNam2.space,
          overhang = _this$glyphs$glyphNam2.overhang,
          width = _this$glyphs$glyphNam2.width,
          leftSpace = _this$glyphs$glyphNam2.leftSpace,
          rightSpace = _this$glyphs$glyphNam2.rightSpace,
          xOffset = _this$glyphs$glyphNam2.xOffset,
          annotationsOverContent = _this$glyphs$glyphNam2.annotationsOverContent;
      var glyph = this.glyphs[glyphName];
      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      contentBounds.copyFrom(contentBoundsIn);
      var glyphLength = contentBounds.width;
      var contentX = contentBounds.left;

      if (overhang != null) {
        glyphLength += 2 * overhang * scale;
        contentX = contentBounds.left - overhang * scale;
      }

      if (width != null) {
        glyphLength = width * scale;
      }

      if (leftSpace != null || rightSpace != null) {
        glyphLength = (leftSpace || 0) * scale + contentBounds.width + (rightSpace || 0) * scale;

        if (leftSpace != null) {
          contentX = contentBounds.left - leftSpace * scale;
        }
      }

      if (leftSpace == null && rightSpace == null && width != null) {
        contentX = contentBounds.left + (contentBounds.width - width) / 2;
      } else if (leftSpace == null && rightSpace != null && width != null) {
        contentX = contentBounds.right + rightSpace * scale - width;
      }

      var contentY;

      if (glyphName === 'top') {
        contentY = contentBounds.top + space * scale;
      } else {
        contentY = contentBounds.bottom - space * scale;
      }

      var glyphBounds = glyph.glyph.getBounds(glyph.glyph.custom.options, contentX + xOffset, contentY, glyphLength, // $FlowFixMe
      null, glyphName);
      var inSizeBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      inSizeBounds.copyFrom(contentBounds);
      inSizeBounds.growWithSameBaseline(glyphBounds);
      fullBounds.copyFrom(inSizeBounds);
      var glyphAndAnnotationBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      glyphAndAnnotationBounds.copyFrom(glyphBounds);
      glyph.width = glyphBounds.width;
      glyph.height = glyphBounds.height;
      glyph.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](glyphBounds.left, glyphBounds.bottom);
      glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
      glyph.annotations.forEach(function (annotation) {
        annotation.content.calcSize(glyph.location, scale * annotation.scale);

        _this4.setAnnotationPosition(glyphBounds, annotation, scale);

        var annotationBounds = annotation.content.getBounds();
        inSizeBounds.growWithSameBaseline(annotationBounds);
        glyphAndAnnotationBounds.growWithSameBaseline(annotationBounds);
        var fullAnnotationBounds = annotation.content.getBounds(true);
        fullBounds.growWithSameBaseline(fullAnnotationBounds);
      });
      var yOffset = 0;

      if (glyphName === 'top' && glyphAndAnnotationBounds.bottom < contentY && annotationsOverContent === false) {
        yOffset = contentY - glyphAndAnnotationBounds.bottom;
      }

      if (glyphName === 'bottom' && glyphAndAnnotationBounds.top > contentY && annotationsOverContent === false) {
        yOffset = contentY - glyphAndAnnotationBounds.top;
      }

      if (yOffset !== 0) {
        var locationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, yOffset);
        glyph.location = glyph.location.add(locationOffset);
        glyph.glyph.custom.setSize(glyph.location, glyph.width, glyph.height);
        glyph.annotations.forEach(function (annotation) {
          annotation.content.offsetLocation(locationOffset);
        });
        inSizeBounds.top += yOffset;
        inSizeBounds.bottom += yOffset;
        fullBounds.top += yOffset;
        fullBounds.bottom += yOffset;
      }

      return [inSizeBounds, fullBounds];
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "setAnnotationPosition",
    value: function setAnnotationPosition(contentToAnnotateBounds, annotation, scale) {
      var xPosition = annotation.xPosition,
          yPosition = annotation.yPosition,
          xAlign = annotation.xAlign,
          yAlign = annotation.yAlign,
          offset = annotation.offset;
      offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(offset);
      var content = annotation.content,
          fullContentBounds = annotation.fullContentBounds;
      var locationContentToAnnotate = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](contentToAnnotateBounds.left, contentToAnnotateBounds.bottom + contentToAnnotateBounds.descent);
      var xPos;
      var yPos; // $FlowFixMe

      if (contentToAnnotateBounds.annotations != null && annotation.reference != null) {
        // $FlowFixMe
        var reference = contentToAnnotateBounds.annotations[annotation.reference];

        if (reference.xPosition != null) {
          xPosition = reference.xPosition;
        }

        if (reference.yPosition != null) {
          yPosition = reference.yPosition;
        }

        if (reference.xAlign != null) {
          xAlign = reference.xAlign;
        }

        if (reference.yAlign != null) {
          yAlign = reference.yAlign;
        }

        if (reference.offset != null) {
          offset = offset.add(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(reference.offset));
        }
      }

      if (xPosition === 'right') {
        xPos = 1;
      } else if (xPosition === 'center') {
        xPos = 0.5;
      } else if (typeof xPosition === 'number') {
        xPos = xPosition;
      } else {
        // left
        xPos = 0;
      }

      xPos = xPos * contentToAnnotateBounds.width + locationContentToAnnotate.x;

      if (yPosition === 'bottom') {
        yPos = 0;
      } else if (yPosition === 'middle') {
        yPos = 0.5;
      } else if (yPosition === 'top') {
        yPos = 1;
      } else if (typeof yPosition === 'number') {
        yPos = yPosition;
      } else if (typeof yPosition === 'string' && yPosition.slice(-1)[0] === 'a') {
        var ascentPercentage = parseFloat(yPosition);
        var ascentPercentHeight = contentToAnnotateBounds.ascent / contentToAnnotateBounds.height;
        var descentPercentHeight = contentToAnnotateBounds.descent / contentToAnnotateBounds.height;
        yPos = ascentPercentHeight * ascentPercentage + descentPercentHeight;
      } else {
        // baseline
        yPos = contentToAnnotateBounds.descent / contentToAnnotateBounds.height;
      }

      yPos = yPos * contentToAnnotateBounds.height + locationContentToAnnotate.y - contentToAnnotateBounds.descent;
      var contentBounds = content.getBounds(fullContentBounds);

      if (xAlign === 'center') {
        xPos -= contentBounds.width * 0.5;
      } else if (xAlign === 'right') {
        xPos -= contentBounds.width;
      } else if (typeof xAlign === 'number') {
        xPos -= contentBounds.width * xAlign;
      }

      if (yAlign === 'bottom') {
        yPos += contentBounds.descent;
      } else if (yAlign === 'middle') {
        yPos = yPos + contentBounds.descent - contentBounds.height / 2;
      } else if (yAlign === 'top') {
        yPos -= contentBounds.ascent;
      } else if (typeof yAlign === 'string' && yAlign.slice(-1)[0] === 'a') {
        var _ascentPercentage = parseFloat(yAlign);

        yPos -= contentBounds.ascent * _ascentPercentage;
      } else if (typeof yAlign === 'number') {
        yPos += contentBounds.descent - contentBounds.height * yAlign;
      }

      var offsetToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(offset);
      xPos += offsetToUse.x * scale;
      yPos += offsetToUse.y * scale;
      var locationOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xPos, yPos).sub(contentBounds.left, contentBounds.bottom + contentBounds.descent);
      content.offsetLocation(locationOffset);
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      var useFullSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (useFullSize && this.fullSize != null) {
        return new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]({
          left: this.location.x + this.fullSize.leftOffset,
          right: this.location.x + this.fullSize.leftOffset + this.fullSize.width,
          top: this.location.y + this.fullSize.ascent,
          bottom: this.location.y - this.fullSize.descent,
          width: this.fullSize.width,
          height: this.fullSize.height,
          ascent: this.fullSize.ascent,
          descent: this.fullSize.descent
        });
      }

      return new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]({
        left: this.location.x,
        right: this.location.x + this.width,
        top: this.location.y + this.ascent,
        bottom: this.location.y - this.descent,
        width: this.width,
        height: this.height,
        ascent: this.ascent,
        descent: this.descent
      });
    }
  }]);

  return BaseAnnotationFunction;
}();



/***/ }),

/***/ "./src/js/figure/Equation/Elements/BaseEquationFunction.js":
/*!*****************************************************************!*\
  !*** ./src/js/figure/Equation/Elements/BaseEquationFunction.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseEquationFunction; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Element */ "./src/js/figure/Equation/Elements/Element.js");
/* harmony import */ var _Symbols_SymbolNew__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Symbols/SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

 // import {
//   FigureElementPrimitive, FigureElementCollection,
// } from '../../../Element';



 // import type { ElementInterface } from './Element';
// import Bounds from './Bounds';

var BaseEquationFunction = /*#__PURE__*/function (_Elements) {
  _inherits(BaseEquationFunction, _Elements);

  var _super = _createSuper(BaseEquationFunction);

  // inSize: boolean;
  function BaseEquationFunction(content, glyph, // inSize: boolean = true,
  options) {
    var _this;

    _classCallCheck(this, BaseEquationFunction);

    var glyphElements = [];

    if (Array.isArray(glyph)) {
      glyph.forEach(function (g) {
        glyphElements.push(g != null ? new _Element__WEBPACK_IMPORTED_MODULE_2__["Element"](g) : null);
      });
    } else {
      glyphElements.push(glyph != null ? new _Element__WEBPACK_IMPORTED_MODULE_2__["Element"](glyph) : null);
    }

    var glyphs = [];

    if (Array.isArray(glyph)) {
      glyphs = glyph;
    } else {
      glyphs.push(glyph);
    }

    var contentArray = [];

    if (Array.isArray(content)) {
      contentArray = content;
    } else {
      contentArray.push(content);
    }

    _this = _super.call(this, [].concat(glyphElements, _toConsumableArray(contentArray)));
    _this.glyphs = glyphs;
    _this.contents = contentArray;
    _this.glyphLocations = glyphElements.map(function () {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    });
    _this.glyphWidths = glyphElements.map(function () {
      return 1;
    });
    _this.glyphHeights = glyphElements.map(function () {
      return 1;
    });
    _this.options = options; // this.fullSize = null;

    return _this;
  } // getFullSize(useFullSize: boolean) {
  //   if (useFullSize && this.full != null) {
  //     return {
  //       width: this.fullBounds.width,
  //       height: this.fullBounds.height,
  //       ascent: this.fullBounds.ascent,
  //       descent: this.fullBounds.descent,
  //     };
  //   }
  //   return {
  //     width: this.width,
  //     height: this.height,
  //     ascent: this.ascent,
  //     descent: this.descent,
  //   };
  // }


  _createClass(BaseEquationFunction, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var copyContent = this.contents.map(function (content) {
        return content == null ? null : content._dup(namedCollection);
      });
      var glyphs = this.glyphs; // let copyGlyphs = [];

      if (namedCollection) {
        var newGlyphs = [];
        this.glyphs.forEach(function (g) {
          if (g != null) {
            // $FlowFixMe
            newGlyphs.push(namedCollection[g.name]);
          } else {
            newGlyphs.push(g);
          }
        });
        glyphs = newGlyphs;
      }

      var copy = new this.constructor(copyContent, glyphs, this.options);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, copy, ['content', 'contents', 'glyphs']);
      return copy;
    }
  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];
      this.contents.forEach(function (c) {
        if (c != null) {
          elements = [].concat(_toConsumableArray(elements), _toConsumableArray(c.getAllElements()));
        }
      });
      this.glyphs.forEach(function (g) {
        if (g != null) {
          elements = [].concat(_toConsumableArray(elements), [g]);
        }
      });
      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      var _this2 = this;

      this.glyphs.forEach(function (glyph, index) {
        if (glyph != null) {
          var t = glyph.getTransform()._dup();

          t.updateTranslation(_this2.glyphLocations[index].x, _this2.glyphLocations[index].y);
          t.updateScale(_this2.glyphWidths[index], _this2.glyphHeights[index]);
          glyph.setTransform(t);
        }
      });
      this.contents.forEach(function (content) {
        if (content != null) {
          content.setPositions();
        }
      });
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var _this3 = this;

      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.glyphLocations.forEach(function (glyphLocation, index) {
        if (_this3.glyphs[index] != null) {
          _this3.glyphLocations[index] = glyphLocation.add(offset);
        }
      });
      this.contents.forEach(function (content) {
        if (content != null) {
          content.offsetLocation(offset);
        }
      });
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {// this.location = ;
      // this.glyphLocations[] = ;
      // this.glyphHeights[] = ;
      // this.glyphWidths[] = ;
      // this.width = ;
      // this.ascent = ;
      // this.descent = ;
      // this.height = ;
      // this.fullSize = {
      //   leftOffset: ,
      //   width: ,
      //   ascent: ,
      //   descent: ,
      //   height: ,
      // };
    }
  }]);

  return BaseEquationFunction;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["Elements"]);



/***/ }),

/***/ "./src/js/figure/Equation/Elements/Bounds.js":
/*!***************************************************!*\
  !*** ./src/js/figure/Equation/Elements/Bounds.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bounds; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var Bounds = /*#__PURE__*/function () {
  function Bounds() {
    var boundsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Bounds);

    var defaultBounds = {
      width: 0,
      height: 0,
      ascent: 0,
      descent: 0,
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    var bounds = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])(defaultBounds, boundsIn);
    this.copyFrom(bounds);
  }

  _createClass(Bounds, [{
    key: "toRect",
    value: function toRect() {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](this.left, this.bottom, this.width, this.height);
    }
  }, {
    key: "copyFrom",
    value: function copyFrom(from) {
      if (from.width != null) {
        this.width = from.width;
      }

      if (from.height != null) {
        this.height = from.height;
      }

      if (from.ascent != null) {
        this.ascent = from.ascent;
      }

      if (from.descent != null) {
        this.descent = from.descent;
      }

      if (from.left != null) {
        this.left = from.left;
      }

      if (from.right != null) {
        this.right = from.right;
      }

      if (from.top != null) {
        this.top = from.top;
      }

      if (from.bottom != null) {
        this.bottom = from.bottom;
      }
    }
  }, {
    key: "leftOffset",
    value: function leftOffset(leftDelta) {
      this.left += leftDelta;
      this.width = this.right - this.left;
    }
  }, {
    key: "rightOffset",
    value: function rightOffset(rightDelta) {
      this.right += rightDelta;
      this.width = this.right - this.left;
    }
  }, {
    key: "topOffset",
    value: function topOffset(topDelta) {
      this.top += topDelta;
      this.ascent += topDelta;
      this.height = this.ascent + this.descent;
    }
  }, {
    key: "bottomOffset",
    value: function bottomOffset(bottomDelta) {
      this.bottom += bottomDelta;
      this.descent -= bottomDelta;
      this.height = this.ascent + this.descent;
    }
  }, {
    key: "offset",
    value: function offset(top, right, bottom, left) {
      this.left += left;
      this.right += right;
      this.top += top;
      this.ascent += top;
      this.descent -= bottom;
      this.bottom += bottom;
      this.width = this.right - this.left;
      this.height = this.ascent + this.descent;
    }
  }, {
    key: "growWithSameBaseline",
    value: function growWithSameBaseline(newBounds) {
      var baseline = this.bottom + this.descent;

      if (newBounds.left < this.left) {
        this.left = newBounds.left;
      }

      if (newBounds.right > this.right) {
        this.right = newBounds.right;
      }

      if (newBounds.top > this.top) {
        this.top = newBounds.top;
      }

      if (newBounds.bottom < this.bottom) {
        this.bottom = newBounds.bottom;
      }

      this.width = this.right - this.left;
      this.height = this.top - this.bottom;
      this.ascent = this.top - baseline;
      this.descent = baseline - this.bottom;
    }
  }]);

  return Bounds;
}();



/***/ }),

/***/ "./src/js/figure/Equation/Elements/Container.js":
/*!******************************************************!*\
  !*** ./src/js/figure/Equation/Elements/Container.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Container; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
/* harmony import */ var _BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseEquationFunction */ "./src/js/figure/Equation/Elements/BaseEquationFunction.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var Container = /*#__PURE__*/function (_BaseEquationFunction) {
  _inherits(Container, _BaseEquationFunction);

  var _super = _createSuper(Container);

  function Container() {
    _classCallCheck(this, Container);

    return _super.apply(this, arguments);
  }

  _createClass(Container, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      var _this$options = this.options,
          width = _this$options.width,
          descent = _this$options.descent,
          ascent = _this$options.ascent,
          xAlign = _this$options.xAlign,
          yAlign = _this$options.yAlign,
          fit = _this$options.fit,
          scaleModifier = _this$options.scaleModifier,
          fullContentBounds = _this$options.fullContentBounds;

      var _this$contents = _slicedToArray(this.contents, 1),
          mainContent = _this$contents[0];

      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var containerBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

      if (mainContent != null) {
        mainContent.calcSize(loc._dup(), scale * scaleModifier);
        contentBounds.copyFrom(mainContent.getBounds(fullContentBounds)); // contentBounds.copyFrom(mainContent);

        containerBounds.copyFrom(contentBounds);
      }

      if (width != null) {
        containerBounds.width = width;
      }

      if (descent != null) {
        containerBounds.descent = descent;
      }

      if (ascent != null) {
        containerBounds.ascent = ascent;
      }

      containerBounds.height = containerBounds.descent + containerBounds.ascent;

      if (mainContent != null) {
        if (fit === 'width') {
          mainContent.calcSize(loc._dup(), containerBounds.width / contentBounds.width);
        } else if (fit === 'height') {
          mainContent.calcSize(loc._dup(), containerBounds.height / contentBounds.height);
        } else if (fit === 'contain') {
          var newScale = Math.min(containerBounds.width / contentBounds.width, containerBounds.height / contentBounds.height);
          mainContent.calcSize(loc._dup(), newScale);
        }

        contentBounds.copyFrom(mainContent);
      }

      var contentLoc = loc._dup();

      if (xAlign === 'center') {
        contentLoc.x = loc.x + containerBounds.width / 2 - contentBounds.width / 2;
      } else if (xAlign === 'right') {
        contentLoc.x = loc.x + containerBounds.width - contentBounds.width;
      } else if (typeof xAlign === 'number') {
        contentLoc.x = loc.x + containerBounds.width * xAlign;
      }

      if (yAlign === 'bottom') {
        contentLoc.y = loc.y - containerBounds.descent + contentBounds.descent;
      } else if (yAlign === 'middle') {
        contentLoc.y = loc.y - containerBounds.descent + containerBounds.height / 2 - contentBounds.height / 2 + contentBounds.descent;
      } else if (yAlign === 'top') {
        contentLoc.y = loc.y + containerBounds.ascent - contentBounds.height + contentBounds.descent;
      } else if (typeof yAlign === 'number') {
        contentLoc.y = loc.y - containerBounds.descent + containerBounds.height * yAlign + contentBounds.descent;
      }

      if (mainContent != null) {
        mainContent.offsetLocation(contentLoc.sub(mainContent.location));
      }

      if (mainContent != null) {
        fullBounds.copyFrom(mainContent.getBounds(true));
        fullBounds.growWithSameBaseline(containerBounds);
      } else {
        fullBounds.copyFrom(containerBounds);
      }

      this.width = containerBounds.width;
      this.height = containerBounds.height;
      this.descent = containerBounds.descent;
      this.ascent = containerBounds.ascent;
      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    }
  }]);

  return Container;
}(_BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Elements/Element.js":
/*!****************************************************!*\
  !*** ./src/js/figure/Equation/Elements/Element.js ***!
  \****************************************************/
/*! exports provided: BlankElement, Element, Elements */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlankElement", function() { return BlankElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Element", function() { return Element; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Elements", function() { return Elements; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../tools/FunctionMap */ "./src/js/tools/FunctionMap.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }







// Equation is a class that takes a set of drawing objects (TextObjects,
// FigureElementPrimitives or FigureElementCollections and HTML Objects
// and arranges their size in a )
var BlankElement = /*#__PURE__*/function () {
  function BlankElement() {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.03;
    var ascent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var descent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, BlankElement);

    this.width = width;
    this.ascent = ascent;
    this.descent = descent;
    this.height = this.ascent + this.descent;
  }

  _createClass(BlankElement, [{
    key: "_dup",
    value: function _dup() {
      return new BlankElement(this.width, this.ascent, this.descent);
    }
  }]);

  return BlankElement;
}();

var Element = /*#__PURE__*/function () {
  function Element(content) {
    _classCallCheck(this, Element);

    this.content = content;
    this.ascent = 0;
    this.descent = 0;
    this.width = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.height = 0;
    this.fullSize = {
      leftOffset: 0,
      width: this.width,
      height: this.height,
      ascent: this.ascent,
      descent: this.descent
    };
    this.fnMap = new _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_4__["FunctionMap"]();
  } // execFn(fn: string | Function | null, ...args: Array<any>) {
  //   // if (fn == null) {
  //   //   return null;
  //   // }
  //   // if (typeof fn === 'string') {
  //   //   return this.fnMap.exec(fn, ...args);
  //   // }
  //   // return fn(...args);
  //   return this.fnMap.exec(fn, ...args);
  // }


  _createClass(Element, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      var content = this.content;

      if (content instanceof BlankElement) {
        this.width = content.width * scale;
        this.height = content.height * scale;
        this.ascent = content.ascent * scale;
        this.descent = content.descent * scale;
        this.location = location._dup();
        this.scale = scale;
      }

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["FigureElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["FigureElementPrimitive"]) {
        // Update translation and scale
        content.transform.updateTranslation(location.x, location.y);
        content.transform.updateScale(scale, scale);
        content.updateLastDrawTransform();

        if (content.internalSetTransformCallback != null) {
          this.fnMap.exec(content.internalSetTransformCallback, content.transform);
        } // Get the boundaries of element
        // const r = content.getRelativeVertexSpaceBoundingRect();


        var r = content.getRelativeBoundingRect('draw');
        this.location = location._dup();
        this.scale = scale;
        this.ascent = r.top * scale;
        this.descent = -r.bottom * scale;
        this.height = r.height * scale;
        this.width = r.width * scale;
      }

      this.fullSize = {
        leftOffset: 0,
        width: this.width,
        height: this.height,
        ascent: this.ascent,
        descent: this.descent
      };
    }
  }, {
    key: "_dup",
    value: function _dup(namedCollection) {
      var c;

      if (this.content instanceof BlankElement) {
        c = new Element(this.content);
      } else if (namedCollection) {
        c = new Element(namedCollection[this.content.name]);
      } else {
        c = new Element(this.content);
      }

      c.ascent = this.ascent;
      c.descent = this.descent;
      c.width = this.width;
      c.location = this.location._dup();
      c.height = this.height;
      c.scale = this.scale;
      return c;
    } // getFullSize() {
    //   return this.fullSize;
    // }

  }, {
    key: "getAllElements",
    value: function getAllElements() {
      if (this.content instanceof BlankElement) {
        return [];
      }

      return [this.content];
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      var content = this.content;

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["FigureElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_3__["FigureElementPrimitive"]) {
        content.transform.updateTranslation(this.location.x, this.location.y);
        content.transform.updateScale(this.scale, this.scale);
        content.updateLastDrawTransform();
      }
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
    } // getFullBounds() {
    //   return new Bounds({
    //     left: this.location.x + this.fullSize.leftOffset,
    //     right: this.location.x + this.fullSize.leftOffset + this.fullSize.width,
    //     top: this.location.y + this.fullSize.ascent,
    //     bottom: this.location.y - this.fullSize.descent,
    //     width: this.fullSize.width,
    //     height: this.fullSize.height,
    //     ascent: this.fullSize.ascent,
    //     descent: this.fullSize.descent,
    //   });
    // }

  }, {
    key: "getBounds",
    value: function getBounds() {
      var useFullSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (useFullSize && this.fullSize != null) {
        return new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]({
          left: this.location.x + this.fullSize.leftOffset,
          right: this.location.x + this.fullSize.leftOffset + this.fullSize.width,
          top: this.location.y + this.fullSize.ascent,
          bottom: this.location.y - this.fullSize.descent,
          width: this.fullSize.width,
          height: this.fullSize.height,
          ascent: this.fullSize.ascent,
          descent: this.fullSize.descent
        });
      }

      return new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]({
        left: this.location.x,
        right: this.location.x + this.width,
        top: this.location.y + this.ascent,
        bottom: this.location.y - this.descent,
        width: this.width,
        height: this.height,
        ascent: this.ascent,
        descent: this.descent
      });
    }
  }]);

  return Element;
}();

var Elements = /*#__PURE__*/function () {
  function Elements(content) {
    _classCallCheck(this, Elements);

    var nonNullContent = [];
    content.forEach(function (c) {
      if (c !== null) {
        nonNullContent.push(c);
      }
    });
    this.content = nonNullContent;
    this.ascent = 0;
    this.descent = 0;
    this.width = 0;
    this.location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    this.height = 0;
    this.fnMap = new _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_4__["FunctionMap"]();
  } // execFn(fn: string | Function | null, ...args: Array<any>) {
  //   // if (fn == null) {
  //   //   return null;
  //   // }
  //   // if (typeof fn === 'string') {
  //   //   return this.fnMap.exec(fn, ...args);
  //   // }
  //   // return fn(...args);
  //   return this.fnMap.exec(fn, ...args);
  // }


  _createClass(Elements, [{
    key: "_dup",
    value: function _dup(namedCollection) {
      var contentCopy = [];
      this.content.forEach(function (element) {
        return contentCopy.push(element._dup(namedCollection));
      });
      var c = new Elements(contentCopy);
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, c, ['content']);
      return c;
    }
  }, {
    key: "calcSize",
    value: function calcSize(location, scale) {
      var des = 0;
      var asc = 0;

      var loc = location._dup();

      var fullBounds = null;
      this.content.forEach(function (element) {
        element.calcSize(loc, scale);
        loc.x += element.width;

        if (element.descent > des) {
          des = element.descent;
        }

        if (element.ascent > asc) {
          asc = element.ascent;
        }

        var fullElementBounds = element.getBounds(true);

        if (fullBounds == null) {
          fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]();
          fullBounds.copyFrom(fullElementBounds);
        }
      });

      if (fullBounds === null) {
        fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]();
        fullBounds.left = location.x;
        fullBounds.top = location.y;
        fullBounds.bottom = location.y;
      }

      this.width = loc.x - location.x;
      this.ascent = asc;
      this.descent = des;
      this.location = location._dup();
      this.height = this.descent + this.ascent;
      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    } // getFullBounds() {
    //   // const fullSize = {
    //   //   leftOffset: 0,
    //   //   width: this.width,
    //   //   ascent: this.ascent,
    //   //   descent: this.descent,
    //   //   height: this.height,
    //   // };
    //   // const bounds = new Bounds();
    //   // bounds.width = this.width;
    //   // bounds.left = this.location.x;
    //   // bounds.right = bounds.left + bounds.right;
    //   // bounds.bottom = this.location.y - this.descent;
    //   // bounds.top = this.location.y + this.ascent;
    //   // bounds.ascent = this.ascent;
    //   // bounds.descent = this.descent;
    //   // bounds.height = this.height;
    //   const bounds = new Bounds();
    //   bounds.left = this.location.x;
    //   bounds.bottom = this.location.y;
    //   bounds.top = this.location.y;
    //   this.content.forEach((element) => {
    //     const elementBounds = element.getBounds();
    //     bounds.growWithSameBaseline(elementBounds);
    //   });
    //   return bounds;
    // }

  }, {
    key: "getAllElements",
    value: function getAllElements() {
      var elements = [];
      this.content.forEach(function (e) {
        elements = [].concat(_toConsumableArray(elements), _toConsumableArray(e.getAllElements()));
      });
      return elements;
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      this.content.forEach(function (e) {
        e.setPositions();
      });
    }
  }, {
    key: "offsetLocation",
    value: function offsetLocation() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.location = this.location.add(offset);
      this.content.forEach(function (e) {
        e.offsetLocation(offset);
      });
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      var useFullSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (useFullSize && this.fullSize != null) {
        return new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]({
          left: this.location.x + this.fullSize.leftOffset,
          right: this.location.x + this.fullSize.leftOffset + this.fullSize.width,
          top: this.location.y + this.fullSize.ascent,
          bottom: this.location.y - this.fullSize.descent,
          width: this.fullSize.width,
          height: this.fullSize.height,
          ascent: this.fullSize.ascent,
          descent: this.fullSize.descent
        });
      }

      return new _Bounds__WEBPACK_IMPORTED_MODULE_2__["default"]({
        left: this.location.x,
        right: this.location.x + this.width,
        top: this.location.y + this.ascent,
        bottom: this.location.y - this.descent,
        width: this.width,
        height: this.height,
        ascent: this.ascent,
        descent: this.descent
      });
    }
  }]);

  return Elements;
}();



/***/ }),

/***/ "./src/js/figure/Equation/Elements/Fraction.js":
/*!*****************************************************!*\
  !*** ./src/js/figure/Equation/Elements/Fraction.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Fraction; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
/* harmony import */ var _BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseEquationFunction */ "./src/js/figure/Equation/Elements/BaseEquationFunction.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



 // // Equation is a class that takes a set of drawing objects (TextObjects,
// // FigureElementPrimitives or FigureElementCollections and HTML Objects
// // and arranges their size in a )

var Fraction = /*#__PURE__*/function (_BaseEquationFunction) {
  _inherits(Fraction, _BaseEquationFunction);

  var _super = _createSuper(Fraction);

  function Fraction() {
    _classCallCheck(this, Fraction);

    return _super.apply(this, arguments);
  }

  _createClass(Fraction, [{
    key: "calcSize",
    value: function calcSize(location, incomingScale) {
      this.location = location._dup();

      var loc = location._dup();

      var _this$glyphs = _slicedToArray(this.glyphs, 1),
          vinculum = _this$glyphs[0];

      var _this$contents = _slicedToArray(this.contents, 2),
          numerator = _this$contents[0],
          denominator = _this$contents[1];

      var _this$options = this.options,
          scaleModifier = _this$options.scaleModifier,
          numeratorSpace = _this$options.numeratorSpace,
          denominatorSpace = _this$options.denominatorSpace,
          overhang = _this$options.overhang,
          offsetY = _this$options.offsetY,
          fullContentBounds = _this$options.fullContentBounds,
          baseline = _this$options.baseline;
      var scale = incomingScale * scaleModifier;
      var vinculumBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var numeratorBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var denominatorBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"](); // console.log(numeratorBounds)
      // console.log(denominatorBounds)

      if (numerator != null) {
        numerator.calcSize(loc._dup(), scale);
        numeratorBounds.copyFrom(numerator.getBounds(fullContentBounds));
      }

      if (denominator != null) {
        denominator.calcSize(loc._dup(), scale);
        denominatorBounds.copyFrom(denominator.getBounds(fullContentBounds));
      }

      this.location = location._dup(); // numerator.calcSize(location, scale);
      // denominator.calcSize(location, scale);

      vinculumBounds.width = Math.max(numeratorBounds.width, denominatorBounds.width) + overhang * 2 * scale;

      if (vinculum != null) {
        vinculumBounds.height = vinculum.getHeight(vinculum.custom.options, vinculumBounds.width);
      } // const vSpaceNum = scale * numeratorSpace;
      // const vSpaceDenom = scale * denominatorSpace;


      var lineVAboveBaseline = scale * offsetY / scaleModifier;
      var numeratorLoc = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x + (vinculumBounds.width - numeratorBounds.width) / 2, loc.y + lineVAboveBaseline + vinculumBounds.height + numeratorSpace * scale + numeratorBounds.descent);
      var denominatorLoc = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](loc.x + (vinculumBounds.width - denominatorBounds.width) / 2, loc.y + lineVAboveBaseline - denominatorSpace * scale - denominatorBounds.ascent); // const xNumerator = (vinculumBounds.width - numeratorBounds.width) / 2;
      // const xDenominator = (vinculumBounds.width - denominatorBounds.width) / 2;
      // const lineWidth = Math.max(scale * 0.01, 0.008);
      // const yNumerator = numeratorBounds.descent
      //                     + vSpaceNum + lineVAboveBaseline;
      // const yDenominator = denominatorBounds.ascent
      //                      + vSpaceDenom - lineVAboveBaseline;

      var baselineOffset = 0;

      if (baseline === 'numerator' && numerator != null) {
        baselineOffset = loc.y - numeratorLoc.y;
      } else if (baseline === 'denominator' && denominator != null) {
        baselineOffset = loc.y - denominatorLoc.y;
      }

      if (numerator != null) {
        numerator.offsetLocation(numeratorLoc.sub(numerator.location.x, numerator.location.y - baselineOffset));
      }

      if (denominator != null) {
        denominator.offsetLocation(denominatorLoc.sub(denominator.location.x, denominator.location.y - baselineOffset));
      }

      this.width = vinculumBounds.width;
      this.descent = loc.y - (denominatorLoc.y - denominatorBounds.descent); // vSpaceNum + lineWidth / 2
      //                - lineVAboveBaseline
      //                + denominatorBounds.ascent + denominatorBounds.descent;

      if (this.descent < 0) {
        this.descent = 0;
      }

      this.ascent = numeratorLoc.y + numeratorBounds.ascent - loc.y; // vSpaceNum + lineWidth / 2
      //               + lineVAboveBaseline + numeratorBounds.ascent
      //               + numeratorBounds.descent;

      this.height = this.descent + this.ascent;
      this.glyphLocations[0] = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.location.x, this.location.y + lineVAboveBaseline + baselineOffset);
      this.glyphWidths[0] = vinculumBounds.width;
      this.glyphHeights[0] = vinculumBounds.height;
      fullBounds.copyFrom(vinculumBounds);
      fullBounds.left = this.glyphLocations[0].x;
      fullBounds.bottom = this.glyphLocations[0].y;

      if (numerator != null) {
        fullBounds.growWithSameBaseline(numerator.getBounds(true));
      }

      if (denominator != null) {
        fullBounds.growWithSameBaseline(denominator.getBounds(true));
      }

      if (vinculum) {
        vinculum.custom.setSize(this.glyphLocations[0], vinculumBounds.width, vinculumBounds.height);
      }

      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    }
  }]);

  return Fraction;
}(_BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Elements/Matrix.js":
/*!***************************************************!*\
  !*** ./src/js/figure/Equation/Elements/Matrix.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Element */ "./src/js/figure/Equation/Elements/Element.js");
/* harmony import */ var _BaseEquationFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BaseEquationFunction */ "./src/js/figure/Equation/Elements/BaseEquationFunction.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






function getMaxAscentDescent(numRows, numCols, matrix, bounds) {
  var rowAscents = [];
  var rowDescents = [];
  var rowHeights = [];
  var maxAscent = 0;
  var maxDescent = 0;
  var maxHeight = 0;

  for (var row = 0; row < numRows; row += 1) {
    var rowMaxAscent = 0;
    var rowMaxDescent = 0; // let rowMaxHeight = 0;

    for (var col = 0; col < numCols; col += 1) {
      var bound = bounds[row][col];

      if (bound.ascent > rowMaxAscent || col === 0) {
        rowMaxAscent = bound.ascent;
      }

      if (bound.descent > rowMaxDescent || col === 0) {
        rowMaxDescent = bound.descent;
      }
    }

    if (rowMaxAscent > maxAscent || row === 0) {
      maxAscent = rowMaxAscent;
    }

    if (rowMaxDescent > maxDescent || row === 0) {
      maxDescent = rowMaxDescent;
    }

    var rowMaxHeight = rowMaxDescent + rowMaxAscent;

    if (rowMaxHeight > maxHeight || row === 0) {
      maxHeight = rowMaxHeight;
    }

    rowHeights.push(rowMaxHeight);
    rowAscents.push(rowMaxAscent);
    rowDescents.push(rowMaxDescent);
  }

  return {
    ascents: rowAscents,
    descents: rowDescents,
    heights: rowHeights,
    maxAscent: maxAscent,
    maxDescent: maxDescent,
    maxHeight: maxHeight
  };
}

function getMaxColWidth(numRows, numCols, matrix, bounds) {
  var colWidths = [];
  var maxWidth = 0;

  for (var col = 0; col < numCols; col += 1) {
    var maxColWidth = 0;

    for (var row = 0; row < numRows; row += 1) {
      var elementWidth = bounds[row][col].width;

      if (elementWidth > maxColWidth) {
        maxColWidth = elementWidth;
      }

      if (elementWidth > maxWidth) {
        maxWidth = elementWidth;
      }
    }

    colWidths.push(maxColWidth);
  }

  return [colWidths, maxWidth];
} // Matrix is centered in y.


var Matrix = /*#__PURE__*/function (_BaseEquationFunction) {
  _inherits(Matrix, _BaseEquationFunction);

  var _super = _createSuper(Matrix);

  function Matrix() {
    _classCallCheck(this, Matrix);

    return _super.apply(this, arguments);
  }

  _createClass(Matrix, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      var aboveBaseline = scale * 0.07;
      var _this$options = this.options,
          order = _this$options.order,
          fit = _this$options.fit,
          space = _this$options.space,
          contentScale = _this$options.contentScale,
          yAlign = _this$options.yAlign,
          fullContentBounds = _this$options.fullContentBounds;

      var _order = _slicedToArray(order, 2),
          numRows = _order[0],
          numCols = _order[1];

      var bounds = [];
      var locs = [];
      var index = 0;
      var matrix = [];

      for (var row = 0; row < numRows; row += 1) {
        matrix.push([]);
        bounds.push([]);
        locs.push([]);

        for (var col = 0; col < numCols; col += 1) {
          var elementBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
          var element = this.contents[index];

          if (element != null) {
            element.calcSize(loc._dup(), scale * contentScale);
            elementBounds.copyFrom(element.getBounds(fullContentBounds));
          }

          matrix[row].push(element);
          bounds[row].push(elementBounds);
          locs[row].push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
          index += 1;
        }
      }

      var rowBounds = getMaxAscentDescent(numRows, numCols, matrix, bounds);

      var _getMaxColWidth = getMaxColWidth(numRows, numCols, matrix, bounds),
          _getMaxColWidth2 = _slicedToArray(_getMaxColWidth, 2),
          colWidths = _getMaxColWidth2[0],
          maxWidth = _getMaxColWidth2[1];

      var maxDim = Math.max(maxWidth, rowBounds.maxHeight);

      if (fit !== 'min') {
        var dim;

        if (fit === 'max') {
          dim = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](maxDim, maxDim);
        } else {
          dim = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(fit);

          if (dim == null) {
            dim = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
          }
        }

        for (var _row = 0; _row < numRows; _row += 1) {
          rowBounds.heights[_row] = dim.y;
        }

        for (var _col = 0; _col < numCols; _col += 1) {
          colWidths[_col] = dim.x;
        }
      }

      var cumHeight = 0;
      var cumWidth = 0;

      for (var _row2 = numRows - 1; _row2 >= 0; _row2 -= 1) {
        cumWidth = 0;

        for (var _col2 = 0; _col2 < numCols; _col2 += 1) {
          var bound = bounds[_row2][_col2];
          var x = cumWidth + colWidths[_col2] / 2 - bound.width / 2;
          var y = cumHeight + rowBounds.heights[_row2] / 2 - (bound.ascent - bound.descent) / 2;

          if (yAlign === 'baseline') {
            y = cumHeight + rowBounds.descents[_row2];
          }

          cumWidth += colWidths[_col2] + space.x * scale;
          locs[_row2][_col2] = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x, y);
        }

        if (yAlign === 'baseline') {
          cumHeight += rowBounds.descents[_row2] + rowBounds.ascents[_row2] + space.y * scale;
        } else {
          cumHeight += rowBounds.heights[_row2] + space.y * scale;
        }
      }

      var totalHeight = cumHeight - space.y * scale;
      var totalWidth = cumWidth - space.x * scale;
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

      for (var _row3 = 0; _row3 < numRows; _row3 += 1) {
        for (var _col3 = 0; _col3 < numCols; _col3 += 1) {
          locs[_row3][_col3].x += loc.x;
          locs[_row3][_col3].y = loc.y - totalHeight / 2 + locs[_row3][_col3].y + aboveBaseline;
          var _element = matrix[_row3][_col3];

          if (_element != null) {
            _element.offsetLocation(locs[_row3][_col3].sub(_element.location));

            if (fullBounds.width === 0) {
              fullBounds.copyFrom(_element.getBounds(true));
            }

            fullBounds.growWithSameBaseline(_element.getBounds(true));
          }
        }
      }

      this.width = totalWidth;
      this.height = totalHeight;
      this.descent = totalHeight / 2 - aboveBaseline;
      this.ascent = totalHeight / 2 + aboveBaseline;
      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    }
  }]);

  return Matrix;
}(_BaseEquationFunction__WEBPACK_IMPORTED_MODULE_3__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Elements/Scale.js":
/*!**************************************************!*\
  !*** ./src/js/figure/Equation/Elements/Scale.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Scale; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
/* harmony import */ var _BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseEquationFunction */ "./src/js/figure/Equation/Elements/BaseEquationFunction.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var Scale = /*#__PURE__*/function (_BaseEquationFunction) {
  _inherits(Scale, _BaseEquationFunction);

  var _super = _createSuper(Scale);

  function Scale() {
    _classCallCheck(this, Scale);

    return _super.apply(this, arguments);
  }

  _createClass(Scale, [{
    key: "calcSize",
    value: function calcSize(location, scale) {
      this.location = location._dup();

      var loc = location._dup();

      var _this$options = this.options,
          scaleModifier = _this$options.scaleModifier,
          fullContentBounds = _this$options.fullContentBounds;

      var _this$contents = _slicedToArray(this.contents, 1),
          mainContent = _this$contents[0];

      var contentBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();
      var fullBounds = new _Bounds__WEBPACK_IMPORTED_MODULE_1__["default"]();

      if (mainContent != null) {
        mainContent.calcSize(loc._dup(), scale * scaleModifier);
        contentBounds.copyFrom(mainContent.getBounds(fullContentBounds));
        fullBounds.copyFrom(mainContent.getBounds(true));
      }

      this.width = contentBounds.width;
      this.height = contentBounds.height;
      this.descent = contentBounds.descent;
      this.ascent = contentBounds.ascent;
      this.fullSize = {
        leftOffset: this.location.x - fullBounds.left,
        width: fullBounds.width,
        ascent: fullBounds.ascent,
        descent: fullBounds.descent,
        height: fullBounds.height
      };
    }
  }]);

  return Scale;
}(_BaseEquationFunction__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Equation.js":
/*!********************************************!*\
  !*** ./src/js/figure/Equation/Equation.js ***!
  \********************************************/
/*! exports provided: Equation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Equation", function() { return Equation; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DrawingObjects/TextObject/TextObject */ "./src/js/figure/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/figure/Equation/Elements/Element.js");
/* harmony import */ var _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Elements/BaseAnnotationFunction */ "./src/js/figure/Equation/Elements/BaseAnnotationFunction.js");
/* harmony import */ var _EquationForm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EquationForm */ "./src/js/figure/Equation/EquationForm.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _EquationSymbols__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EquationSymbols */ "./src/js/figure/Equation/EquationSymbols.js");
/* harmony import */ var _EquationFunctions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EquationFunctions */ "./src/js/figure/Equation/EquationFunctions.js");
/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Animation/Animation */ "./src/js/figure/Animation/Animation.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


 // import { RGBToArray } from '../../tools/color';






// import HTMLObject from '../DrawingObjects/HTMLObject/HTMLObject';

 // import type { TypeSymbolOptions } from './EquationSymbols';




/**
 * Next form animation step
 *
 * ![](./apiassets/nextformanimationstep.gif)
 *
 * Animation step that animates to the next equation form in a formSeries.
 * Equivalent to a triggering a
 * <a href="#equationnextform">Equation.nextForm</a> call.
 *
 * This animation step is only available in {@link Equation}.
 *
 * @extends TriggerAnimationStep
 * @param {OBJ_NextFormAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#equation-boilerplate">boilerplate</a>
 *
 * @example
 * // Example showing both ways to access GoToForm animation step
 * figure.add({
 *   name: 'eqn',
 *   method: 'equation',
 *   options: {
 *     elements: { times: ' \u00D7', equals: ' = ' },
 *     forms: {
 *       0: ['a', 'equals', 'b', 'times', ' ', '_1'],
 *       1: ['a', 'equals', 'b', 'times', { strike: [[' ', '_1'], 'strike'] }],
 *       2: ['a', 'equals', 'b'],
 *     },
 *     formSeries: ['0', '1', '2'],
 *   },
 * });
 * const e = figure.getElement('eqn');
 * e.showForm('0');
 * e.animations.new()
 *   .delay(2)
 *   .inParallel([
 *     e.animations.nextForm({ animate: 'move', duration: 1 }),
 *     e._times.animations.dim({ duration: 1 }),
 *     e.__1.animations.dim({ duration: 1 }),
 *   ])
 *   .delay(1)
 *   .nextForm({ animate: 'move', duration: 1 })
 *   .start();
 */
// eslint-disable-next-line no-unused-vars
var NextFormAnimationStep = /*#__PURE__*/function (_TriggerAnimationStep) {
  _inherits(NextFormAnimationStep, _TriggerAnimationStep);

  var _super = _createSuper(NextFormAnimationStep);

  function NextFormAnimationStep() {
    _classCallCheck(this, NextFormAnimationStep);

    return _super.apply(this, arguments);
  }

  return NextFormAnimationStep;
}(_Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["TriggerAnimationStep"]);
/**
 * GoToForm form animation step
 *
 * ![](./apiassets/gotoformanimationstep.gif)
 *
 * Animation step that animates moving between equation forms. Equivalent to
 * a triggering a <a href="#equationgotoform">Equation.goToForm</a> call.
 *
 * This animation step is only available in {@link Equation}.
 *
 * @extends TriggerAnimationStep
 * @param {OBJ_GoToFormAnimationStep} options
 *
 * @see To test examples, append them to the
 * <a href="#equation-boilerplate">boilerplate</a>
 *
 * @example
 * // Example showing both ways to access GoToForm animation step
 * figure.add({
 *   name: 'eqn',
 *   method: 'equation',
 *   options: {
 *     elements: { times: ' \u00D7', equals: ' = ' },
 *     forms: {
 *       0: ['a', 'equals', 'b', 'times', ' ', '_1'],
 *       1: ['a', 'equals', 'b', 'times', { strike: [[' ', '_1'], 'strike'] }],
 *       2: ['a', 'equals', 'b'],
 *     }
 *   },
 * });
 * const e = figure.getElement('eqn');
 * e.showForm('0');
 * e.animations.new()
 *   .delay(2)
 *   .inParallel([
 *     e.animations.goToForm({ target: '1', animate: 'move' }),
 *     e._times.animations.dim({ duration: 1 }),
 *     e.__1.animations.dim({ duration: 1 }),
 *   ])
 *   .delay(1)
 *   .goToForm({ target: '2', animate: 'move' })
 *   .start();
 */
// eslint-disable-next-line no-unused-vars


var GoToFormAnimationStep = /*#__PURE__*/function (_TriggerAnimationStep2) {
  _inherits(GoToFormAnimationStep, _TriggerAnimationStep2);

  var _super2 = _createSuper(GoToFormAnimationStep);

  function GoToFormAnimationStep() {
    _classCallCheck(this, GoToFormAnimationStep);

    return _super2.apply(this, arguments);
  }

  return GoToFormAnimationStep;
}(_Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["TriggerAnimationStep"]); // export const foo = () => {};
// An Equation is a collection of elements that can be arranged into different
// forms.
// Equation allows setting of forms, and navigating through form series
// Eqn manages different forms of the

/**
 * An Equation is a collection of elements that can be arranged into different
 * forms.
 *
 * `Equation` should be instantiated from an *object definition*, or from
 * the `figure.primitives.equation` method.
 *
 * Equation includes two additional animation steps in {@link Equation.animations}:
 * * {@link GoToFormAnimationStep}
 * * {@link NextFormAnimationStep}
 *
 * @extends FigureElementCollection
 *
 * @see To test examples, append them to the
 * <a href="#equation-boilerplate">boilerplate</a>
 *
 * @param {EQN_Equation} options
 * @example
 * // Create with options definition
 * figure.add({
 *   name: 'eqn',
 *   method: 'equation',
 *   options: {
 *     elements: {
 *       a: 'a',
 *       b: { color: [0, 0, 1, 1] },
 *       c: 'c',
 *       equals: ' = ',
 *       plus: ' + ',
 *     },
 *     forms: {
 *       1: ['a', 'equals', 'b', 'plus', 'c'],
 *     },
 *   },
 * });
 *
 * @example
 * // Create with methods
 * const eqn = figure.collections.equation();
 * eqn.addElements({
 *   a: 'a',
 *   b: { color: [0, 0, 1, 1] },
 *   c: 'c',
 *   equals: ' = ',
 *   plus: ' + ',
 * });
 * eqn.addForms({
 *   1: ['a', 'equals', 'b', 'plus', 'c'],
 * });
 * figure.add('eqn', eqn);
 * eqn.showForm('1');
 */
// $FlowFixMe


var Equation = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(Equation, _FigureElementCollect);

  var _super3 = _createSuper(Equation);

  /**
   * Equation parameters and functions
   * @property {EquationFunctions} functions - equation functions
   */

  /**
   * {@link AnimationManager} extended to include additional animation steps
   * specific to equations
   * @property {NextFormAnimationStep} nextForm
   * @property {GoToFormAnimationStep} goToForm
   * @extends AnimationManager
   */
  // isTouchDevice: boolean;
  // animateNextFrame: void => void;

  /**
   * @hideconstructor
   */
  function Equation(shapes) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Equation);

    var color = options.color;

    if (color == null) {
      color = shapes.defaultColor;
    }

    var dimColor = options.dimColor;

    if (dimColor == null) {
      dimColor = shapes.defaultDimColor.slice();
    }

    var defaultFont = {
      family: 'Times New Roman',
      style: 'normal',
      size: 0.2,
      weight: '200',
      color: color
    };
    var defaultOptions = {
      color: color,
      dimColor: dimColor,
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      scale: 0.7,
      formDefaults: {
        alignment: {
          fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
          xAlign: 'left',
          yAlign: 'baseline'
        },
        elementMods: {}
      },
      elements: {},
      forms: {},
      // formSeries: {},
      formRestart: null,
      limits: shapes.limits,
      touchBorder: 'rect',
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Equation').scale(1, 1).rotate(0).translate(0, 0)
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjectsWithOptions"])({
      except: ['font']
    }, {}, defaultOptions, options);

    if (options.font instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_3__["FigureFont"]) {
      optionsToUse.font = options.font;
    } else if (options.font != null) {
      optionsToUse.font = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_3__["FigureFont"](Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultFont, options.font));
    } else {
      optionsToUse.font = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_3__["FigureFont"](defaultFont);
    }

    if (optionsToUse.transform != null) {
      optionsToUse.transform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(optionsToUse.transform);
    }

    optionsToUse.formDefaults.alignment.fixTo = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(optionsToUse.formDefaults.alignment.fixTo, optionsToUse.formDefaults.alignment.fixTo); // optionsToUse.defaultFormAlignment.fixTo = parsePoint(
    //   optionsToUse.defaultFormAlignment.fixTo,
    //   optionsToUse.defaultFormAlignment.fixTo,
    // );

    if (optionsToUse.formRestart != null && optionsToUse.formRestart.pulse != null) {
      optionsToUse.formRestart.pulse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
        scale: 1.1,
        duration: 1
      }, optionsToUse.formRestart.pulse);
    }

    _this = _super3.call(this, optionsToUse); // if (optionsToUse.transform != null) {
    //   this.setTransform(getTransform(optionsToUse.transform));
    // }

    _this.shapes = shapes;

    _this.setColor(optionsToUse.color);

    _this.dimColor = optionsToUse.dimColor; // this.touchBorder = 'rect';
    // this.border = 'children';
    // this.isTouchDevice = isTouchDevice;
    // this.animateNextFrame = animateNextFrame;
    // Set default values

    _this.eqn = {
      forms: {},
      currentForm: '',
      // currentSubForm: '',
      // subFormPriority: ['base'],
      formSeries: {
        base: []
      },
      currentFormSeries: [],
      currentFormSeriesName: '',
      scale: optionsToUse.scale,
      // defaultFormAlignment: optionsToUse.defaultFormAlignment,
      formDefaults: {
        alignment: optionsToUse.formDefaults.alignment,
        elementMods: optionsToUse.formDefaults.elementMods,
        // animation: optionsToUse.formDefaults.animation,
        duration: optionsToUse.formDefaults.duration,
        translation: optionsToUse.formDefaults.translation
      },
      functions: new _EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["EquationFunctions"](_this.elements, _this.addElementFromKey.bind(_assertThisInitialized(_this)), _this.getExistingOrAddSymbol.bind(_assertThisInitialized(_this))),
      symbols: new _EquationSymbols__WEBPACK_IMPORTED_MODULE_8__["default"](_this.shapes, _this.color),
      font: optionsToUse.font,
      // fontText: optionsToUse.fontText,
      isAnimating: false,
      descriptionElement: null,
      descriptionPosition: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      formRestart: optionsToUse.formRestart
    };

    if (optionsToUse.elements != null) {
      _this.addElements(optionsToUse.elements);
    }

    if (optionsToUse.phrases != null) {
      _this.addPhrases(optionsToUse.phrases);
    }

    if (optionsToUse.forms != null) {
      _this.addForms(optionsToUse.forms);
    }

    if (optionsToUse.initialForm != null) {
      _this.initialForm = optionsToUse.initialForm;
    }

    if (optionsToUse.formSeries != null) {
      if (Array.isArray(optionsToUse.formSeries)) {
        _this.eqn.formSeries = {
          base: optionsToUse.formSeries
        };
        _this.eqn.currentFormSeries = _this.eqn.formSeries.base;
        _this.eqn.currentFormSeriesName = 'base';
      } else {
        _this.eqn.formSeries = optionsToUse.formSeries;

        if (optionsToUse.defaultFormSeries != null) {
          _this.setFormSeries(optionsToUse.defaultFormSeries);
        } else {
          _this.setFormSeries(Object.keys(_this.eqn.formSeries)[0]);
        }
      }
    } else {
      _this.eqn.formSeries = {
        base: Object.keys(_this.eqn.forms).slice()
      };
      _this.eqn.currentFormSeries = _this.eqn.formSeries.base;
      _this.eqn.currentFormSeriesName = 'base';
    }

    _this.animations.goToForm = function () {
      for (var _len = arguments.length, opt = new Array(_len), _key = 0; _key < _len; _key++) {
        opt[_key] = arguments[_key];
      }

      var o = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
        element: _assertThisInitialized(_this),
        duration: 1
      }].concat(opt));

      if (o.callback != null) {
        o.done = o.callback;
      }

      o.callback = function () {
        var currentForm = _this.getCurrentForm();

        if (currentForm != null) {
          if (o.start == null) {
            o.start = currentForm.name;
          }

          if (o.target == null) {
            o.target = currentForm.name;
          }
        }

        _this.showForm(o.start);

        _this.goToForm(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, o, {
          form: o.target,
          callback: null,
          delay: 0
        }));

        return _this.getRemainingAnimationTime(['_Equation', '_EquationColor']);
      };

      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["TriggerAnimationStep"](o);
    };

    _this.animations.customSteps.push({
      step: _this.animations.goToForm.bind(_assertThisInitialized(_this)),
      name: 'goToForm'
    });

    _this.animations.nextForm = function () {
      for (var _len2 = arguments.length, opt = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        opt[_key2] = arguments[_key2];
      }

      var o = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
        element: _assertThisInitialized(_this),
        duration: 1 // need a non zero duration so trigger can incorporate the new duration

      }].concat(opt));

      if (o.callback != null) {
        o.done = o.callback;
      }

      o.callback = function () {
        _this.nextForm(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, o, {
          callback: null,
          delay: 0
        }));

        return _this.getRemainingAnimationTime(['_Equation', '_EquationColor']);
      };

      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_10__["TriggerAnimationStep"](o);
    };

    _this.animations.customSteps.push({
      step: _this.animations.nextForm.bind(_assertThisInitialized(_this)),
      name: 'nextForm'
    });

    return _this;
  }

  _createClass(Equation, [{
    key: "setFigure",
    value: function setFigure(figure) {
      _get(_getPrototypeOf(Equation.prototype), "setFigure", this).call(this, figure);

      if (this.initialForm != null) {
        this.showForm(this.initialForm);
      }
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties(options) {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(Equation.prototype), "_getStateProperties", this).call(this, options)), ['eqn.currentForm', // 'eqn.currentSubForm',
      'eqn.isAnimating', 'eqn.currentFormSeries', 'eqn.currentFormSeriesName']);
    }
  }, {
    key: "_getStatePropertiesMin",
    value: function _getStatePropertiesMin() {
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(Equation.prototype), "_getStatePropertiesMin", this).call(this)), ['eqn.currentForm' // 'eqn.currentSubForm',
      ]);
    } // animateToState(
    //   state: Object,
    //   options: Object,
    //   independentOnly: boolean = false,
    //   // countStart: () => void,
    //   // countEnd: () => void,
    // ) {
    //   super.animateToState(state, options, independentOnly);
    //   if (this.eqn.currentForm !== state.eqn.currentForm) {
    //     // countStart();
    //     this.goToForm({ name: state.eqn.currentForm, callback: countEnd });
    //   }
    // }

    /**
      * Set the current form series to 'name'
     */

  }, {
    key: "setFormSeries",
    value: function setFormSeries(name) {
      if (this.eqn.formSeries[name] != null) {
        this.eqn.currentFormSeries = this.eqn.formSeries[name];
        this.eqn.currentFormSeriesName = name;
      }
    }
    /**
      * Get the current form series name
     */

  }, {
    key: "getFormSeries",
    value: function getFormSeries() {
      return this.eqn.currentFormSeriesName;
    }
  }, {
    key: "layoutForms",
    value: function layoutForms(forms) {
      var _this2 = this;

      if (forms === 'none') {
        return;
      }

      var arrange = function arrange(formName) {
        var form = _this2.eqn.forms[formName];
        var _form$arranged = form.arranged,
            scale = _form$arranged.scale,
            xAlign = _form$arranged.xAlign,
            yAlign = _form$arranged.yAlign,
            fixTo = _form$arranged.fixTo;
        form.arrange(scale, xAlign, yAlign, fixTo);
      };

      if (forms === 'current') {
        arrange(this.eqn.currentForm);
        return;
      }

      Object.keys(this.eqn.forms).forEach(function (formName) {
        arrange(formName);
      });
      this.showForm(this.eqn.currentForm);
    }
    /**
     * Update text of equation element or elements
     *
     * @param {EQN_UpdateElementText} elements elements to update
     * @param {'all' | 'current' | 'none'} [layoutForms] which forms to re-layout
     * with the updated text
     */

  }, {
    key: "updateElementText",
    value: function updateElementText(elements) {
      var _this3 = this;

      var layoutForms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'none';
      Object.keys(elements).forEach(function (elementName) {
        var e = _this3.getElement(elementName);

        if (e == null) {
          return;
        }

        var col = e.color.slice();
        e.custom.updateText({
          text: elements[elementName]
        });
        e.setColor(col);
      });
      this.layoutForms(layoutForms);
    }
  }, {
    key: "makeTextElem",
    value: function makeTextElem(options) {
      var defaultText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var textToUse = defaultText;

      if (options.text != null) {
        textToUse = options.text;
      }

      var defaultFontDefinition = this.eqn.font.definition();
      var fontDefinition = defaultFontDefinition;

      if (options.font != null && options.font instanceof _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_3__["FigureFont"]) {
        fontDefinition = options.font.definition();
      } else {
        fontDefinition = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultFontDefinition, {
          style: options.style,
          weight: options.weight,
          family: options.family,
          size: options.size,
          color: options.color
        }, options.font);
      }

      if (options.style == null && (options.font != null && options.font.style == null || options.font == null)) {
        if (textToUse.match(/[A-Z,a-z,\u0370-\u03ff]/)) {
          fontDefinition.style = 'italic';
        } else {
          fontDefinition.style = 'normal';
        }
      }

      if (fontDefinition.color == null) {
        fontDefinition.color = this.color;
      } // console.log(textToUse, fontDefinition)
      // const font = new FigureFont(fontDefinition);


      var p = this.shapes.text({
        text: {
          text: textToUse,
          touchBorder: 0 // touchBorder: options.touchBorder == null ? 0 : options.touchBorder,

        },
        position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        font: fontDefinition,
        xAlign: 'left',
        yAlign: 'baseline',
        touchBorder: 'buffer',
        mods: {
          dimColor: this.dimColor.slice()
        } // border: 'draw',
        // touchBorder: options.touchBorder == null ? 'buffer' : options.touchBorder,
        // defaultTextTouchBorder: options.defaultTextTouchBorder,

      });

      if (options.touchBorder != null) {
        p.touchBorder = options.touchBorder;
      }

      if (options.isTouchable != null) {
        p.isTouchable = options.isTouchable;
      }

      if (options.onClick != null) {
        p.onClick = options.onClick;
      }

      if (options.mods != null) {
        p.setProperties(options.mods);
      }

      return p;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getTextFromKey",
    value: function getTextFromKey(key) {
      return key.replace(/^_*/, '').replace(/_.*/, '');
    }
  }, {
    key: "getExistingOrAddSymbol",
    value: function getExistingOrAddSymbol(symbol) {
      if (typeof symbol === 'string') {
        return this.getExistingOrAddSymbolFromKey(symbol, {});
      }

      var _Object$entries$ = _slicedToArray(Object.entries(symbol)[0], 2),
          key = _Object$entries$[0],
          params = _Object$entries$[1]; // $FlowFixMe


      return this.getExistingOrAddSymbolFromKey(key, params);
    } // 'text'
    // 'text_id'
    // 'id_symbol'
    // 'id_id_symbol'
    // 'symbol'

  }, {
    key: "getExistingOrAddSymbolFromKey",
    value: function getExistingOrAddSymbolFromKey(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var existingElement = this.getElement(key);

      if (existingElement != null) {
        return existingElement;
      } // console.log(this.name, key, this.dimColor.slice())
      // Check if the options has a symbol definition


      if (options.symbol != null && typeof options.symbol === 'string') {
        // debugger;
        var _symbol = this.makeSymbolElem(options);

        if (_symbol != null) {
          // symbol.dimColor = this.dimColor.slice();
          this.add(key, _symbol);
          return _symbol;
        }
      } // Check the key is a symbol


      var cleanKey = key.replace(/^_*/, ''); // console.log(cleanKey)

      var symbol = this.eqn.symbols.get(cleanKey, options);

      if (symbol != null) {
        // symbol.dimColor = this.dimColor.slice();
        if (symbol.color[3] > 0.01) {
          symbol.setColor(this.color);
        }

        if (options.mods != null) {
          symbol.setProperties(options.mods);
        }

        this.add(key, symbol);
        return symbol;
      }

      var ending = cleanKey.match(/_[^_]*$/); // console.log(ending)

      if (ending != null) {
        symbol = this.eqn.symbols.get(ending[0].replace(/_/, ''), options);

        if (symbol != null) {
          // symbol.dimColor = this.dimColor.slice();
          if (symbol.color[3] > 0.01) {
            symbol.setColor(this.color);
          }

          if (options.mods != null) {
            symbol.setProperties(options.mods);
          }

          this.add(key.replace(/_[^_]*$/, ''), symbol);
          return symbol;
        }
      }

      return null;
    }
  }, {
    key: "addElementFromKey",
    value: function addElementFromKey(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var element = this.getExistingOrAddSymbolFromKey(key, options);

      if (element != null) {
        return element;
      }

      var cleanKey = key.replace(/^_*/, '');
      var text = cleanKey.replace(/_.*/, '');
      element = this.makeTextElem(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({
        text: text
      }, options));
      this.add(key, element);
      return element;
    } // addElementFromObject(key: string, options: Object) {
    //   if (typeof key !== 'string') {
    //     return null;
    //   }
    //   const existingElement = this.getElement(key);
    //   if (existingElement != null) {
    //     return existingElement;
    //   }
    //   const text = this.getTextFromKey(key);
    //   const element = this.makeTextElem({ text });
    //   this.add(key, element);
    //   return element;
    // }

  }, {
    key: "makeSymbolElem",
    value: function makeSymbolElem(options) {
      var symbol = this.eqn.symbols.get(options.symbol, options);

      if (symbol == null) {
        symbol = this.makeTextElem({
          text: "Symbol ".concat(options.symbol, " not valid")
        });
      }

      if (options.color == null && symbol.color[3] > 0.01) {
        symbol.setColor(this.color);
      }

      symbol.dimColor = this.dimColor.slice();

      if (options.mods != null) {
        symbol.setProperties(options.mods);
      }

      return symbol;
    }
    /**
     * Add elements to equation.
     */

  }, {
    key: "addElements",
    value: function addElements(elems) {
      var _this4 = this;

      // Go through each element and add it
      Object.keys(elems).forEach(function (key) {
        // const [key, elem] = entry;
        var elem = elems[key];

        if (typeof elem === 'string') {
          if (!(key.startsWith('space') && key.startsWith(' '))) {
            _this4.add(key, _this4.makeTextElem({
              text: elem
            }));
          }
        } else if (elem instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementPrimitive"]) {
          _this4.add(key, elem);
        } else if (elem instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]) {
          _this4.add(key, elem);
        } else {
          var figureElem; // $FlowFixMe

          if (elem.symbol != null && typeof elem.symbol === 'string') {
            // console.log(elem.symbol)
            // $FlowFixMe
            figureElem = _this4.makeSymbolElem(elem);
          } else {
            // $FlowFixMe
            figureElem = _this4.makeTextElem(elem, _this4.getTextFromKey(key));
          }

          if (figureElem != null) {
            if (elem.mods != null) {
              figureElem.setProperties(elem.mods);
            }

            _this4.add(key, figureElem);
          }
        }
      });
      var fullLineHeightPrimitive = this.makeTextElem({
        text: 'gh'
      });
      var form = this.createForm({
        elem: fullLineHeightPrimitive
      });
      form.content = [this.eqn.functions.contentToElement(fullLineHeightPrimitive)];
      form.arrange(this.eqn.scale, 'left', 'baseline', new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      this.eqn.functions.fullLineHeight = form;
      this.setFirstTransform(this.transform);
    }
  }, {
    key: "addDescriptionElement",
    value: function addDescriptionElement() {
      var descriptionElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var descriptionPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.eqn.descriptionElement = descriptionElement;
      this.eqn.descriptionPosition = descriptionPosition;

      if (this.eqn.descriptionElement) {
        this.eqn.descriptionElement.setPosition(this.getPosition('figure').add(descriptionPosition));
      }
    }
  }, {
    key: "setPosition",
    value: function setPosition(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _get(_getPrototypeOf(Equation.prototype), "setPosition", this).call(this, pointOrX, y);

      var position = this.getPosition('figure'); // console.log(this.eqn, this.eqn.descriptionElement)

      if (this.eqn.descriptionElement != null) {
        this.eqn.descriptionElement.setPosition(position.add(this.eqn.descriptionPosition));
      }
    } // scaleForm(name: string, scale: number, subForm: string = 'base') {
    //   // console.log(name, this.form, formType, this.form[name][formType])
    //   if (name in this.eqn.forms) {
    //     if (subForm in this.eqn.forms[name]) {
    //       this.eqn.forms[name][subForm].arrange(
    //         scale,
    //         this.eqn.formAlignment.xAlign,
    //         this.eqn.formAlignment.yAlign,
    //         this.eqn.formAlignment.fixTo,
    //       );
    //     }
    //   }
    // }
    // scale(scale: number) {
    //   Object.keys(this.form).forEach((name) => {
    //     Object.keys(this.form[name]).forEach((formType) => {
    //       if (formType !== 'name') {
    //         this.scaleForm(name, scale, formType);
    //       }
    //     });
    //   });
    // }

  }, {
    key: "addPhrases",
    value: function addPhrases(phrases) {
      var _this5 = this;

      Object.keys(phrases).forEach(function (phraseName) {
        var phrase = phrases[phraseName];
        _this5.eqn.functions.phrases[phraseName] = phrase;
      });
    }
    /**
     * Add forms to equation.
     */

  }, {
    key: "addForms",
    value: function addForms(forms) {
      var _this6 = this;

      var isFormString = function isFormString(form) {
        return typeof form === 'string';
      };

      var isFormArray = function isFormArray(form) {
        return Array.isArray(form);
      };

      var isFormMethodDefinition = function isFormMethodDefinition(form) {
        if (isFormString(form) || isFormArray(form)) {
          return false;
        }

        if (form != null && _typeof(form) === 'object') {
          // $FlowFixMe
          var keys = Object.keys(form);

          if (keys.length === 1 && keys[0] in _this6.eqn.functions) {
            return true;
          }
        }

        return false;
      }; // eslint-disable-next-line max-len


      var isFormElements = function isFormElements(form) {
        return form instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_4__["Elements"] || form instanceof _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_5__["default"];
      };

      var addFormNormal = function addFormNormal(name, form) {
        // $FlowFixMe
        var formContent = [_this6.eqn.functions.contentToElement(form)];

        _this6.addForm(name, formContent);
      };

      var addFormFullObject = function addFormFullObject(name, form) {
        // $FlowFixMe
        var formContent = [_this6.eqn.functions.contentToElement(form.content)];
        var elementMods = form.elementMods,
            duration = form.duration,
            alignment = form.alignment,
            scale = form.scale,
            description = form.description,
            modifiers = form.modifiers,
            translation = form.translation,
            fromForm = form.fromForm,
            onShow = form.onShow,
            onTransition = form.onTransition;
        var options = {
          elementMods: elementMods,
          alignment: alignment,
          scale: scale,
          description: description,
          modifiers: modifiers,
          fromForm: fromForm,
          duration: duration,
          translation: translation,
          onShow: onShow,
          onTransition: onTransition
        }; // $FlowFixMe

        _this6.addForm(name, formContent, options);
      };

      Object.keys(forms).forEach(function (name) {
        var form = forms[name];

        if (isFormString(form) || isFormArray(form) || isFormMethodDefinition(form) || isFormElements(form)) {
          addFormNormal(name, form);
        } else {
          addFormFullObject(name, form);
        }
      });

      if (this.initialForm == null && Object.keys(this.eqn.forms).length > 0) {
        // eslint-disable-next-line prefer-destructuring
        this.initialForm = Object.keys(this.eqn.forms)[0];
      }
    }
  }, {
    key: "checkFixTo",
    value: function checkFixTo(fixTo) {
      if (typeof fixTo === 'string') {
        var element = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getFigureElement"])(this, fixTo);

        if (element != null) {
          return element;
        }

        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      }

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementPrimitive"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"] || fixTo instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        return fixTo;
      }

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
    }
  }, {
    key: "createForm",
    value: function createForm() {
      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.elements;
      return new _EquationForm__WEBPACK_IMPORTED_MODULE_6__["default"](elements, {
        getAllElements: this.getChildren.bind(this),
        hideAll: this.hideAll.bind(this),
        show: this.show.bind(this),
        showOnly: this.showOnly.bind(this),
        stop: this.stopEquationAnimating.bind(this),
        getElementTransforms: this.getElementTransforms.bind(this),
        setElementTransforms: this.setElementTransforms.bind(this),
        animateToTransforms: this.animateToTransforms.bind(this)
      });
    }
  }, {
    key: "stopEquationAnimating",
    value: function stopEquationAnimating() {
      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';
      this.stopAnimating(how, '_Equation', true);
      this.stopAnimating(how, '_EquationColor', true);
      this.stopPulsing(how);
    }
  }, {
    key: "addForm",
    value: function addForm(name, content) {
      var _this7 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      // if (!(name in this.eqn.forms)) {
      //   // $FlowFixMe   - its ok for this to start undefined, it will be filled.
      //   this.eqn.forms[name] = {};
      // }
      var defaultOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
        elementMods: {},
        description: '',
        modifiers: {},
        scale: this.eqn.scale,
        // animation: {
        duration: undefined,
        // use null for velocities
        onStart: null,
        // },
        fromForm: {},
        onShow: null,
        onTransition: null
      }, this.eqn.formDefaults);
      var optionsToUse = defaultOptions;

      if (options) {
        optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);
      }

      var _optionsToUse = optionsToUse,
          description = _optionsToUse.description,
          modifiers = _optionsToUse.modifiers,
          fromForm = _optionsToUse.fromForm,
          onShow = _optionsToUse.onShow,
          onTransition = _optionsToUse.onTransition,
          duration = _optionsToUse.duration,
          translation = _optionsToUse.translation; // this.eqn.forms[name].name = name;
      // const form = this.eqn.forms[name];
      // form[subForm] = this.createForm();

      var form = this.createForm();
      this.eqn.forms[name] = form;
      form.description = description;
      form.modifiers = modifiers;
      form.name = name;
      form.duration = duration;
      form.translation = translation; // form.animation = animation;

      form.fromForm = fromForm;
      form.onShow = onShow;
      form.onTransition = onTransition; // Populate element mods

      form.elementMods = {};

      var transformElementMods = function transformElementMods(elementMods) {
        var newMods = {};
        Object.keys(elementMods).forEach(function (elementName) {
          var mods = elementMods[elementName];
          var figureElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getFigureElement"])(_this7, elementName);

          if (figureElement != null) {
            newMods[elementName] = {
              element: figureElement,
              mods: mods
            };
          }
        });
        return newMods;
      };

      var transformTranslation = function transformTranslation(trans) {
        var newTranslation = {};
        Object.keys(trans).forEach(function (elementName) {
          var figureElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_9__["getFigureElement"])(_this7, elementName);
          var mods = trans[elementName];
          var direction;
          var style;
          var mag;

          if (Array.isArray(mods)) {
            var _mods = _slicedToArray(mods, 3);

            style = _mods[0];
            direction = _mods[1];
            mag = _mods[2];
          } else {
            style = mods.style;
            direction = mods.direction;
            mag = mods.mag;
          }

          if (figureElement != null) {
            newTranslation[elementName] = {
              element: figureElement,
              style: style,
              direction: direction,
              mag: mag
            };
          }
        });
        return newTranslation;
      };

      form.elementMods = transformElementMods(optionsToUse.elementMods);

      if (form.translation != null) {
        form.translation = transformTranslation(form.translation);
      }

      if (form.fromForm != null) {
        Object.keys(form.fromForm).forEach(function (fromFormKey) {
          var f = form.fromForm[fromFormKey];

          if (f.elementMods != null) {
            f.elementMods = transformElementMods(f.elementMods);
          }

          if (f.translation != null) {
            // $FlowFixMe
            f.translation = transformTranslation(f.translation);
          }
        });
      }

      optionsToUse.alignment.fixTo = this.checkFixTo(optionsToUse.alignment.fixTo);
      form.content = content;
      form.arrange(optionsToUse.scale, optionsToUse.alignment.xAlign, optionsToUse.alignment.yAlign, optionsToUse.alignment.fixTo); // // make the first form added also equal to the base form as always
      // // need a base form for some functions
      // if (this.eqn.forms[name].base === undefined) {
      //   const baseOptions = joinObjects({}, optionsToUse);
      //   baseOptions.subForm = 'base';
      //   this.addForm(name, content, baseOptions);
      // }

      if (this.eqn.currentForm === '') {
        this.eqn.currentForm = name;
      } // if (this.eqn.currentSubForm === '') {
      //   this.eqn.currentSubForm = 'base';
      // }

    }
    /**
     * Get the current equation form
     */

  }, {
    key: "getCurrentForm",
    value: function getCurrentForm() {
      if (this.eqn.forms[this.eqn.currentForm] == null) {
        return null;
      } // if (this.eqn.forms[this.eqn.currentForm][this.eqn.currentSubForm] == null) {
      //   return null;
      // }


      return this.eqn.forms[this.eqn.currentForm];
    }
  }, {
    key: "render",
    value: function render() {
      var animationStop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var form = this.getCurrentForm();

      if (form != null) {
        form.setPositions();
        form.showHide(0, 0, null, animationStop);
        this.show(); // form.setPositions();

        form.applyElementMods(); // this.updateDescription();
      }
    }
    /**
     * Set current equation form - Note, this does not show the form.
     */

  }, {
    key: "setCurrentForm",
    value: function setCurrentForm(formOrName) // subForm: string = 'base',
    {
      if (typeof formOrName === 'string') {
        this.eqn.currentForm = ''; // this.eqn.currentSubForm = '';

        if (formOrName in this.eqn.forms) {
          this.eqn.currentForm = formOrName; // if (subForm in this.eqn.forms[formOrName]) {
          //   this.eqn.currentSubForm = subForm;
          // }
        }
      } else {
        this.eqn.currentForm = formOrName.name; // this.eqn.currentSubForm = formOrName.subForm;
      }
    }
    /**
     * Show equation form
     */

  }, {
    key: "showForm",
    value: function showForm() // showCollection: boolean = true,
    {
      var formOrName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.eqn.currentForm;
      var animationStop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      _get(_getPrototypeOf(Equation.prototype), "show", this).call(this); // this.custom.settingForm = true;


      var form = formOrName;

      if (typeof formOrName === 'string') {
        form = this.getForm(formOrName);
      }

      if (form) {
        this.setCurrentForm(form);
        this.render(animationStop); // $FlowFixMe

        this.fnMap.exec(form.onTransition); // $FlowFixMe

        this.fnMap.exec(form.onShow);
      } // this.custom.settingForm = false;

    }
  }, {
    key: "showAll",
    value: function showAll() {
      this.showForm();
    } // show(
    //   toShow: FigureElementPrimitive | FigureElementCollection | string
    //     | Array<FigureElementPrimitive | FigureElementCollection | string> = [],
    // ) {
    //   // if (!this.custom.settingForm) {
    //   //   if (Array.isArray(toShow) && toShow.length === 0) {
    //   //     // console.log(this.eqn.currentForm)
    //   //     this.showForm(this.eqn.currentForm, true, false);
    //   //     return;
    //   //   }
    //   // }
    //   super.show(toShow);
    // }

    /**
     * Get an equation form object from a form name
     */

  }, {
    key: "getForm",
    value: function getForm(formOrName) {
      if (formOrName instanceof _EquationForm__WEBPACK_IMPORTED_MODULE_6__["default"]) {
        return formOrName;
      }

      if (formOrName in this.eqn.forms) {
        // let formTypeToUse = subForm;
        // if (formTypeToUse == null) {
        //   const possibleFormTypes     // $FlowFixMe
        //     = this.eqn.subFormPriority.filter(fType => fType in this.eqn.forms[formOrName]);
        //   if (possibleFormTypes.length) {
        //     // eslint-disable-next-line prefer-destructuring
        //     formTypeToUse = possibleFormTypes[0];
        //   }
        // }
        // if (formTypeToUse != null) {
        //   return this.eqn.forms[formOrName][formTypeToUse];
        // }
        return this.eqn.forms[formOrName];
      }

      return null;
    }
    /**
     * Start an animation to an equation form
     */

  }, {
    key: "goToForm",
    value: function goToForm() {
      var _this8 = this;

      var optionsIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        duration: null,
        prioritizeFormDuration: true,
        delay: 0,
        fromWhere: '_current',
        animate: 'dissolve',
        callback: null,
        ifAnimating: {
          skipToTarget: true,
          cancelGoTo: true
        }
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);

      if (this.eqn.isAnimating) {
        if (options.ifAnimating.skipToTarget) {
          // this.stopEquationAnimating('complete', '_Equation', true);
          // this.stopEquationAnimating('complete', '_EquationColor', true);
          // this.stopEquationAnimatingPulsing();
          this.stopEquationAnimating('complete'); // this.stopEquationAnimating('complete');

          var currentForm = this.getCurrentForm();

          if (currentForm != null) {
            this.showForm(currentForm);
          }
        } else {
          // this.stopEquationAnimating('cancel');
          // this.stopEquationAnimating('cancel', '_Equation', true);
          // this.stopEquationAnimating('cancel', '_EquationColor', true);
          // this.stopEquationAnimatingPulsing();
          this.stopEquationAnimating('cancel');
        }

        this.eqn.isAnimating = false;

        if (options.ifAnimating.cancelGoTo) {
          return;
        }
      } // this.stopEquationAnimating(true, true);
      // this.eqn.isAnimating = false;
      // Get the desired form - preference is name, then series index,
      // then next form in the current series


      var form;

      if (options.form != null) {
        form = this.eqn.forms[options.form];
      } else if (options.index != null) {
        form = this.eqn.forms[this.eqn.currentFormSeries[options.index]];
      } else if (this.eqn.currentFormSeries.length > 0) {
        var index = 0;

        var _currentForm = this.getCurrentForm();

        if (_currentForm != null) {
          index = this.eqn.currentFormSeries.indexOf(_currentForm.name);

          if (index < 0) {
            index = 0;
          }
        }

        var formIndex = index + 1;

        if (formIndex === this.eqn.currentFormSeries.length) {
          formIndex = 0;
        }

        form = this.eqn.forms[this.eqn.currentFormSeries[formIndex]];
      }

      if (form == null) {
        return;
      }

      if (options.fromWhere === '_current') {
        options.fromWhere = this.eqn.currentForm;
      } // if (form.onStart != null) {
      // this.fnMap.exec(form.onTransition);
      // }


      var duration = options.duration; // console.log(options)

      if (options.prioritizeFormDuration) {
        if (form.duration !== undefined) {
          duration = form.duration;
        }

        if (options.fromWhere != null && form.fromForm[options.fromWhere] != null && form.fromForm[options.fromWhere].duration !== undefined) {
          duration = form.fromForm[options.fromWhere].duration;
        }
      }

      var _form = form,
          onTransition = _form.onTransition;

      if (form.fromForm != null && form.fromForm[options.fromWhere] != null && form.fromForm[options.fromWhere].onTransition !== undefined) {
        onTransition = form.fromForm[options.fromWhere].onTransition;
      }

      if (duration != null && duration > 0 && options.animate === 'dissolve') {
        if (options.dissolveOutTime == null) {
          options.dissolveOutTime = duration * 0.4;
        }

        if (options.dissolveInTime == null) {
          options.dissolveInTime = duration * 0.4;
        }

        if (options.blankTime == null) {
          options.blankTime = duration * 0.2;
        }
      } else {
        if (options.dissolveOutTime == null) {
          options.dissolveOutTime = 0.4;
        }

        if (options.dissolveInTime == null) {
          options.dissolveInTime = 0.4;
        }

        if (options.blankTime == null) {
          options.blankTime = 0.2;
        }
      }

      if (duration === 0) {
        this.showForm(form);
        this.fnMap.exec(options.callback); // if (options.callback != null) {
        //   options.callback();
        // }
        // if (form.onShow != null) {
        // this.fnMap.exec(form.onTransition);
        // this.fnMap.exec(form.onShow);
        // }
      } else {
        this.eqn.isAnimating = true;
        this.fnMap.exec(onTransition);

        var end = function end() {
          // $FlowFixMe
          _this8.fnMap.exec(form.onShow); // }


          _this8.eqn.isAnimating = false;

          _this8.fnMap.exec(options.callback); // if (options.callback != null) {
          //   options.callback();
          // }

        };

        if (options.animate === 'move') {
          // console.log('move', duration, options, subForm.duration)
          // console.log('******************* animate')
          form.animatePositionsTo(options.delay, options.dissolveOutTime, duration, options.dissolveInTime, end, options.fromWhere, false);
        } else if (options.animate === 'dissolveInThenMove') {
          // console.log('move', duration, options, subForm.duration)
          // console.log('******************* animate')
          form.animatePositionsTo(options.delay, options.dissolveOutTime, duration, options.dissolveInTime, end, options.fromWhere, true);
        } else if (options.animate === 'moveFrom' && this.eqn.formRestart != null && this.eqn.formRestart.moveFrom != null) {
          var moveFrom = this.eqn.formRestart.moveFrom;
          var target = this.getPosition();
          var start = this.getPosition();

          if (moveFrom instanceof Equation) {
            moveFrom.showForm(form.name);
          }

          if (moveFrom instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]) {
            start = moveFrom.getPosition();
          } else {
            // $FlowFixMe
            start = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(this.eqn.formRestart.moveFrom);
          }

          var showFormCallback = function showFormCallback() {
            // $FlowFixMe
            _this8.showForm(form.name, false);
          };

          this.fnMap.add('_equationShowFormCallback', showFormCallback);
          this.animations["new"]('_Equation').dissolveOut({
            duration: options.dissolveOutTime
          }).position({
            target: start,
            duration: 0
          }).trigger({
            callback: 'showFormCallback',
            duration: 0.01
          }).position({
            target: target,
            duration: duration
          }).whenFinished(end).start();
        } else if (options.animate === 'pulse' && this.eqn.formRestart != null && this.eqn.formRestart.pulse != null) {
          var pulse = this.eqn.formRestart.pulse;

          var newEnd = function newEnd() {
            _this8.pulse({
              duration: pulse.duration,
              scale: pulse.scale,
              frequency: 0,
              done: end
            });

            if (pulse.element != null && pulse.element instanceof Equation // $FlowFixMe
            && pulse.element.getCurrentForm().name === form.name) {
              // $FlowFixMe
              pulse.element.pulse({
                duration: pulse.duration,
                scale: pulse.scale
              });
            }
          };

          form.allHideShow(options.delay, options.dissolveOutTime, options.blankTime, options.dissolveInTime, newEnd);
        } else {
          // console.log('******************* hideshow')
          form.allHideShow(options.delay, options.dissolveOutTime, options.blankTime, options.dissolveInTime, end);
        }

        this.setCurrentForm(form);
      }
    }
  }, {
    key: "getFormIndex",
    value: function getFormIndex(formToGet) {
      var form = this.getForm(formToGet);
      var index = -1;

      if (form != null) {
        index = this.eqn.currentFormSeries.indexOf(form.name);
      }

      return index;
    }
    /**
     * Animate to previous form in the current form series
     */

  }, {
    key: "prevForm",
    value: function prevForm() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var currentForm = this.getCurrentForm();

      if (currentForm == null) {
        return;
      }

      var index = this.getFormIndex(currentForm);

      if (index > -1) {
        index -= 1;

        if (index < 0) {
          index = this.eqn.currentFormSeries.length - 1;
        }

        if (typeof durationOrOptions === 'number' || durationOrOptions == null) {
          this.goToForm({
            index: index,
            duration: durationOrOptions,
            delay: delay,
            fromWhere: currentForm.name
          });
        } else {
          this.goToForm(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({
            index: index,
            fromWhere: currentForm.name
          }, durationOrOptions));
        }
      }
    }
    /**
     * Animate to next form in the current form series
     */

  }, {
    key: "nextForm",
    value: function nextForm() {
      var durationOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var animate = 'move';
      var currentForm = this.getCurrentForm();

      if (currentForm == null) {
        return;
      }

      var index = this.getFormIndex(currentForm);

      if (index > -1) {
        index += 1;

        if (index > this.eqn.currentFormSeries.length - 1) {
          index = 0;
          var formRestart = this.eqn.formRestart;

          if (formRestart != null && formRestart.moveFrom != null) {
            animate = 'moveFrom';
          } else if (formRestart != null && formRestart.pulse != null) {
            animate = 'pulse';
          } else {
            animate = 'dissolve';
          }
        }

        if (typeof durationOrOptions === 'number' || durationOrOptions == null) {
          this.goToForm({
            index: index,
            duration: durationOrOptions,
            delay: delay,
            fromWhere: currentForm.name,
            animate: animate
          });
        } else {
          this.goToForm(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({
            index: index,
            animate: animate,
            fromWhere: currentForm.name
          }, durationOrOptions));
        }
      }
    }
    /**
     * Start from previous form and animate to current form
     */

  }, {
    key: "replayCurrentForm",
    value: function replayCurrentForm(duration) {
      if (this.eqn.isAnimating) {
        // this.stopEquationAnimating(true, true);
        this.stopEquationAnimating('complete'); // this.animations.cancel('complete');
        // this.animations.cancel('complete');

        this.eqn.isAnimating = false;
        var currentForm = this.getCurrentForm();

        if (currentForm != null) {
          this.showForm(currentForm);
        }

        return;
      } // this.animations.cancel();
      // this.animations.cancel();
      // this.stopEquationAnimating();


      this.stopEquationAnimating();
      this.eqn.isAnimating = false;
      this.prevForm(0);
      this.nextForm(duration, 0.5);
    }
  }, {
    key: "animateToForm",
    value: function animateToForm(name) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // this.stopEquationAnimatingColor(true, true);
      // this.stopEquationAnimatingColor(true, true);
      // this.stopEquationAnimating();
      this.stopEquationAnimating(); // this.animations.cancel();
      // this.animations.cancel();

      var form = this.getForm(name);

      if (form != null) {
        form.animatePositionsTo(delay, 0.4, duration, 0.4, callback);
      }

      this.setCurrentForm(name);
    }
  }, {
    key: "changeDescription",
    value: function changeDescription(formOrName) // subForm: string = 'base',
    {
      var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var form = this.getForm(formOrName);

      if (form != null) {
        form.description = "".concat(description);
        form.modifiers = modifiers;
      }
    }
  }, {
    key: "getDescription",
    value: function getDescription(formOrName) // subForm: string = 'base',
    {
      var form = this.getForm(formOrName);

      if (form != null && form.description != null) {
        return _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_7__["applyModifiers"](form.description, form.modifiers);
      }

      return '';
    } // updateDescription(
    //   formOrName: EquationForm | string | null = null,
    //   subForm: string = 'base',
    // ) {
    //   const element = this.eqn.descriptionElement;
    //   if (element == null) {
    //     return;
    //   }
    //   if (element.isShown === false) {
    //     return;
    //   }
    //   let form = null;
    //   if (formOrName == null) {
    //     form = this.getCurrentForm();
    //   } else if (typeof formOrName === 'string') {
    //     form = this.getForm(formOrName, subForm);
    //   } else {
    //     form = formOrName;
    //   }
    //   if (form == null) {
    //     return;
    //   }
    //   if (form.description == null) {
    //     return;
    //   }
    //   const { drawingObject } = element;
    //   if (drawingObject instanceof HTMLObject) {
    //     drawingObject.change(
    //       html.applyModifiers(form.description, form.modifiers),
    //       element.lastDrawTransform.m(),
    //     );
    //     html.setOnClicks(form.modifiers);
    //   }
    // }

  }]);

  return Equation;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]);

/***/ }),

/***/ "./src/js/figure/Equation/EquationForm.js":
/*!************************************************!*\
  !*** ./src/js/figure/Equation/EquationForm.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationForm; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/figure/Equation/Elements/Element.js");
/* harmony import */ var _EquationFunctions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EquationFunctions */ "./src/js/figure/Equation/EquationFunctions.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

 // import { roundNum } from '../../../tools/math';



 // eslint-disable-next-line import/no-cycle



var EquationForm = /*#__PURE__*/function (_Elements) {
  _inherits(EquationForm, _Elements);

  var _super = _createSuper(EquationForm);

  // These properties are just saved in the form and not used by this class
  // They are used by external classes using this form
  // subForm: string;
  // animation: {
  // };
  function EquationForm(elements, collectionMethods) {
    var _this;

    _classCallCheck(this, EquationForm);

    _this = _super.call(this, []);
    _this.elements = elements;
    _this.collectionMethods = collectionMethods;
    _this.description = null;
    _this.modifiers = {};
    _this.elementMods = {};
    _this.onShow = null;
    _this.onTransition = null; // this.duration = null;
    // this.translation = {};
    // this.animation = {};

    _this.fromForm = {}; // this.subForm = '';

    return _this;
  }

  _createClass(EquationForm, [{
    key: "getNamedElements",
    value: function getNamedElements() {
      var namedElements = {};
      this.collectionMethods.getAllElements().forEach(function (element) {
        namedElements[element.name] = element;
      });
      return namedElements;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.elements;
      var collectionMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.collectionMethods;
      var equationCopy = new EquationForm(elements, collectionMethods);
      var namedElements = {};
      collectionMethods.getAllElements().forEach(function (element) {
        namedElements[element.name] = element;
      });
      var newContent = [];
      this.content.forEach(function (contentElement) {
        newContent.push(contentElement._dup(namedElements));
      });
      equationCopy.content = newContent;
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["duplicateFromTo"])(this, equationCopy, ['content', 'collectionMethods', 'form', 'elements']);
      return equationCopy;
    }
  }, {
    key: "createEq",
    value: function createEq(content) {
      var _this2 = this;

      var elements = [];
      content.forEach(function (c) {
        if (typeof c === 'string') {
          if (c.startsWith('space')) {
            var spaceNum = parseFloat(c.replace(/space[_]*/, '')) || 0.03;
            elements.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](spaceNum)));
          } else if (c.startsWith(' ')) {
            var _spaceNum = c.length * 0.03;

            elements.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](_spaceNum)));
          } else {
            var figureElement = Object(_EquationFunctions__WEBPACK_IMPORTED_MODULE_4__["getFigureElement"])(_this2.elements, c);

            if (figureElement) {
              elements.push(new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](figureElement));
            }
          }
        } else {
          elements.push(c._dup());
        }

        _this2.content = elements;
      }); // this.content = content;
    } // An Equation collection is a flat collection of FigureElements.
    //
    // The form determines how elements are positioned relative to each other.
    //
    // A form of an equation takes the form's elements (a subset of the
    // collection) and applies a translation and scale transformation. This
    // aligns all the elements of a form relative to each other to render
    // the desired form.
    //
    // Arranging a form of an equation goes through each element in the form
    // and positions and scales it in the equation's vertex space.
    // It also saves the locaiton and scale information in the form's element
    // property.
    //
    // The elements are positioned relative to 0,0 in vertex space based on the
    // fixTo, xAlign and yAlign parameters.
    //
    // fixTo can only be a point in the equation's vertex space, or a
    // FigureElement in the equation.
    //
    // If fixTo is an element in the equation:
    //    - the fixTo element is positioned at 0, 0, and all other elements
    //      repositioned relative to that.
    //    - The equation collection setPosition (or translation transform) can
    //      then be used to position the equation in the figure (or relative
    //      collection space)
    //    - if xAlign is:
    //        - 'center': the fixTo element is centered in x around (0, 0)
    //        - 'right': the fixTo element right most point is at x = 0
    //        - 'left': default - the fixTo element x position at 0
    //    - if yAlign is:
    //        - 'middle': the fixTo element is centered in y around (0, 0)
    //        - 'bottom': the fixTo element bottom most point is at y = 0
    //        - 'top': the fixTo element top most point is at y = 0
    //        - 'baseline': default - the fixTo element y position at 0
    //
    // If fixTo is a Point, the equation is positioned at that point in the
    // equation's vertex space.
    //  - xAlign:
    //    - 'left': The equation's left most element's left most point is at
    //              Point.x
    //    - 'right': The equation's right most element's right most point is at
    //              Point.x
    //    - 'center': The equation is centered horizontally around Point.x
    //  - yAlign:
    //    - 'baseline': The equation's baseline is at Point.y
    //    - 'top': The equation's top most element's top most point is at Point.y
    //    - 'bottom': The equation's top most element's top most point is at
    //                Point.y
    //    - 'middle': The equation is centered vertically around Point.y
    //

  }, {
    key: "arrange",
    value: function arrange() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var xAlign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'left';
      var yAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'baseline';
      var fixTo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.arranged = {
        scale: scale,
        xAlign: xAlign,
        yAlign: yAlign,
        fixTo: fixTo
      };
      var elementsInCollection = this.collectionMethods.getAllElements();
      var elementsCurrentlyShowing = elementsInCollection.filter(function (e) {
        return e.isShown;
      });
      this.collectionMethods.hideAll();
      this.collectionMethods.show();

      _get(_getPrototypeOf(EquationForm.prototype), "calcSize", this).call(this, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), scale);

      this.setPositions();
      var fixPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementPrimitive"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]) {
        var t = fixTo.transform.t();

        if (t != null) {
          fixPoint = t._dup();
        }
      } else {
        fixPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-fixTo.x, -fixTo.y);
      }

      var w = this.width;
      var h = this.height;
      var a = this.ascent;
      var d = this.descent;

      var p = this.location._dup();

      if (fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementPrimitive"] || fixTo instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]) {
        // const rect = fixTo.getBoundingRect('local');
        // const t = fixTo.getPosition('local');
        // w = rect.width;
        // h = rect.height;
        // a = rect.top - t.y;
        // d = t.y - rect.bottom;
        // p = t._dup();
        var _t = fixTo.transform.t();

        var s = fixTo.transform.s(); // console.log(fixTo.transform._dup())
        // console.log(t, s, fixTo.name)

        if (_t != null && s != null) {
          var rect = fixTo.getBoundingRect('draw'); // console.log(rect)
          // const rect = getBoundingRect(fixTo.drawingObject.border);

          w = rect.width * s.x;
          h = rect.height * s.y;
          a = rect.top * s.y - _t.y;
          d = _t.y - rect.bottom * s.y;
          p = _t._dup();
        }
      }

      if (xAlign === 'right') {
        fixPoint.x += w;
      } else if (xAlign === 'center') {
        fixPoint.x += w / 2;
      } else if (typeof xAlign === 'number') {
        fixPoint.x += xAlign * w;
      } else if (xAlign != null && xAlign.slice(-1)[0] === 'o') {
        var offset = parseFloat(xAlign);
        fixPoint.x += offset;
      }

      if (yAlign === 'top') {
        fixPoint.y += p.y + a;
      } else if (yAlign === 'bottom') {
        fixPoint.y += p.y - d;
      } else if (yAlign === 'middle') {
        fixPoint.y += p.y - d + h / 2;
      } else if (typeof yAlign === 'number') {
        fixPoint.y += p.y - d + yAlign * h;
      } else if (yAlign != null && yAlign.slice(-1)[0] === 'o') {
        var _offset = parseFloat(yAlign);

        fixPoint.y += p.y + _offset;
      }

      var delta = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0).sub(fixPoint);

      if (delta.x !== 0 || delta.y !== 0) {
        this.offsetLocation(delta);
        this.setPositions();
      }

      this.collectionMethods.showOnly(elementsCurrentlyShowing);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "dissolveElements",
    value: function dissolveElements(elements) {
      var _this3 = this;

      var dissolve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'in';
      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;
      var time = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

      if (elements.length === 0) {
        if (callback) {
          this.fnMap.exec(callback, false); // callback(false);

          return;
        }
      }

      var count = elements.length;
      var completed = 0;

      var onFinish = function onFinish(cancelled) {
        completed += 1;

        if (completed === count) {
          if (callback) {
            // callback(cancelled);
            _this3.fnMap.exec(callback, cancelled);
          }
        }
      };

      elements.forEach(function (e) {
        e.animations.addTo('_EquationColor').opacity({
          dissolve: dissolve,
          onFinish: onFinish,
          duration: time,
          delay: delay,
          completeOnCancel: true
        }).start();
      });
    }
  }, {
    key: "getElementsToShowAndHide",
    value: function getElementsToShowAndHide() {
      var allElements = this.collectionMethods.getAllElements();
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsShownTarget = this.getAllElements();
      var elementsToHide = elementsShown.filter(function (e) {
        return elementsShownTarget.indexOf(e) === -1;
      });
      var elementsToShow = elementsShownTarget.filter(function (e) {
        return elementsShown.indexOf(e) === -1;
      });
      return {
        show: elementsToShow,
        hide: elementsToHide
      };
    }
  }, {
    key: "render",
    value: function render() {
      this.hideShow();
      this.setPositions();
    }
  }, {
    key: "showHide",
    value: function showHide() {
      var showTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var animationStop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (animationStop) {
        this.collectionMethods.stop();
      }

      this.collectionMethods.show();

      var _this$getElementsToSh = this.getElementsToShowAndHide(),
          show = _this$getElementsToSh.show,
          hide = _this$getElementsToSh.hide;

      if (showTime === 0) {
        show.forEach(function (e) {
          e.showAll();
        });
      } else {
        this.dissolveElements(show, 'in', 0.01, showTime, null);
      }

      if (hideTime === 0) {
        hide.forEach(function (e) {
          return e.hide();
        });
      } else {
        this.dissolveElements(hide, 'out', showTime, hideTime, callback);
      }
    }
  }, {
    key: "hideShow",
    value: function hideShow() {
      var showTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var animationStop = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (animationStop) {
        this.collectionMethods.stop();
      }

      this.collectionMethods.show();

      var _this$getElementsToSh2 = this.getElementsToShowAndHide(),
          show = _this$getElementsToSh2.show,
          hide = _this$getElementsToSh2.hide;

      if (hideTime === 0) {
        hide.forEach(function (e) {
          return e.hide();
        });
      } else {
        this.dissolveElements(hide, 'out', 0.01, hideTime, null);
      }

      if (showTime === 0) {
        show.forEach(function (e) {
          e.showAll();
        });

        if (callback != null) {
          callback();
        }
      } else {
        this.dissolveElements(show, 'in', hideTime, showTime, callback);
      }
    }
  }, {
    key: "allHideShow",
    value: function allHideShow() {
      var _this4 = this;

      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var hideTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
      var blankTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;
      var showTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      this.collectionMethods.stop();
      var allElements = this.collectionMethods.getAllElements();
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsToShow = this.getAllElements();
      var elementsToDelayShowing = elementsToShow.filter(function (e) {
        return !e.isShown;
      });
      var elementsToShowAfterDissolve = elementsToShow.filter(function (e) {
        return e.isShown;
      });
      var cumTime = delay;

      if (elementsToShow.length === 0 && elementsShown.length === 0) {
        if (callback != null) {
          callback(false);
          return;
        }
      }

      var dissolveOutCallback = function dissolveOutCallback() {
        _this4.setPositions();
      };

      if (elementsToShow.length === 0) {
        dissolveOutCallback = function dissolveOutCallback(cancelled) {
          _this4.setPositions();

          if (callback != null) {
            callback(cancelled);
          }
        };
      }

      if (elementsShown.length > 0) {
        this.dissolveElements(elementsShown, 'out', delay, hideTime, dissolveOutCallback);
        cumTime += hideTime;
      } else {
        this.setPositions();
      }

      this.applyElementMods();
      var count = elementsToShow.length;
      var completed = 0;

      var onFinish = function onFinish(cancelled) {
        completed += 1;

        if (completed === count - 1) {
          if (callback) {
            callback(cancelled);
          }
        }
      };

      elementsToDelayShowing.forEach(function (e) {
        e.animations.addTo('_EquationColor').dissolveIn({
          duration: showTime,
          onFinish: onFinish,
          delay: cumTime + blankTime
        }).start();
      });
      elementsToShowAfterDissolve.forEach(function (e) {
        e.animations.addTo('_EquationColor').dissolveIn({
          duration: showTime,
          onFinish: onFinish,
          delay: blankTime
        }).start();
      });
    }
  }, {
    key: "applyElementMods",
    value: function applyElementMods() {
      var fromWhere = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var setProps = function setProps(elementMods) {
        Object.keys(elementMods).forEach(function (elementName) {
          var _elementMods$elementN = elementMods[elementName],
              element = _elementMods$elementN.element,
              mods = _elementMods$elementN.mods;

          if (element != null && mods != null) {
            element.setProperties(mods);

            if (mods.color != null) {
              element.setColor(mods.color);
            }

            if (mods.opacity != null) {
              element.setOpacity(mods.opacity);
            }
          }
        });
      };

      setProps(this.elementMods);

      if (fromWhere != null && fromWhere.length > 0 && this.fromForm[fromWhere] != null && this.fromForm[fromWhere].elementMods != null) {
        setProps(this.fromForm[fromWhere].elementMods);
      }
    } // Check callback is being called

  }, {
    key: "animatePositionsTo",
    value: function animatePositionsTo(delay, dissolveOutTime, moveTime, dissolveInTime) {
      var callback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var fromWhere = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
      var dissolveInBeforeMove = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      var allElements = this.collectionMethods.getAllElements();
      this.collectionMethods.stop();
      var elementsShownTarget = this.getAllElements();
      elementsShownTarget.forEach(function (e) {
        if (e.opacity === 0.001) {
          e.hide();
          e.setOpacity(1);
        } else {
          e.setOpacity(1);
        }
      });
      var elementsShown = allElements.filter(function (e) {
        return e.isShown;
      });
      var elementsToHide = elementsShown.filter(function (e) {
        return elementsShownTarget.indexOf(e) === -1;
      });
      var elementsToShow = elementsShownTarget.filter(function (e) {
        return elementsShown.indexOf(e) === -1;
      });
      var currentTransforms = this.collectionMethods.getElementTransforms();
      this.setPositions();
      var animateToTransforms = this.collectionMethods.getElementTransforms();
      var elementsToMove = [];
      var toMoveStartTransforms = [];
      var toMoveStopTransforms = [];
      Object.keys(animateToTransforms).forEach(function (key) {
        var currentT = currentTransforms[key];
        var nextT = animateToTransforms[key];

        if (!currentT.isEqualTo(nextT)) {
          elementsToMove.push(key);
          toMoveStartTransforms.push(currentT);
          toMoveStopTransforms.push(nextT);
        }
      });
      var toShowTransforms = {};
      elementsToShow.forEach(function (element) {
        toShowTransforms[element.name] = element.transform._dup();
      }); // Find move time to use. If moveTime is null, then a velocity is used.

      var moveTimeToUse;

      if (moveTime === null) {
        moveTimeToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getMoveTime"])(toMoveStartTransforms, toMoveStopTransforms, 0, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0.35, 0.35), // 0.25 figure space per s
        2 * Math.PI / 6, // 60º per second
        new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0.4, 0.4) // 100% per second
        );
      } else {
        moveTimeToUse = moveTime;
      }

      this.collectionMethods.setElementTransforms(currentTransforms);
      this.collectionMethods.setElementTransforms(toShowTransforms);
      var cumTime = delay;
      var moveCallback = null;
      var dissolveInCallback = null;
      var dissolveOutCallback = null;

      if (dissolveInBeforeMove) {
        if (elementsToMove.length === 0 && elementsToShow.length === 0) {
          dissolveOutCallback = callback;
        } else if (elementsToMove.length === 0) {
          dissolveInCallback = callback;
        } else {
          moveCallback = callback;
        }
      } else if (elementsToMove.length === 0 && elementsToShow.length === 0) {
        dissolveOutCallback = callback;
      } else if (elementsToShow.length === 0) {
        moveCallback = callback;
      } else {
        dissolveInCallback = callback;
      }

      if (elementsToHide.length > 0) {
        this.dissolveElements(elementsToHide, 'out', delay, dissolveOutTime, dissolveOutCallback);
        cumTime += dissolveOutTime;
      } else if (dissolveOutCallback != null) {
        this.fnMap.exec(dissolveOutCallback);
      }

      this.applyElementMods(fromWhere);
      var translationToUse = {};

      if (typeof fromWhere === 'string' && fromWhere.length !== 0 && this.fromForm != null && this.fromForm[fromWhere] != null // && this.fromForm[fromWhere].animation != null
      && this.fromForm[fromWhere].translation !== undefined) {
        translationToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.translation, this.fromForm[fromWhere].translation);
      } else {
        translationToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.translation);
      }

      Object.keys(translationToUse).forEach(function (key) {
        var mods = translationToUse[key];
        var element = mods.element,
            style = mods.style,
            direction = mods.direction,
            mag = mods.mag;

        if (element) {
          if (style != null) {
            element.animations.options.translation.style = style;
          }

          if (direction != null) {
            element.animations.options.translation.direction = direction;
          }

          if (mag != null) {
            element.animations.options.translation.magnitude = mag;
          }
        }
      });

      if (dissolveInBeforeMove) {
        if (elementsToShow.length > 0) {
          this.dissolveElements(elementsToShow, 'in', cumTime, dissolveInTime, dissolveInCallback);
          cumTime += dissolveInTime + 0.001;
        }
      }

      var t = this.collectionMethods.animateToTransforms(animateToTransforms, moveTimeToUse, cumTime, 0, moveCallback, '_Equation');

      if (t > 0) {
        cumTime = t;
      } // if (elementsToShow.length > 0) {
      //   this.dissolveElements(elementsToShow, 'in', cumTime, dissolveInTime, dissolveInCallback);
      //   cumTime += dissolveInTime + 0.001;
      // }


      if (!dissolveInBeforeMove) {
        if (elementsToShow.length > 0) {
          this.dissolveElements(elementsToShow, 'in', cumTime, dissolveInTime, dissolveInCallback);
          cumTime += dissolveInTime + 0.001;
        }
      }

      return cumTime;
    }
  }]);

  return EquationForm;
}(_Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]);



/***/ }),

/***/ "./src/js/figure/Equation/EquationFunctions.js":
/*!*****************************************************!*\
  !*** ./src/js/figure/Equation/EquationFunctions.js ***!
  \*****************************************************/
/*! exports provided: getFigureElement, EquationFunctions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFigureElement", function() { return getFigureElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquationFunctions", function() { return EquationFunctions; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _Elements_Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Elements/Element */ "./src/js/figure/Equation/Elements/Element.js");
/* harmony import */ var _Elements_Fraction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Elements/Fraction */ "./src/js/figure/Equation/Elements/Fraction.js");
/* harmony import */ var _EquationForm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EquationForm */ "./src/js/figure/Equation/EquationForm.js");
/* harmony import */ var _Elements_Matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Elements/Matrix */ "./src/js/figure/Equation/Elements/Matrix.js");
/* harmony import */ var _Elements_Scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Elements/Scale */ "./src/js/figure/Equation/Elements/Scale.js");
/* harmony import */ var _Elements_Container__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Elements/Container */ "./src/js/figure/Equation/Elements/Container.js");
/* harmony import */ var _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Elements/BaseAnnotationFunction */ "./src/js/figure/Equation/Elements/BaseAnnotationFunction.js");
/* harmony import */ var _Symbols_Line__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Symbols/Line */ "./src/js/figure/Equation/Symbols/Line.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





 // eslint-disable-next-line import/no-cycle






 // eslint-disable-next-line import/no-cycle
// import type {
//   EQN_Annotation, EQN_EncompassGlyph, EQN_LeftRightGlyph, EQN_TopBottomGlyph,
// } from './Elements/BaseAnnotationFunction';

function getFigureElement(elementsObject, name) {
  if (typeof name !== 'string') {
    return name;
  }

  if (elementsObject instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]) {
    if (elementsObject && "_".concat(name) in elementsObject) {
      // $FlowFixMe
      return elementsObject["_".concat(name)];
    }

    return null;
  }

  if (elementsObject && name in elementsObject) {
    return elementsObject[name];
  }

  return null;
}
/* eslint-disable no-use-before-define */

/**
 * An equation phrase is used to define an equation form and can be any of the
 * below:
 *
 *  - `string` (which represents the unique identifier of an equation element)
 *  - `{ frac: `{@link EQN_Fraction} `}`
 *  - `{ strike: `{@link EQN_Strike} `}`
 *  - `{ box: `{@link EQN_Box} `}`
 *  - `{ tBox: `{@link EQN_TouchBox} `}`
 *  - `{ root: `{@link EQN_Root} `}`
 *  - `{ brac: `{@link EQN_Bracket} `}`
 *  - `{ sub: `{@link EQN_Subscript} `}`
 *  - `{ sup: `{@link EQN_Superscript} `}`
 *  - `{ supSub: `{@link EQN_SuperscriptSubscript} `}`
 *  - `{ topBar: `{@link EQN_Bar} `}`
 *  - `{ bottomBar: `{@link EQN_Bar} `}`
 *  - `{ annotate: `{@link EQN_Annotate} `}`
 *  - `{ topComment: `{@link EQN_Comment} `}`
 *  - `{ bottomComment: `{@link EQN_Comment} `}`
 *  - `{ pad: `{@link EQN_Pad} `}`
 *  - `{ bar: `{@link EQN_Bar} `}`
 *  - `{ scale: `{@link EQN_Scale} `}`
 *  - `{ container: `{@link EQN_Container} `}`
 *  - `{ matrix: `{@link EQN_Matrix} `}`
 *  - `{ int: `{@link EQN_Integral} `}`
 *  - `{ sumOf: `{@link EQN_SumOf} `}`
 *  - `{ prodOf: `{@link EQN_ProdOf} `}`
 *  - `{ topStrike: `{@link EQN_StrikeComment} `}`
 *  - `{ bottomStrike: `{@link EQN_StrikeComment} `}`
 *  - `Array<TypeEquationPhrase>`
 *
 *
 * @example
 * forms: {
 *   form1: 'a'
 *   form2: ['a', 'equals', 'b']
 *   form3: [{
 *     frac: {
 *       numerator: 'a',
 *       symbol: 'v',
 *       denominator: '1'
 *     },
 *   }, 'equals', 'b'],
 *   form4: [{ frac: ['a', 'v', '1'], 'equals', 'b'}],
 * },
 */

// There are lots of FlowFixMes in this file. This is not perfect, but
// haven't been able to come up with a quick work around. The problem statement
// is each function can accept as arguements either a full object definition
// or the definition split over parameters.
// The problem is then the first arguement can be so many types, some of which
// are subsets of the other, then when its parameters are extracted, their type
// is all confused.

/**
 * Equation Functions.
 *
 * Contains methods for all equation functions.
 */
var EquationFunctions = /*#__PURE__*/function () {
  // eslint-disable-next-line no-use-before-define
  // [methodName: string]: (TypeEquationPhrase) => {};

  /**
   * @hideconstructor
   */
  // eslint-disable-next-line no-use-before-define
  function EquationFunctions(elements, addElementFromKey, getExistingOrAddSymbol) {
    _classCallCheck(this, EquationFunctions);

    this.elements = elements;
    this.phrases = {};
    this.fullLineHeight = null;
    this.addElementFromKey = addElementFromKey;
    this.getExistingOrAddSymbol = getExistingOrAddSymbol;
  } // eslint-disable-next-line class-methods-use-this


  _createClass(EquationFunctions, [{
    key: "stringToElement",
    value: function stringToElement(content) {
      if (content.startsWith('space')) {
        var spaceNum = parseFloat(content.replace(/space[_]*/, '')) || 0.03;
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](spaceNum));
      }

      if (content.startsWith(' ')) {
        var _spaceNum = content.length * 0.03;

        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["BlankElement"](_spaceNum));
      }

      var figureElement = getFigureElement(this.elements, content);

      if (figureElement) {
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](figureElement);
      }

      if (content in this.phrases) {
        return this.parseContent(this.phrases[content]);
      }

      var elementFromKey = this.addElementFromKey(content, {});

      if (elementFromKey != null) {
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](elementFromKey);
      }

      return null;
    }
  }, {
    key: "parseContent",
    value: function parseContent(content) {
      var _this = this;

      if (content == null) {
        return null;
      }

      if (typeof content === 'number') {
        return null;
      }

      if (content instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]) {
        return content;
      }

      if (content instanceof _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_9__["default"]) {
        return content;
      }

      if (typeof content === 'string') {
        return this.stringToElement(content);
      }

      if (Array.isArray(content)) {
        var elementArray = [];
        content.forEach(function (c) {
          // $FlowFixMe
          var result = _this.parseContent(c);

          if (Array.isArray(result)) {
            elementArray = [].concat(_toConsumableArray(elementArray), _toConsumableArray(result));
          } else {
            elementArray.push(result);
          }
        });
        return elementArray;
      } // Otherwise its an object


      var _Object$entries$ = _slicedToArray(Object.entries(content)[0], 2),
          method = _Object$entries$[0],
          params = _Object$entries$[1]; // if (this[method] != null) {
      // return this[method](params);
      // }
      // $FlowFixMe


      var eqnMethod = this.eqnMethod(method, params);

      if (eqnMethod != null) {
        return eqnMethod;
      } // If it is not a known function, then it must be a new text or
      // symbol element           // $FlowFixMe


      var elem = this.addElementFromKey(method, params); // $FlowFixMe

      return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](elem);
    }
  }, {
    key: "contentToElement",
    value: function contentToElement(content) {
      // If input is alread an Elements object, then return it
      if (content instanceof _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]) {
        return content._dup();
      }

      if (content instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"] || content instanceof _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementPrimitive"]) {
        return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"]([new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Element"](content)]);
      }

      var elementArray = this.parseContent(content);

      if (!Array.isArray(elementArray)) {
        elementArray = [elementArray];
      }

      return new _Elements_Element__WEBPACK_IMPORTED_MODULE_3__["Elements"](elementArray);
    }
  }, {
    key: "eqnMethod",
    value: function eqnMethod(name, params) {
      // $FlowFixMe
      if (name === 'frac') {
        return this.frac(params);
      } // $FlowFixMe


      if (name === 'strike') {
        return this.strike(params);
      } // $FlowFixMe


      if (name === 'box') {
        return this.box(params);
      } // $FlowFixMe


      if (name === 'tBox') {
        return this.touchBox(params);
      } // $FlowFixMe


      if (name === 'root') {
        return this.root(params);
      } // $FlowFixMe


      if (name === 'brac') {
        return this.brac(params);
      } // $FlowFixMe


      if (name === 'sub') {
        return this.sub(params);
      } // $FlowFixMe


      if (name === 'sup') {
        return this.sup(params);
      } // $FlowFixMe


      if (name === 'supSub') {
        return this.supSub(params);
      } // $FlowFixMe


      if (name === 'topBar') {
        return this.topBar(params);
      } // $FlowFixMe


      if (name === 'bottomBar') {
        return this.bottomBar(params);
      } // $FlowFixMe


      if (name === 'annotate') {
        return this.annotate(params);
      } // $FlowFixMe


      if (name === 'bottomComment') {
        return this.bottomComment(params);
      } // $FlowFixMe


      if (name === 'topComment') {
        return this.topComment(params);
      } // $FlowFixMe


      if (name === 'bar') {
        return this.bar(params);
      } // $FlowFixMe


      if (name === 'topStrike') {
        return this.topStrike(params);
      } // $FlowFixMe


      if (name === 'bottomStrike') {
        return this.bottomStrike(params);
      } // $FlowFixMe


      if (name === 'pad') {
        return this.pad(params);
      } // $FlowFixMe


      if (name === 'int') {
        return this["int"](params);
      } // $FlowFixMe


      if (name === 'sumOf') {
        return this.sumProd(params);
      } // $FlowFixMe


      if (name === 'prodOf') {
        return this.sumProd(params);
      } // $FlowFixMe


      if (name === 'matrix') {
        return this.matrix(params);
      } // $FlowFixMe


      if (name === 'scale') {
        return this.scale(params);
      } // $FlowFixMe


      if (name === 'container') {
        return this.container(params);
      }

      return null;
    }
    /**
     * Equation container function
     * @see {@link EQN_Container} for description and examples
     */

  }, {
    key: "container",
    value: function container(options) {
      var content;
      var scale;
      var fit; // fits content to container - width, height, contain, null

      var width;
      var ascent;
      var descent;
      var xAlign; // left, center, right, multiplier (to left)

      var yAlign; // bottom, baseline, middle, top, multiplier (to bottom)

      var fullContentBounds;
      var defaultOptions = {
        scaleModifier: 1,
        fit: null,
        width: null,
        ascent: null,
        descent: null,
        xAlign: 'center',
        yAlign: 'baseline',
        fullContentBounds: false
      };

      if (Array.isArray(options)) {
        var _options = _slicedToArray(options, 9);

        content = _options[0];
        width = _options[1];
        descent = _options[2];
        ascent = _options[3];
        xAlign = _options[4];
        yAlign = _options[5];
        fit = _options[6];
        scale = _options[7];
        fullContentBounds = _options[8];
      } else {
        content = options.content;
        width = options.width;
        descent = options.descent;
        ascent = options.ascent;
        xAlign = options.xAlign;
        yAlign = options.yAlign;
        fit = options.fit;
        scale = options.scale;
        fullContentBounds = options.fullContentBounds;
      }

      var optionsIn = {
        scaleModifier: scale,
        fit: fit,
        width: width,
        ascent: ascent,
        descent: descent,
        xAlign: xAlign,
        yAlign: yAlign,
        fullContentBounds: fullContentBounds
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Elements_Container__WEBPACK_IMPORTED_MODULE_8__["default"]([this.contentToElement(content)], [], o);
    }
    /**
     * Equation bracket function
     * @see {@link EQN_Bracket} for description and examples
     */

  }, {
    key: "brac",
    value: function brac(options) {
      var content;
      var left;
      var right;
      var insideSpace;
      var outsideSpace;
      var topSpace;
      var bottomSpace;
      var minContentHeight;
      var minContentDescent;
      var descent;
      var height;
      var inSize;
      var useFullBounds;
      var fullContentBounds;

      if (Array.isArray(options)) {
        var _options2 = _slicedToArray(options, 14);

        left = _options2[0];
        content = _options2[1];
        right = _options2[2];
        inSize = _options2[3];
        insideSpace = _options2[4];
        outsideSpace = _options2[5];
        // $FlowFixMe
        topSpace = _options2[6];
        bottomSpace = _options2[7];
        minContentHeight = _options2[8];
        // $FlowFixMe
        minContentDescent = _options2[9];
        height = _options2[10];
        descent = _options2[11];
        fullContentBounds = _options2[12];
        // $FlowFixMe
        useFullBounds = _options2[13];
      } else {
        left = options.left;
        content = options.content;
        right = options.right;
        inSize = options.inSize;
        insideSpace = options.insideSpace;
        outsideSpace = options.outsideSpace;
        topSpace = options.topSpace;
        bottomSpace = options.bottomSpace;
        minContentHeight = options.minContentHeight;
        minContentDescent = options.minContentDescent;
        height = options.height;
        descent = options.descent;
        fullContentBounds = options.fullContentBounds;
        useFullBounds = options.useFullBounds;
      }

      var defaultOptions = {
        insideSpace: 0.03,
        outsideSpace: 0.03,
        topSpace: 0.05,
        bottomSpace: 0.05,
        minContentHeight: null,
        minContentDescent: null,
        descent: null,
        height: null,
        inSize: true,
        useFullBounds: false,
        fullContentBounds: false
      };
      var optionsIn = {
        insideSpace: insideSpace,
        outsideSpace: outsideSpace,
        topSpace: topSpace,
        bottomSpace: bottomSpace,
        minContentHeight: minContentHeight,
        minContentDescent: minContentDescent,
        descent: descent,
        height: height,
        inSize: inSize,
        useFullBounds: useFullBounds,
        fullContentBounds: fullContentBounds
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      var glyphs = {};

      if (left) {
        glyphs.left = {
          symbol: left,
          space: o.insideSpace,
          topSpace: o.topSpace,
          bottomSpace: o.bottomSpace,
          minContentHeight: o.minContentHeight,
          minContentDescent: o.minContentDescent,
          descent: o.descent,
          height: o.height
        };
      }

      if (right) {
        glyphs.right = {
          symbol: right,
          space: o.insideSpace,
          topSpace: o.topSpace,
          bottomSpace: o.bottomSpace,
          minContentHeight: o.minContentHeight,
          minContentDescent: o.minContentDescent,
          descent: o.descent,
          height: o.height
        };
      }

      return this.annotate({
        content: content,
        glyphs: glyphs,
        inSize: o.inSize,
        leftSpace: o.outsideSpace,
        rightSpace: o.outsideSpace,
        useFullBounds: o.useFullBounds,
        fullContentBounds: o.fullContentBounds
      });
    }
    /**
     * Equation bar function
     * @see {@link EQN_Bar} for description and examples
     */

  }, {
    key: "bar",
    value: function bar(options) {
      var forceOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var content;
      var symbol;
      var side;
      var space;
      var overhang;
      var length;
      var left;
      var right;
      var top;
      var bottom;
      var inSize;
      var minContentHeight;
      var minContentDescent;
      var minContentAscent;
      var descent;
      var fullContentBounds;
      var useFullBounds;
      var defaultOptions = {
        inSize: true,
        space: 0.03,
        overhang: 0,
        length: null,
        left: null,
        right: null,
        top: null,
        bottom: null,
        side: 'top',
        minContentHeight: null,
        minContentDescent: null,
        minContentAscent: null,
        descent: null,
        fullContentBounds: false,
        useFullBounds: false
      };

      if (Array.isArray(options)) {
        var _options3 = _slicedToArray(options, 17);

        content = _options3[0];
        symbol = _options3[1];
        inSize = _options3[2];
        space = _options3[3];
        overhang = _options3[4];
        length = _options3[5];
        left = _options3[6];
        right = _options3[7];
        top = _options3[8];
        bottom = _options3[9];
        side = _options3[10];
        minContentHeight = _options3[11];
        minContentDescent = _options3[12];
        minContentAscent = _options3[13];
        descent = _options3[14];
        fullContentBounds = _options3[15];
        useFullBounds = _options3[16];
      } else {
        content = options.content;
        symbol = options.symbol;
        inSize = options.inSize;
        space = options.space;
        overhang = options.overhang;
        length = options.length;
        left = options.left;
        right = options.right;
        top = options.top;
        bottom = options.bottom;
        side = options.side;
        minContentHeight = options.minContentHeight;
        minContentDescent = options.minContentDescent;
        minContentAscent = options.minContentAscent;
        descent = options.descent;
        fullContentBounds = options.fullContentBounds;
        useFullBounds = options.useFullBounds;
      }

      var optionsIn = {
        side: side,
        space: space,
        overhang: overhang,
        length: length,
        left: left,
        right: right,
        top: top,
        bottom: bottom,
        inSize: inSize,
        minContentHeight: minContentHeight,
        minContentDescent: minContentDescent,
        minContentAscent: minContentAscent,
        descent: descent,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn, forceOptions);
      var glyphs = {};

      if (o.side === 'top') {
        glyphs.top = {
          symbol: symbol,
          space: o.space,
          overhang: o.overhang,
          leftSpace: o.left,
          rightSpace: o.right,
          width: o.length
        };
      }

      if (o.side === 'bottom') {
        glyphs.bottom = {
          symbol: symbol,
          space: o.space,
          overhang: o.overhang,
          leftSpace: o.left,
          rightSpace: o.right,
          width: o.length
        };
      }

      if (o.side === 'left') {
        glyphs.left = {
          symbol: symbol,
          space: o.space,
          overhang: o.overhang,
          topSpace: o.top,
          bottomSpace: o.bottom,
          height: o.length,
          minContentHeight: o.minContentHeight,
          minContentDescent: o.minContentDescent,
          minContentAscent: o.minContentAscent,
          descent: o.descent
        };
      }

      if (o.side === 'right') {
        glyphs.right = {
          symbol: symbol,
          space: o.space,
          overhang: o.overhang,
          topSpace: o.top,
          bottomSpace: o.bottom,
          height: o.length,
          minContentHeight: o.minContentHeight,
          minContentDescent: o.minContentDescent,
          minContentAscent: o.minContentAscent,
          descent: o.descent
        };
      }

      return this.annotate({
        content: content,
        // $FlowFixMe
        glyphs: glyphs,
        inSize: o.inSize,
        fullContentBounds: o.fullContentBounds,
        useFullBounds: o.useFullBounds
      });
    } // /**
    //  */
    // pointer(options: EQN_Pointer) {
    //   const defaultOptions = {
    //     xPosition: 'center',
    //     yPosition: 'top',
    //     xAlign: 'center',
    //     yAlign: 'bottom',
    //     offset: new Point(0, 0),
    //     scale: 1,
    //     inSize: true,
    //     fullContentBounds: false,
    //     glyph: {
    //       content: {
    //         xPosition: 'center',
    //         yPosition: 'top',
    //         offset: new Point(0, 0),
    //         space: 0.05,
    //       },
    //       comment: {
    //         xPosition: 'center',
    //         yPosition: 'top',
    //         offset: new Point(0, 0),
    //         space: 0.05,
    //       }
    //     }
    //   }
    // }

    /**
     * Equation annotate function
     * @see {@link EQN_Annotate} for description and examples
     */

  }, {
    key: "annotate",
    value: function annotate(options) {
      var _this2 = this;

      var defaultOptions = {
        inSize: true,
        useFullBounds: false,
        fullContentBounds: false,
        space: 0,
        contentScale: 1,
        encompass: {
          space: 0
        },
        left: {
          space: 0,
          overhang: 0,
          yOffset: 0,
          annotationsOverContent: false
        },
        right: {
          space: 0,
          overhang: 0,
          yOffset: 0,
          annotationsOverContent: false
        },
        top: {
          space: 0,
          overhang: 0,
          xOffset: 0,
          annotationsOverContent: false
        },
        bottom: {
          space: 0,
          overhang: 0,
          xOffset: 0,
          annotationsOverContent: false
        },
        line: {
          content: {
            xAlign: 'left',
            yAlign: 'bottom',
            space: 0
          },
          annotation: {
            xAlign: 'left',
            yAlign: 'bottom',
            space: 0
          },
          annotationIndex: 0
        }
      };
      var content = options.content,
          annotation = options.annotation,
          annotations = options.annotations,
          glyphs = options.glyphs;
      var defaultAnnotation = {
        xPosition: 'center',
        yPosition: 'top',
        xAlign: 'center',
        yAlign: 'bottom',
        offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        scale: 1,
        inSize: true,
        fullContentBounds: false
      };
      var annotationsToProcess = [];

      if (annotation != null) {
        annotationsToProcess.push(annotation);
      } else if (annotations != null) {
        annotationsToProcess = annotations;
      }

      var fillAnnotation = function fillAnnotation(ann) {
        var annCopy = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultAnnotation, ann); // $FlowFixMe

        annCopy.offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(annCopy.offset); // $FlowFixMe

        annCopy.content = _this2.contentToElement(ann.content);
        return annCopy;
      };

      var fillAnnotations = function fillAnnotations(anns) {
        if (anns == null || !Array.isArray(anns)) {
          return [];
        }

        var annsCopy = [];
        anns.forEach(function (ann) {
          annsCopy.push(fillAnnotation(ann));
        });
        return annsCopy;
      };

      var annotationsToUse = fillAnnotations(annotationsToProcess);
      var glyphsToUse = {};

      var fillGlyphAnnotation = function fillGlyphAnnotation(side) {
        if (glyphs == null) {
          return;
        }

        var glyphSide = glyphs[side];

        if (glyphSide == null) {
          return;
        }

        glyphsToUse[side] = {}; // $FlowFixMe

        var glyphAnnotationsToProcess = glyphSide.annotations; // $FlowFixMe

        if (glyphSide.annotation != null) {
          // $FlowFixMe
          glyphAnnotationsToProcess = [glyphSide.annotation];
        }

        var glyphAnnotationsToUse = fillAnnotations(glyphAnnotationsToProcess);
        glyphsToUse[side] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions[side], glyphSide);
        glyphsToUse[side].annotations = glyphAnnotationsToUse; // $FlowFixMe

        glyphsToUse[side].glyph = _this2.getExistingOrAddSymbol(glyphSide.symbol || '');
      };

      fillGlyphAnnotation('encompass');
      fillGlyphAnnotation('left');
      fillGlyphAnnotation('right');
      fillGlyphAnnotation('top');
      fillGlyphAnnotation('bottom');
      fillGlyphAnnotation('line');
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Elements_BaseAnnotationFunction__WEBPACK_IMPORTED_MODULE_9__["default"](this.contentToElement(content), annotationsToUse, // $FlowFixMe
      glyphsToUse, o);
    }
    /**
     * Equation annotate function
     * @see {@link EQN_Scale} for description and examples
     */

  }, {
    key: "scale",
    value: function scale(options) {
      var content;
      var scale;
      var fullContentBounds;
      var defaultOptions = {
        scaleModifier: 1,
        fullContentBounds: false
      };

      if (Array.isArray(options)) {
        var _options4 = _slicedToArray(options, 3);

        content = _options4[0];
        scale = _options4[1];
        fullContentBounds = _options4[2];
      } else {
        content = options.content;
        scale = options.scale;
        fullContentBounds = options.fullContentBounds;
      }

      var optionsIn = {
        scaleModifier: scale,
        fullContentBounds: fullContentBounds
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Elements_Scale__WEBPACK_IMPORTED_MODULE_7__["default"]([this.contentToElement(content)], [], o);
    }
    /**
     * Equation fraction function
     * @see {@link EQN_Fraction} for description and examples
     */

  }, {
    key: "frac",
    value: function frac(options) {
      var numerator;
      var denominator;
      var symbol;
      var scale;
      var overhang;
      var numeratorSpace;
      var denominatorSpace;
      var offsetY;
      var fullContentBounds;
      var baseline; // This is imperfect type checking, as the assumption is if den, sym
      // and fractionScale is null, then they weren't defined by the caller
      // and therefore the caller is passing in a TypeFracObject or TypeFracArray
      // All the flow errors go away if TypeEquationPhrase is removed from
      // optionsOrNum (and then also remove the first if statement below)

      var defaultOptions = {
        scaleModifier: 1,
        numeratorSpace: 0.05,
        denominatorSpace: 0.05,
        offsetY: 0.07,
        overhang: 0.05,
        fullContentBounds: false,
        baseline: 'vinculum'
      };

      if (Array.isArray(options)) {
        var _options5 = _slicedToArray(options, 10);

        numerator = _options5[0];
        symbol = _options5[1];
        denominator = _options5[2];
        scale = _options5[3];
        numeratorSpace = _options5[4];
        denominatorSpace = _options5[5];
        overhang = _options5[6];
        offsetY = _options5[7];
        baseline = _options5[8];
        fullContentBounds = _options5[9];
      } else {
        numerator = options.numerator;
        symbol = options.symbol;
        denominator = options.denominator;
        scale = options.scale;
        numeratorSpace = options.numeratorSpace;
        denominatorSpace = options.denominatorSpace;
        overhang = options.overhang;
        offsetY = options.offsetY;
        baseline = options.baseline;
        fullContentBounds = options.fullContentBounds;
      }

      var optionsIn = {
        scaleModifier: scale,
        overhang: overhang,
        numeratorSpace: numeratorSpace,
        denominatorSpace: denominatorSpace,
        offsetY: offsetY,
        fullContentBounds: fullContentBounds,
        baseline: baseline
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Elements_Fraction__WEBPACK_IMPORTED_MODULE_4__["default"]([this.contentToElement(numerator), this.contentToElement(denominator)], // $FlowFixMe
      this.getExistingOrAddSymbol(symbol), o);
    }
  }, {
    key: "root",
    value: function root(optionsOrArray) {
      var content;
      var root;
      var symbol;
      var space;
      var leftSpace;
      var topSpace;
      var bottomSpace;
      var rightSpace;
      var rootScale;
      var rootOffset;
      var inSize = true;
      var fullContentBounds;
      var useFullBounds;

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray = _slicedToArray(optionsOrArray, 13);

        // $FlowFixMe
        symbol = _optionsOrArray[0];
        content = _optionsOrArray[1];
        inSize = _optionsOrArray[2];
        // $FlowFixMe
        space = _optionsOrArray[3];
        topSpace = _optionsOrArray[4];
        rightSpace = _optionsOrArray[5];
        bottomSpace = _optionsOrArray[6];
        leftSpace = _optionsOrArray[7];
        // $FlowFixMe
        root = _optionsOrArray[8];
        rootOffset = _optionsOrArray[9];
        rootScale = _optionsOrArray[10];
        fullContentBounds = _optionsOrArray[11];
        useFullBounds = _optionsOrArray[12];
      } else {
        symbol = optionsOrArray.symbol;
        content = optionsOrArray.content;
        inSize = optionsOrArray.inSize;
        space = optionsOrArray.space;
        topSpace = optionsOrArray.topSpace;
        rightSpace = optionsOrArray.rightSpace;
        bottomSpace = optionsOrArray.bottomSpace;
        leftSpace = optionsOrArray.leftSpace;
        root = optionsOrArray.root;
        rootOffset = optionsOrArray.rootOffset;
        rootScale = optionsOrArray.rootScale;
        fullContentBounds = optionsOrArray.fullContentBounds;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var defaultOptions = {
        space: 0.02,
        rootScale: 0.6,
        rootOffset: [0, 0.06],
        inSize: true,
        fullContentBounds: false,
        useFullBounds: false
      };
      var optionsIn = {
        leftSpace: leftSpace,
        topSpace: topSpace,
        bottomSpace: bottomSpace,
        rightSpace: rightSpace,
        space: space,
        rootScale: rootScale,
        rootOffset: rootOffset,
        inSize: inSize,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      options.rootOffset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.rootOffset);
      var annotations = [];

      if (root != null) {
        annotations.push({
          content: root,
          offset: options.rootOffset,
          scale: options.rootScale,
          reference: 'root'
        });
      }

      return this.annotate({
        content: content,
        inSize: options.inSize,
        useFullBounds: options.useFullBounds,
        fullContentBounds: options.fullContentBounds,
        glyphs: {
          encompass: {
            symbol: symbol,
            // $FlowFixMe
            annotations: annotations,
            space: options.space,
            leftSpace: options.leftSpace,
            rightSpace: options.rightSpace,
            topSpace: options.topSpace,
            bottomSpace: options.bottomSpace
          }
        }
      });
    }
    /**
     * Equation super-sub script function
     * @see {@link EQN_SuperscriptSubscript} for description and examples
     */

  }, {
    key: "supSub",
    value: function supSub(options) {
      var content;
      var superscript = null;
      var subscript = null;
      var scale = null;
      var subscriptOffset = null;
      var superscriptOffset = null;
      var inSize;

      if (Array.isArray(options)) {
        var _options6 = _slicedToArray(options, 7);

        // $FlowFixMe
        content = _options6[0];
        superscript = _options6[1];
        subscript = _options6[2];
        scale = _options6[3];
        // $FlowFixMe
        superscriptOffset = _options6[4];
        subscriptOffset = _options6[5];
        inSize = _options6[6];
      } else {
        content = options.content;
        superscript = options.superscript;
        subscript = options.subscript;
        scale = options.scale;
        superscriptOffset = options.superscriptOffset;
        subscriptOffset = options.subscriptOffset;
        inSize = options.inSize;
      }

      var defaultOptions = {
        scale: 0.5,
        subscriptOffset: [0, 0],
        superscriptOffset: [0, 0],
        inSize: true
      };
      var optionsIn = {
        superscript: superscript,
        subscript: subscript,
        scale: scale,
        subscriptOffset: subscriptOffset,
        superscriptOffset: superscriptOffset,
        inSize: inSize
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      var annotations = [];

      if (superscript != null) {
        annotations.push({
          content: o.superscript,
          xPosition: 'right',
          yPosition: '0.7a',
          xAlign: 'left',
          yAlign: 'baseline',
          offset: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.superscriptOffset).add(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](o.scale * 0.04, 0)),
          scale: o.scale
        });
      }

      if (subscript != null) {
        annotations.push({
          content: o.subscript,
          xPosition: 'right',
          yPosition: 'baseline',
          xAlign: 'left',
          yAlign: '0.7a',
          offset: o.subscriptOffset,
          scale: o.scale
        });
      }

      return this.annotate({
        content: content,
        // $FlowFixMe
        annotations: annotations,
        inSize: o.inSize
      });
    }
    /**
     * Equation superscript function
     * @see {@link EQN_Superscript} for description and examples
     */

  }, {
    key: "sup",
    value: function sup(options) {
      var content;
      var superscript;
      var scale;
      var offset; // let superscriptOffset = null;

      var inSize;

      if (Array.isArray(options)) {
        var _options7 = _slicedToArray(options, 5);

        // $FlowFixMe
        content = _options7[0];
        superscript = _options7[1];
        scale = _options7[2];
        offset = _options7[3];
        inSize // $FlowFixMe
        = _options7[4];
      } else {
        content = options.content;
        superscript = options.superscript;
        scale = options.scale;
        offset = options.offset;
        inSize = options.inSize;
      } // $FlowFixMe


      return this.supSub({
        // $FlowFixMe
        content: content,
        // $FlowFixMe
        superscript: superscript,
        // $FlowFixMe
        superscriptOffset: offset,
        // $FlowFixMe
        inSize: inSize,
        // $FlowFixMe
        scale: scale
      });
    }
    /**
     * Equation subscript function
     * @see {@link EQN_Subscript} for description and examples
     */

  }, {
    key: "sub",
    value: function sub(options) {
      var content;
      var subscript;
      var scale;
      var offset;
      var inSize;

      if (Array.isArray(options)) {
        var _options8 = _slicedToArray(options, 5);

        // $FlowFixMe
        content = _options8[0];
        subscript = _options8[1];
        scale = _options8[2];
        offset = _options8[3];
        inSize // $FlowFixMe
        = _options8[4];
      } else {
        content = options.content;
        subscript = options.subscript;
        scale = options.scale;
        offset = options.offset;
        inSize = options.inSize;
      } // $FlowFixMe


      return this.supSub({
        // $FlowFixMe
        content: content,
        // $FlowFixMe
        subscript: subscript,
        // $FlowFixMe
        subscriptOffset: offset,
        // $FlowFixMe
        inSize: inSize,
        // $FlowFixMe
        scale: scale
      });
    }
    /**
     * Equation touch box function
     * @see {@link EQN_TouchBox} for description and examples
     */

  }, {
    key: "touchBox",
    value: function touchBox(options) {
      var content;
      var symbol;
      var space;
      var topSpace;
      var bottomSpace;
      var leftSpace;
      var rightSpace;
      var defaultOptions = {
        inSize: false,
        space: 0,
        topSpace: null,
        bottomSpace: null,
        leftSpace: null,
        rightSpace: null
      };

      if (Array.isArray(options)) {
        var _options9 = _slicedToArray(options, 7);

        content = _options9[0];
        symbol = _options9[1];
        space = _options9[2];
        topSpace = _options9[3];
        rightSpace = _options9[4];
        bottomSpace = _options9[5];
        leftSpace = _options9[6];
      } else {
        content = options.content;
        symbol = options.symbol;
        space = options.space;
        topSpace = options.topSpace;
        rightSpace = options.rightSpace;
        bottomSpace = options.bottomSpace;
        leftSpace = options.leftSpace;
      }

      var optionsIn = {
        content: content,
        symbol: symbol,
        space: space,
        topSpace: topSpace,
        rightSpace: rightSpace,
        bottomSpace: bottomSpace,
        leftSpace: leftSpace
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return this.annotate({
        content: content,
        inSize: false,
        fullContentBounds: false,
        useFullBounds: false,
        glyphs: {
          encompass: {
            symbol: symbol,
            space: o.space,
            leftSpace: o.leftSpace,
            rightSpace: o.rightSpace,
            topSpace: o.topSpace,
            bottomSpace: o.bottomSpace
          }
        }
      });
    }
    /**
     * Equation box function
     * @see {@link EQN_Box} for description and examples
     */

  }, {
    key: "box",
    value: function box(options) {
      var content;
      var symbol;
      var inSize;
      var space;
      var topSpace;
      var bottomSpace;
      var leftSpace;
      var rightSpace;
      var fullContentBounds;
      var useFullBounds;
      var defaultOptions = {
        inSize: false,
        space: 0,
        topSpace: null,
        bottomSpace: null,
        leftSpace: null,
        rightSpace: null,
        fullContentBounds: false,
        useFullBounds: false
      };

      if (Array.isArray(options)) {
        var _options10 = _slicedToArray(options, 10);

        content = _options10[0];
        symbol = _options10[1];
        inSize = _options10[2];
        space = _options10[3];
        topSpace = _options10[4];
        rightSpace = _options10[5];
        bottomSpace = _options10[6];
        leftSpace = _options10[7];
        fullContentBounds = _options10[8];
        useFullBounds = _options10[9];
      } else {
        content = options.content;
        symbol = options.symbol;
        inSize = options.inSize;
        space = options.space;
        topSpace = options.topSpace;
        rightSpace = options.rightSpace;
        bottomSpace = options.bottomSpace;
        leftSpace = options.leftSpace;
        fullContentBounds = options.fullContentBounds;
        useFullBounds = options.useFullBounds;
      }

      var optionsIn = {
        content: content,
        symbol: symbol,
        inSize: inSize,
        space: space,
        topSpace: topSpace,
        rightSpace: rightSpace,
        bottomSpace: bottomSpace,
        leftSpace: leftSpace,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return this.annotate({
        content: content,
        inSize: o.inSize,
        fullContentBounds: o.fullContentBounds,
        useFullBounds: o.useFullBounds,
        glyphs: {
          encompass: {
            symbol: symbol,
            space: o.space,
            leftSpace: o.leftSpace,
            rightSpace: o.rightSpace,
            topSpace: o.topSpace,
            bottomSpace: o.bottomSpace
          }
        }
      });
    }
    /**
     * Equation pad function
     * @see {@link EQN_Pad} for description and examples
     */

  }, {
    key: "pad",
    value: function pad(options) {
      var content;
      var top;
      var right;
      var bottom;
      var left;
      var defaultOptions = {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };

      if (Array.isArray(options)) {
        var _options11 = _slicedToArray(options, 5);

        content = _options11[0];
        top = _options11[1];
        right = _options11[2];
        bottom = _options11[3];
        left = _options11[4];
      } else {
        content = options.content;
        top = options.top;
        right = options.right;
        bottom = options.bottom;
        left = options.left;
      }

      var optionsIn = {
        top: top,
        right: right,
        bottom: bottom,
        left: left
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return this.annotate({
        content: content,
        topSpace: o.top,
        bottomSpace: o.bottom,
        rightSpace: o.right,
        leftSpace: o.left
      });
    }
    /**
     * Equation top bar function
     * @see {@link EQN_Bar} for description and examples
     */

  }, {
    key: "topBar",
    value: function topBar(options) {
      return this.bar(options, {
        side: 'top'
      });
    }
    /**
     * Equation bottom bar function
     * @see {@link EQN_Bar} for description and examples
     */

  }, {
    key: "bottomBar",
    value: function bottomBar(options) {
      return this.bar(options, {
        side: 'bottom'
      });
    }
    /**
     * Equation matrix function
     * @see {@link EQN_Matrix} for description and examples
     */

  }, {
    key: "matrix",
    value: function matrix(options) {
      var _this3 = this;

      var content;
      var left;
      var right;
      var order;
      var fit;
      var space;
      var scale;
      var yAlign;
      var brac;
      var fullContentBounds;
      var defaultOptions = {
        contentScale: 0.7,
        fit: 'min',
        space: [0.05, 0.05],
        yAlign: 'baseline',
        brac: {},
        fullContentBounds: false
      };

      if (Array.isArray(options)) {
        var _options12 = _slicedToArray(options, 10);

        order = _options12[0];
        left = _options12[1];
        content = _options12[2];
        right = _options12[3];
        scale = _options12[4];
        fit = _options12[5];
        space = _options12[6];
        yAlign = _options12[7];
        brac = _options12[8];
        fullContentBounds = _options12[9];
      } else {
        order = options.order;
        left = options.left;
        content = options.content;
        right = options.right;
        scale = options.scale;
        fit = options.fit;
        space = options.space;
        yAlign = options.yAlign;
        brac = options.brac;
        fullContentBounds = options.fullContentBounds;
      }

      var optionsIn = {
        space: space,
        fit: fit,
        order: order,
        contentScale: scale,
        brac: brac,
        yAlign: yAlign,
        fullContentBounds: fullContentBounds
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      var contentArray = [];

      if (content != null) {
        // $FlowFixMe
        contentArray = content.map(function (c) {
          return _this3.contentToElement(c);
        });
      }

      if (o.order == null || o.order[0] * o.order[1] !== contentArray.length) {
        o.order = [1, contentArray.length];
      }

      if (o.space != null) {
        o.space = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.space);
      }

      var matrixContent = new _Elements_Matrix__WEBPACK_IMPORTED_MODULE_6__["default"](contentArray, [], o);

      if (left != null && right != null) {
        return this.brac(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, o.brac, {
          content: matrixContent,
          left: left,
          right: right
        }));
      }

      return matrixContent;
    }
    /**
     * Equation integral function
     * @see {@link EQN_Integral} for description and examples
     */

  }, {
    key: "int",
    value: function int(options) {
      var content;
      var symbol;
      var space;
      var topSpace;
      var bottomSpace;
      var height;
      var yOffset;
      var inSize;
      var from;
      var to;
      var scale;
      var fromScale;
      var toScale; // let fromSpace;
      // let toSpace;

      var fromOffset;
      var toOffset;
      var limitsPosition;
      var limitsAroundContent;
      var fromXPosition;
      var fromYPosition;
      var fromXAlign;
      var fromYAlign;
      var toXPosition;
      var toYPosition;
      var toXAlign;
      var toYAlign;
      var fullBoundsContent;
      var useFullBounds;
      var defaultOptions = {
        inSize: true,
        space: 0.01,
        topSpace: 0.1,
        bottomSpace: 0.1,
        height: null,
        yOffset: 0,
        contentScale: 1,
        fromScale: 0.5,
        toScale: 0.5,
        fromOffset: [0, 0],
        toOffset: [0.04, 0],
        limitsPosition: 'side',
        limitsAroundContent: true,
        fromXPosition: 0.5,
        fromYPosition: 'bottom',
        fromXAlign: 'left',
        fromYAlign: 'middle',
        toXPosition: 'right',
        toYPosition: 'top',
        toXAlign: 'left',
        toYAlign: 'middle',
        fullBoundsContent: false,
        useFullBounds: false
      };

      if (Array.isArray(options)) {
        var _options13 = _slicedToArray(options, 27);

        // $FlowFixMe
        symbol = _options13[0];
        content = _options13[1];
        from = _options13[2];
        to = _options13[3];
        inSize = _options13[4];
        space = _options13[5];
        // $FlowFixMe
        topSpace = _options13[6];
        bottomSpace = _options13[7];
        // $FlowFixMe
        height = _options13[8];
        yOffset = _options13[9];
        scale = _options13[10];
        // $FlowFixMe
        fromScale = _options13[11];
        toScale = _options13[12];
        // $FlowFixMe
        fromOffset = _options13[13];
        toOffset = _options13[14];
        limitsPosition = _options13[15];
        // $FlowFixMe
        limitsAroundContent = _options13[16];
        // $FlowFixMe
        fromXPosition = _options13[17];
        fromYPosition = _options13[18];
        fromXAlign = _options13[19];
        fromYAlign = _options13[20];
        // $FlowFixMe
        toXPosition = _options13[21];
        toYPosition = _options13[22];
        toXAlign = _options13[23];
        toYAlign = _options13[24];
        // $FlowFixMe
        fullBoundsContent = _options13[25];
        useFullBounds = _options13[26];
      } else {
        content = options.content;
        symbol = options.symbol;
        from = options.from;
        to = options.to;
        inSize = options.inSize;
        space = options.space;
        topSpace = options.topSpace;
        bottomSpace = options.bottomSpace;
        height = options.height;
        yOffset = options.yOffset;
        scale = options.scale;
        fromScale = options.fromScale;
        toScale = options.toScale;
        fromOffset = options.fromOffset;
        toOffset = options.toOffset;
        limitsPosition = options.limitsPosition;
        limitsAroundContent = options.limitsAroundContent;
        fromXPosition = options.fromXPosition;
        fromYPosition = options.fromYPosition;
        fromXAlign = options.fromXAlign;
        fromYAlign = options.fromYAlign;
        toXPosition = options.toXPosition;
        toYPosition = options.toYPosition;
        toXAlign = options.toXAlign;
        toYAlign = options.toYAlign;
        fullBoundsContent = options.fullBoundsContent;
        useFullBounds = options.useFullBounds;
      }

      if (limitsPosition === 'topBottom') {
        defaultOptions.fromXPosition = 0.1;
        defaultOptions.fromYPosition = 'bottom';
        defaultOptions.fromXAlign = 'center';
        defaultOptions.fromYAlign = 'top'; // $FlowFixMe

        defaultOptions.toXPosition = 0.9;
        defaultOptions.toYPosition = 'top';
        defaultOptions.toXAlign = 'center';
        defaultOptions.toYAlign = 'bottom';
        defaultOptions.fromOffset = [0, -0.04];
        defaultOptions.toOffset = [0, 0.04];
      }

      if (limitsPosition === 'topBottomCenter') {
        // $FlowFixMe
        defaultOptions.fromXPosition = 'center';
        defaultOptions.fromYPosition = 'bottom';
        defaultOptions.fromXAlign = 'center';
        defaultOptions.fromYAlign = 'top';
        defaultOptions.toXPosition = 'center';
        defaultOptions.toYPosition = 'top';
        defaultOptions.toXAlign = 'center';
        defaultOptions.toYAlign = 'bottom';
        defaultOptions.fromOffset = [0, -0.04];
        defaultOptions.toOffset = [0, 0.04];
      }

      var optionsIn = {
        space: space,
        topSpace: topSpace,
        bottomSpace: bottomSpace,
        height: height,
        yOffset: yOffset,
        inSize: inSize,
        contentScale: scale,
        fromScale: fromScale,
        toScale: toScale,
        // fromSpace,
        // toSpace,
        fromOffset: fromOffset,
        toOffset: toOffset,
        limitsPosition: limitsPosition,
        limitsAroundContent: limitsAroundContent,
        fromXPosition: fromXPosition,
        fromYPosition: fromYPosition,
        fromXAlign: fromXAlign,
        fromYAlign: fromYAlign,
        toXPosition: toXPosition,
        toYPosition: toYPosition,
        toXAlign: toXAlign,
        toYAlign: toYAlign,
        fullBoundsContent: fullBoundsContent,
        useFullBounds: useFullBounds
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      o.fromOffset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.fromOffset);
      o.toOffset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.toOffset);
      var annotations = [{
        content: to,
        xPosition: o.toXPosition,
        yPosition: o.toYPosition,
        xAlign: o.toXAlign,
        yAlign: o.toYAlign,
        offset: o.toOffset,
        scale: o.toScale
      }, {
        content: from,
        xPosition: o.fromXPosition,
        yPosition: o.fromYPosition,
        xAlign: o.fromXAlign,
        yAlign: o.fromYAlign,
        offset: o.fromOffset,
        scale: o.fromScale
      }];
      return this.annotate({
        // $FlowFixMe
        content: content,
        inSize: o.inSize,
        contentScale: o.contentScale,
        fullBoundsContent: o.fullBoundsContent,
        useFullBounds: o.useFullBounds,
        glyphs: {
          left: {
            // $FlowFixMe
            symbol: symbol,
            space: o.space,
            topSpace: o.topSpace,
            bottomSpace: o.bottomSpace,
            height: o.height,
            yOffset: o.yOffset,
            annotationsOverContent: o.limitsAroundContent,
            // $FlowFixMe
            annotations: annotations
          }
        }
      });
    }
    /**
     * Equation sum of function
     * @see {@link EQN_SumOf} for description and examples
     */

  }, {
    key: "sumOf",
    value: function sumOf(options) {
      return this.sumProd(options);
    }
    /**
     * Equation product of function
     * @see {@link EQN_ProdOf} for description and examples
     */

  }, {
    key: "prodOf",
    value: function prodOf(options) {
      return this.sumProd(options);
    }
  }, {
    key: "sumProd",
    value: function sumProd(optionsOrArray) {
      var content;
      var symbol;
      var space;
      var topSpace;
      var bottomSpace;
      var height;
      var yOffset;
      var inSize;
      var from;
      var to;
      var scale;
      var fromScale;
      var toScale;
      var fromSpace;
      var toSpace;
      var fromOffset;
      var toOffset;
      var fullBoundsContent;
      var useFullBounds;
      var defaultOptions = {
        inSize: true,
        space: 0.1,
        topSpace: 0.07,
        bottomSpace: 0.07,
        height: null,
        yOffset: 0,
        contentScale: 1,
        fromScale: 0.5,
        toScale: 0.5,
        fromSpace: 0.04,
        toSpace: 0.04,
        fromOffset: [0, 0],
        toOffset: [0, 0],
        fullBoundsContent: false,
        useFullBounds: false
      };

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray2 = _slicedToArray(optionsOrArray, 19);

        symbol = _optionsOrArray2[0];
        content = _optionsOrArray2[1];
        from = _optionsOrArray2[2];
        to = _optionsOrArray2[3];
        inSize = _optionsOrArray2[4];
        space = _optionsOrArray2[5];
        topSpace = _optionsOrArray2[6];
        bottomSpace = _optionsOrArray2[7];
        height = _optionsOrArray2[8];
        yOffset = _optionsOrArray2[9];
        scale = _optionsOrArray2[10];
        fromScale = _optionsOrArray2[11];
        toScale = _optionsOrArray2[12];
        fromSpace = _optionsOrArray2[13];
        toSpace = _optionsOrArray2[14];
        fromOffset = _optionsOrArray2[15];
        toOffset = _optionsOrArray2[16];
        fullBoundsContent = _optionsOrArray2[17];
        useFullBounds = _optionsOrArray2[18];
      } else {
        symbol = optionsOrArray.symbol;
        content = optionsOrArray.content;
        from = optionsOrArray.from;
        to = optionsOrArray.to;
        inSize = optionsOrArray.inSize;
        space = optionsOrArray.space;
        topSpace = optionsOrArray.topSpace;
        bottomSpace = optionsOrArray.bottomSpace;
        height = optionsOrArray.height;
        yOffset = optionsOrArray.yOffset;
        scale = optionsOrArray.scale;
        fromScale = optionsOrArray.fromScale;
        toScale = optionsOrArray.toScale;
        fromSpace = optionsOrArray.fromSpace;
        toSpace = optionsOrArray.toSpace;
        fromOffset = optionsOrArray.fromOffset;
        toOffset = optionsOrArray.toOffset;
        fullBoundsContent = optionsOrArray.fullBoundsContent;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var optionsIn = {
        space: space,
        topSpace: topSpace,
        bottomSpace: bottomSpace,
        height: height,
        yOffset: yOffset,
        inSize: inSize,
        contentScale: scale,
        fromScale: fromScale,
        toScale: toScale,
        fromSpace: fromSpace,
        toSpace: toSpace,
        fromOffset: fromOffset,
        toOffset: toOffset,
        fullBoundsContent: fullBoundsContent,
        useFullBounds: useFullBounds
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      var annotations = [{
        content: to,
        xPosition: 'center',
        yPosition: 'top',
        xAlign: 'center',
        yAlign: 'bottom',
        offset: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.toOffset).add(0, options.toSpace),
        scale: options.toScale
      }, {
        content: from,
        xPosition: 'center',
        yPosition: 'bottom',
        xAlign: 'center',
        yAlign: 'top',
        offset: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.fromOffset).add(0, -options.fromSpace),
        scale: options.fromScale
      }];
      return this.annotate({
        content: content,
        contentScale: options.contentScale,
        fullBoundsContent: options.fullBoundsContent,
        useFullBounds: options.useFullBounds,
        glyphs: {
          left: {
            // $FlowFixMe
            symbol: symbol,
            // $FlowFixMe
            annotations: annotations,
            // $FlowFixMe
            space: options.space,
            topSpace: options.topSpace,
            bottomSpace: options.bottomSpace,
            yOffset: options.yOffset,
            height: options.height
          }
        },
        inSize: options.inSize
      });
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "processComment",
    value: function processComment(optionsOrArray) {
      var content;
      var comment;
      var symbol;
      var contentSpace;
      var commentSpace;
      var contentLineSpace;
      var commentLineSpace;
      var scale;
      var inSize;
      var fullContentBounds;
      var useFullBounds;

      if (Array.isArray(optionsOrArray)) {
        var _optionsOrArray3 = _slicedToArray(optionsOrArray, 11);

        content = _optionsOrArray3[0];
        comment = _optionsOrArray3[1];
        symbol = _optionsOrArray3[2];
        contentSpace = _optionsOrArray3[3];
        commentSpace = _optionsOrArray3[4];
        scale = _optionsOrArray3[5];
        inSize = _optionsOrArray3[6];
        contentLineSpace = _optionsOrArray3[7];
        commentLineSpace = _optionsOrArray3[8];
        // $FlowFixMe
        fullContentBounds = _optionsOrArray3[9];
        useFullBounds = _optionsOrArray3[10];
      } else {
        content = optionsOrArray.content;
        comment = optionsOrArray.comment;
        symbol = optionsOrArray.symbol;
        contentSpace = optionsOrArray.contentSpace;
        commentSpace = optionsOrArray.commentSpace;
        scale = optionsOrArray.scale;
        inSize = optionsOrArray.inSize;
        contentLineSpace = optionsOrArray.contentLineSpace;
        commentLineSpace = optionsOrArray.commentLineSpace;
        fullContentBounds = optionsOrArray.fullContentBounds;
        useFullBounds = optionsOrArray.useFullBounds;
      }

      var optionsIn = {
        contentSpace: contentSpace,
        commentSpace: commentSpace,
        scale: scale,
        inSize: inSize,
        useFullBounds: useFullBounds,
        fullContentBounds: fullContentBounds,
        contentLineSpace: contentLineSpace,
        commentLineSpace: commentLineSpace
      };
      var defaultOptions = {
        contentSpace: 0.03,
        commentSpace: 0.03,
        scale: 0.6,
        inSize: true,
        fullContentBounds: false,
        useFullBounds: false,
        contentLineSpace: 0.03,
        commentLineSpace: 0.03
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return [content, comment, symbol, options.contentSpace, options.commentSpace, options.scale, options.inSize, options.contentLineSpace, options.commentLineSpace, options.fullContentBounds, options.useFullBounds];
    }
    /**
     * Equation top comment of function
     * @param {EQN_Comment} options
     * @see {@link EQN_Comment} for description and examples
     */
    // $FlowFixMe

  }, {
    key: "topComment",
    value: function topComment() {
      var _this$processComment = this.processComment.apply(this, arguments),
          _this$processComment2 = _slicedToArray(_this$processComment, 11),
          content = _this$processComment2[0],
          comment = _this$processComment2[1],
          symbol = _this$processComment2[2],
          contentSpaceToUse = _this$processComment2[3],
          commentSpaceToUse = _this$processComment2[4],
          scaleToUse = _this$processComment2[5],
          inSize = _this$processComment2[6],
          contentLineSpace = _this$processComment2[7],
          commentLineSpace = _this$processComment2[8],
          fullContentBounds = _this$processComment2[9],
          useFullBounds = _this$processComment2[10];

      var annotations = [{
        content: comment,
        xPosition: 'center',
        yPosition: 'top',
        xAlign: 'center',
        yAlign: 'bottom',
        scale: scaleToUse,
        offset: [0, commentSpaceToUse]
      }];

      if (symbol === '' || symbol == null) {
        return this.annotate({
          content: content,
          // $FlowFixMe
          annotations: annotations,
          inSize: inSize
        });
      }

      var glyph = this.getExistingOrAddSymbol(symbol);

      if (glyph instanceof _Symbols_Line__WEBPACK_IMPORTED_MODULE_10__["default"]) {
        annotations[0].offset = [0, commentSpaceToUse + contentSpaceToUse];
        return this.annotate({
          content: content,
          fullContentBounds: fullContentBounds,
          useFullBounds: useFullBounds,
          // $FlowFixMe
          annotations: annotations,
          glyphs: {
            line: {
              symbol: symbol,
              // $FlowFixMe
              content: {
                xAlign: 'center',
                yAlign: 'top',
                space: contentLineSpace
              },
              annotation: {
                xAlign: 'center',
                yAlign: 'bottom',
                space: commentLineSpace
              },
              annotationIndex: 0
            }
          },
          inSize: inSize
        });
      }

      return this.annotate({
        content: content,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds,
        glyphs: {
          top: {
            symbol: symbol,
            // $FlowFixMe
            annotations: annotations,
            space: contentSpaceToUse
          }
        },
        inSize: inSize
      });
    }
    /**
     * Equation bottom comment of function
     * @param {EQN_Comment} options
     * @see {@link EQN_Comment} for description and examples
     */
    // $FlowFixMe

  }, {
    key: "bottomComment",
    value: function bottomComment() {
      var _this$processComment3 = this.processComment.apply(this, arguments),
          _this$processComment4 = _slicedToArray(_this$processComment3, 11),
          content = _this$processComment4[0],
          comment = _this$processComment4[1],
          symbol = _this$processComment4[2],
          contentSpaceToUse = _this$processComment4[3],
          commentSpaceToUse = _this$processComment4[4],
          scaleToUse = _this$processComment4[5],
          inSize = _this$processComment4[6],
          contentLineSpace = _this$processComment4[7],
          commentLineSpace = _this$processComment4[8],
          fullContentBounds = _this$processComment4[9],
          useFullBounds = _this$processComment4[10];

      var annotations = [{
        content: comment,
        xPosition: 'center',
        yPosition: 'bottom',
        xAlign: 'center',
        yAlign: 'top',
        scale: scaleToUse,
        offset: [0, -commentSpaceToUse]
      }];

      if (symbol === '' || symbol == null) {
        return this.annotate({
          content: content,
          // $FlowFixMe
          annotations: annotations,
          inSize: inSize
        });
      }

      var glyph = this.getExistingOrAddSymbol(symbol);

      if (glyph instanceof _Symbols_Line__WEBPACK_IMPORTED_MODULE_10__["default"]) {
        annotations[0].offset = [0, -commentSpaceToUse - contentSpaceToUse];
        return this.annotate({
          content: content,
          fullContentBounds: fullContentBounds,
          useFullBounds: useFullBounds,
          // $FlowFixMe
          annotations: annotations,
          glyphs: {
            line: {
              symbol: symbol,
              // $FlowFixMe
              content: {
                xAlign: 'center',
                yAlign: 'bottom',
                space: contentLineSpace
              },
              annotation: {
                xAlign: 'center',
                yAlign: 'top',
                space: commentLineSpace
              },
              annotationIndex: 0
            }
          },
          inSize: inSize
        });
      }

      return this.annotate({
        content: content,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds,
        glyphs: {
          bottom: {
            symbol: symbol,
            // $FlowFixMe
            annotations: annotations,
            space: contentSpaceToUse
          }
        },
        inSize: inSize
      });
    }
    /**
     * Equation strike of function
     * @see {@link EQN_Strike} for description and examples
     */

  }, {
    key: "strike",
    value: function strike(options) {
      var content;
      var symbol;
      var inSize;
      var space;
      var topSpace;
      var bottomSpace;
      var leftSpace;
      var rightSpace;
      var fullContentBounds;
      var useFullBounds;
      var defaultOptions = {
        inSize: false,
        space: 0.02,
        topSpace: null,
        bottomSpace: null,
        leftSpace: null,
        rightSpace: null,
        fullContentBounds: false,
        useFullBounds: false
      };

      if (Array.isArray(options)) {
        var _options14 = _slicedToArray(options, 10);

        content = _options14[0];
        symbol = _options14[1];
        inSize = _options14[2];
        space = _options14[3];
        topSpace = _options14[4];
        rightSpace = _options14[5];
        bottomSpace = _options14[6];
        leftSpace = _options14[7];
        fullContentBounds = _options14[8];
        useFullBounds = _options14[9];
      } else {
        content = options.content;
        symbol = options.symbol;
        inSize = options.inSize;
        space = options.space;
        topSpace = options.topSpace;
        rightSpace = options.rightSpace;
        bottomSpace = options.bottomSpace;
        leftSpace = options.leftSpace;
        fullContentBounds = options.fullContentBounds;
        useFullBounds = options.useFullBounds;
      }

      var glyph = this.getExistingOrAddSymbol(symbol);

      if (glyph != null && glyph.custom.options.style === 'horizontal') {
        defaultOptions.space = 0; // $FlowFixMe

        defaultOptions.leftSpace = 0.02; // $FlowFixMe

        defaultOptions.rightSpace = 0.02; // $FlowFixMe
      }

      var optionsIn = {
        content: content,
        symbol: symbol,
        inSize: inSize,
        space: space,
        topSpace: topSpace,
        rightSpace: rightSpace,
        bottomSpace: bottomSpace,
        leftSpace: leftSpace,
        fullContentBounds: fullContentBounds,
        useFullBounds: useFullBounds
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn); // console.log(glyph, o)

      return this.annotate({
        content: content,
        inSize: o.inSize,
        fullContentBounds: o.fullContentBounds,
        useFullBounds: o.useFullBounds,
        glyphs: {
          encompass: {
            symbol: symbol,
            topSpace: o.topSpace,
            bottomSpace: o.bottomSpace,
            leftSpace: o.leftSpace,
            rightSpace: o.rightSpace,
            space: o.space
          }
        }
      });
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "processStrike",
    value: function processStrike(optionsOrContent) {
      var content;
      var comment;
      var symbol;
      var commentSpace;
      var scale;
      var space;
      var inSize;

      if (Array.isArray(optionsOrContent)) {
        // $FlowFixMe
        var _optionsOrContent = _slicedToArray(optionsOrContent, 7);

        content = _optionsOrContent[0];
        symbol = _optionsOrContent[1];
        comment = _optionsOrContent[2];
        inSize = _optionsOrContent[3];
        space = _optionsOrContent[4];
        scale = _optionsOrContent[5];
        commentSpace = _optionsOrContent[6];
      } else {
        content = optionsOrContent.content;
        comment = optionsOrContent.comment;
        symbol = optionsOrContent.symbol;
        inSize = optionsOrContent.inSize;
        space = optionsOrContent.space;
        scale = optionsOrContent.scale;
        commentSpace = optionsOrContent.commentSpace;
      }

      var optionsIn = {
        inSize: inSize,
        commentSpace: commentSpace,
        scale: scale,
        space: space
      };
      var defaultOptions = {
        space: 0,
        scale: 0.5,
        commentSpace: 0.1,
        inSize: true
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return [content, symbol, comment, options.inSize, options.commentSpace, options.scale, options.space];
    }
    /**
     * Equation top strike of function
     * @param {EQN_Strike} options
     * @see {@link EQN_Strike} for description and examples
     */
    // $FlowFixMe

  }, {
    key: "topStrike",
    value: function topStrike() {
      var _this$processStrike = this.processStrike.apply(this, arguments),
          _this$processStrike2 = _slicedToArray(_this$processStrike, 7),
          content = _this$processStrike2[0],
          symbol = _this$processStrike2[1],
          comment = _this$processStrike2[2],
          inSize = _this$processStrike2[3],
          commentSpace = _this$processStrike2[4],
          scale = _this$processStrike2[5],
          space = _this$processStrike2[6];

      var annotations = [{
        content: comment,
        xPosition: 'center',
        yPosition: 'top',
        xAlign: 'center',
        yAlign: 'bottom',
        offset: [0, commentSpace],
        scale: scale
      }];
      return this.annotate({
        // $FlowFixMe
        content: content,
        inSize: inSize,
        glyphs: {
          encompass: {
            // $FlowFixMe
            symbol: symbol,
            space: space,
            // $FlowFixMe
            annotations: annotations
          }
        }
      });
    }
    /**
     * Equation bottom strike of function
     * @param {EQN_Strike} options
     * @see {@link EQN_Strike} for description and examples
     */
    // $FlowFixMe

  }, {
    key: "bottomStrike",
    value: function bottomStrike() {
      var _this$processStrike3 = this.processStrike.apply(this, arguments),
          _this$processStrike4 = _slicedToArray(_this$processStrike3, 7),
          content = _this$processStrike4[0],
          symbol = _this$processStrike4[1],
          comment = _this$processStrike4[2],
          inSize = _this$processStrike4[3],
          commentSpace = _this$processStrike4[4],
          scale = _this$processStrike4[5],
          space = _this$processStrike4[6];

      var annotations = [{
        content: comment,
        xPosition: 'center',
        yPosition: 'bottom',
        xAlign: 'center',
        yAlign: 'top',
        offset: [0, -commentSpace],
        scale: scale
      }];
      return this.annotate({
        // $FlowFixMe
        content: content,
        inSize: inSize,
        glyphs: {
          encompass: {
            // $FlowFixMe
            symbol: symbol,
            space: space,
            // $FlowFixMe
            annotations: annotations
          }
        }
      });
    }
  }]);

  return EquationFunctions;
}();

/***/ }),

/***/ "./src/js/figure/Equation/EquationSymbols.js":
/*!***************************************************!*\
  !*** ./src/js/figure/Equation/EquationSymbols.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationSymbols; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _FigurePrimitives_FigurePrimitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../FigurePrimitives/FigurePrimitives */ "./src/js/figure/FigurePrimitives/FigurePrimitives.js");
/* harmony import */ var _Symbols_Bracket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Symbols/Bracket */ "./src/js/figure/Equation/Symbols/Bracket.js");
/* harmony import */ var _Symbols_Box__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Symbols/Box */ "./src/js/figure/Equation/Symbols/Box.js");
/* harmony import */ var _Symbols_Brace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Symbols/Brace */ "./src/js/figure/Equation/Symbols/Brace.js");
/* harmony import */ var _Symbols_SquareBracket__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Symbols/SquareBracket */ "./src/js/figure/Equation/Symbols/SquareBracket.js");
/* harmony import */ var _Symbols_AngleBracket__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Symbols/AngleBracket */ "./src/js/figure/Equation/Symbols/AngleBracket.js");
/* harmony import */ var _Symbols_Bar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Symbols/Bar */ "./src/js/figure/Equation/Symbols/Bar.js");
/* harmony import */ var _Symbols_Sum__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Symbols/Sum */ "./src/js/figure/Equation/Symbols/Sum.js");
/* harmony import */ var _Symbols_Product__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Symbols/Product */ "./src/js/figure/Equation/Symbols/Product.js");
/* harmony import */ var _Symbols_Integral__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Symbols/Integral */ "./src/js/figure/Equation/Symbols/Integral.js");
/* harmony import */ var _Symbols_Arrow__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Symbols/Arrow */ "./src/js/figure/Equation/Symbols/Arrow.js");
/* harmony import */ var _Symbols_Vinculum__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Symbols/Vinculum */ "./src/js/figure/Equation/Symbols/Vinculum.js");
/* harmony import */ var _Symbols_Strike__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Symbols/Strike */ "./src/js/figure/Equation/Symbols/Strike.js");
/* harmony import */ var _Symbols_Radical__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Symbols/Radical */ "./src/js/figure/Equation/Symbols/Radical.js");
/* harmony import */ var _Symbols_Line__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Symbols/Line */ "./src/js/figure/Equation/Symbols/Line.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // import { FigureElementCollection } from '../Element';
// import Integral from './Symbols/Integral';
// import SuperSub from './Elements/SuperSub';

 // import BracketNew from './Symbols/BracketNew';

 // import Radical from './Symbols/Radical';



 // import SquareBracketNew from './Symbols/SquareBracketNew';



 // import SimpleIntegral from './Symbols/SimpleIntegral';








var EquationSymbols = /*#__PURE__*/function () {
  function EquationSymbols(shapes, defaultColor) {
    _classCallCheck(this, EquationSymbols);

    this.shapes = shapes;
    this.defaultColor = defaultColor;
  }

  _createClass(EquationSymbols, [{
    key: "get",
    value: function get(name, options) {
      if (name === 'vinculum') {
        // $FlowFixMe
        return this.vinculum(options);
      }

      if (name === 'strike') {
        // $FlowFixMe
        return this.strike(options);
      }

      if (name === 'bracket') {
        // $FlowFixMe
        return this.bracket(options);
      }

      if (name === 'squareBracket') {
        // $FlowFixMe
        return this.squareBracket(options);
      }

      if (name === 'brace') {
        // $FlowFixMe
        return this.brace(options);
      }

      if (name === 'bar') {
        // $FlowFixMe
        return this.bar(options);
      }

      if (name === 'tBox') {
        // $FlowFixMe
        return this.touchBox(options);
      }

      if (name === 'box') {
        // $FlowFixMe
        return this.box(options);
      }

      if (name === 'angleBracket') {
        // $FlowFixMe
        return this.angleBracket(options);
      }

      if (name === 'radical') {
        // $FlowFixMe
        return this.radical(options);
      }

      if (name === 'sum') {
        // $FlowFixMe
        return this.sum(options);
      }

      if (name === 'prod') {
        // $FlowFixMe
        return this.product(options);
      }

      if (name === 'int') {
        // $FlowFixMe
        return this.integral(options);
      }

      if (name === 'arrow') {
        // $FlowFixMe
        return this.arrow(options);
      }

      if (name === 'line') {
        // $FlowFixMe
        return this.line(options);
      }

      return null;
    } // vinculumOld(options: { color?: TypeColor } = {}) {
    //   let { color } = options;
    //   if (color == null) {
    //     color = this.defaultColor;
    //   }
    //   return this.shapes.horizontalLine(
    //     new Point(0, 0),
    //     1, 1, 0,
    //     color,
    //     new Transform('vinculum').scale(1, 1).translate(0, 0),
    //   );
    // }

  }, {
    key: "vinculum",
    value: function vinculum(options) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: null,
        staticHeight: null,
        // not definable by user
        draw: 'dynamic',
        staticWidth: 'first',
        drawBorderBuffer: 0,
        touchBorder: 0
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Vinculum__WEBPACK_IMPORTED_MODULE_13__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('VinculumSymbol').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "box",
    value: function box(optionsIn) {
      var defaultOptions = {
        color: this.defaultColor,
        fill: false,
        width: null,
        height: null,
        lineWidth: 0.01,
        draw: 'dynamic',
        staticHeight: 'first',
        staticWidth: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Symbols_Box__WEBPACK_IMPORTED_MODULE_4__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Box').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "line",
    value: function line(optionsIn) {
      var defaultOptions = {
        color: this.defaultColor,
        width: 0.01,
        dash: [],
        arrow: null,
        draw: 'dynamic',
        staticHeight: 'first',
        staticWidth: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Symbols_Line__WEBPACK_IMPORTED_MODULE_16__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Line').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "touchBox",
    value: function touchBox(optionsIn) {
      var defaultOptions = {
        color: [0, 0, 0, 0.0001],
        fill: false,
        width: null,
        height: null,
        lineWidth: 0.01,
        draw: 'static',
        staticHeight: 'first',
        staticWidth: 'first',
        isTouchable: true
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Symbols_Box__WEBPACK_IMPORTED_MODULE_4__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('TouchBox').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "arrow",
    value: function arrow(options) {
      var defaultOptions = {
        color: this.defaultColor,
        direction: 'right',
        lineWidth: 0.01,
        arrowWidth: 0.03,
        arrowLength: 0.04,
        length: 0.1,
        staticHeight: 'first',
        draw: 'static',
        staticWidth: null // not definable by user

      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);

      if (optionsToUse.direction === 'left' || optionsToUse.direction === 'right') {
        optionsToUse.side = 'top';
      } else {
        optionsToUse.side = 'left';
      }

      return new _Symbols_Arrow__WEBPACK_IMPORTED_MODULE_12__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('ArrowSymbol').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "sum",
    value: function sum(options) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: null,
        sides: 5,
        staticHeight: 'first',
        draw: 'static',
        staticWidth: null,
        // not definable by user
        drawBorderBuffer: 0,
        touchBorder: 0
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Sum__WEBPACK_IMPORTED_MODULE_9__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('sum').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "product",
    value: function product(options) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: null,
        sides: 5,
        staticHeight: 'first',
        draw: 'static',
        staticWidth: null // not definable by user

      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Product__WEBPACK_IMPORTED_MODULE_10__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Sum').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "integral",
    value: function integral(options) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: null,
        width: null,
        tipWidth: null,
        // percentage: 0.95,
        sides: 30,
        // staticSize: 'first',
        // radius: 0.03,
        serif: true,
        staticHeight: 'first',
        draw: 'static',
        staticWidth: null,
        // not definable by user
        num: 1,
        type: 'generic',
        serifSides: 10,
        lineIntegralSides: 20
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Integral__WEBPACK_IMPORTED_MODULE_11__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Integral').scale(1, 1).translate(0, 0), this.shapes.limits, // optionsToUse.staticSize,
      optionsToUse);
    }
  }, {
    key: "radical",
    value: function radical(optionsIn) {
      var defaultOptions = {
        color: this.defaultColor,
        lineWidth: 0.01,
        staticSize: null,
        startHeight: 0.5,
        startWidth: 0.5,
        maxStartWidth: 0.15,
        maxStartHeight: 0.15,
        proportionalToHeight: true,
        draw: 'dynamic',
        staticHeight: 'first',
        staticWidth: 'first'
      };

      if (optionsIn.proportionalToHeight != null && optionsIn.proportionalToHeight === false) {
        defaultOptions.startHeight = 0.15;
        defaultOptions.startWidth = 0.15; // defaultOptions.maxStartHeight = null;
        // defaultOptions.maxStartWidth = null;
      }

      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, optionsIn);
      return new _Symbols_Radical__WEBPACK_IMPORTED_MODULE_15__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bracket').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "strike",
    value: function strike(options) {
      var defaultOptions = {
        style: 'cross',
        color: this.defaultColor,
        lineWidth: null,
        draw: 'dynamic',
        staticHeight: 'first',
        width: null,
        height: null,
        staticWidth: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Strike__WEBPACK_IMPORTED_MODULE_14__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bracket').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse); // let { color } = options;
      // if (color == null) {
      //   color = this.defaultColor;
      // }
      // return this.shapes.horizontalLine(
      //   new Point(0, 0),
      //   1, 1, 0,
      //   color,
      //   new Transform('strike').scale(1, 1).rotate(0).translate(0, 0),
      // );
    } // xStrike(options: { color?: TypeColor } = {}) {
    //   let { color } = options;
    //   if (color == null) {
    //     color = this.defaultColor;
    //   }
    //   const cross = this.collections.collection(new Transform('xStrike')
    //     .scale(1, 1).rotate(0).translate(0, 0));
    //   cross.color = color;
    //   const strike1 = this.shapes.horizontalLine(
    //     new Point(0, 0),
    //     1, 1, 0,
    //     color,
    //     new Transform('strikeLine').scale(1, 1).rotate(0).translate(0, 0),
    //   );
    //   const strike2 = strike1._dup();
    //   cross.add('s1', strike1);
    //   cross.add('s2', strike2);
    //   return cross;
    // }

  }, {
    key: "bracket",
    value: function bracket(options) {
      var defaultOptions = {
        side: 'left',
        color: this.defaultColor,
        lineWidth: null,
        sides: 10,
        draw: 'dynamic',
        staticHeight: 'first',
        width: null,
        tipWidth: null,
        staticWidth: null
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Bracket__WEBPACK_IMPORTED_MODULE_3__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bracket').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "angleBracket",
    value: function angleBracket(options) {
      var defaultOptions = {
        side: 'left',
        lineWidth: null,
        width: null,
        color: this.defaultColor,
        draw: 'dynamic',
        staticHeight: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_AngleBracket__WEBPACK_IMPORTED_MODULE_7__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "brace",
    value: function brace(options) {
      var defaultOptions = {
        side: 'left',
        color: this.defaultColor,
        lineWidth: null,
        sides: 10,
        draw: 'dynamic',
        staticHeight: 'first',
        width: null,
        tipWidth: null,
        staticWidth: null
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Brace__WEBPACK_IMPORTED_MODULE_5__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('brace').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "bar",
    value: function bar(options) {
      var defaultOptions = {
        side: 'left',
        lineWidth: 0.01,
        color: this.defaultColor,
        draw: 'dynamic',
        staticHeight: 'first'
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options);
      return new _Symbols_Bar__WEBPACK_IMPORTED_MODULE_8__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }, {
    key: "squareBracket",
    value: function squareBracket(options) {
      var defaultOptions = {
        side: 'left',
        lineWidth: null,
        color: this.defaultColor,
        width: null,
        draw: 'dynamic',
        staticHeight: 'first',
        radius: 0,
        sides: 5,
        tipWidth: null
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, options); // if (optionsToUse.endLineWidth == null) {
      //   optionsToUse.endLineWidth = optionsToUse.lineWidth * 0.7;
      // }

      return new _Symbols_SquareBracket__WEBPACK_IMPORTED_MODULE_6__["default"](this.shapes.webgl, optionsToUse.color, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('bar').scale(1, 1).translate(0, 0), this.shapes.limits, optionsToUse);
    }
  }]);

  return EquationSymbols;
}();



/***/ }),

/***/ "./src/js/figure/Equation/HTMLEquation.js":
/*!************************************************!*\
  !*** ./src/js/figure/Equation/HTMLEquation.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTMLEquation; });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function makeDiv(id, classes, text) {
  var indent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var indentStr = ' '.repeat(indent);
  var idStr = id ? " id=\"".concat(id, "\"") : '';
  var classString = classes ? " ".concat(classes.join(' ')) : '';
  var out = "".concat(indentStr, "<div").concat(idStr, " class=\"equation_element").concat(classString, "\">\n");
  out += "".concat(text, "\n");
  out += "".concat(indentStr, "</div>");
  return out;
} // Most fundamental Equation Element properties includes element size and
// location, as well as html id and classes.


var HTMLElementProperties = /*#__PURE__*/function () {
  function HTMLElementProperties() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, HTMLElementProperties);

    this.id = id;

    if (Array.isArray(classes)) {
      this.classes = classes;
    } else if (classes.length > 0) {
      this.classes = classes.split(' ');
    } else {
      this.classes = [];
    }
  }

  _createClass(HTMLElementProperties, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return makeDiv(this.id, this.classes, text, indent);
    }
  }]);

  return HTMLElementProperties;
}();

var HTMLElement = /*#__PURE__*/function (_HTMLElementPropertie) {
  _inherits(HTMLElement, _HTMLElementPropertie);

  var _super = _createSuper(HTMLElement);

  function HTMLElement(text) {
    var _this;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, HTMLElement);

    _this = _super.call(this, id, classes);

    _this.classes.push('equation_text');

    _this.text = text;
    return _this;
  }

  _createClass(HTMLElement, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return _get(_getPrototypeOf(HTMLElement.prototype), "render", this).call(this, indent, "".concat(' '.repeat(indent + 2)).concat(this.text));
    }
  }]);

  return HTMLElement;
}(HTMLElementProperties);

var HTMLElements = /*#__PURE__*/function (_HTMLElementPropertie2) {
  _inherits(HTMLElements, _HTMLElementPropertie2);

  var _super2 = _createSuper(HTMLElements);

  function HTMLElements(content) {
    var _this2;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, HTMLElements);

    _this2 = _super2.call(this, id, classes);
    var filteredContent = [];
    content.forEach(function (c) {
      if (c !== null) {
        filteredContent.push(c);
      }
    });
    _this2.content = filteredContent;
    return _this2;
  }

  _createClass(HTMLElements, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return _get(_getPrototypeOf(HTMLElements.prototype), "render", this).call(this, indent, this.content.map(function (c) {
        return c.render(indent + 2);
      }).join('\n'));
    }
  }]);

  return HTMLElements;
}(HTMLElementProperties);

var Fraction = /*#__PURE__*/function (_HTMLElementPropertie3) {
  _inherits(Fraction, _HTMLElementPropertie3);

  var _super3 = _createSuper(Fraction);

  function Fraction(numerator, denominator) {
    var _this3;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    _classCallCheck(this, Fraction);

    _this3 = _super3.call(this, id, classes);

    _this3.classes.push('fraction');

    _this3.numerator = numerator;
    _this3.denominator = denominator;
    return _this3;
  }

  _createClass(Fraction, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"numerator\">\n");
      out += this.numerator.render(indent + 4);
      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"fraction_line\"> </div>\n");
      out += "".concat(s, "<div class=\"denominator\">\n");
      out += this.denominator.render(indent + 4);
      out += "\n".concat(s, "</div>");
      return _get(_getPrototypeOf(Fraction.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return Fraction;
}(HTMLElementProperties);

var SuperSub = /*#__PURE__*/function (_HTMLElementPropertie4) {
  _inherits(SuperSub, _HTMLElementPropertie4);

  var _super4 = _createSuper(SuperSub);

  function SuperSub(content, superscript, subscript) {
    var _this4;

    var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var classes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';

    _classCallCheck(this, SuperSub);

    _this4 = _super4.call(this, id, classes);

    _this4.classes.push('supersub');

    _this4.superscript = superscript;
    _this4.subscript = subscript;
    _this4.content = content;
    return _this4;
  }

  _createClass(SuperSub, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"supsub_content element\">\n");
      out += this.content.render(indent + 2);
      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"super_sub element\">\n");
      out += "".concat(s, "<div class=\"super_sub_super superscript_text element\">\n");

      if (this.superscript !== null) {
        out += this.superscript.render(indent + 4);
      }

      out += "\n".concat(s, "</div>\n");
      out += "".concat(s, "<div class=\"super_sub_sub subscript_text element\">\n");

      if (this.subscript !== null) {
        out += this.subscript.render(indent + 4);
      }

      out += "\n".concat(s, "</div>");
      out += "\n".concat(s, "</div>\n");
      return _get(_getPrototypeOf(SuperSub.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return SuperSub;
}(HTMLElementProperties);

var Subscript = /*#__PURE__*/function (_SuperSub) {
  _inherits(Subscript, _SuperSub);

  var _super5 = _createSuper(Subscript);

  function Subscript(content, // eslint-disable-line no-use-before-define
  subscript) {
    var _this5;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    _classCallCheck(this, Subscript);

    _this5 = _super5.call(this, content, null, subscript, id, classes);

    var index = _this5.classes.indexOf('supersub');

    if (index > -1) {
      _this5.classes.splice(index, 1);
    }

    _this5.classes.push('subscript');

    return _this5;
  }

  return Subscript;
}(SuperSub);

var Superscript = /*#__PURE__*/function (_SuperSub2) {
  _inherits(Superscript, _SuperSub2);

  var _super6 = _createSuper(Superscript);

  function Superscript(content, // eslint-disable-line no-use-before-define
  superscript) {
    var _this6;

    var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    _classCallCheck(this, Superscript);

    _this6 = _super6.call(this, content, superscript, null, id, classes);

    var index = _this6.classes.indexOf('supersub');

    if (index > -1) {
      _this6.classes.splice(index, 1);
    }

    _this6.classes.push('superscript');

    return _this6;
  }

  return Superscript;
}(SuperSub);

var Root = /*#__PURE__*/function (_HTMLElementPropertie5) {
  _inherits(Root, _HTMLElementPropertie5);

  var _super7 = _createSuper(Root);

  function Root(content) {
    var _this7;

    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, Root);

    _this7 = _super7.call(this, id, classes);
    _this7.content = content;
    return _this7;
  }

  _createClass(Root, [{
    key: "render",
    value: function render() {
      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var s = ' '.repeat(indent + 2);
      var out = '';
      out += "".concat(s, "<div class=\"square_root element\">\n");
      out += "".concat(s, "  <div class=\"equation_element radical element\">\n");
      out += "".concat(s, "    &radic;\n");
      out += "".concat(s, "  </div>\n");
      out += this.content.render(indent + 4);
      out += "\n".concat(s, "</div>");
      return _get(_getPrototypeOf(Root.prototype), "render", this).call(this, indent, out);
    }
  }]);

  return Root;
}(HTMLElementProperties); // function contentToE(content: string | HTMLElements): HTMLElements {
//   let c;
//   if (typeof content === 'string') {
//     c = new HTMLElements(content);
//   } else {
//     c = content;
//   }
//   return c;
// }


function contentToElement(content) {
  if (content instanceof HTMLElements) {
    return content;
  }

  if (content instanceof HTMLElement || content instanceof HTMLElementProperties) {
    return new HTMLElements([content]);
  }

  if (typeof content === 'string') {
    return new HTMLElements([new HTMLElement(content)]);
  } // Otherwise must be array


  var elementArray = [];
  content.forEach(function (c) {
    if (typeof c === 'string') {
      elementArray.push(new HTMLElement(c));
    } else {
      elementArray.push(c);
    }
  });
  return new HTMLElements(elementArray);
}

var HTMLEquation = /*#__PURE__*/function (_HTMLElements) {
  _inherits(HTMLEquation, _HTMLElements);

  var _super8 = _createSuper(HTMLEquation);

  function HTMLEquation() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, HTMLEquation);

    return _super8.call(this, [], id, classes);
  }

  _createClass(HTMLEquation, [{
    key: "createEq",
    value: function createEq(content) {
      var _this8 = this;

      var elements = [];
      content.forEach(function (c) {
        if (typeof c === 'string') {
          elements.push(new HTMLElement(c));
        } else {
          elements.push(c);
        }

        _this8.content = elements;
      });
    }
  }, {
    key: "htmlElement",
    value: function htmlElement() {
      var element = document.createElement('div');
      element.setAttribute('id', this.id);
      element.innerHTML = this.render();
      this.classes.forEach(function (c) {
        if (c) {
          element.classList.add(c);
        }
      });
      return element;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "el",
    value: function el(content) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return new HTMLElement(content, id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "supsub",
    value: function supsub(content, superscript, subscript) {
      var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var classes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
      return new SuperSub(contentToElement(content), contentToElement(superscript), contentToElement(subscript), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sub",
    value: function sub(content, subscript) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Subscript(contentToElement(content), contentToElement(subscript), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sup",
    value: function sup(content, superscript) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Superscript(contentToElement(content), contentToElement(superscript), id, classes);
    } // e(
    //   content: string | Array<HTMLElementProperties>,
    //   id: string = '',
    //   classes: string | Array<string> = [],
    // ) {
    //   return new HTMLElements(content, id, classes);
    // }
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "frac",
    value: function frac(numerator, denominator) {
      var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var classes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      return new Fraction(contentToElement(numerator), contentToElement(denominator), id, classes);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "sqrt",
    value: function sqrt(content) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return new Root(contentToElement(content), id, classes);
    }
  }]);

  return HTMLEquation;
}(HTMLElements);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/AngleBracket.js":
/*!********************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/AngleBracket.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bar; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/figure/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Bar = /*#__PURE__*/function (_Bracket) {
  _inherits(Bar, _Bracket);

  var _super = _createSuper(Bar);

  function Bar() {
    _classCallCheck(this, Bar);

    return _super.apply(this, arguments);
  }

  _createClass(Bar, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    // Angle Bracket
    //                         width
    //                      |<------->|
    //                      |         |
    //                      |      ___
    //           A          |     /  /
    //           |          |    /  /
    //           |          |   /  /
    //           |          |  /  /
    //           |            /  /
    //    height |           /  /
    //           |           \  \
    //           |            \  \
    //           |             \  \
    //           |              \  \
    //           |               \  \
    //           |                \  \
    //           V                 \__\
    // To calculate dimensions, need to solve the below where we know:
    //   * height (h)
    //   * width (w)
    //
    // Looking at the bottom half of the bracket:
    //
    //                                 width
    //                   |<------------------------------>|
    //                   |                                |
    //                   |   tip width           Dh       |
    //                   |<-------------->|<------------->|
    //
    //          ______   __________________...............:
    //          A        :\*               \              :
    //          |        : \  *             \             :
    //          |        :  \   *            \            :
    //          |        :   \    *           \           :
    //          |        :    \     *          \          :
    //          |        :     \      *         \         :
    //          |        :      \       * A      \ D      :
    //   h / 2  |        :       \        *       \       :
    //          |        :        \         *      \      :
    //          |        :       C \          *     \     :
    //          |        :          \           *    \    :
    //          |        :           \            *   \   :
    //          |        :            \             *  \  :
    //          |        :             \              * \ :
    //          |        :              \               *\:
    //          V_____   :...............\________________\  B
    //                                    \               *
    //                        C extension  \          *
    //                                      \      *   E
    //                                     R \ *
    //
    //   - Draw a circle at B of radius lineWidth
    //   - This circle will touch an extended line C at a right angle (R)
    //   - Line E is the line from the circle center (B) to the tangent point (R)
    //   - Line A is the secant and the extended line C is the tangent of the
    //     the angle Theta which is angle between the line A and line E
    //   - The angle between lines E and D is also a right angle (as C || D),
    //     therefore we can calculate the angle between A and D (Beta)
    //   - Calculate the angle from the horiontal to A: a = arctan2(h/2, w)
    //   - Calculate the angle from the horizontal to D: alpha = a + Beta
    //   - Calculate the horizontal component of D: Dh = h / 2 / tan(alpha)
    //   - Calculate Tip Width = w - Dh
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      // const { side } = options;
      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width;

      var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height / 2));
      var theta = Math.acos(lineWidth / line.distance);
      var beta = Math.PI / 2 - theta;
      var alpha = line.ang + beta;
      var tipWidth = width - height / 2 / Math.tan(alpha);
      var leftPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - tipWidth, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - tipWidth, height)];
      var rightPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tipWidth, height / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height)]; // if (side === 'top' || side === 'bottom') {
      //   return this.getBracketPoints(leftPoints, rightPoints, side, height, width);
      // }

      return [leftPoints, rightPoints, width, height]; // return this.getBracketPoints(leftPoints, rightPoints, side, width, height);
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (width == null && options.width == null) {
        out.width = 97570.78 + (0.004958708 - 97570.78) / (1 + Math.pow(height / 2399858, 0.9383909));
      }

      if (width != null) {
        out.width = width;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.7;
      } else {
        out.lineWidth = options.lineWidth;
      }

      return out;
    }
  }]);

  return Bar;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Arrow.js":
/*!*************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Arrow.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Arrow; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/figure/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Arrow = /*#__PURE__*/function (_Bracket) {
  _inherits(Arrow, _Bracket);

  var _super = _createSuper(Arrow);

  function Arrow() {
    _classCallCheck(this, Arrow);

    return _super.apply(this, arguments);
  }

  _createClass(Arrow, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    //                      arrow width
    //                 |<--------------->|
    //                 |                 |
    //                 |        6        |
    //          -------|------- 0 -------|---------
    //          A      |      00000      |        A
    //   arrow  |      |     0000000     |        |
    //   height |      |   00000000000   |        |
    //          V      | 000000000000000 |        |
    //          ---- 5 0000000000000000000 4      |
    //                       0000000              |
    //                    3  0000000 2            |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |  height
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              |
    //                       0000000              V
    //                       0000000 --------------
    //                      1       0
    //                       |     |
    //                       |     |
    //                       |<--->|
    //                     Line Width
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, lengthIn) {
      var direction = options.direction;
      var length = lengthIn;

      if (length == null) {
        length = options.length;
      }

      var _this$getVerticalDefa = this.getVerticalDefaultValues(length, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          arrowWidth = _this$getVerticalDefa.arrowWidth,
          arrowLength = _this$getVerticalDefa.arrowLength;

      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](arrowWidth / 2 + lineWidth / 2, 0);
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](arrowWidth / 2 - lineWidth / 2, 0);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p0.x, length - arrowLength);
      var p3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p1.x, p2.y);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](arrowWidth, p2.y);
      var p5 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, p2.y);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](arrowWidth / 2, length);
      var leftPoints = [p1._dup(), p3._dup(), p5._dup(), p6._dup()];
      var rightPoints = [p0._dup(), p2._dup(), p4._dup(), p6._dup()];

      if (direction === 'down' || direction === 'left') {
        var m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, -1).translate(0, length).m(); // $FlowFixMe

        leftPoints = leftPoints.map(function (p) {
          return p.transformBy(m);
        }); // $FlowFixMe

        rightPoints = rightPoints.map(function (p) {
          return p.transformBy(m);
        });
      } // let side = 'left';
      // if (direction === 'up' || direction === 'down') {
      //   side = 'left';
      // } else if (direction === 'left' || direction === 'right') {
      //   side = 'top';
      // }
      // return [points, widthIn, length];
      // $FlowFixMe
      // if (direction === 'up' || direction === 'down') {
      //   // console.log(length, arrowWidth)
      //   return [leftPoints, rightPoints, length, arrowWidth];
      // }
      // $FlowFixMe


      return [leftPoints, rightPoints, arrowWidth, length];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(length, width, options) {
      var out = {};

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(length / 39.01413, 0.618041))) * 0.8;
      } else {
        out.lineWidth = options.lineWidth;
      }

      if (options.arrowWidth == null) {
        out.arrowWidth = out.lineWidth * 3;
      } else {
        out.arrowWidth = options.arrowWidth;
      }

      if (options.arrowLength == null) {
        out.arrowLength = out.lineWidth * 3;
      } else {
        out.arrowLength = options.arrowLength;
      }

      out.width = out.arrowWidth; // $FlowFixMe

      return out;
    }
  }]);

  return Arrow;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Bar.js":
/*!***********************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Bar.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bar; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/figure/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Bar = /*#__PURE__*/function (_Bracket) {
  _inherits(Bar, _Bracket);

  var _super = _createSuper(Bar);

  function Bar() {
    _classCallCheck(this, Bar);

    return _super.apply(this, arguments);
  }

  _createClass(Bar, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width;

      var leftPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height)];
      var rightPoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lineWidth, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lineWidth, height)];
      return [leftPoints, rightPoints, width, height];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.8;
      } else {
        out.lineWidth = options.lineWidth;
      }

      out.width = out.lineWidth;
      return out;
    }
  }]);

  return Bar;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Box.js":
/*!***********************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Box.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Box; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
/* harmony import */ var _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Elements/Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




 // import WebGLInstance from '../../../webgl/webgl';

var Box = /*#__PURE__*/function (_Symbol2) {
  _inherits(Box, _Symbol2);

  var _super = _createSuper(Box);

  function Box() {
    _classCallCheck(this, Box);

    return _super.apply(this, arguments);
  }

  _createClass(Box, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //                                          width
    //                 |<--------------------------------------------------->|
    //                 |                                                     |
    //                 |                                                     |
    //                2                                                       4
    //         ------- 0000000000000000000000000000000000000000000000000000000
    //         A       0000000000000000000000000000000000000000000000000000000
    //         |       0000 3                                           5 0000
    //         |       0000                                               0000
    //         |       0000                                               0000
    //  height |       0000                                               0000
    //         |       0000                                               0000
    //         |       0000                                               0000
    //         |       0000                                               0000
    //         |       0000 1                                           7 0000
    //         |       0000000000000000000000000000000000000000000000000000000
    //         V______ 0000000000000000000000000000000000000000000000000000000
    //                0                                                        6
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      var fill = options.fill;

      var _this$getDefaultValue = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width,
          height = _this$getDefaultValue.height;

      var points;

      if (fill) {
        points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height)];
      } else {
        points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](lineWidth, lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](lineWidth, height - lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width - lineWidth, height - lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width - lineWidth, lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](lineWidth, lineWidth)];
      }

      return [points, width, height, 'strip'];
    }
    /* eslint-disable class-methods-use-this */

  }, {
    key: "getBounds",
    value: function getBounds(options, leftIn, bottomIn, widthIn, heightIn) {
      var _this$getDefaultValue2 = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue2.lineWidth,
          width = _this$getDefaultValue2.width,
          height = _this$getDefaultValue2.height;

      var bounds = new _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__["default"]();

      if (options.draw === 'static') {
        var staticWidth = options.staticWidth,
            staticHeight = options.staticHeight;

        if (staticWidth === 'first') {
          staticWidth = width + lineWidth * 2;
        }

        if (staticHeight === 'first') {
          staticHeight = height + lineWidth * 2;
        }

        if (staticWidth == null) {
          staticWidth = 1;
        }

        if (staticHeight == null) {
          staticHeight = 1;
        }

        var heightLineWidthRatio = lineWidth / staticHeight;
        var widthLineWidthRatio = lineWidth / staticWidth;
        bounds.width = width / (1 - 2 * widthLineWidthRatio);
        bounds.height = height / (1 - 2 * heightLineWidthRatio);
        var widthLineWidth = bounds.width * widthLineWidthRatio;
        var heightLineWidth = bounds.height * heightLineWidthRatio;
        bounds.left = leftIn - widthLineWidth;
        bounds.right = bounds.left + bounds.width;
        bounds.bottom = bottomIn - heightLineWidth;
        bounds.top = bounds.bottom + bounds.height;
        bounds.ascent = bounds.height;
        bounds.descent = 0;
      } else {
        bounds.left = leftIn + widthIn / 2 - width / 2 - lineWidth;
        bounds.bottom = bottomIn + heightIn / 2 - height / 2 - lineWidth;
        bounds.width = width + lineWidth * 2;
        bounds.height = height + lineWidth * 2;
        bounds.right = bounds.left + bounds.width;
        bounds.top = bounds.bottom + bounds.height;
        bounds.descent = 0;
        bounds.ascent = bounds.height;
      }

      return bounds;
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth != null && typeof options.lineWidth === 'number') {
        out.lineWidth = options.lineWidth;
      } else {
        out.lineWidth = 0.01;
      }

      if (options.fill === true) {
        out.lineWidth = 0;
      }

      if (options.height != null && typeof options.height === 'number') {
        out.height = options.height;
      } else if (height != null) {
        out.height = height;
      } else {
        out.height = 1;
      }

      if (options.width != null && typeof options.width === 'number') {
        out.width = options.width;
      } else if (width != null) {
        out.width = width;
      } else {
        out.width = 1;
      }

      return out;
    }
  }, {
    key: "surround",
    value: function surround(parent, children) {
      var spaceIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var drawingSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'local';
      var elements = [parent];

      if (children != null && children.length !== 0) {
        elements = parent.getElements(children);
      }

      if (elements.length === 0) {
        return;
      }

      var space = typeof spaceIn === 'number' ? Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])([spaceIn, spaceIn]) : Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(spaceIn);
      var maxBounds;

      if (parent instanceof _Element__WEBPACK_IMPORTED_MODULE_0__["FigureElementCollection"]) {
        maxBounds = parent.getBoundingRect(drawingSpace, 'border', children);
      } else {
        maxBounds = parent.getBoundingRect(drawingSpace);
      }

      maxBounds.left -= space.x;
      maxBounds.bottom -= space.y;
      maxBounds.width += 2 * space.x;
      maxBounds.height += 2 * space.y;
      maxBounds.right = maxBounds.left + maxBounds.width;
      maxBounds.top = maxBounds.bottom + maxBounds.height;
      this.custom.setSize(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](maxBounds.left, maxBounds.bottom), maxBounds.width, maxBounds.height); // this.drawingObject.updateBox(
      //   maxBounds.width,
      //   maxBounds.height,
      // );
      // this.setPosition(
      //   maxBounds.left + maxBounds.width / 2,
      //   maxBounds.bottom + maxBounds.height / 2,
      // );
    } // surround(parent, childrenToUse, space) {
    //   let elements = [parent];
    //   if (childrenToUse !== '' && childrenToUse != null) {
    //     elements = parent.getElements(childrenToUse);
    //   }
    //   maxBounds = elements.
    // }

  }]);

  return Box;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Brace.js":
/*!*************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Brace.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Brace; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/figure/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Brace = /*#__PURE__*/function (_Bracket) {
  _inherits(Brace, _Bracket);

  var _super = _createSuper(Brace);

  function Brace() {
    _classCallCheck(this, Brace);

    return _super.apply(this, arguments);
  }

  _createClass(Brace, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (type: 'static' | 'dynamic', options: Object, height: number) => {
    //     const { width } = options;
    //     if (type === 'static') {
    //       return height * width;
    //     }
    //     return width;
    //   };
    // }
    //  - Curve R1 and R2 are repeated 4 times in brace
    //  - Curve R1 is a full 90º circle
    //  - Curve R2 > R1 and is less than 90º
    //                                       width
    //                               |<--------------->|
    //                               |                 |
    //                               |                *|
    //           A                   |              * *
    //           |                   |       R1   *  *
    //           |                   |          *   *  R2
    //           |                   |        *    *
    //           |                   |       *    *
    //           |                   |       *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |      *    *
    //           |                   |     *    *
    //           |                   |     *    *
    //           |                   |    *    *
    //           |                      *   *
    //   height  |                    *  *
    //           |                   * *
    //           |          A        * *
    //           |          |          *  *
    //           |          |        |   *   *
    //           |          |        |     *    *
    //           |          |        |      *    *
    //           |          |        |      *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |    h / 2 |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |       *    *
    //           |          |        |        *    *
    //           |          |        |        *    *
    //           |          |        |         *    *
    //           |          |        |           *   *
    //           |          |        |             *  *
    //           V          V        |_______________ *
    //                           (0,0)
    //
    // The solution to a circle that intersect at the same
    //
    //                       |OOO ooo
    //                       |       OOo
    //                       |         | OOo              A
    //                       |         |    OOo           |
    //                       |         |      OOo         |
    //                       |         |        OOo       |
    //                       |         |         OOo      | h
    //                       |         |          OOo     |
    //                       |         |           OOo    |
    //                       |         |           OOo    |
    //                       C---------|-----------OOo    V
    //                       |         |      w      |
    //                       |         |<----------->|
    //                       |                       |
    //                       |          r            |
    //                       |<--------------------->|
    // Circle with radius r intersects a vertical line with height h
    // a distance w from the circle horizontal.
    //
    // Calculate r:
    //          w^2 + h^2
    //     r = -----------
    //              2w
    //
    // Calculate angle from center C to intersection with h:
    //
    //     theta = arcsin (h / r))
    //
    //
    //
    //  For the brace case, the outside radius is a full 90º arc
    //  The inside arc is calculated from the top equations where
    //
    //       w = outsideRadius - lineWidth
    //
    //                              width
    //                   <---------------------->
    //
    //           A       OOO ooo
    //  TipWidth |       00o    OOo
    //           V       00o        OOo   ---------------
    //                     00o         OOo              A
    //                       00o           OOo          |
    //                        00o            OOo        |
    //                         00o            OOo       | h
    //                         00o             OOo      |
    //                          00o            OOo      |
    //  Ci              Co      00o            OOo      V
    //  |                |
    //  |                |     |  line width     |
    //  |                |     |<--------------->|
    //  |                |     |                 |
    //  |  inside radius |     |                 |
    //  |<-------------------->|                 |
    //                   |                       |
    //                   |    outside radius     |
    //                   |<--------------------->|
    //
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      var sides = options.sides;

      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width,
          tipWidth = _this$getVerticalDefa.tipWidth;

      var outsideRadius = width / 2 + lineWidth / 2;
      var h = outsideRadius - tipWidth;
      var w = outsideRadius - lineWidth; // const w = lineWidth;

      var insideRadius = (Math.pow(w, 2) + Math.pow(h, 2)) / (2 * w);
      var leftPoints = [];
      var rightPoints = [];
      var outsideStep = Math.PI / 2 / sides;
      var insideStep = Math.asin(h / insideRadius) / sides;
      var insidePoints = [];
      var outsidePoints = [];

      for (var i = 0; i < sides + 1; i += 1) {
        var outsideAngle = i * outsideStep;
        var insideAngle = i * insideStep;
        outsidePoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideRadius * Math.cos(outsideAngle), outsideRadius * Math.sin(outsideAngle)));
        insidePoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideRadius * Math.cos(insideAngle) - insideRadius + outsideRadius - lineWidth, insideRadius * Math.sin(insideAngle)));
      } // const topCurveCenter = new Point(width, height - outsideRadius);


      var m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, 1).translate(width, height - outsideRadius).m();

      for (var _i = 0; _i < sides + 1; _i += 1) {
        leftPoints.push(outsidePoints[sides - _i].transformBy(m));
        rightPoints.push(insidePoints[sides - _i].transformBy(m));
      }

      m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, -1).translate(0, height / 2 - tipWidth / 2 + outsideRadius).m();

      for (var _i2 = 0; _i2 < sides + 1; _i2 += 1) {
        leftPoints.push(insidePoints[_i2].transformBy(m));
        rightPoints.push(outsidePoints[_i2].transformBy(m));
      }

      m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, height / 2 + tipWidth / 2 - outsideRadius).m();

      for (var _i3 = 0; _i3 < sides + 1; _i3 += 1) {
        leftPoints.push(insidePoints[sides - _i3].transformBy(m));
        rightPoints.push(outsidePoints[sides - _i3].transformBy(m));
      }

      m = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, -1).translate(width, outsideRadius).m();

      for (var _i4 = 0; _i4 < sides + 1; _i4 += 1) {
        leftPoints.push(outsidePoints[_i4].transformBy(m));
        rightPoints.push(insidePoints[_i4].transformBy(m));
      } // if (side === 'top' || side === 'bottom') {
      //   return this.getBracketPoints(leftPoints, rightPoints, side, height, width);
      // }


      return [leftPoints, rightPoints, width, height];
    } // Values that look good:
    // height          width         lineWidth
    //   2              0.2           0.04  0.03
    //   1              0.1           0.03  0.02
    //   0.5            0.05          0.015
    //   0.3            0.05          0.015
    //   0.2            0.03          0.012
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (width == null && options.width == null) {
        out.width = 97570.78 + (0.004958708 - 97570.78) / (1 + Math.pow(height / 2399858, 0.9383909));
      }

      if (width != null) {
        out.width = width;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.8;
      } else {
        out.lineWidth = options.lineWidth;
      }

      if (options.tipWidth == null) {
        out.tipWidth = out.lineWidth / 3;
      } else {
        out.tipWidth = options.tipWidth;
      }

      return out;
    }
  }]);

  return Brace;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Bracket.js":
/*!***************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Bracket.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bracket; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


 // import Bounds from '../Elements/Bounds';

var Bracket = /*#__PURE__*/function (_Symbol2) {
  _inherits(Bracket, _Symbol2);

  var _super = _createSuper(Bracket);

  function Bracket() {
    _classCallCheck(this, Bracket);

    return _super.apply(this, arguments);
  }

  _createClass(Bracket, [{
    key: "getPoints",
    // This is the same math as for Brace, but the outside radius is only a
    // portion of a half circle
    //                             * *
    //                          *  *
    //                        *   *
    //                      *    *
    //                     *    *
    //                     *    *
    //                    *    *
    //                    *    *
    //                    *    *
    //                     *    *
    //                     *    *
    //                      *    *
    //                        *   *
    //                          *  *
    //                            * *
    //
    //
    //
    //
    //
    //
    //
    //
    //
    //                                     0000000
    //                                0000       |
    //                            000         0000
    //                         00          000
    //                       0           00
    //                      00         000
    //                    0           0
    //                   00         00
    //                 00          0
    //                 0           0
    //                 0           0
    //                 0           0
    //
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      var side = options.side;
      var leftPoints;
      var rightPoints;
      var width;
      var height;

      if (side === 'left' || side === 'right') {
        var _this$getLeftPoints = this.getLeftPoints(options, widthIn, heightIn);

        var _this$getLeftPoints2 = _slicedToArray(_this$getLeftPoints, 4);

        leftPoints = _this$getLeftPoints2[0];
        rightPoints = _this$getLeftPoints2[1];
        width = _this$getLeftPoints2[2];
        height = _this$getLeftPoints2[3];
      } else {
        var _this$getLeftPoints3 = this.getLeftPoints(options, heightIn, widthIn);

        var _this$getLeftPoints4 = _slicedToArray(_this$getLeftPoints3, 4);

        leftPoints = _this$getLeftPoints4[0];
        rightPoints = _this$getLeftPoints4[1];
        width = _this$getLeftPoints4[2];
        height = _this$getLeftPoints4[3];
      } // The points of the glyph are for side 'left' by default
      // Transform the glyph to the correct side and have it's lower left corner
      // at (0, 0) and be


      var t;

      if (side === 'right') {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(-1, 1).translate(width, 0);
      } else if (side === 'top') {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, -height / 2).rotate(-Math.PI / 2).translate(height / 2, width);
      } else if (side === 'bottom') {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(0, -height / 2).rotate(Math.PI / 2).translate(height / 2, 0);
      } else {
        t = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]();
      }

      var newPointsLeft = leftPoints.map(function (p) {
        return p.transformBy(t.m());
      });
      var newPointsRight = rightPoints.map(function (p) {
        return p.transformBy(t.m());
      });
      var points = [];
      newPointsLeft.forEach(function (r1p, index) {
        var r2p = newPointsRight[index];
        points.push(r1p);
        points.push(r2p);
      });

      if (side === 'top' || side === 'bottom') {
        return [points, height, width, 'strip'];
      }

      return [points, width, height, 'strip'];
    }
  }, {
    key: "getLeftPoints",
    value: function getLeftPoints(options, widthIn, heightIn) {
      var sides = options.sides;

      var _this$getVerticalDefa = this.getVerticalDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width,
          tipWidth = _this$getVerticalDefa.tipWidth; // width of bracket without linewidth - essentially width of inner radius


      var wInnerRadius = width - lineWidth;
      var innerRadius = (Math.pow(wInnerRadius, 2) + Math.pow(heightIn / 2, 2)) / (2 * wInnerRadius); // top line width is half middle line width

      var wOuterRadius = width - tipWidth;
      var outerRadius = (Math.pow(wOuterRadius, 2) + Math.pow(heightIn / 2, 2)) / (2 * wOuterRadius);
      var angleInner = Math.asin(heightIn / 2 / innerRadius);
      var stepAngleInner = angleInner * 2 / sides;
      var angleOuter = Math.asin(heightIn / 2 / outerRadius);
      var stepAngleOuter = angleOuter * 2 / sides;
      var innerPoints = [];
      var outerPoints = [];

      for (var i = 0; i < sides + 1; i += 1) {
        innerPoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(innerRadius, angleInner - stepAngleInner * i + Math.PI).add(innerRadius + lineWidth, heightIn / 2));
        outerPoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(outerRadius, angleOuter - stepAngleOuter * i + Math.PI).add(outerRadius, heightIn / 2));
      }

      return [outerPoints, innerPoints, innerPoints[0].x, heightIn];
    } // Default values are values of width, height, lineWidth
    // Values that look good:
    // height          width         lineWidth
    //   2              0.2           0.04
    //   1              0.1           0.03
    //   0.5            0.05          0.015
    //   0.3            0.05          0.015
    //   0.2            0.03          0.012

    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(contentHeight, contentWidth, options) {
      var out = {};

      if (options.side === 'left' || options.side === 'right') {
        out = this.getVerticalDefaultValues(contentHeight, contentWidth, options); // $FlowFixMe

        out.height = contentHeight;
      } else {
        out = this.getVerticalDefaultValues(contentWidth, contentHeight, options);
        var _out = out,
            width = _out.width;
        out.width = contentWidth; // $FlowFixMe

        out.height = width;
      }

      return out;
    }
  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(contentHeight, contentWidth, options) {
      var out = {};

      if (contentWidth == null && options.width == null) {
        out.width = 97570.78 + (0.004958708 - 97570.78) / (1 + Math.pow(contentHeight / 2399858, 0.9383909));
      }

      if (contentWidth != null) {
        out.width = contentWidth;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      if (options.lineWidth == null) {
        out.lineWidth = 0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(contentHeight / 39.01413, 0.618041));
      } else {
        out.lineWidth = options.lineWidth;
      }

      if (options.tipWidth == null) {
        out.tipWidth = out.lineWidth / 3;
      } else {
        out.tipWidth = options.tipWidth;
      }

      return out;
    }
  }]);

  return Bracket;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Integral.js":
/*!****************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Integral.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Integral; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

 // import {
//   joinObjects,
// } from '../../../../tools/tools';




var Integral = /*#__PURE__*/function (_Symbol2) {
  _inherits(Integral, _Symbol2);

  var _super = _createSuper(Integral);

  function Integral() {
    _classCallCheck(this, Integral);

    return _super.apply(this, arguments);
  }

  _createClass(Integral, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'triangles';
    // }
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (options: Object, height: number) => {
    //     let width;
    //     if (options.draw === 'static') {
    //       let { staticHeight } = options;
    //       if (typeof staticHeight !== 'number') {
    //         staticHeight = height;
    //       }
    //       ({ width } = this.getDefaultValues(staticHeight, null, options));
    //       return width / staticHeight * height;
    //     }
    //     ({ width } = options);
    //     ({ width } = this.getDefaultValues(height, width, options));
    //     return width;
    //   };
    // }
    //     --------------------------------------------------   0000000
    //     A                                              000000011111111
    //     |                                         0000000   111111111111
    //     |                                       0000000    11111111111111
    //     |                                      0000000     11111111111111
    //     |                                     0000000       111111111111
    //     |                                   000000000         11111111
    //     |                                  000000000
    //     |                                 0000000000
    //     |    S curve gradient = k         000000000
    //     |                                0000000000
    //     |                                0000000000
    //     |                               00000000000
    //     |                              00000000000
    //     |                              000000000000
    //     |                             000000000000      lineWidth
    //   h |                     ------->000000000000<----------
    //     |                             000000000000
    //     |                             000000000000
    //     |                            000000000000
    //     |                             00000000000
    //     |                            00000000000
    //     |                            0000000000
    //     |                            0000000000
    //     |                            000000000
    //     |                           000000000
    //     |                          0000000000
    //     |      11111111           000000000
    //     |    111111111111       00000000
    //     |   11111111111111     0000000
    //     |   11111111111111   0000000
    //     |    111111111111   0000000
    //     V      111111110000000
    //     -------  0000000
    // Integral line is generated from a sigmoid function (S-curve) that is
    // thickened more in middle than on ends (square of cosine of normalized
    // height)
    //
    // S (sigmoid) Curve:
    //                    h
    //         s(x) = -----------            (1)
    //                       -kx
    //                  1 + e
    //
    // It's derivative is:
    //
    //        ds
    //       ----  =  h k s (1 - s)          (2)
    //        dx
    //
    // The angle theta of the curve at some given x can is then:
    //
    //     theta = atan(ds/dx)               (3)
    //
    //
    // If you know s, x and want to find k, then can rearrange the above to:
    //
    //      k = -ln((h / s) - 1) / x         (4)
    //
    // Procedure:
    //    - Find gradient where s = 0.999999 of the height and x is w / 2
    //    - Make an xRange from w / 2 to w / 2 (with buffer for serif)
    //    - Go through all x and:
    //        - Find y from (1)
    //        - Find the derivative at x using (2) and theta using (3)
    //        - Find the left and right sides of the line using theta + PI / 2
    //          and add more thickness in the middle
    //
    //    - Find serifs by:
    //        - Go to end outside point and find its theta
    //        - Center of serif is then at vector from end point to
    //          theta + π/2 with magnitude of serif radius
    //        - Draw circle at serif
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, height) {
      var sides = options.sides,
          serif = options.serif,
          num = options.num,
          type = options.type,
          serifSides = options.serifSides,
          lineIntegralSides = options.lineIntegralSides;

      var _this$getDefaultValue = this.getDefaultValues(height, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width,
          tipWidth = _this$getDefaultValue.tipWidth;

      var singleWidth = width - (num - 1) * lineWidth * 3;
      var percentage = 0.99999999999;
      var h = height;
      var serifRadius = lineWidth * 0.7;
      var widthWithoutSerifs = singleWidth;

      if (serif) {
        widthWithoutSerifs = singleWidth - serifRadius * 2;
      }

      var xArray = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["range"])(-widthWithoutSerifs / 2, widthWithoutSerifs / 2, widthWithoutSerifs / sides);
      var targetY = percentage * height;
      var k = -Math.log(height / targetY - 1) / singleWidth / 2;
      var bottomTheta = 0;
      var linePoints = [];
      var prevLeft;
      var prevRight;
      xArray.forEach(function (x, index) {
        var sigmoid = 1 / (1 + Math.exp(-k * x));
        var derivative = h * k * sigmoid * (1 - sigmoid);
        var theta = Math.atan(derivative);
        var y = sigmoid * h;
        var a = (lineWidth / 2 - tipWidth / 2) * Math.pow(Math.cos((y - height / 2) / height * Math.PI), 2) + tipWidth / 2;
        var xDelta = a * Math.cos(theta + Math.PI / 2);
        var yDelta = a * Math.sin(theta + Math.PI / 2);
        var left = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x + xDelta + singleWidth / 2, y + yDelta);
        var right = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x - xDelta + singleWidth / 2, y - yDelta);

        if (index > 0) {
          linePoints.push(prevLeft._dup());
          linePoints.push(prevRight._dup());
          linePoints.push(right._dup());
          linePoints.push(prevLeft._dup());
          linePoints.push(right._dup());
          linePoints.push(left._dup());
        }

        prevLeft = left;
        prevRight = right;

        if (index === 0) {
          bottomTheta = theta;
        }
      });
      var points = [];

      if (serif === false) {
        points = linePoints;
      } else {
        var serifPoints = serifSides;
        var bottomCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](linePoints[1].x + serifRadius * Math.cos(bottomTheta + Math.PI / 2), linePoints[1].y + serifRadius * Math.sin(bottomTheta + Math.PI / 2));
        var topCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](linePoints[linePoints.length - 1].x + serifRadius * Math.cos(bottomTheta - Math.PI / 2), linePoints[linePoints.length - 1].y + serifRadius * Math.sin(bottomTheta - Math.PI / 2));
        var bottomSerifPoints = [];
        var topSerifPoints = [];
        var angleDelta = Math.PI * 2 / Math.max(serifPoints, 3);
        var prevBottom = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0); // initialied for flow only

        var prevTop = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0); // initialied for flow only

        for (var i = 0; i < serifPoints + 1; i += 1) {
          var bottom = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bottomCenter.x + serifRadius * Math.cos(angleDelta * i), bottomCenter.y + serifRadius * Math.sin(angleDelta * i));
          var top = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](topCenter.x + serifRadius * Math.cos(angleDelta * i), topCenter.y + serifRadius * Math.sin(angleDelta * i));

          if (i > 0) {
            bottomSerifPoints.push(linePoints[1]._dup());
            bottomSerifPoints.push(prevBottom._dup());
            bottomSerifPoints.push(bottom._dup());
            topSerifPoints.push(linePoints[linePoints.length - 2]._dup());
            topSerifPoints.push(prevTop._dup());
            topSerifPoints.push(top._dup());
          }

          prevBottom = bottom;
          prevTop = top;
        }

        points = [].concat(bottomSerifPoints, linePoints, topSerifPoints);
      }

      var numPoints = points.length;

      for (var _i = 1; _i < num; _i += 1) {
        for (var j = 0; j < numPoints; j += 1) {
          points.push(points[j].add(lineWidth * 3 * _i, 0));
        } // width = width + lineWidth * 2;

      }

      if (type === 'line') {
        var lineIntegralEllipsePoints = this.getLineIntegralPoints(lineWidth, num, width, height, lineIntegralSides);
        points = [].concat(_toConsumableArray(points), _toConsumableArray(lineIntegralEllipsePoints));
      }

      return [points, width, height, 'triangles'];
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getLineIntegralPoints",
    value: function getLineIntegralPoints(lineWidth, num, width, height, sides) {
      var ellipseHeight = lineWidth * 6;
      var ellipseWidth = Math.max(ellipseHeight, (lineWidth * 3 + (num - 1) * lineWidth * 3 / 2) * 2);
      var center = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, height / 2);
      var deltaAngle = Math.PI * 2 / sides;
      var prevOuter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var prevInner = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var ellipseLineWidth = lineWidth / 2;
      var points = [];

      for (var i = 0; i < sides + 1; i += 1) {
        var angle = i * deltaAngle;
        var inner = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]((ellipseWidth / 2 - ellipseLineWidth / 2) * Math.cos(angle), (ellipseHeight / 2 - ellipseLineWidth / 2) * Math.sin(angle)).add(center);
        var outer = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]((ellipseWidth / 2 + ellipseLineWidth / 2) * Math.cos(angle), (ellipseHeight / 2 + ellipseLineWidth / 2) * Math.sin(angle)).add(center);

        if (i > 0) {
          points.push(prevOuter._dup());
          points.push(prevInner._dup());
          points.push(inner._dup());
          points.push(prevOuter._dup());
          points.push(inner._dup());
          points.push(outer._dup());
        }

        prevOuter = outer;
        prevInner = inner;
      }

      return points;
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      // at 2:
      //    lw = 0.05 (40)
      //     w = 0.4 (5)
      //     e = 0.01 (200)
      //
      // at 1:
      //    lw = 0.03 (33)
      //     w = 0.25 (4)
      //     e = 0.01 (100)
      //
      // at 0.5:
      //    lw = 0.02 (25)
      //     w = 0.15 (3.3)
      //     e = 0.008 (63)
      //
      // at 0.3:
      //    lw = 0.017 (17)
      //     w = 0.15 (2)
      //     e = 0.006 (50)
      //
      // Using https://mycurvefit.com and add 0 to each to keep values under 0.3 positive
      var defaultLineWidth = 607.73 + (0.0004220802 - 607.73) / (1 + Math.pow(height / 5368595, 0.6370402));
      var defaultSingleWidth = 12277.16 + (0.003737719 - 12277.16) / (1 + Math.pow(height / 36507180, 0.6193363));
      var defaultTotalWidth = defaultSingleWidth + (options.num - 1) * defaultLineWidth * 3;
      var out = {
        lineWidth: defaultLineWidth,
        width: defaultTotalWidth,
        tipWidth: 0.01033455 + (0.000004751934 - 0.01033455) / (1 + Math.pow(height / 0.2588074, 2.024942)),
        height: height
      };

      if (width != null) {
        out.width = width;
      }

      if (options.lineWidth != null) {
        out.lineWidth = options.lineWidth;
      }

      if (options.tipWidth != null) {
        out.tipWidth = options.tipWidth;
      } else {
        out.tipWidth = out.lineWidth / 3;
      }

      return out;
    }
  }]);

  return Integral;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Line.js":
/*!************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Line.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationLine; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _geometries_lines_lines__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometries/lines/lines */ "./src/js/figure/geometries/lines/lines.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




 // import WebGLInstance from '../../../webgl/webgl';

var EquationLine = /*#__PURE__*/function (_Symbol2) {
  _inherits(EquationLine, _Symbol2);

  var _super = _createSuper(EquationLine);

  function EquationLine() {
    _classCallCheck(this, EquationLine);

    return _super.apply(this, arguments);
  }

  _createClass(EquationLine, [{
    key: "getPoints",
    // constructor(
    //   webgl: Array<WebGLInstance>,
    //   color: TypeColor,
    //   transformOrLocation: Transform | Point,
    //   figureLimits: Rect,
    //   symbolOptions: Object,
    //   // triangles: 'strip' | 'triangles' | 'fan',
    // ) {
    //   super(webgl, color, transformOrLocation, figureLimits, symbolOptions);
    //   // this.custom.setSize = (location: Point) => {
    //   // }
    // }
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //                             width
    //          |<---------------------------------------->|
    //          |                                          |  3
    //        1 |                                          | ____
    //          00000000000000000000000000000000000000000000   A
    //          00000000000000000000000000000000000000000000   |  Line Width
    //          00000000000000000000000000000000000000000000 __V_
    //         0                                            2
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, angle, length) {
      // const { lineWidth, width, height } = this.getDefaultValues(
      //   null, null, options,
      // );
      // const p1 = options.spacedLine.p1;
      // const p2 = options.spacedLine.p2;
      // console.log(angle, length)
      var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"]([0, 0], length, angle); // console.log(line)

      var _makePolyLine = Object(_geometries_lines_lines__WEBPACK_IMPORTED_MODULE_2__["makePolyLine"])([new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), line.p2], options.width, false, 'mid', 'none', 0.1, 1, 0, options.dash, false, 2, [[]], 0, [[]], options.arrow),
          _makePolyLine2 = _slicedToArray(_makePolyLine, 1),
          points = _makePolyLine2[0]; // const points = [
      //   new Point(0, 0),
      //   new Point(0, lineWidth),
      //   new Point(width, 0),
      //   new Point(width, lineWidth),
      // ];


      return [points, angle, length, 'triangles'];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe
    // getDefaultValues(height: number, width: ?number, options: {
    //     lineWidth?: number,
    //   }) {
    //   const out = {};
    //   if (options.lineWidth != null) {
    //     out.lineWidth = options.lineWidth;
    //   } else {
    //     out.lineWidth = 0.01;
    //   }
    //   out.height = out.lineWidth;
    //   if (width != null) {
    //     out.width = width;
    //   } else {
    //     out.width = 1;
    //   }
    //   return out;
    // }

  }]);

  return EquationLine;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_3__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Product.js":
/*!***************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Product.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Product; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


 // import Bounds from '../Elements/Bounds';

var Product = /*#__PURE__*/function (_Symbol2) {
  _inherits(Product, _Symbol2);

  var _super = _createSuper(Product);

  function Product() {
    _classCallCheck(this, Product);

    return _super.apply(this, arguments);
  }

  _createClass(Product, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (options: Object, height: number) => {
    //     // The width should be 7 times the thick2 linewidth;
    //     // const { lineWidth } = options;
    //     let width;
    //     if (options.draw === 'static') {
    //       let { staticHeight } = options;
    //       if (typeof staticHeight !== 'number') {
    //         staticHeight = height;
    //       }
    //       ({ width } = this.getDefaultValues(staticHeight, null, options));
    //       return width / staticHeight * height;
    //     }
    //     ({ width } = options);
    //     ({ width } = this.getDefaultValues(height, width, options));
    //     return width;
    //   };
    // }
    //                                            w
    //             |<--------------------------------------------------------->|
    //             |                                                           |
    //             |   a                                                       |
    //             |<---->|                                                    |
    //             |      |                     thick1                         |
    //             |      |                     /                              |
    //             |      |                    /                               |
    //       ---- 00000000000000000000000000000000000000000000000000000000000000
    //       A         000000000000000000000000000000000000000000000000000000
    //       |           00000000000000000000000000000000000000000000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000   \                 /   00000000000
    //    h  |            00000000000    \              /     00000000000
    //       |            00000000000      \          /       00000000000
    //       |            00000000000        \      /         00000000000
    //       |            00000000000         thick2          00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |            00000000000                         00000000000
    //       |           0000000000000                       00000000000000
    //       V         00000000000000000                   000000000000000000
    //       ----- 0000000000000000000000000           00000000000000000000000000
    //
    //                         10 0000000000000000000000000 11
    //                          8 0000000000000000000000000 9
    //                                 6 00000000000 7
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                   00000000000
    //                                 4 00000000000 5
    //                          2 00000000000000000000000000  3
    //                          0 00000000000000000000000000  1
    //                        (0, 0)
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, height) {
      var serif = options.serif,
          sides = options.sides;

      var _this$getDefaultValue = this.getDefaultValues(height, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width;

      var sidesToUse = sides;

      if (serif === 'false') {
        sidesToUse = 2;
      } // const { lineWidth, sides } = options;
      // let lineWidthToUse = lineWidth;
      // if (lineWidth == null) {
      //   // lineWidthToUse = width / (25 * height + 15);
      //   lineWidthToUse = width / 21;
      // }


      var thick1 = lineWidth * 1.2;
      var thick2 = lineWidth * 3;
      var tipWidth = lineWidth / 2;
      var a = thick2 * 0.9;
      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](thick2 + a * 2, 0);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p0.x, tipWidth);
      var p3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p1.x, tipWidth);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a, p2.y);
      var p5 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a + thick2, p4.y);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p4.x, height - tipWidth);
      var p7 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p5.x, height - tipWidth);
      var p8 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p2.x, height - tipWidth); // const p9 = new Point(p3.x, height - tipWidth);

      var p10 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p2.x, height);
      var p11 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p3.x, height);
      var p40 = p2;
      var p41 = p4;
      var p42 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p4.x, p4.y + a);
      var p50 = p3;
      var p51 = p5;
      var p52 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p5.x, p4.y + a);
      var p4Curve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p40, p41, p42, sidesToUse);
      var p5Curve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p50, p51, p52, sidesToUse);
      var bottomCurve = [];
      p4Curve.forEach(function (p, index) {
        bottomCurve.push(p);
        bottomCurve.push(p5Curve[index]);
      });
      var p60 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p6.x, p6.y - a);
      var p61 = p6;
      var p62 = p8; // const p70 = new Point(p7.x, p7.y - a);
      // const p71 = p7;
      // const p72 = p9;

      var p6Curve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p60, p61, p62, sidesToUse); // const p7Curve = quadBezierPoints(p70, p71, p72, sides);

      var topCurve = [];
      p6Curve.forEach(function (p) {
        topCurve.push(p); // topCurve.push(p7Curve[index]);

        topCurve.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p7.x, p.y));
      });
      var leg = [p0, p1].concat(bottomCurve, topCurve, [p10, p11]);
      var leg2 = [];

      for (var i = leg.length - 1; i > 0; i -= 2) {
        leg2.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - leg[i - 1].x, leg[i - 1].y));
        leg2.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - leg[i].x, leg[i].y));
      }

      var transition = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a + thick2, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a + thick2, height - thick1), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - a - thick2, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - a - thick2, height - thick1)];
      var points = [].concat(_toConsumableArray(leg), transition, leg2);
      return [points, width, height, 'strip'];
    } // Linewidths that look good:
    // height          width         lineWidth
    //   2              1.6            0.05
    //   1              0.8            0.025
    //   0.5            0.4            0.012
    //   0.3            0.25           0.009
    //   0.2            0.2           0.008

    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {
        lineWidth: options.lineWidth || 1,
        // height * 0.93 / (25 * height + 15),
        width: width || 1,
        height: height
      };

      if (options.lineWidth == null && width != null) {
        out.lineWidth = width / 7 / 3;
      } else if (options.lineWidth == null && width == null) {
        // out.lineWidth = height * 0.93 / (25 * height + 15);
        out.lineWidth = 12902.65 + (0.001053004 - 12902.65) / (1 + Math.pow(height / 573148, 0.9938213));
        out.width = 1704804 + (0.002184303 - 1704804) / (1 + Math.pow(height / 2234236, 0.9967453));
      } else if (options.lineWidth != null && width == null) {
        out.width = options.lineWidth * 7 * 3;
      }

      return out;
    }
  }]);

  return Product;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Radical.js":
/*!***************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Radical.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Radical; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
/* harmony import */ var _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Elements/Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




 // import WebGLInstance from '../../../webgl/webgl';

var Radical = /*#__PURE__*/function (_Symbol2) {
  _inherits(Radical, _Symbol2);

  var _super = _createSuper(Radical);

  function Radical() {
    _classCallCheck(this, Radical);

    return _super.apply(this, arguments);
  }

  _createClass(Radical, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //   height                      left space                right space
    //   |                             >|--|<                    >|--|<
    //   |                              |  |                      |  |
    //   |                              |  |                      |  |
    //   |_____________________________ XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX____V
    //   A                             X|  |                      |_______|
    //   |   startHeight              X |   CCCCCCCCCCCCCCCCCCCCCCC       A
    //   |   |                       X  |   CCCCCCCCCCCCCCCCCCCCCCC    top space
    //   |   |    tickHeight        X   |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |    |                X    |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |____V____           X     |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   A    |    X         X      |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |    |__X |X       X       |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |    A |  | X     X        |   CCCCCCCCCCCCCCCCCCCCCCC
    //   |   |      |  |  X   X         |   CCCCCCCCCCCCCCCCCCCCCCC   bottom space
    //   |   |      |  |   X X          |   CCCCCCCCCCCCCCCCCCCCCCC_______V
    //   V___V______|__|____X __________|_________________________________|
    //              |  |    |           |                                 A
    //              |  |    |           |
    //        tick >|--|<   |           |
    //       width  |  |    |           |
    //              |  |<-->|down width |
    //              |                   |
    //              |<------------------|
    //                     startWidth
    //
    //
    //
    //  First define bottom line (B), then offset the lines and find intercepts to
    //  get the top line (T)
    //         RRRRRRRRRRRRRRRR                  7                          9
    //         RRRRRRRRRRRRRRRR                    TTTTTTTTTTTTTTTTTTTTTTTTT
    //         RRRRRRRRRRRRRRRR                   T  BBBBBBBBBBBBBBBBBBBBBBB
    //         RRRRRRRRRRRRRRRR                  T  B 6                     8
    //         RRRRRRRRRRRRRRRR                 T  B
    //         RRRRRRRRRRRRRRRR                T  B
    //         RRRRRRRRRRRRRRRR               T  B
    //                        |              T  B
    //                        |             T  B
    //            3           |            T  B
    //            T           |           T  B
    //           T T          |          T  B
    //          T   T   lineWidth2      T  B\
    //         T     T       /|        T  B  \
    //        T  B    T    /  |       T  B    \
    //       T  B B    T /    |      T  B      lineWidth
    //    1 T  B 2 B    T     |     T  B
    //        B     B    T    |    T  B
    //        0      B    T   |   T  B
    //                B    T  |  T  B
    //                 B    T 5 T  B
    //                  B    T T  B
    //                   B    T  B
    //                    B     B
    //                     B   B
    //                      B B
    //                       B
    //                       4
    //
    // Root aligns with downWidth + tickWidth
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      // const { proportionalToHeight } = options;
      var _this$getDefaultValue = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          startWidth = _this$getDefaultValue.startWidth,
          tickWidth = _this$getDefaultValue.tickWidth,
          tickHeight = _this$getDefaultValue.tickHeight,
          downWidth = _this$getDefaultValue.downWidth,
          startHeight = _this$getDefaultValue.startHeight,
          lineWidth2 = _this$getDefaultValue.lineWidth2,
          height = _this$getDefaultValue.height,
          width = _this$getDefaultValue.width;

      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, startHeight - tickHeight);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](tickWidth, startHeight);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](downWidth + tickWidth, 0);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](startWidth, height - lineWidth);
      var p8 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height - lineWidth);
      var line02 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"](p0, p2);
      var line24 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"](p2, p4);
      var line46 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"](p4, p6);
      var line68 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Line"](p6, p8);
      var line02Offset = line02.offset('top', lineWidth);
      var line24Offset = line24.offset('top', lineWidth2);
      var line46Offset = line46.offset('top', lineWidth);
      var line68Offset = line68.offset('top', lineWidth);

      var p1 = line02Offset.p1._dup();

      var p3 = line02Offset.intersectsWith(line24Offset).intersect;
      var p5 = line24Offset.intersectsWith(line46Offset).intersect;
      var p7 = line46Offset.intersectsWith(line68Offset).intersect;
      var p9 = p8.add(0, lineWidth);
      var points = [p0, p1, p2, p3, p4, p5, p6, p7, p8, p9];
      return [points, widthIn, heightIn, 'strip'];
    } // Get Glyph bounds based on content

    /* eslint-disable class-methods-use-this */

  }, {
    key: "getBounds",
    value: function getBounds(options, contentX, contentY, contentWidthIn, contentHeightIn) {
      // $FlowFixMe
      var height = this.getHeightFromContentHeight(contentHeightIn, options);

      var _this$getDefaultValue2 = this.getDefaultValues( // $FlowFixMe
      height, contentWidthIn, options),
          width = _this$getDefaultValue2.width,
          startWidth = _this$getDefaultValue2.startWidth,
          lineWidth = _this$getDefaultValue2.lineWidth,
          startHeight = _this$getDefaultValue2.startHeight,
          downWidth = _this$getDefaultValue2.downWidth,
          tickWidth = _this$getDefaultValue2.tickWidth,
          lineWidth2 = _this$getDefaultValue2.lineWidth2;

      var bounds = new _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__["default"]();

      if (options.draw === 'static') {
        var staticWidth = options.staticWidth,
            staticHeight = options.staticHeight;

        if (staticWidth === 'first') {
          staticWidth = width + startWidth;
        }

        if (staticHeight === 'first') {
          staticHeight = height + lineWidth;
        }

        if (staticWidth == null) {
          staticWidth = 1;
        }

        if (staticHeight == null) {
          staticHeight = 1;
        }

        var heightLineWidthRatio = lineWidth / staticHeight;
        var widthStartWidthRatio = startWidth / staticWidth;
        var heightStartHeightRatio = startHeight / staticHeight;
        bounds.width = width / (1 - widthStartWidthRatio);
        bounds.height = height / (1 - heightLineWidthRatio);
        var widthStartWidth = bounds.width * widthStartWidthRatio;
        var heightStartHeight = bounds.height * heightStartHeightRatio;
        var heightLineWidth = bounds.height * heightLineWidthRatio;
        bounds.left = contentX - widthStartWidth;
        bounds.right = bounds.left + bounds.width;
        bounds.bottom = contentY;
        bounds.top = bounds.bottom + bounds.height;
        bounds.ascent = bounds.height;
        bounds.descent = 0; // $FlowFixMe

        bounds.annotations = {
          root: {
            xPosition: 'left',
            yPosition: 'bottom',
            xAlign: 'right',
            yAlign: 'bottom',
            offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](widthStartWidth * 0.5, heightStartHeight + heightLineWidth * 2)
          }
        };
      } else {
        bounds.left = contentX + contentWidthIn / 2 - width / 2 - startWidth;
        bounds.bottom = contentY;
        bounds.width = width + startWidth;
        bounds.height = height;
        bounds.right = bounds.left + bounds.width;
        bounds.top = bounds.bottom + bounds.height;
        bounds.descent = 0;
        bounds.ascent = bounds.height; // $FlowFixMe

        bounds.annotations = {
          root: {
            xPosition: 'left',
            yPosition: 'bottom',
            xAlign: 'right',
            yAlign: 'bottom',
            offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](downWidth + tickWidth, startHeight + lineWidth2)
          }
        };
      }

      return bounds;
    }
    /* eslint-disable class-methods-use-this */

  }, {
    key: "getHeightFromContentHeight",
    value: function getHeightFromContentHeight(contentHeightIn, options) {
      var lineWidth;
      var contentHeight;

      if (options.lineWidth != null && typeof options.lineWidth === 'number') {
        lineWidth = options.lineWidth;
      } else {
        lineWidth = 0.01;
      }

      if (contentHeightIn != null) {
        contentHeight = contentHeightIn;
      } else {
        contentHeight = 1;
      }

      return contentHeight + lineWidth;
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth != null && typeof options.lineWidth === 'number') {
        out.lineWidth = options.lineWidth;
      } else {
        out.lineWidth = 0.01;
      }

      if (options.lineWidth2 != null && typeof options.lineWidth2 === 'number') {
        out.lineWidth2 = options.lineWidth2;
      } else {
        out.lineWidth2 = out.lineWidth * 2;
      }

      if (options.height != null && typeof options.height === 'number') {
        out.height = options.height;
      } else if (height != null) {
        out.height = height;
      } else {
        out.height = 1;
      }

      if (options.startHeight != null && typeof options.startHeight === 'number') {
        out.startHeight = options.startHeight;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.startHeight = options.startHeight * out.height;
        }
      } else {
        out.startHeight = out.height / 3;
      }

      if (options.maxStartHeight != null && options.maxStartHeight < out.startHeight) {
        out.startHeight = options.maxStartHeight;
      }

      if (options.tickHeight != null && typeof options.tickHeight === 'number') {
        out.tickHeight = options.tickHeight;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.tickHeight = options.tickHeight * out.startHeight;
        }
      } else {
        out.tickHeight = out.startHeight * 0.1;
      }

      if (options.startWidth != null && typeof options.startWidth === 'number') {
        out.startWidth = options.startWidth;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.startWidth = options.startWidth * out.height;
        }
      } else {
        out.startWidth = out.startHeight / 2;
      }

      if (options.maxStartWidth != null && options.maxStartWidth < out.startWidth) {
        out.startWidth = options.maxStartWidth;
      }

      if (options.tickWidth != null && typeof options.tickWidth === 'number') {
        out.tickWidth = options.tickWidth;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.tickWidth = options.tickWidth * out.startWidth;
        }
      } else {
        out.tickWidth = out.startWidth / 5;
      }

      if (options.downWidth != null && typeof options.downWidth === 'number') {
        out.downWidth = options.downWidth;

        if (options.proportionalToHeight) {
          // $FlowFixMe
          out.downWidth = options.downWidth * out.startWidth;
        }
      } else {
        out.downWidth = out.startWidth / 5 * 2;
      }

      if (options.width != null && typeof options.width === 'number') {
        out.width = options.width;
      } else if (width != null) {
        out.width = width;
      } else {
        out.width = 1;
      }

      return out;
    }
  }]);

  return Radical;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/SquareBracket.js":
/*!*********************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/SquareBracket.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SquareBracket; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Bracket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bracket */ "./src/js/figure/Equation/Symbols/Bracket.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var SquareBracket = /*#__PURE__*/function (_Bracket) {
  _inherits(SquareBracket, _Bracket);

  var _super = _createSuper(SquareBracket);

  function SquareBracket() {
    _classCallCheck(this, SquareBracket);

    return _super.apply(this, arguments);
  }

  _createClass(SquareBracket, [{
    key: "getLeftPoints",
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (type: 'static' | 'dynamic', options: Object, height: number) => {
    //     const { width } = options;
    //     if (type === 'static') {
    //       return height * width;
    //     }
    //     return width;
    //   };
    // }
    //                            width
    //                  |<--------------------->|
    //
    //            ___   ._______________________    ____
    //           A      |                       |      A
    //           |      |                       |      | tipWidth
    //           |      |      .________________|   ___V
    //           |      |      |
    //           |      |      |
    //           |      |      |
    //           |      |      |
    //  height   |      |      |
    //           |      |      |
    //           |      |      |
    //           |      |      |
    //           |      |      |
    //           |      |      |________________
    //           |      |                       |
    //           |      |                       |
    //           V___   |_______________________|
    //
    //                  |      |
    //                  |      |
    //                  |<---->|
    //                 line width
    //
    // If radius is defined, then lineEndWidth = lineWidth
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getLeftPoints(options, widthIn, height) {
      // const {
      //   lineWidth, width, endLineWidth, radius, sides,
      // } = options;
      var sides = options.sides,
          radius = options.radius;

      var _this$getVerticalDefa = this.getVerticalDefaultValues(height, widthIn, options),
          lineWidth = _this$getVerticalDefa.lineWidth,
          width = _this$getVerticalDefa.width,
          tipWidth = _this$getVerticalDefa.tipWidth;

      if (radius === 0) {
        var _outsidePoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height)];
        var _insidePoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, tipWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lineWidth, tipWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](lineWidth, height - tipWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height - tipWidth)];
        return [_outsidePoints, _insidePoints, width, height];
      }

      var radiusToUse = Math.min(radius, width, height / 2);
      var rOutside = radiusToUse;
      var rInside = radiusToUse - lineWidth;
      var outsidePoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, 0)];
      var insidePoints = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, lineWidth)];
      var lowCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rOutside, rOutside);
      var highCenter = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](rOutside, height - rOutside);

      for (var i = 0; i <= sides; i += 1) {
        var angle = Math.PI / 2 / sides * i;
        outsidePoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(rOutside, Math.PI / 2 * 3 - angle).add(lowCenter));
        insidePoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(rInside, Math.PI / 2 * 3 - angle).add(lowCenter));
      }

      for (var _i = 0; _i <= sides; _i += 1) {
        var _angle = Math.PI / 2 / sides * _i;

        outsidePoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(rOutside, Math.PI - _angle).add(highCenter));
        insidePoints.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(rInside, Math.PI - _angle).add(highCenter));
      }

      outsidePoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height));
      insidePoints.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height - lineWidth)); // if (side === 'top' || side === 'bottom') {
      //   return this.getBracketPoints(outsidePoints, insidePoints, side, height, width);
      // }

      return [outsidePoints, insidePoints, width, height];
    }
    /* eslint-disable class-methods-use-this */

  }, {
    key: "getVerticalDefaultValues",
    value: function getVerticalDefaultValues(height, width, options) {
      var out = {};

      if (width == null && options.width == null) {
        out.width = (97570.78 + (0.004958708 - 97570.78) / (1 + Math.pow(height / 2399858, 0.9383909))) * 0.8;
      }

      if (width != null) {
        out.width = width;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      if (options.lineWidth == null) {
        out.lineWidth = (0.2933614 + (0.0001418178 - 0.2933614) / (1 + Math.pow(height / 39.01413, 0.618041))) * 0.8;
      } else {
        out.lineWidth = options.lineWidth;
      }

      if (options.tipWidth == null) {
        out.tipWidth = out.lineWidth * 0.7;
      } else {
        out.tipWidth = options.tipWidth;
      }

      return out;
    }
  }]);

  return SquareBracket;
}(_Bracket__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Strike.js":
/*!**************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Strike.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Strike; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
/* harmony import */ var _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Elements/Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




 // import WebGLInstance from '../../../webgl/webgl';

var Strike = /*#__PURE__*/function (_Symbol2) {
  _inherits(Strike, _Symbol2);

  var _super = _createSuper(Strike);

  function Strike() {
    _classCallCheck(this, Strike);

    return _super.apply(this, arguments);
  }

  _createClass(Strike, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //                             X Strike
    //               2    3                  4      5
    //             --- 000                     000
    //             A     000                 000
    //             |       000             000
    //             |         000         000
    //             |           000     000
    //             |             000 000
    //     height  |               000
    //             |             000 000
    //             |           000     000
    //             |         000         000
    //             |       000             000
    //             V     000                 000
    //             --- 000                     000
    //               0 |   1                 6   |  7
    //                 |                         |
    //                 |<----------------------->|
    //                           width
    //
    //
    //                          Forward Strike
    //
    //                                         000
    //                                       000
    //                                     000
    //                                   000
    //                                 000
    //                               000
    //                             000
    //                           000
    //                         000
    //                       000
    //                     000
    //                   000
    //                 000
    //                          Back Strike
    //                 000
    //                   000
    //                     000
    //                       000
    //                         000
    //                           000
    //                             000
    //                               000
    //                                 000
    //                                   000
    //                                     000
    //                                       000
    //                                         000
    //                1      Horizontal Strike     3
    //                 000000000000000000000000000
    //                 000000000000000000000000000
    //                0                            2
    //
    //              |
    //              |           \      00000000000000
    //              |             \  00000000000000
    //              |              00000000000000
    //              |            00000000000000
    //              |          00000000000000
    //              |        00000000000000
    //              |      00000000000000  \
    //              |    00000000000000      \ LineWidth
    //              |  00000000000000   o
    //           -- |00000000000000       o   theta
    //           A  |  0000000000          o
    //         b |  |    000000             o
    //           V  |    g 00               o
    //           --- -------------------------------
    //              |       |
    //              |<----->|
    //                  a
    //
    // theta = atan(height / width)
    //
    // angle g = 180 - theta - 90
    // b = lineWidth * sin(g)
    // a = lineWidth * cos(g)
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      var style = options.style;

      var _this$getDefaultValue = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width,
          height = _this$getDefaultValue.height;

      var points;
      var theta = Math.atan2(height, width);
      var g = Math.PI / 2 - theta;
      var a = lineWidth * Math.cos(g);
      var b = lineWidth * Math.sin(g);
      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, b);
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](a, 0);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height - b);
      var p3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](a, height);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width - a, height);
      var p5 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height - b);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width - a, 0);
      var p7 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, b);
      var h0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height / 2 - lineWidth / 2);
      var h1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height / 2 + lineWidth / 2);
      var h2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height / 2 - lineWidth / 2);
      var h3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height / 2 + lineWidth / 2);

      if (style === 'forward') {
        points = [p0, p1, p5, p0, p5, p4];
      } else if (style === 'back') {
        points = [p2, p3, p7, p2, p7, p6];
      } else if (style === 'cross') {
        points = [p0, p1, p5, p0, p5, p4, p2, p3, p7, p2, p7, p6];
      } else {
        points = [h0, h2, h3, h0, h3, h1];
      }

      return [points, width, height, 'triangles'];
    }
    /* eslint-disable class-methods-use-this */

  }, {
    key: "getBounds",
    value: function getBounds(options, leftIn, bottomIn, widthIn, heightIn) {
      var _this$getDefaultValue2 = this.getDefaultValues(heightIn, widthIn, options),
          width = _this$getDefaultValue2.width,
          height = _this$getDefaultValue2.height;

      var bounds = new _Elements_Bounds__WEBPACK_IMPORTED_MODULE_3__["default"]();
      bounds.left = leftIn;
      bounds.bottom = bottomIn;
      bounds.width = width;
      bounds.height = height;
      bounds.right = bounds.left + bounds.width;
      bounds.top = bounds.bottom + bounds.height;
      bounds.descent = 0;
      bounds.ascent = bounds.height;
      return bounds;
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth != null && typeof options.lineWidth === 'number') {
        out.lineWidth = options.lineWidth;
      } else {
        out.lineWidth = 0.015;
      }

      if (options.height != null && typeof options.height === 'number') {
        out.height = options.height;
      } else if (height != null) {
        out.height = height;
      } else {
        out.height = 1;
      }

      if (options.width != null && typeof options.width === 'number') {
        out.width = options.width;
      } else if (width != null) {
        out.width = width;
      } else {
        out.width = 1;
      }

      return out;
    }
  }]);

  return Strike;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Sum.js":
/*!***********************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Sum.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Sum; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


 // import Bounds from '../Elements/Bounds';

var Sum = /*#__PURE__*/function (_Symbol2) {
  _inherits(Sum, _Symbol2);

  var _super = _createSuper(Sum);

  function Sum() {
    _classCallCheck(this, Sum);

    return _super.apply(this, arguments);
  }

  _createClass(Sum, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    // // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (type: 'static' | 'dynamic', options: Object, height: number) => {
    //     const { width } = options;
    //     if (type === 'static') {
    //       return height * width;
    //     }
    //     return width;
    //   };
    // }
    // eslint-disable-next-line class-methods-use-this
    // getWidth() {
    //   return (options: Object, height: number) => {
    //     let width;
    //     if (options.draw === 'static') {
    //       let { staticHeight } = options;
    //       if (typeof staticHeight !== 'number') {
    //         staticHeight = height;
    //       }
    //       ({ width } = this.getDefaultValues(staticHeight, null, options));
    //       return width / staticHeight * height;
    //     }
    //     ({ width } = options);
    //     ({ width } = this.getDefaultValues(height, width, options));
    //     return width;
    //   };
    // }
    //                   8                                    10
    //          ---------- 00000000000000000000000000000000000_______________
    //          A            0000000 9         \      11 000000           *
    //          |              0000000          \           000           *
    //          |                0000000         thick2       00  12     *
    //          |                  0000000  D             13    \       * tipAngle
    //          |                    0000000                     \    *
    //          |                  B   0000000       thick1        \*
    //          |                        0000000    /
    //          |                          0000000 /
    //          |                            0000000
    //          |                              0000000
    //          |                                000000  -- 7
    //          |      -------------------------6  000
    //          |      A                         00|0
    //       h  |      |                       0000|
    //          |      |                     0000  |\
    //          |      |                   0000    | \
    //          |      | e               0000      |  thick2
    //          |      |               0000  C     |
    //          |      |         A   0000          |             0
    //          |      |           0000            |         1   |____
    //          |      |         0000       thick3 |           00    A
    //          |      |       0000        /       |      3  000|    |
    //          |      |     0000  5      /        |      000000|    |  c
    //          V      V   000000000000000000000000|00000000000 |    |
    //          --------  0000000000000000000000000|0000000000__|____V
    //                 4 |                         |        2|  |
    //                   |                         |         |  |
    //                   |                         |         |  |
    //                   |<----------------------->|         |  |
    //                   |           a                       |  |
    //                   |                                   |  |
    //                   |                                   |  |  b
    //                   |                              ---->|  |<---
    //                   |                                      |
    //                   |                                      |
    //                   |                  w                   |
    //                   |<------------------------------------>|
    //
    // Linewidths that look good:
    // height = 0.2, linewWidth = width / 20
    // height = 0.6, linewWidth = width / 30
    // height = 1, linewWidth = width / 40
    // height = 1.4, linewWidth = width / 50
    // height = 1.8, linewWidth = width / 60
    // Therefore default lineWidth =  width / (25 * height + 15)
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, height) {
      var sides = options.sides; // let lineWidthToUse = lineWidth;

      var _this$getDefaultValue = this.getDefaultValues(height, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width; // if (lineWidth == null) {
      //   lineWidthToUse = width / (25 * height + 15);
      // }


      var bottomTipAngle = Math.PI / 2 * 0.9;
      var topTipAngle = Math.PI / 2 * 0.95;
      var a = 0.431 * width;
      var e = height / 2 - lineWidth;
      var cBottom = 0.176 * height;
      var cTop = 0.153 * height;
      var bBottom = cBottom / Math.tan(bottomTipAngle);
      var bTop = cTop / Math.tan(topTipAngle);
      var thick2 = lineWidth;
      var thick3 = lineWidth * 2;
      var thick1 = lineWidth * 3;
      var tipWidth = lineWidth * 0.6;
      var lineA = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a, e));
      var CxOffset = thick2 / Math.sin(lineA.ang);
      var lineC = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](CxOffset, 0), height, lineA.ang);
      var lineB = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a, e));
      var DxOffset = -thick1 / Math.sin(lineB.ang);
      var lineD = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](DxOffset, height), height, lineB.ang);
      var intersection = lineC.intersectsWith(lineD).intersect;
      var p0 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, cBottom);
      var p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - tipWidth, cBottom);
      var p2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - bBottom, 0);
      var p3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p1.x - (cBottom - thick3) / Math.tan(bottomTipAngle), thick3);
      var p4 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var p5 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](thick2 / Math.sin(lineA.ang) + thick3 / Math.tan(lineA.ang), thick3);
      var p6 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](a, e);
      var p7 = intersection;
      var p8 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height);
      var p9 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-thick1 / Math.sin(lineB.ang) - thick2 / Math.tan(lineB.ang), height - thick2);
      var p10 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - bTop, height);
      var p12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height - cTop);
      var p13 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width - tipWidth, height - cTop);
      var p11 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p13.x - (cTop - thick2) / Math.tan(topTipAngle), height - thick2);
      var p30 = p1;
      var p31 = p3;
      var p32 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p31.x - (cBottom - thick3), thick3);
      var bottomCurve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p30, p31, p32, sides);
      var bottomCurvePairs = [];
      bottomCurve.forEach(function (p) {
        bottomCurvePairs.push(p2);
        bottomCurvePairs.push(p);
      });
      var p111 = p11;
      var p110 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p111.x - cTop + thick2, height - thick2);
      var p112 = p13;
      var topCurve = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["quadBezierPoints"])(p110, p111, p112, sides);
      var topCurvePairs = [];
      topCurve.forEach(function (p) {
        topCurvePairs.push(p10);
        topCurvePairs.push(p);
      });
      var points = [p0, p1].concat(bottomCurvePairs, [p4, p5, p6, p7, p8, p9], topCurvePairs, [p12, p13]);
      return [points, width, height, 'strip'];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {
        lineWidth: height * 0.88 / (25 * height + 15),
        width: height * 0.88,
        height: height
      };

      if (options.lineWidth != null) {
        out.lineWidth = options.lineWidth;
      }

      if (options.width != null) {
        out.width = options.width;
      }

      return out;
    } // getBounds(options: Object,
    //   leftIn: number,
    //   bottomIn: number,
    //   widthIn: number,
    //   heightIn: number,
    // ) {
    //   const { width, height } = this.getDefaultValues(
    //     heightIn, widthIn, options,
    //   );
    //   const bounds = new Bounds();
    //   bounds.left = leftIn - width;
    //   bounds.bottom = bottomIn;
    //   bounds.width = width;
    //   bounds.right = bounds.left + width;
    //   bounds.ascent = height;
    //   bounds.descent = 0;
    //   bounds.height = height;
    //   bounds.top = bounds.bottom + bounds.height;
    //   return bounds;
    // }

  }]);

  return Sum;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/SymbolNew.js":
/*!*****************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/SymbolNew.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Symbol; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawingObjects_VertexObject_VertexGeneric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../DrawingObjects/VertexObject/VertexGeneric */ "./src/js/figure/DrawingObjects/VertexObject/VertexGeneric.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _Elements_Bounds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Elements/Bounds */ "./src/js/figure/Equation/Elements/Bounds.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



 // import VertexSymbol from './VertexSymbol';





var _Symbol = /*#__PURE__*/function (_FigureElementPrimiti) {
  _inherits(_Symbol, _FigureElementPrimiti);

  var _super = _createSuper(_Symbol);

  function _Symbol(webgl, color, transformOrLocation, figureLimits, symbolOptions) // triangles: 'strip' | 'triangles' | 'fan',
  {
    var _this;

    _classCallCheck(this, _Symbol);

    var vertexObject = new _DrawingObjects_VertexObject_VertexGeneric__WEBPACK_IMPORTED_MODULE_3__["default"](webgl);
    var initialT;

    if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]) {
      initialT = transformOrLocation;
    } else {
      initialT = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('Symbol').scale(1, 1).translate(0, 0);
    }

    _this = _super.call(this, vertexObject, initialT, color, figureLimits);

    if (symbolOptions.touchBorder != null) {
      _this.touchBorder = symbolOptions.touchBorder;
    }

    if (symbolOptions.border != null) {
      _this.border = symbolOptions.border;
    }

    if (symbolOptions.onClick != null) {
      _this.onClick = symbolOptions.onClick;
    }

    if (symbolOptions.isTouchable != null) {
      _this.isTouchable = symbolOptions.isTouchable;
    }

    _this.custom.options = symbolOptions;

    if (_this.custom.options.draw === 'dynamic') {
      _this.custom.scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](1, 1);

      _this.internalSetTransformCallback = function () {
        var s = _this.getScale();

        if (_this.custom.scale.isNotEqualTo(s, 8)) {
          var _this$getPoints = _this.getPoints(_this.custom.options, s.x, s.y),
              _this$getPoints2 = _slicedToArray(_this$getPoints, 4),
              pointsNew = _this$getPoints2[0],
              widthNew = _this$getPoints2[1],
              heightNew = _this$getPoints2[2],
              drawType = _this$getPoints2[3];

          _this.pointsDefinition = {
            points: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(pointsNew),
            width: widthNew,
            height: heightNew,
            drawType: drawType
          }; // $FlowFixMe
          // this.drawingObject.change(pointsNew);
          // this.drawBorder = [
          //   new Point(0, 0),
          //   new Point(widthNew, 0),
          //   new Point(widthNew, heightNew),
          //   new Point(0, heightNew),
          // ];

          _this.updateSymbol(pointsNew, widthNew, heightNew, drawType); // this.drawingObject.updatePoints(
          //   pointsNew,
          //   widthNew,
          //   heightNew,
          // );


          _this.custom.scale = s;
        }
      };
    } // eslint-disable-next-line max-len


    _this.custom.setSize = function (location, widthIn, heightIn) {
      var t = _this.transform._dup();

      if (_this.custom.options.draw === 'static' // && this.drawingObject.points.length === 0
      ) {
          var points = [];
          var width = 0;
          var height = 0;
          var drawType = 'strip';

          if (_this.custom.options.staticHeight === 'first' || _this.custom.options.staticWidth === 'first') {
            var _this$getPoints3 = _this.getPoints(symbolOptions, widthIn, heightIn);

            var _this$getPoints4 = _slicedToArray(_this$getPoints3, 4);

            points = _this$getPoints4[0];
            width = _this$getPoints4[1];
            height = _this$getPoints4[2];
            drawType = _this$getPoints4[3];
          } else if (_this.custom.options.staticHeight != null || _this.custom.options.staticWidth != null) {
            var _this$getPoints5 = _this.getPoints(symbolOptions, _this.custom.options.staticWidth, _this.custom.options.staticHeight);

            var _this$getPoints6 = _slicedToArray(_this$getPoints5, 4);

            points = _this$getPoints6[0];
            width = _this$getPoints6[1];
            height = _this$getPoints6[2];
            drawType = _this$getPoints6[3];
          }

          _this.pointsDefinition = {
            points: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(points),
            width: width,
            height: height,
            drawType: drawType
          }; // $FlowFixMe
          // this.drawingObject.updatePoints(points, width, height);

          _this.updateSymbol(points, width, height, drawType);

          _this.custom.options.staticHeight = height;
          _this.custom.options.staticWidth = width; // console.log('a', width, height)

          t.updateScale(width, height);
        } else {
        var _this$getPoints7 = _this.getPoints(_this.custom.options, widthIn, heightIn),
            _this$getPoints8 = _slicedToArray(_this$getPoints7, 4),
            pointsNew = _this$getPoints8[0],
            widthNew = _this$getPoints8[1],
            heightNew = _this$getPoints8[2],
            _drawType = _this$getPoints8[3];

        _this.pointsDefinition = {
          points: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(pointsNew),
          width: widthNew,
          height: heightNew,
          drawType: _drawType
        }; // $FlowFixMe

        _this.updateSymbol(pointsNew, widthNew, heightNew, _drawType); // this.drawingObject.updatePoints(
        //   pointsNew,
        //   widthNew,
        //   heightNew,
        // );


        _this.custom.scale = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](widthIn, heightIn); // console.log('b', widthIn, heightIn, this.getPath())

        t.updateScale(widthIn, heightIn);
      }

      t.updateTranslation(location.x, location.y);

      _this.setTransform(t);
    };

    _this.setPointsFromDefinition = function () {
      if (Object.keys(_this.pointsDefinition).length === 0) {
        return;
      }

      var _this$pointsDefinitio = _this.pointsDefinition,
          points = _this$pointsDefinitio.points,
          width = _this$pointsDefinitio.width,
          height = _this$pointsDefinitio.height,
          drawType = _this$pointsDefinitio.drawType; // $FlowFixMe

      _this.updateSymbol(points, width, height, drawType); // this.drawingObject.updatePoints(points, width, height);
      // // if (width == null || height == null || location == null) {
      // //   return;
      // // }
      // this.custom.setSize(this.getPosition(), width, height);

    };

    return _this;
  }

  _createClass(_Symbol, [{
    key: "updateSymbol",
    value: function updateSymbol(pointsIn, width, height, drawType) {
      this.drawingObject.change({
        points: pointsIn,
        drawType: drawType
      });
      this.drawBorder = [[new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height)]];

      if (typeof this.custom.options.drawBorderBuffer === 'number' || Array.isArray(this.custom.options.drawBorderBuffer) && typeof this.custom.options.drawBorderBuffer[0] === 'number') {
        this.drawBorderBuffer = [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBoundingBorder"])( // $FlowFixMe
        this.drawBorder, this.custom.options.drawBorderBuffer)];
      } else if (Array.isArray(this.custom.options.drawBorderBuffer)) {
        // $FlowFixMe
        this.drawBorderBuffer = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBorder"])(this.custom.options.drawBorderBuffer);
      } else {
        this.drawBorderBuffer = this.drawBorder;
      }
    } // // eslint-disable-next-line class-methods-use-this, no-unused-vars
    // updatePoints(points: Array<Point>, width: Number, height: number) {
    // }

  }, {
    key: "getTransform",
    value: function getTransform() {
      if (this.custom.options.draw === 'static') {
        var _t = this.transform._dup();

        var s = _t.s();

        if (s != null) {
          _t.updateScale(s.x / this.custom.options.staticWidth, s.y / this.custom.options.staticHeight);
        }

        return _t;
      }

      var t = this.transform._dup();

      t.updateScale(1, 1);
      return t;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getWidth",
    value: function getWidth(options, height) {
      var width;

      if (options.draw === 'static') {
        var staticHeight = options.staticHeight;
        var staticWidth = options.staticWidth;

        if (staticHeight === 'first') {
          staticHeight = height;
        }

        var _this$getDefaultValue = this.getDefaultValues(staticHeight, staticWidth, options);

        width = _this$getDefaultValue.width;

        if (width == null) {
          width = height;
        }

        return width / staticHeight * height;
      }

      width = options.width;

      var _this$getDefaultValue2 = this.getDefaultValues(height, width, options);

      width = _this$getDefaultValue2.width;
      return width;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getHeight",
    value: function getHeight(options, width) {
      var height;

      if (options.draw === 'static') {
        var staticWidth = options.staticWidth;
        var staticHeight = options.staticHeight;

        if (staticWidth === 'first') {
          staticWidth = width;
        } // ????


        var _this$getDefaultValue3 = this.getDefaultValues(staticHeight, staticWidth, options);

        height = _this$getDefaultValue3.height;

        if (height == null) {
          height = width;
        }

        return height / staticWidth * width;
      }

      height = options.height;

      var _this$getDefaultValue4 = this.getDefaultValues(height, width, options);

      height = _this$getDefaultValue4.height;
      return height;
    }
  }, {
    key: "getBounds",
    value: function getBounds(options, contentX, contentY, contentWidth, contentHeight, side) {
      // const contentWidth = contentWidthIn == null ? 0 : contentWidthIn;
      // const contentHeight = contentHeightIn == null ? 0 : contentHeightIn;
      var _this$getDefaultValue5 = this.getDefaultValues(contentHeight, contentWidth, options),
          width = _this$getDefaultValue5.width,
          height = _this$getDefaultValue5.height;

      var bounds = new _Elements_Bounds__WEBPACK_IMPORTED_MODULE_5__["default"]();

      if (side === 'left') {
        bounds.left = contentX - width;
        bounds.bottom = contentY;
        bounds.top = bounds.bottom + height;
        bounds.right = bounds.left + width;
      } else if (side === 'right') {
        bounds.left = contentX;
        bounds.bottom = contentY;
        bounds.top = bounds.bottom + height;
        bounds.right = bounds.left + width;
      } else if (side === 'top') {
        bounds.bottom = contentY;
        bounds.top = contentY + height;
        bounds.left = contentX + contentWidth / 2 - width / 2;
        bounds.right = bounds.left + width;
      } else {
        bounds.top = contentY;
        bounds.bottom = contentY - height;
        bounds.left = contentX + contentWidth / 2 - width / 2;
        bounds.right = bounds.left + width;
      }

      bounds.width = width;
      bounds.height = height;
      bounds.ascent = height;
      bounds.descent = 0;
      return bounds;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "getPoints",
    value: function getPoints(options, width, height) {
      var points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, height), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, height)];
      return [points, width, height, 'strip'];
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      // const out: {
      //   height?: number,
      //   width?: number,
      //   lineWidth?: number,
      //   tipWidth?: number,
      //   arrowWidth?: number,
      //   arrowHeight?: number,
      // } = {};
      // return out;
      return {};
    }
  }]);

  return _Symbol;
}(_Element__WEBPACK_IMPORTED_MODULE_0__["FigureElementPrimitive"]);



/***/ }),

/***/ "./src/js/figure/Equation/Symbols/Vinculum.js":
/*!****************************************************!*\
  !*** ./src/js/figure/Equation/Symbols/Vinculum.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Bracket; });
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _SymbolNew__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SymbolNew */ "./src/js/figure/Equation/Symbols/SymbolNew.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



 // import WebGLInstance from '../../../webgl/webgl';

var Bracket = /*#__PURE__*/function (_Symbol2) {
  _inherits(Bracket, _Symbol2);

  var _super = _createSuper(Bracket);

  function Bracket() {
    _classCallCheck(this, Bracket);

    return _super.apply(this, arguments);
  }

  _createClass(Bracket, [{
    key: "getPoints",
    // eslint-disable-next-line class-methods-use-this
    // getTriangles() {
    //   return 'strip';
    // }
    //                             width
    //          |<---------------------------------------->|
    //          |                                          |  3
    //        1 |                                          | ____
    //          00000000000000000000000000000000000000000000   A
    //          00000000000000000000000000000000000000000000   |  Line Width
    //          00000000000000000000000000000000000000000000 __V_
    //         0                                            2
    //
    // eslint-disable-next-line class-methods-use-this
    value: function getPoints(options, widthIn, heightIn) {
      var _this$getDefaultValue = this.getDefaultValues(heightIn, widthIn, options),
          lineWidth = _this$getDefaultValue.lineWidth,
          width = _this$getDefaultValue.width,
          height = _this$getDefaultValue.height;

      var points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, lineWidth), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](width, lineWidth)];
      return [points, width, height, 'strip'];
    }
    /* eslint-disable class-methods-use-this */
    // $FlowFixMe

  }, {
    key: "getDefaultValues",
    value: function getDefaultValues(height, width, options) {
      var out = {};

      if (options.lineWidth != null) {
        out.lineWidth = options.lineWidth;
      } else {
        out.lineWidth = 0.01;
      }

      out.height = out.lineWidth;

      if (width != null) {
        out.width = width;
      } else {
        out.width = 1;
      }

      return out;
    }
  }]);

  return Bracket;
}(_SymbolNew__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/js/figure/Figure.js":
/*!*********************************!*\
  !*** ./src/js/figure/Figure.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/FunctionMap */ "./src/js/tools/FunctionMap.js");
/* harmony import */ var _Recorder_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Recorder/state */ "./src/js/figure/Recorder/state.js");
/* harmony import */ var _Recorder_parseState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Recorder/parseState */ "./src/js/figure/Recorder/parseState.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Element */ "./src/js/figure/Element.js");
/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./webgl/GlobalAnimation */ "./src/js/figure/webgl/GlobalAnimation.js");
/* harmony import */ var _Recorder_Recorder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Recorder/Recorder */ "./src/js/figure/Recorder/Recorder.js");
/* harmony import */ var _Gesture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Gesture */ "./src/js/figure/Gesture.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DrawContext2D */ "./src/js/figure/DrawContext2D.js");
/* harmony import */ var _FigurePrimitives_FigurePrimitives__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./FigurePrimitives/FigurePrimitives */ "./src/js/figure/FigurePrimitives/FigurePrimitives.js");
/* harmony import */ var _FigureCollections_FigureCollections__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./FigureCollections/FigureCollections */ "./src/js/figure/FigureCollections/FigureCollections.js");
/* harmony import */ var _SlideNavigator__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./SlideNavigator */ "./src/js/figure/SlideNavigator.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

 // import getShaders from './webgl/shaders';


// import * as math from '../tools/math';
// import { round } from '../tools/math';






 // eslint-disable-next-line import/no-cycle




// import FigureEquation from './Equation/FigureEquation';
 // import addElements from './FigureAddElements/addElements';
// import type { TypeAddElementObject } from './FigureAddElements/addElements';



// There are several coordinate spaces that need to be considered for a
// figure.
//
// In the simplest figure, there will be in hierarchy:
//  - GL Canvas
//    - Figure
//      - Element Collection
//        - Element Primitive
//          - Drawing Object (e.g. shape, text) from primative vertices
//
// A shape is defined in Drawing Object space.
// It is then transformed by the element primative
// It is then transformed by the element colleciton
// It is then transformed by the figure
// it is then transformed into GL Space
//
// Figure elements can also be rendered to an image in a HTML 2D canvas
// element. To do so, pass in:
//    - Figure Element (primative or collection) to render
//    - HTML element (which is a 2D canvas)
//    - Window of figure to render
//    - Window scaling (how does the window fit within the HTML Element)
//      - fit: figure units will be scaled so that figure window limits
//             aspect ratio fits within the element aspect ratio
//      - 1em: figure units will be scaled so 0.2 figure units (default font
//             size) looks like 1em of the html element font size in pixels
//      - 10px: figure units will be scaled so that the max figure window
//              limit will be the pixel count
//      - strech: figure units will be scaled so that the figure window
//                limits will be stretched to fit the html element width
//                and height
// Then the process is:
//    - html element size in pixels and aspect ratio found
//    - html element size in gl coordinates found
//  /**
//   * @typedef FigureOptions
//   * @type {object}
//   * @property {string} [htmlId = 'figureOneContainer'] - div id of figure container.
//   * @property {Rect} [limits = Rect(-1, -1, 2, 2)] - limits of figure.
//   */

/**
 * Primary Figure class.
 *
 * A figure will attach a WebGL canvas and Context2D
 * canvas to the html `div` element with id `"figureOneContainer"`.
 *
 * The figure manages all drawing elements, renders the drawing elements
 * on a browser's animation frames and listens for guestures from the user.
 *
 * The figure also has a recorder, allowing to record and playback states,
 * and gestures - though this is not yet documented.
 *
 * To attach to a different `div`, use the `htmlId` property in the class
 * constructor.
 *
 * If a figure is paused, then all drawing element animations will
 * also be paused.
 *
 * `Figure` has a number of convenience methods for create drawing elements
 * already attached to the drawing canvases, and useful transforms for
 * converting between the different spaces (e.g. pixel, GL, figure).
 *
 * @class
 * @param {OBJ_Figure} options
 * @property {FigurePrimitives} primitives create figure primitives such
 * as shapes, lines and grids
 * @property {FigureCollections} collections create figure collections such
 * as advanced lines, shapes, equations and plots
 *
 * @example
 * // Simple html and javascript example to create a figure, and add a
 * // hexagon.
 * //
 * // For additional examples, see https://github.com/airladon/FigureOne
 * //
 * // Two files `index.html` and `index.js` in the same directory
 *
 * // index.html
 * <!doctype html>
 * <html>
 * <body>
 *     <div id="figureOneContainer" style="width: 800px; height: 800px; background-color: white;">
 *     </div>
 *     <script type="text/javascript" src='https://cdn.jsdelivr.net/npm figureone@0.3.12/figureone.min.js'></script>
 *     <script type="text/javascript" src='./index.js'></script>
 * </body>
 * </html>
 *
 * // index.js
 * const figure = new Fig.Figure({ limits: [-1, -1, 2, 2 ]});
 * figure.add(
 *   {
 *     name: 'p',
 *     method: 'polygon',
 *     options: {
 *       radius: 0.5,
 *       sides: 6,
 *     },
 *   },
 * );
 * figure.initialize();
 *
 * @example
 * // Alternately, an element can be added programatically
 * // index.js
 * const figure = new Fig.Figure({ limits: [-1, -1, 2, 2 ]});
 * const hex = figure.shapes.polygon({
 *   radius: 0.5,
 *   sides: 6,
 * });
 * figure.add('hexagon', hex);
 */
var Figure = /*#__PURE__*/function () {
  // canvasHigh: HTMLCanvasElement;
  // textCanvasHigh: HTMLCanvasElement;
  // draw2DHigh: DrawContext2D;
  // webglHigh: WebGLInstance;
  // gestureElement: HTMLElement;
  // shapesHigh: Object;
  // equation: Object;
  // equationLow: Object;
  // equationHigh: Object;
  // objectsHigh: FigureCollections;
  // layout: Object;

  /**
   * Useful transforms between spaces at the figure level and above.
   * @property {OBJ_SpaceTransforms} spaceTransforms
   */
  // oldScrollY: number;
  // used for drawing debug only
  // updateFontSize: string;
  // pauseAfterNextDrawFlag: boolean;
  function Figure() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Figure);

    var defaultOptions = {
      htmlId: 'figureOneContainer',
      limits: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rect"](-1, -1, 2, 2),
      fontScale: 1,
      color: [0, 0, 0, 1],
      dimColor: [0.5, 0.5, 0.5, 1],
      font: {
        family: 'Helvetica',
        size: 0.2,
        style: 'normal',
        weight: '100',
        opacity: 1
      }
    };
    this.fnMap = new _tools_FunctionMap__WEBPACK_IMPORTED_MODULE_2__["FunctionMap"]();
    this.isPaused = false;
    this.scrolled = false;
    this.cursorElementName = 'cursor';
    this.setStateCallback = null;
    this.mockPreviousTouchPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0); // this.oldScrollY = 0;

    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"])({}, defaultOptions, options);
    var htmlId = optionsToUse.htmlId,
        limits = optionsToUse.limits;
    this.defaultColor = optionsToUse.color; // this.defaultLineWidth = optionsToUse.lineWidth;

    if (optionsToUse.font.color == null) {
      optionsToUse.font.color = this.defaultColor.slice();
    }

    this.defaultDimColor = optionsToUse.dimColor;
    this.defaultFont = optionsToUse.font;
    this.htmlId = htmlId;
    this.animationFinishedCallback = null; // this.layout = layout;

    if (typeof htmlId === 'string') {
      var container = document.getElementById(htmlId);

      if (container instanceof HTMLElement) {
        this.container = container;
        var children = container.children;

        for (var i = 0; i < children.length; i += 1) {
          var child = children[i];

          if (child instanceof HTMLCanvasElement && child.classList.contains('figureone__gl')) {
            this.canvasLow = child;
          }

          if (child instanceof HTMLCanvasElement && child.classList.contains('figureone__gl__offscreen')) {
            this.canvasOffscreen = child;
          }

          if (child instanceof HTMLCanvasElement && child.classList.contains('figureone__text')) {
            this.textCanvasLow = child;
          }

          if (child instanceof HTMLCanvasElement && child.classList.contains('figureone__text__offscreen')) {
            this.textCanvasOffscreen = child;
          }

          if (child.classList.contains('figureone__html')) {
            this.htmlCanvas = child;
          }
        }

        if (this.canvasLow == null) {
          this.canvasLow = document.createElement('canvas');
          this.canvasLow.classList.add('figureone__gl', 'figureone__canvas');
          container.appendChild(this.canvasLow);
        }

        if (this.textCanvasLow == null) {
          this.textCanvasLow = document.createElement('canvas');
          this.textCanvasLow.classList.add('figureone__text', 'figureone__canvas');
          container.appendChild(this.textCanvasLow);
        }

        if (this.htmlCanvas == null) {
          this.htmlCanvas = document.createElement('div');
          this.htmlCanvas.classList.add('figureone__html', 'figureone__canvas');
          container.appendChild(this.htmlCanvas);
        }

        var canvasStyle = document.createElement('style');
        canvasStyle.type = 'text/css';
        container.classList.add('figureone__container');
        canvasStyle.innerHTML = "\n          .figureone__container {\n            position: relative;\n            pointer-events: none;\n          }\n          .figureone__canvas {\n            width: 100%;\n            height: 100%;\n            position: absolute;\n          }\n          .figureone__html {\n            pointer-events: auto;\n          }\n        ";
        document.getElementsByTagName('head')[0].appendChild(canvasStyle);
        this.backgroundColor = [1, 1, 1, 1];
        var webglLow = new _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__["default"](this.canvasLow, this.backgroundColor);
        this.webglLow = webglLow;

        if (this.canvasOffscreen) {
          var webglOffscreen = new _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__["default"](this.canvasOffscreen, this.backgroundColor);
          this.webglOffscreen = webglOffscreen;
        }

        this.draw2DLow = new _DrawContext2D__WEBPACK_IMPORTED_MODULE_10__["default"](this.textCanvasLow);

        if (this.textCanvasOffscreen) {
          var draw2DOffscreen = new _DrawContext2D__WEBPACK_IMPORTED_MODULE_10__["default"](this.textCanvasOffscreen);
          this.draw2DOffscreen = draw2DOffscreen;
        } // this.draw2DHigh = new DrawContext2D(this.textCanvasHigh);

      }
    }

    if (optionsToUse.gestureCanvas != null) {
      var gestureCanvas = document.getElementById(optionsToUse.gestureCanvas);

      if (gestureCanvas != null) {
        this.gestureCanvas = gestureCanvas;
      }
    }

    if (this.gestureCanvas == null) {
      this.gestureCanvas = this.htmlCanvas;
    }

    if (this instanceof Figure) {
      // $FlowFixMe
      this.gesture = new _Gesture__WEBPACK_IMPORTED_MODULE_9__["default"](this);
    }

    this.previousCursorPoint = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
    this.isTouchDown = false; // this.pauseAfterNextDrawFlag = false;

    this.fontScale = optionsToUse.fontScale; // console.log(this.canvasLow.getClientBoundingRect())

    this.updateLimits(limits);
    this.setDefaultLineWidth(options.lineWidth || null);
    this.setDefaultLength(options.length || null);
    this.drawQueued = false;
    this.lastDrawTime = 0;
    this.inTransition = false;
    this.beingMovedElements = [];
    this.beingTouchedElements = [];
    this.touchTopElementOnly = true;
    this.globalAnimation = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_7__["default"]();
    this.subscriptions = new _tools_tools__WEBPACK_IMPORTED_MODULE_5__["SubscriptionManager"](this.fnMap);
    this.recorder = new _Recorder_Recorder__WEBPACK_IMPORTED_MODULE_8__["Recorder"]();
    this.recorder.figure = this;
    this.bindRecorder();
    this.pauseTime = this.globalAnimation.now() / 1000;
    this.shapesLow = this.getShapes(); // this.shapesHigh = this.getShapes(true);

    this.shapes = this.shapesLow;
    this.primitives = this.shapes; // this.equationLow = this.getEquations();
    // this.equationHigh = this.getEquations(true);
    // this.equation = this.equationLow;

    this.collectionsLow = this.getObjects(); // this.collectionsHigh = this.getObjects(true);

    this.collections = this.collectionsLow;
    this.createFigureElements();

    if (this.elements.name === '') {
      this.elements.name = 'figureRoot';
    }

    this.state = {
      pause: 'unpaused',
      preparingToStop: false,
      preparingToSetState: false
    };
    this.stateTime = this.globalAnimation.now() / 1000; // this.updateFontSize = optionsToUse.updateFontSize;

    window.addEventListener('resize', this.resize.bind(this));
    this.sizeHtmlText();
    this.isTouchDevice = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["isTouchDevice"])();
    this.animateNextFrame(true, 'first frame');

    if (optionsToUse.elements) {
      // eslint-disable-next-line new-cap
      this.elements = new optionsToUse.elements(this);
      this.elements.figureLimits = this.limits;
      this.initElements();
    }

    this.waitForFrames = 0;
    this.scrollingFast = false;
    this.scrollTimeoutId = null;
    this.drawTimeoutId = null;
    this.oldScroll = window.pageYOffset;
    this.drawAnimationFrames = 0;
    this.cursorShown = false; // /**
    //  * Create built in {@link FigureElement}s
    //  * @property {function(OBJ_Polygon): FigureElementPrimitive} polygon
    //  */
    // deprecate
    // $FlowFixMe
    // this.create = {
    //   collection: this.collections.collection.bind(this.shapes),
    //   generic: this.shapes.generic.bind(this.shapes),
    //   polyline: this.shapes.polyline.bind(this.shapes),
    //   polygon: this.shapes.polygon.bind(this.shapes),
    //   grid: this.shapes.grid.bind(this.shapes),
    //   triangle: this.shapes.triangle.bind(this.shapes),
    //   rectangle: this.shapes.rectangle.bind(this.shapes),
    //   // radialLines: this.shapes.radialLines.bind(this.shapes),
    //   text: this.shapes.text.bind(this.shapes),
    //   textLine: this.shapes.textLine.bind(this.shapes),
    //   textLines: this.shapes.textLines.bind(this.shapes),
    //   // arrow: this.shapes.arrow.bind(this.shapes),
    //   html: this.shapes.html.bind(this.shapes),
    //   // htmlImage: this.shapes.htmlImage.bind(this.shapes),
    //   // htmlText: this.shapes.htmlText.bind(this.shapes),
    //   line: this.collections.line.bind(this.collections),
    //   angle: this.collections.angle.bind(this.collections),
    //   smartPolyLine: this.collections.polyline.bind(this.collections),
    //   equation: this.equation.equation.bind(this.equation),
    // };
  }

  _createClass(Figure, [{
    key: "slideNavigator",
    value: function slideNavigator(options) {
      return new _SlideNavigator__WEBPACK_IMPORTED_MODULE_13__["default"](Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"])({}, {
        collection: this.elements
      }, options));
    }
  }, {
    key: "bindRecorder",
    value: function bindRecorder() {
      var _this = this;

      // this.recorder.figure = {
      //   animateNextFrame: this.animateNextFrame.bind(this),
      //   setState: this.setState.bind(this),
      //   getState: this.getState.bind(this),
      //   getElement: this.getElement.bind(this),
      //   showCursor: this.showCursor.bind(this),
      //   pause: this.pause.bind(this),
      //   unpause: this.unpause.bind(this),
      //   getIsInTransition: this.getIsInTransition.bind(this),
      //   animateToState: this.animateToState.bind(this),
      //   isAnimating: this.isAnimating.bind(this),
      //   setAnimationFinishedCallback: this.setAnimationFinishedCallback.bind(this),
      //   subscriptions: this.subscriptions,
      //   getPauseState: this.getPauseState.bind(this),
      //   dissolveToState: this.dissolveToState.bind(this),
      // };
      var onCursor = function onCursor(payload) {
        var _payload = _slicedToArray(payload, 3),
            action = _payload[0],
            x = _payload[1],
            y = _payload[2];

        if (action === 'show') {
          _this.showCursor('up', new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](x, y));
        } else {
          _this.showCursor('hide');
        }
      };

      var onTouch = function onTouch(payload) {
        var _payload2 = _slicedToArray(payload, 3),
            action = _payload2[0],
            x = _payload2[1],
            y = _payload2[2];

        if (!_this.isCursorShown()) {
          return;
        }

        if (action === 'down') {
          _this.showCursor('down', new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](x, y));
        } else {
          _this.showCursor('up');
        }
      };

      var onCursorMove = function onCursorMove(payload) {
        var _payload3 = _slicedToArray(payload, 2),
            x = _payload3[0],
            y = _payload3[1];

        _this.setCursor(new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](x, y));
      };

      var moved = function moved(payload) {
        var _payload4 = _slicedToArray(payload, 2),
            elementPath = _payload4[0],
            transform = _payload4[1];

        var element = _this.getElement(elementPath);

        if (element == null) {
          return;
        }

        element.moved(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getTransform"])(transform));
      };

      var startBeingMoved = function startBeingMoved(payload) {
        var _payload5 = _slicedToArray(payload, 1),
            elementPath = _payload5[0];

        var element = _this.getElement(elementPath);

        if (element == null) {
          return;
        }

        element.startBeingMoved();
      };

      var stopBeingMoved = function stopBeingMoved(payload) {
        var _payload6 = _slicedToArray(payload, 3),
            elementPath = _payload6[0],
            transform = _payload6[1],
            velocity = _payload6[2];

        var element = _this.getElement(elementPath);

        if (element == null) {
          return;
        }

        element.stopBeingMoved();
        element.state.movement.velocity = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getTransform"])(velocity);
        element.transform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getTransform"])(transform);
      };

      var startMovingFreely = function startMovingFreely(payload) {
        var _payload7 = _slicedToArray(payload, 3),
            elementPath = _payload7[0],
            transform = _payload7[1],
            velocity = _payload7[2];

        var element = _this.getElement(elementPath);

        if (element == null) {
          return;
        }

        element.transform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getTransform"])(transform);
        element.state.movement.velocity = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getTransform"])(velocity);
        element.startMovingFreely();
      };

      var click = function click(payload) {
        var _payload8 = _slicedToArray(payload, 1),
            id = _payload8[0];

        var element = document.getElementById(id);

        if (element != null) {
          element.click();
        }
      };

      var elementClick = function elementClick(payload) {
        var _payload9 = _slicedToArray(payload, 1),
            elementPath = _payload9[0];

        var element = _this.getElement(elementPath);

        if (element != null) {
          element.click(payload);
        }
      };

      var eqnNavClick = function eqnNavClick(payload) {
        var _payload10 = _slicedToArray(payload, 2),
            direction = _payload10[0],
            elementPath = _payload10[1];

        var element = _this.getElement(elementPath);

        if (element == null) {
          // element.click();
          return;
        }

        if (direction === 'next') {
          // $FlowFixMe
          element.clickNext();
        }

        if (direction === 'prev') {
          // $FlowFixMe
          element.clickPrev();
        }

        if (direction === 'refresh') {
          // $FlowFixMe
          element.clickRefresh();
        }
      };

      this.recorder.addEventType('cursor', onCursor);
      this.recorder.addEventType('cursorMove', onCursorMove);
      this.recorder.addEventType('touch', onTouch);
      this.recorder.addEventType('moved', moved);
      this.recorder.addEventType('stopBeingMoved', stopBeingMoved);
      this.recorder.addEventType('startMovingFreely', startMovingFreely);
      this.recorder.addEventType('startBeingMoved', startBeingMoved);
      this.recorder.addEventType('click', click);
      this.recorder.addEventType('elementClick', elementClick);
      this.recorder.addEventType('eqnNavClick', eqnNavClick);
    }
  }, {
    key: "setDefaultLineWidth",
    value: function setDefaultLineWidth(userInputLineWidth) {
      if (userInputLineWidth != null) {
        this.defaultLineWidth = userInputLineWidth;
        return;
      }

      var matrix = this.spaceTransforms.pixelToFigure.matrix();
      this.defaultLineWidth = Math.abs(matrix[0]);
    }
  }, {
    key: "setDefaultLength",
    value: function setDefaultLength(userInputLength) {
      if (userInputLength != null) {
        this.defaultLength = userInputLength;
        return;
      }

      this.defaultLength = this.limits.width / 4;
    }
  }, {
    key: "scrollEvent",
    value: function scrollEvent() {
      this.scrolled = true;
      this.animateNextFrame(false, 'scroll event');
    }
  }, {
    key: "enableScrolling",
    value: function enableScrolling() {
      document.addEventListener('scroll', this.scrollEvent.bind(this), false);
    }
  }, {
    key: "disableScrolling",
    value: function disableScrolling() {
      document.removeEventListener('scroll', this.scrollEvent.bind(this), false);
    }
  }, {
    key: "getState",
    value: function getState(options) {
      this.stateTime = this.globalAnimation.now() / 1000;
      return Object(_Recorder_state__WEBPACK_IMPORTED_MODULE_3__["getState"])(this, ['lastDrawTime', 'elements', 'stateTime'], options);
    }
  }, {
    key: "setState",
    value: function setState(stateIn) {
      var _this2 = this;

      var optionsIn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'instant';
      // console.log(stateIn)
      // $FlowFixMe
      var state = Object(_Recorder_parseState__WEBPACK_IMPORTED_MODULE_4__["default"])(stateIn, this);
      var finishedFlag = false;
      this.state.preparingToSetState = false;

      var finished = function finished() {
        finishedFlag = true;
        _this2.state.preparingToSetState = false; // if (window.asdf) {
        //   debugger;
        // }

        Object(_Recorder_state__WEBPACK_IMPORTED_MODULE_3__["setState"])(_this2, state);

        _this2.elements.setTimeDelta(_this2.globalAnimation.now() / 1000 - _this2.stateTime);

        _this2.elements.setPointsFromDefinition();

        _this2.elements.setPrimitiveColors();

        if (_this2.setStateCallback != null) {
          _this2.fnMap.exec(_this2.setStateCallback);
        }

        _this2.animateNextFrame(); // console.log('triggered')


        _this2.subscriptions.publish('stateSet');
      };

      var options = {
        how: 'instant',
        maxDuration: 6,
        // velocity: {
        //   position: 2,
        //   rotation: Math.PI * 2 / 2,
        //   scale: 1,
        //   opacity: 0.8,
        //   color: 0.8,
        // },
        allDurationsSame: true,
        zeroDurationThreshold: 0.00001,
        // minDuration: 0,
        duration: 0
      };

      if (optionsIn.velocity != null) {
        // $FlowFixMe
        options.velocity = {
          position: 2,
          rotation: Math.PI * 2 / 2,
          scale: 1,
          opacity: 0.8,
          color: 0.8
        };
      } // console.log(resumeSettings)


      if (typeof optionsIn === 'string') {
        options.how = optionsIn;
      } else {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"])({}, options, optionsIn); // velocity trumps duration by default, but if only duration is defined by the
        // user, then remove velocity;
        // if (this.settings.resume.duration != null && this.settings.resume.velocity == null) {
        //   options.velocity = undefined;
        // }
      }

      if (options.how === 'dissolve') {
        var defaultDuration = {
          dissolveIn: 0.8,
          dissolveOut: 0.8,
          delay: 0.2
        };

        if (options.duration === 0) {
          options.duration = defaultDuration;
        } else if (typeof options.duration === 'number') {
          options.duration = {
            dissolveOut: options.duration / 10 * 4.5,
            dissolveIn: options.duration / 10 * 4.5,
            delay: options.duration / 10 * 1
          };
        } else {
          options.duration = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"])({}, defaultDuration, options.duration);
        }
      } else if (options.duration != null && typeof options.duration !== 'number') {
        // $FlowFixMe
        options.duration = {
          dissolveOut: 0,
          dissolveIn: 0,
          delay: 0
        };
      }

      if (options.how === 'instant' // $FlowFixMe
      || this.elements.isStateSame(state.elements, true, ['cursor'])) {
        finished();
      } else if (options.how === 'animate') {
        this.elements.stop('freeze'); // This is cancelling the pulse

        this.animateToState(state, options, finished, 'now');
      } else {
        // this.figure.elements.freezePulseTransforms(false);
        this.elements.stop('freeze');
        this.dissolveToState({
          state: state,
          dissolveInDuration: options.duration.dissolveIn,
          dissolveOutDuration: options.duration.dissolveOut,
          done: finished,
          delay: options.duration.delay,
          startTime: 'now'
        });
      }

      if (!finishedFlag) {
        this.state.preparingToSetState = true;
        this.subscriptions.publish('preparingToSetState');
      }

      this.animateNextFrame();
    }
  }, {
    key: "animateToState",
    value: function animateToState(state) {
      var optionsIn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var done = arguments.length > 2 ? arguments[2] : undefined;
      var startTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      // const defaultOptions = {
      //   // delay: 0,
      //   duration: 1,
      // };
      // if (optionsIn.velocity != null) {
      //   defaultOptions.duration = null;
      // }
      // const options = joinObjects(optionsIn, optionsIn);
      // countStart();
      var duration = this.elements.animateToState(state.elements, optionsIn, true, startTime); // countEnd();

      if (done != null) {
        if (duration === 0) {
          this.fnMap.exec(done);
        } else if (done != null) {
          this.subscriptions.add('animationsFinished', done, 1);
        }
      }
    }
  }, {
    key: "dissolveToState",
    value: function dissolveToState(optionsIn) {
      var _this3 = this;

      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"])({}, {
        dissolveOutDuration: 0.8,
        dissolveInDuration: 0.8,
        delay: 0.2,
        done: null,
        startTime: null
      }, optionsIn);
      this.elements.animations["new"]().opacity({
        duration: options.dissolveOutDuration,
        start: 1,
        target: 0.001
      }).trigger({
        callback: function callback() {
          _this3.elements.hideAll();

          _this3.elements.show(); // this.elements.setOpacity(1);

        }
      }).delay({
        duration: options.delay
      }).trigger({
        callback: function callback() {
          _this3.dissolveInToState({
            state: options.state,
            duration: options.dissolveInDuration,
            done: options.done,
            startTime: options.startTime
          }); // this.

        },
        // duration: options.dissolveInDuration,
        duration: 0
      }).start(options.startTime); // console.log(this.elements)
      // console.log(this.globalAnimation.now())
    } // dissolveToComplete(optionsIn: {
    //   dissolveOutDuration: number,
    //   dissolveInDuration: number,
    //   delay: Number,
    //   done: ?(string | (() => void)),
    //   startTime: ?number | 'now' | 'prev' | 'next',
    // }) {
    //   const options = joinObjects({}, {
    //     dissolveOutDuration: 0.8,
    //     dissolveInDuration: 0.8,
    //     delay: 0.2,
    //     done: null,
    //     startTime: null,
    //   }, optionsIn);
    //   const state = this.getState({});
    //   this.stop('complete');
    //   const completeState = this.getState({});
    //   this.setState(state, 'instant');
    //   this.elements.animations.new()
    //     .opacity({ duration: options.dissolveOutDuration, start: 1, target: 0.001 })
    //     .trigger(
    //       {
    //         callback: () => {
    //           this.elements.hideAll();
    //           this.elements.show();
    //           // this.elements.setOpacity(1);
    //         },
    //       },
    //     )
    //     .delay({ duration: options.delay })
    //     .trigger({
    //       callback: () => {
    //         this.dissolveInToState({
    //           state: completeState,
    //           duration: options.dissolveInDuration,
    //           done: options.done,
    //           startTime: options.startTime,
    //         });
    //         // this.
    //       },
    //       // duration: options.dissolveInDuration,
    //       duration: 0,
    //     })
    //     .start(options.startTime);
    // }

  }, {
    key: "dissolveInToState",
    value: function dissolveInToState(optionsIn) {
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"])({}, {
        duration: 0.8,
        done: null,
        startTime: null
      }, optionsIn);
      var state = options.state,
          duration = options.duration,
          done = options.done,
          startTime = options.startTime;
      var dissolveDuration = this.elements.dissolveInToState(state.elements, duration, startTime); // force update of transforms to update any dependent transforms

      var elements = this.elements.getAllElements();
      elements.forEach(function (element) {
        if (element.isShown && element.dependantTransform === false) {
          element.setTransform(element.transform);
        }
      });

      if (done != null) {
        if (dissolveDuration === 0) {
          this.fnMap.exec(done);
        } else if (done != null) {
          this.subscriptions.add('animationsFinished', done, 1);
        }
      }
    }
    /**
     * Add a {@link FigureElement} to the figure with some `name`.
     * @example
     * const hex = figure.shapes.polygon({
     *   radius: 0.5,
     *   sides: 6,
     * });
     * figure.add('hexagon', hex);
     */

  }, {
    key: "addLegacy",
    value: function addLegacy(name, figureElement) {
      this.elements.add(name, figureElement);
    }
  }, {
    key: "add",
    value: function add(nameOrElementOrElementDefinition, elementToAdd) {
      this.elements.add(nameOrElementOrElementDefinition, elementToAdd);
    }
    /**
     * Get element from an element path with '.' separators.
     *
     * For instance, if a collection has a child collection 'a', which
     * has a child primitive 'b', then the path would be: 'a.b'.
     *
     * @see <a href="#figureelementcollectiongetelement">element.getElement</a>
     *
     * @param {null | string} elementPath
     * @return {FigureElement | null } element at path. If `elementPath`
     * is `null`, then the figure's base collection is returned. If `elementPath`
     * is invalid then `null` is returned.
     *
     * @example
     * // Get all the elements from a figure
     * figure.add(
     *   {
     *     name: 'c',
     *     method: 'collection',
     *     elements: [
     *       {
     *         name: 'tri',
     *         method: 'triangle',
     *         options: {
     *           height: 0.4,
     *           width: 0.4,
     *         },
     *       },
     *       {
     *         name: 'text',
     *         method: 'text',
     *         options: {
     *           text: 'triangle',
     *           position: [0, -0.4],
     *           xAlign: 'center',
     *         },
     *       },
     *     ],
     *   },
     * );
     *
     * const c = figure.getElement('c');
     * // Elements within collections can be found with dot notation
     * const tri = figure.getElement('c.tri');
     * // Or the collection can be queried directly
     * const text = c.getElement('text');
     */

  }, {
    key: "getElement",
    value: function getElement(elementName) {
      if (elementName === this.elements.name) {
        return this.elements;
      }

      return this.elements.getElement(elementName);
    }
    /**
     * Returns an array of result from
     * [getElement](#figureelementcollectiongetelement) calls on an
     * array of paths.
     *
     * @param {TypeElementPath} children
     * @return {Array<FigureElement>} Array of
     * [getElement](#figureelementcollectiongetelement) results
     */

  }, {
    key: "getElements",
    value: function getElements(children) {
      return this.elements.getElements(children);
    }
    /**
     * Set the figure to be touchable.
     *
     * Using <a href="#figureelementsettouchable">element.setTouchable</a> will
     * automatically set this.
     */

  }, {
    key: "setTouchable",
    value: function setTouchable() {
      var touchable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (touchable) {
        this.elements.hasTouchableElements = true;
      } else {
        this.elements.hasTouchableElements = false;
      }
    }
  }, {
    key: "getShapes",
    value: function getShapes() {
      var webgl = [this.webglLow];

      if (this.webglOffscreen) {
        webgl.push(this.webglOffscreen);
      }

      var draw2D = [this.draw2DLow];

      if (this.draw2DOffscreen) {
        draw2D.push(this.draw2DOffscreen);
      } // if (high) {
      //   webgl = this.webglHigh;
      //   draw2D = this.draw2DHigh;
      // }


      return new _FigurePrimitives_FigurePrimitives__WEBPACK_IMPORTED_MODULE_11__["default"](webgl, draw2D, // this.draw2DFigures,
      this.htmlCanvas, this.limits, this.spaceTransforms, this.animateNextFrame.bind(this, true, 'getShapes'), this.defaultColor, this.defaultDimColor, this.defaultFont, this.defaultLineWidth, this.defaultLength);
    } // getEquations() {
    //   const shapes = this.shapesLow;
    //   // if (high) {
    //   //   shapes = this.shapesHigh;
    //   // }
    //   return new FigureEquation(shapes, this.animateNextFrame.bind(this, true, 'equations'));
    // }

  }, {
    key: "getObjects",
    value: function getObjects() {
      var shapes = this.shapesLow; // const equation = this.equationLow;
      // if (high) {
      //   shapes = this.shapesHigh;
      //   equation = this.equationHigh;
      // }

      return new _FigureCollections_FigureCollections__WEBPACK_IMPORTED_MODULE_12__["default"](shapes, // equation,
      this.isTouchDevice, this.animateNextFrame.bind(this, true, 'collections'));
    }
  }, {
    key: "sizeHtmlText",
    value: function sizeHtmlText() {
      var containerRect = this.container.getBoundingClientRect();
      var size = containerRect.width / 35;
      var test = document.getElementById("".concat(this.htmlId, "_measure"));

      if (test != null) {
        test.style.fontSize = "".concat(size, "px");
        var width = test.clientWidth + 1;
        var ratio = width / containerRect.width;

        if (containerRect.width < 500) {
          size = Math.floor(0.84 / ratio * size * 10000) / 10000;
        } else {
          size = Math.floor(0.85 / ratio * size * 10000) / 10000;
        }
      }

      this.htmlCanvas.style.fontSize = "".concat(size, "px");
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.gesture.destroy();
      this.webglLow.gl.getExtension('WEBGL_lose_context').loseContext(); // this.webglHigh.gl.getExtension('WEBGL_lose_context').loseContext();
    }
  }, {
    key: "setSpaceTransforms",
    value: function setSpaceTransforms() {
      var glSpace = {
        x: {
          bottomLeft: -1,
          width: 2
        },
        y: {
          bottomLeft: -1,
          height: 2
        }
      };
      var figureSpace = {
        x: {
          bottomLeft: this.limits.left,
          width: this.limits.width
        },
        y: {
          bottomLeft: this.limits.bottom,
          height: this.limits.height
        }
      }; // console.log(this.canvasLow)

      var canvasRect = this.canvasLow.getBoundingClientRect();
      var pixelSpace = {
        x: {
          bottomLeft: 0,
          width: canvasRect.width
        },
        y: {
          bottomLeft: canvasRect.height,
          height: -canvasRect.height
        }
      };
      var percentSpace = {
        x: {
          bottomLeft: 0,
          width: 1
        },
        y: {
          bottomLeft: 1,
          height: -1
        }
      };
      this.spaceTransforms = {
        figureToGL: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(figureSpace, glSpace, 'Figure'),
        glToFigure: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(glSpace, figureSpace),
        pixelToFigure: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(pixelSpace, figureSpace),
        figureToPixel: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(figureSpace, pixelSpace),
        pixelToGL: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(pixelSpace, glSpace),
        glToPixel: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(glSpace, pixelSpace),
        figureToCSSPercent: Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["spaceToSpaceTransform"])(figureSpace, percentSpace)
      };
    } // startRecording() {
    //   this.isRecording = true;
    // }
    // stopRecording() {
    //   this.isRecording = false;
    // }
    // deprecate
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "initialize",
    value: function initialize() {// const elements = this.elements.getAllElements();
      // /* eslint-disable no-param-reassign */
      // elements.forEach((element) => {
      //   element.figure = this;
      //   element.recorder = this.recorder;
      //   element.animationFinishedCallback = this.animationFinished.bind(this, element);
      // });
      // this.elements.setFigure(this);
      // // /* eslint-enable no-param-reassign */
      // this.setFirstTransform();
      // this.animateNextFrame();
      // this.elements.setFigure({
      //   limits: this.limits,
      //   spaceTransforms: this.spaceTransforms,
      //   animateNextFrame: this.animateNextFrame.bind(this),
      //   animationFinished: this.animationFinished.bind(this),
      //   recorder: this.recorder,
      // });
      // this.setFirstTransform();
      // this.animateNextFrame();
    }
  }, {
    key: "initElements",
    value: function initElements() {
      // const elements = this.elements.getAllElements();
      // /* eslint-disable no-param-reassign */
      // elements.forEach((element) => {
      //   element.figure = this;
      //   element.recorder = this.recorder;
      //   element.animationFinishedCallback = this.animationFinished.bind(this, element);
      // });
      // this.elements.setFigure(this);
      // // /* eslint-enable no-param-reassign */
      // this.setFirstTransform();
      // this.animateNextFrame();
      this.elements.setFigure({
        limits: this.limits,
        spaceTransforms: this.spaceTransforms,
        animateNextFrame: this.animateNextFrame.bind(this),
        animationFinished: this.animationFinished.bind(this),
        recorder: this.recorder
      });
      this.setFirstTransform();
      this.animateNextFrame();
    }
  }, {
    key: "setElements",
    value: function setElements(collection) {
      this.elements = collection;
      this.initElements(); // this.elements.setFigure(this);
      // // /* eslint-enable no-param-reassign */
      // this.setFirstTransform();
      // this.animateNextFrame();
    }
    /**
     * Get remaining animation durations of running animations
     */

  }, {
    key: "getRemainingAnimationTime",
    value: function getRemainingAnimationTime() {
      var nowIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.globalAnimation.now() / 1000;
      var elements = this.elements.getAllElements();
      var now = nowIn;

      if (this.state.pause === 'paused') {
        now = this.pauseTime;
      }

      var remainingTime = 0;
      elements.forEach(function (element) {
        var elementRemainingTime = element.animations.getRemainingTime([], now);

        if (elementRemainingTime > remainingTime) {
          remainingTime = elementRemainingTime;
        }

        var remainingPulseTime = element.getRemainingPulseTime(now);

        if (remainingPulseTime > remainingTime) {
          remainingTime = remainingPulseTime;
        }

        var remainingMovingFreelyTime = element.getRemainingMovingFreelyTime(now);

        if (remainingMovingFreelyTime > remainingTime) {
          remainingTime = remainingMovingFreelyTime;
        }
      });
      return remainingTime;
    }
  }, {
    key: "setAnimationFinishedCallback",
    value: function setAnimationFinishedCallback(callback) {
      this.animationFinishedCallback = callback;
    }
  }, {
    key: "animationFinished",
    value: function animationFinished() {
      if (this.isAnimating()) {
        return;
      }

      this.fnMap.exec(this.animationFinishedCallback);
      this.subscriptions.publish('animationsFinished');
    }
  }, {
    key: "setFirstTransform",
    value: function setFirstTransform() {
      this.elements.setFirstTransform(this.spaceTransforms.figureToGL);
    }
  }, {
    key: "updateLimits",
    value: function updateLimits(limits) {
      var l = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getRect"])(limits);
      this.limits = l._dup();
      this.setSpaceTransforms();
    } // Renders all tied elements in the first level of figure elements

  }, {
    key: "renderAllElementsToTiedCanvases",
    value: function renderAllElementsToTiedCanvases() {
      var _this4 = this;

      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.canvasOffscreen == null) {
        return;
      }

      var needClear = false;
      Object.keys(this.elements.elements).forEach(function (name) {
        var element = _this4.elements.elements[name];

        if (element.isShown && (element.isRenderedAsImage === false || force) && element.tieToHTML.element != null) {
          element.isRenderedAsImage = true;

          _this4.renderElementToTiedCanvas(name);

          needClear = true;
        }
      });

      if (needClear) {
        this.drawQueued = true;
        this.clearContext();
        this.draw2DLow.ctx.clearRect(0, 0, this.textCanvasLow.width, this.textCanvasLow.height);
        this.draw(-1);
      }
    }
  }, {
    key: "renderElementToTiedCanvas",
    value: function renderElementToTiedCanvas(elementName) {
      var _this5 = this;

      // record visibility of top level elements in figure
      var currentVisibility = {};
      Object.keys(this.elements.elements).forEach(function (name) {
        var element = _this5.elements.elements[name];
        currentVisibility[name] = element.isShown;
      }); // Hide all elements

      Object.keys(this.elements.elements).forEach(function (name) {
        _this5.elements.elements[name].hide();
      }); // Show the element to render

      var elementToRender = this.elements.elements[elementName];
      elementToRender.show(); // Move it to the origin to render

      var oldPosition = elementToRender.getPosition();
      var oldScale = elementToRender.getScale();
      var htmlCanvas = document.getElementById(elementToRender.tieToHTML.element);

      if (htmlCanvas instanceof HTMLElement) {
        this.canvasOffscreen.style.width = "".concat(htmlCanvas.clientWidth, "px");
        this.canvasOffscreen.style.height = "".concat(htmlCanvas.clientHeight, "px");
        this.textCanvasOffscreen.style.width = "".concat(htmlCanvas.clientWidth, "px");
        this.textCanvasOffscreen.style.height = "".concat(htmlCanvas.clientHeight, "px");
        this.webglOffscreen.resize();
        this.draw2DOffscreen.resize();
      }

      elementToRender.updateHTMLElementTie(this.canvasOffscreen); // Need to reset position as updateHTMLElementTie doesn't set correct
      // position as it uses a figure pixels space transform that is only
      // relavant to the first gl canvas.

      var scale = elementToRender.getScale();
      elementToRender.setPosition(0 - scale.x * (elementToRender.tieToHTML.window.left + elementToRender.tieToHTML.window.width / 2), 0 - scale.y * (elementToRender.tieToHTML.window.bottom + elementToRender.tieToHTML.window.height / 2)); // elementToRender.setPosition(0, 0);
      // Stop animations and render

      elementToRender.isRenderedAsImage = false;
      elementToRender.stop('complete');
      this.renderToCanvas(elementToRender.tieToHTML.element);
      elementToRender.isRenderedAsImage = true; // elementToRender.setRenderedOnNextDraw();
      // reset position

      elementToRender.setPosition(oldPosition);
      elementToRender.setScale(oldScale); // show all elements that were shown previously (except element that was just rendered)

      Object.keys(this.elements.elements).forEach(function (name) {
        var element = _this5.elements.elements[name];

        if (currentVisibility[name] === true) {
          element.show();
        } else {
          element.hide();
        }
      });
    } // This method will render the gl and 2d contexts to a canvas

  }, {
    key: "renderToCanvas",
    value: function renderToCanvas() {
      var htmlCanvasElementOrId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var htmlCanvas = htmlCanvasElementOrId;

      if (typeof htmlCanvasElementOrId === 'string') {
        htmlCanvas = document.getElementById(htmlCanvasElementOrId);
      }

      if (!(htmlCanvas instanceof HTMLElement)) {
        return;
      }

      this.drawQueued = true;
      this.draw(-1, 1);
      var w = document.getElementById("".concat(htmlCanvasElementOrId, "_webgl"));

      if (w instanceof HTMLImageElement) {
        w.src = this.webglOffscreen.gl.canvas.toDataURL('image/png', 0.5);
        w.style.display = 'block';
      }

      var d = document.getElementById("".concat(htmlCanvasElementOrId, "_2d"));

      if (d instanceof HTMLImageElement) {
        d.src = this.draw2DOffscreen.canvas.toDataURL('image/png', 0.5);
        d.style.display = 'block';
      }

      this.clearContext(1);
    }
  }, {
    key: "unrenderAll",
    value: function unrenderAll() {
      // console.log('unrender all', Object.keys(this.elements.drawOrder).length)
      for (var i = 0; i < this.elements.drawOrder.length; i += 1) {
        var element = this.elements.elements[this.elements.drawOrder[i]];
        element.unrender();
      }
    } // resize should only be called if the viewport size has changed.

  }, {
    key: "resize",
    value: function resize() {
      var skipHTMLTie = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.webglLow.resize();
      this.draw2DLow.resize();
      this.setSpaceTransforms();

      if (this.elements != null) {
        this.elements.updateLimits(this.limits, this.spaceTransforms);
      }

      this.sizeHtmlText(); // this.elements.resizeHtmlObject();
      // this.updateHTMLElementTie();

      if (skipHTMLTie) {
        this.elements.resize();
      } else {
        this.elements.resize(this.canvasLow);
      }

      if (this.oldWidth !== this.canvasLow.clientWidth) {
        // this.unrenderAll();
        // console.log('updating width')
        this.renderAllElementsToTiedCanvases();
        this.oldWidth = this.canvasLow.clientWidth;
      }

      this.animateNextFrame(true, 'resize');
      this.drawAnimationFrames = 2; // this.renderAllElementsToTiedCanvases(true);
    }
  }, {
    key: "updateHTMLElementTie",
    value: function updateHTMLElementTie() {
      if (this.elements != null) {
        this.elements.updateHTMLElementTie(this.canvasLow);
      }
    } // simulateTouchDown(figurePoint: Point) {
    //   // const pixelPoint = figurePoint.transformBy(this.spaceTransforms.figureToPixel.matrix());
    //   // const clientPoint = this.pixelToClient(pixelPoint);
    //   // this.touchDownHandler(clientPoint);
    //   const pointer = this.getElement(this.cursorElementName);
    //   if (pointer == null) {
    //     return;
    //   }
    //   const up = pointer.getElement('up');
    //   const down = pointer.getElement('down');
    //   if (up == null || down == null) {
    //     return;
    //   }
    //   up.hide();
    //   down.show();
    //   pointer.setPosition(figurePoint);
    // }

    /**
     * Show specific elements within the figure
     */

  }, {
    key: "show",
    value: function show() {
      var toShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.elements.show(toShow);
    }
    /**
     * Show specific elements within a figure, while hiding all others
     */

  }, {
    key: "showOnly",
    value: function showOnly() {
      var toShow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.elements.showOnly(toShow);
    }
    /**
     * Set scenarios of all elements with scenarioName defined
     */

  }, {
    key: "setScenarios",
    value: function setScenarios(scenarioName) {
      var onlyIfVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.elements.setScenarios(scenarioName, onlyIfVisible);
    }
  }, {
    key: "toggleCursor",
    value: function toggleCursor() {
      this.cursorShown = !this.cursorShown;

      if (this.recorder.state === 'recording') {
        if (this.cursorShown) {
          this.recorder.recordEvent('cursor', ['show', this.previousCursorPoint.x, this.previousCursorPoint.y]);

          if (this.isTouchDown) {
            this.showCursor('down');
          } else {
            this.showCursor('up');
          }

          this.setCursor(this.previousCursorPoint);
        } else {
          this.recorder.recordEvent('cursor', ['hide']);
          this.showCursor('hide');
        }
      }
    }
  }, {
    key: "showCursor",
    value: function showCursor(show) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var cursor = this.getElement(this.cursorElementName);

      if (cursor == null) {
        return;
      }

      var up = cursor.getElement('up');
      var down = cursor.getElement('down');

      if (up == null || down == null) {
        return;
      }

      if (show === 'up') {
        up.showAll();
        down.hide();
      } else if (show === 'down') {
        up.hide();
        down.showAll();
      } else {
        cursor.hide();
      }

      if (position != null) {
        this.setCursor(position);
      }

      this.animateNextFrame();
    }
  }, {
    key: "isCursorShown",
    value: function isCursorShown() {
      var cursor = this.getElement(this.cursorElementName);

      if (cursor == null) {
        return false;
      }

      return cursor.isShown;
    } // Handle touch down, or mouse click events within the canvas.
    // The default behavior is to be able to move objects that are touched
    // and dragged, then when they are released, for them to move freely before
    // coming to a stop.

  }, {
    key: "touchDownHandler",
    value: function touchDownHandler(clientPoint) {
      if (this.recorder.state === 'recording') {
        var pixelP = this.clientToPixel(clientPoint);
        var figurePoint = pixelP.transformBy(this.spaceTransforms.pixelToFigure.matrix());
        this.recorder.recordEvent('touch', ['down', figurePoint.x, figurePoint.y]);

        if (this.cursorShown) {
          this.showCursor('down');
        }
      }

      if (this.isPaused) {
        this.unpause();
      }

      if (this.recorder.state === 'playing') {
        this.recorder.pausePlayback();
        this.showCursor('hide');
      }

      if (this.inTransition) {
        return false;
      }

      this.isTouchDown = true; // Get the touched point in clip space

      var pixelPoint = this.clientToPixel(clientPoint); // console.log(pixelPoint)

      var glPoint = pixelPoint.transformBy(this.spaceTransforms.pixelToGL.matrix()); // console.log(glPoint)
      // console.log(glPoint, clientPoint)
      // console.log(glPoint.transformBy(this.glToFigureSpaceTransform.matrix()))
      // const clipPoint = this.clientToClip(clientPoint);
      // Get all the figure elements that were touched at this point (element
      // must have isTouchable = true to be considered)

      this.beingTouchedElements = this.elements.getTouched(glPoint);

      if (this.touchTopElementOnly && this.beingTouchedElements.length > 1) {
        this.beingTouchedElements = [this.beingTouchedElements[0]];
      } // if (this.touchTopElementOnly && this.beingTouchedElements.length > 0) {
      //   // if () {
      //   this.beingTouchedElements[0].click(glPoint);
      //   // }
      // } else {


      this.beingTouchedElements.forEach(function (e) {
        return e.click(glPoint);
      }); // }
      // Make a list of, and start moving elements that are being moved
      // (element must be touched and have isMovable = true to be in list)

      this.beingMovedElements = [];

      for (var i = 0; i < this.beingTouchedElements.length; i += 1) {
        var element = this.beingTouchedElements[i];

        if (element.isMovable) {
          this.beingMovedElements.push(element);
          element.startBeingMoved();
        }
      }

      if (this.beingMovedElements.length > 0) {
        this.animateNextFrame(true, 'touch down handler');
      }

      if (this.beingTouchedElements.length > 0) {
        return true;
      }

      return false;
    } // simulateTouchUp() {
    //   // this.touchUpHandler();
    //   const pointer = this.getElement(this.cursorElementName);
    //   if (pointer == null) {
    //     return;
    //   }
    //   const up = pointer.getElement('up');
    //   const down = pointer.getElement('down');
    //   if (up == null || down == null) {
    //     return;
    //   }
    //   up.show();
    //   down.hide();
    // }
    // Handle touch up, or mouse click up events in the canvas. When an UP even
    // happens, the default behavior is to let any elements being moved to move
    // freely until they decelerate to 0.

  }, {
    key: "touchUpHandler",
    value: function touchUpHandler() {
      // console.log(this.beingMovedElements)
      if (this.recorder.state === 'recording') {
        this.recorder.recordEvent('touch', ['up']);

        if (this.cursorShown) {
          this.showCursor('up');
        }
      } // console.log("before", this.elements._circle.transform.t())
      // console.log(this.beingMovedElements)


      for (var i = 0; i < this.beingMovedElements.length; i += 1) {
        var element = this.beingMovedElements[i];

        if (element.state.isBeingMoved) {
          element.stopBeingMoved();
          element.startMovingFreely();
        }
      }

      this.isTouchDown = false;
      this.beingMovedElements = [];
      this.beingTouchedElements = []; // console.log("after", this.elements._circle.transform.t())
    } // simulateCursorMove(figurePoint: Point) {
    //   const pointer = this.getElement(this.cursorElementName);
    //   if (pointer == null) {
    //     return;
    //   }
    //   pointer.setPosition(figurePoint);
    // }

  }, {
    key: "setCursor",
    value: function setCursor(p) {
      var pointer = this.getElement(this.cursorElementName);

      if (pointer == null) {
        return;
      }

      pointer.setPosition(p); // console.log(p, pointer.isShown, pointer._up.isShown, pointer);

      this.animateNextFrame();
    }
  }, {
    key: "touchFreeHandler",
    value: function touchFreeHandler(clientPoint) {
      if (this.recorder.state === 'recording') {
        var pixelP = this.clientToPixel(clientPoint);
        var figurePoint = pixelP.transformBy(this.spaceTransforms.pixelToFigure.matrix());
        this.previousCursorPoint = figurePoint;

        if (this.cursorShown) {
          this.recorder.recordEvent('cursorMove', [figurePoint.x, figurePoint.y]);
          this.setCursor(figurePoint);
        }
      }
    }
  }, {
    key: "rotateElement",
    value: function rotateElement(element, previousClientPoint, currentClientPoint) {
      var centerFigureSpace = element.getPosition('figure');

      if (centerFigureSpace == null) {
        centerFigureSpace = new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](0, 0);
      }

      var center = centerFigureSpace.transformBy(this.spaceTransforms.figureToPixel.matrix());
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint); // const previousFigurePoint =
      //   previousPixelPoint.transformBy(this.pixelToFigureSpaceTransform.matrix());
      // const currentFigurePoint =
      //   currentPixelPoint.transformBy(this.pixelToFigureSpaceTransform.matrix());
      // const currentAngle = Math.atan2(
      //   currentFigurePoint.y - center.y,
      //   currentFigurePoint.x - center.x,
      // );
      // const previousAngle = Math.atan2(
      //   previousFigurePoint.y - center.y,
      //   previousFigurePoint.x - center.x,
      // );

      var currentAngle = Math.atan2(currentPixelPoint.y - center.y, currentPixelPoint.x - center.x);
      var previousAngle = Math.atan2(previousPixelPoint.y - center.y, previousPixelPoint.x - center.x);
      var diffAngle = -Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["minAngleDiff"])(previousAngle, currentAngle);

      var transform = element.transform._dup();

      var rot = transform.r();

      if (rot == null) {
        rot = 0;
      }

      var newAngle = rot - diffAngle; // if (newAngle < 0) {
      //   newAngle += 2 * Math.PI;
      // }
      // if (newAngle > 2 * Math.PI) {
      //   newAngle -= 2 * Math.PI;
      // }

      transform.updateRotation(newAngle);
      element.moved(transform._dup());
    }
  }, {
    key: "translateElement",
    value: function translateElement(element, previousClientPoint, currentClientPoint) {
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint);
      var previousFigurePoint = previousPixelPoint.transformBy(this.spaceTransforms.pixelToFigure.matrix());
      var currentFigurePoint = currentPixelPoint.transformBy(this.spaceTransforms.pixelToFigure.matrix());
      var m = element.spaceTransformMatrix('figure', 'local');
      var currentVertexSpacePoint = currentFigurePoint.transformBy(m);
      var previousVertexSpacePoint = previousFigurePoint.transformBy(m); // const delta = currentFigurePoint.sub(previousFigurePoint);

      var elementSpaceDelta = currentVertexSpacePoint.sub(previousVertexSpacePoint); // console.log(delta, elementSpaceDelta)

      var currentTransform = element.transform._dup();

      var currentTranslation = currentTransform.t();

      if (currentTranslation != null) {
        var newTranslation = currentTranslation.add(elementSpaceDelta);
        currentTransform.updateTranslation(newTranslation);
        element.moved(currentTransform);
      }
    }
  }, {
    key: "scaleElement",
    value: function scaleElement(element, previousClientPoint, currentClientPoint) {
      var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var previousPixelPoint = this.clientToPixel(previousClientPoint);
      var currentPixelPoint = this.clientToPixel(currentClientPoint); // const previousFigurePoint =
      //   previousPixelPoint.transformBy(this.pixelToFigureSpaceTransform.matrix());
      // const currentFigurePoint =
      //   currentPixelPoint.transformBy(this.pixelToFigureSpaceTransform.matrix());
      // const previousMag = previousFigurePoint.sub(center).distance();
      // const currentMag = currentFigurePoint.sub(center).distance();

      var center = element.getPosition('figure').transformBy(this.spaceTransforms.figureToPixel.matrix());
      var previousMag = previousPixelPoint.sub(center).distance();
      var currentMag = currentPixelPoint.sub(center).distance();
      var currentScale = element.transform.s();

      if (currentScale != null) {
        var currentTransform = element.transform._dup();

        var newScaleX = currentScale.x * currentMag / previousMag;
        var newScaleY = currentScale.y * currentMag / previousMag;

        if (type === 'x') {
          currentTransform.updateScale(newScaleX, 1);
        } else if (type === 'y') {
          currentTransform.updateScale(1, newScaleY);
        } else {
          currentTransform.updateScale(newScaleX, newScaleY);
        }

        element.moved(currentTransform);
      }
    }
  }, {
    key: "getIsInTransition",
    value: function getIsInTransition() {
      return this.inTransition;
    } // simulateTouchMove(
    //   previousFigurePoint: Point,
    //   currentFigurePoint: Point,
    //   pointerElement: string = 'pointer',
    // ) {
    //   // const previousPixelPoint = previousFigurePoint
    //   //   .transformBy(this.spaceTransforms.figureToPixel.matrix());
    //   // const previousClientPoint = this.pixelToClient(previousPixelPoint);
    //   // const currentPixelPoint = currentFigurePoint
    //   //   .transformBy(this.spaceTransforms.figureToPixel.matrix());
    //   // const currentClientPoint = this.pixelToClient(currentPixelPoint);
    //   // this.touchMoveHandler(previousClientPoint, currentClientPoint);
    //   const pointer = this.getElement(pointerElement);
    //   if (pointer == null) {
    //     return;
    //   }
    //   pointer.setPosition(currentFigurePoint);
    // }
    // Handle touch/mouse move events in the canvas. These events will only be
    // sent if the initial touch down happened in the canvas.
    // The default behavior is to drag (move) any objects that were touched in
    // the down event to the new location.
    // This function should return true if the move event should NOT be processed
    // by the system. For example, on a touch device, a touch and drag would
    // normally scroll the screen. Typically, you would want to move the figure
    // element and not the screen, so a true would be returned.

  }, {
    key: "touchMoveHandler",
    value: function touchMoveHandler(previousClientPoint, currentClientPoint) {
      if (this.recorder.state === 'recording') {
        var currentPixelPoint = this.clientToPixel(currentClientPoint);
        var figurePoint = currentPixelPoint.transformBy(this.spaceTransforms.pixelToFigure.matrix());
        this.recorder.recordEvent('cursorMove', [figurePoint.x, figurePoint.y]);

        if (this.cursorShown) {
          this.setCursor(figurePoint);
        }
      }

      if (this.inTransition) {
        return false;
      }

      if (this.beingMovedElements.length === 0) {
        return false;
      }

      var previousPixelPoint = this.clientToPixel(previousClientPoint); // const currentPixelPoint = this.clientToPixel(currentClientPoint);

      var previousGLPoint = previousPixelPoint.transformBy(this.spaceTransforms.pixelToGL.matrix()); // Go through each element being moved, get the current translation

      for (var i = 0; i < this.beingMovedElements.length; i += 1) {
        var element = this.beingMovedElements[i];

        if (element !== this.elements) {
          if (element.isBeingTouched(previousGLPoint) || element.move.canBeMovedAfterLosingTouch) {
            var elementToMove = element.move.element == null ? element : element.move.element;

            if (elementToMove.state.isBeingMoved === false) {
              elementToMove.startBeingMoved();
            }

            if (this.beingMovedElements.indexOf(elementToMove) === -1) {
              this.beingMovedElements.push(elementToMove);
            }

            if (element.move.type === 'rotation') {
              this.rotateElement(elementToMove, previousClientPoint, currentClientPoint);
            } else if (element.move.type === 'scale') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint);
            } else if (element.move.type === 'scaleX') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint, 'x');
            } else if (element.move.type === 'scaleY') {
              this.scaleElement(elementToMove, previousClientPoint, currentClientPoint, 'y');
            } else {
              this.translateElement(elementToMove, previousClientPoint, currentClientPoint);
            }
          }
        }

        if (this.touchTopElementOnly) {
          i = this.beingMovedElements.length;
        }
      }

      this.animateNextFrame(true, 'touch move handler');
      return true;
    }
    /**
     * Stop all animations, movement and pulses in figure.
     */

  }, {
    key: "stop",
    value: function stop() {
      var _this6 = this;

      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cancel';

      var stopped = function stopped() {
        _this6.subscriptions.publish('stopped');

        _this6.state.preparingToStop = false;
      };

      if (!this.elements.isAnimating()) {
        stopped();
        return;
      }

      if (how === 'freeze' || how === 'cancel' || how === 'complete') {
        this.elements.stop(how);
        stopped();
        return;
      }

      this.state.preparingToStop = false;

      if (how === 'animateToComplete') {
        this.elements.stop(how);
        var elements = this.elements.getAllElements();
        var preparingToStopCounter = 0;

        var checkAllStopped = function checkAllStopped() {
          if (preparingToStopCounter > 0) {
            preparingToStopCounter -= 1;
          }

          if (preparingToStopCounter === 0) {
            stopped();
          }
        };

        elements.forEach(function (element) {
          if (element.state.preparingToStop) {
            preparingToStopCounter += 1;
            element.subscriptions.add('stopped', checkAllStopped, 1);
          }
        });

        if (preparingToStopCounter === 0) {
          checkAllStopped();
        } else if (preparingToStopCounter > 0) {
          this.subscriptions.publish('preparingToStop');
          this.state.preparingToStop = true;
        }

        return;
      } // console.log('asdf')
      // Otherwise we are dissolving to complete


      var state = this.getState({});
      this.elements.stop('complete');
      var completeState = this.getState({});
      this.setState(state);
      this.elements.stop('freeze');
      this.setState(completeState, 'dissolve');

      if (this.state.preparingToSetState) {
        this.subscriptions.add('stateSet', stopped, 1);
        this.subscriptions.publish('preparingToStop');
        this.state.preparingToStop = true;
      } else {
        stopped();
      }
    } // To add elements to a figure, either this method can be overridden,
    // or the `add` method can be used.

  }, {
    key: "createFigureElements",
    value: function createFigureElements() {
      // this.elements = new FigureElementCollection();
      this.elements = this.collections.collection();
      this.initElements(); // this.elements.setFigure({
      //   limits: this.limits,
      //   spaceTransforms: this.spaceTransforms,
      //   animateNextFrame: this.animateNextFrame,
      //   animationFinished: this.animationFinished.bind(this),
      // });
      // this.setFirstTransform();
      // this.animateNextFrame();
      // this.elements.figureLimits = this.limits;
    }
  }, {
    key: "setElementsToCollection",
    value: function setElementsToCollection(collection) {
      this.elements = collection; // this.elements.setDigram(this);
      // this.setFirstTransform();

      this.initElements();
    }
  }, {
    key: "clearContext",
    value: function clearContext() {
      var canvasIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (canvasIndex === 0) {
        this.webglLow.gl.clearColor(0, 0, 0, 0);
        this.webglLow.gl.clear(this.webglLow.gl.COLOR_BUFFER_BIT);
      } else {
        this.webglOffscreen.gl.clearColor(0, 0, 0, 0);
        this.webglOffscreen.gl.clear(this.webglLow.gl.COLOR_BUFFER_BIT);
      } // this.webglHigh.gl.clearColor(0, 0, 0, 0);
      // this.webglHigh.gl.clear(this.webglHigh.gl.COLOR_BUFFER_BIT);


      this.elements.clear(canvasIndex);
    } // scroll() {
    //   if (this.scrollingFast === false) {
    //     this.webglLow.gl.canvas.style.top = '-10000px';
    //     this.renderAllElementsToTiedCanvases();
    //     this.scrollingFast = true;
    //     if (this.scrollTimeoutId) {
    //       clearTimeout(this.scrollTimeoutId);
    //       this.scrollTimeoutId = null;
    //     }
    //     this.scrollTimeoutId = setTimeout(this.centerDrawingLens.bind(this, true), 100);
    //   }
    // }

  }, {
    key: "drawNow",
    value: function drawNow() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      this.drawQueued = true;
      this.draw(time);
    } // getPaused() {
    //   return this.elements.getPaused();
    // }
    // getPauseState() {
    //   return this.state.pause;
    // }

  }, {
    key: "pause",
    value: function pause() {
      if (this.state.pause === 'pause' || this.state.pause === 'preparingToPause' || this.state.pause === 'preparingToUnpause') {
        return;
      }

      this.state.pause = 'paused';
      this.pauseTime = this.globalAnimation.now() / 1000;
    } // pauseLegacy(pauseSettings: TypePauseSettings = { simplePause: true }) {
    //   // forcePause: boolean = true, clearAnimations: boolean = false) {
    //   this.elements.pause(pauseSettings);
    //   if (pauseSettings.simplePause != null && pauseSettings.simplePause) {
    //     this.state.pause = 'paused';
    //     this.pauseTime = this.globalAnimation.now() / 1000;
    //     return;
    //   }
    //   const elements = this.elements.getAllElements();
    //   let preparingToPauseCounter = 0;
    //   const checkAllPaused = () => {
    //     if (preparingToPauseCounter > 0) {
    //       preparingToPauseCounter -= 1;
    //     }
    //     if (preparingToPauseCounter === 0) {
    //       this.state.pause = 'paused';
    //       this.isPaused = true;
    //       this.subscriptions.publish('paused');
    //     }
    //   }
    //   elements.forEach((element) => {
    //     if (element.state.pause === 'preparingToPause') {
    //       preparingToPauseCounter += 1;
    //       element.subscriptions.add('paused', checkAllPaused, 1);
    //     }
    //   });
    //   this.pauseTime = this.globalAnimation.now() / 1000;
    //   if (preparingToPauseCounter === 0 && this.state.pause !== 'paused') {
    //     checkAllPaused();
    //   } else if (preparingToPauseCounter > 0) {
    //     this.state.pause = 'preparingToPause';
    //     this.subscriptions.publish('preparingToPause');
    //   }
    // }
    // pauseAfterNextDraw() {
    //   this.pauseAfterNextDrawFlag = true;
    // }

  }, {
    key: "unpause",
    value: function unpause() {
      if (this.state.pause === 'unpaused' || this.state.pause === 'preparingToPause' || this.state.pause === 'preparingToUnpause') {
        return;
      }

      this.state.pause = 'unpaused';
      this.isPaused = false;
      this.elements.setTimeDelta(this.globalAnimation.now() / 1000 - this.pauseTime);
      this.animateNextFrame();
      this.subscriptions.publish('unpaused');
    }
  }, {
    key: "touchDown",
    value: function touchDown(figurePosition) {
      var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(figurePosition);
      var pixelPoint = p.transformBy(this.spaceTransforms.figureToPixel.m());
      var clientPoint = this.pixelToClient(pixelPoint);
      this.touchDownHandler(clientPoint);
      this.mockPreviousTouchPoint = clientPoint; // $FlowFixMe

      if (this.elements.elements[this.cursorElementName] != null) {
        this.showCursor('down', p); // cursor.setPosition(p);
      }
    }
  }, {
    key: "touchUp",
    value: function touchUp() {
      this.touchUpHandler(); // $FlowFixMe

      if (this.elements.elements[this.cursorElementName] != null) {
        this.showCursor('up'); // cursor.setPosition(p);
      }
    }
  }, {
    key: "touchMove",
    value: function touchMove(figurePosition) {
      var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(figurePosition);
      var pixelPoint = p.transformBy(this.spaceTransforms.figureToPixel.m());
      var clientPoint = this.pixelToClient(pixelPoint);
      this.touchMoveHandler(this.mockPreviousTouchPoint, clientPoint);
      this.mockPreviousTouchPoint = clientPoint; // $FlowFixMe

      if (this.elements.elements[this.cursorElementName] != null) {
        this.showCursor('down', p); // cursor.setPosition(p);
      }
    } // unpauseLegacy() {
    //   this.elements.unpause();
    //   const elements = this.elements.getAllElements();
    //   let preparingToUnpauseCounter = 0;
    //   const checkAllUnpaused = () => {
    //     if (preparingToUnpauseCounter > 0) {
    //       preparingToUnpauseCounter -= 1;
    //     }
    //     if (preparingToUnpauseCounter === 0) {
    //       this.state.pause = 'unpaused';
    //       this.isPaused = false;
    //       this.elements.setTimeDelta(this.globalAnimation.now() / 1000 - this.pauseTime);
    //       this.animateNextFrame();
    //       this.subscriptions.publish('unpaused');
    //     }
    //   };
    //   elements.forEach((element) => {
    //     if (element.state.pause === 'preparingToUnpause') {
    //       preparingToUnpauseCounter += 1;
    //       element.subscriptions.add('unpaused', checkAllUnpaused, 1)
    //     }
    //   });
    //   if (preparingToUnpauseCounter === 0 && this.state.pause !== 'unpaused') {
    //     checkAllUnpaused();
    //   } else if (preparingToUnpauseCounter > 0) {
    //     this.state.pause = 'preparingToUnpause';
    //     this.subscriptions.publish('preparingToUnpause');
    //   }
    //   // // this.state.pause = this.elements.getPause();
    //   // this.pauseTime = performance.now() / 1000;
    //   // this.elements.unpause();
    //   // this.isPaused = false;
    //   // this.elements.setTimeDelta(performance.now() / 1000 - this.pauseTime);
    //   this.animateNextFrame();
    // }

  }, {
    key: "draw",
    value: function draw(nowIn) {
      var canvasIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // const start = new Date().getTime();
      var t = performance.now(); // if ((nowIn - this.lastDrawTime ) * 1000 > 40) {
      //   console.log((nowIn - this.lastDrawTime) * 1000)
      // }

      window.timeData = [];

      if (this.state.pause === 'paused') {
        return;
      }

      var now = nowIn;

      if (nowIn === -1) {
        now = this.lastDrawTime;
      }

      this.lastDrawTime = now;

      if (this.scrolled === true) {
        this.scrolled = false;

        if (Math.abs(window.pageYOffset - this.oldScroll) > this.webglLow.gl.canvas.clientHeight / 4) {
          this.renderAllElementsToTiedCanvases(); // }

          this.scrollingFast = true;

          if (this.scrollTimeoutId) {
            clearTimeout(this.scrollTimeoutId);
            this.scrollTimeoutId = null;
          }

          this.scrollTimeoutId = setTimeout(this.centerDrawingLens.bind(this, true), 100);
        }
      } // If only a scroll event called draw, then quit before drawing


      if (this.drawQueued === false) {
        return;
      }

      this.drawQueued = false;
      this.clearContext(canvasIndex); // console.log('really drawing')
      // const startSetup = new Date().getTime();

      this.subscriptions.publish('beforeDraw');
      this.elements.setupDraw(now, canvasIndex);
      var t2 = performance.now(); // const endSetup = new Date().getTime();
      // const startDraw = endSetup;

      this.elements.draw(now, [this.spaceTransforms.figureToGL], 1, canvasIndex); // const endDraw = new Date().getTime();

      var t3 = performance.now();

      if (this.elements.isAnyElementMoving()) {
        this.animateNextFrame(true, 'is moving');
      }

      if (this.drawAnimationFrames > 0) {
        this.drawAnimationFrames -= 1;
        this.animateNextFrame(true, 'queued frames');
      }

      this.subscriptions.publish('afterDraw'); // const t3 = performance.now();
      // console.log('Summary', round(t2 - t, 0), round(t3 - t2, 0), round(t - this.lastTime1, 0));
      // this.lastTime1 = t;
      // const end = new Date().getTime();
      // const total = end - start;
      // const setup = endSetup - startSetup;
      // const draw = endDraw - startDraw;
      // console.log(total, setup, draw, total - setup - draw);

      console.log(performance.now() - t, t2 - t, t3 - t2);
      console.log(window.timeData); // console.log(perfr)
    } // renderToImages() {
    //   // console.log('visibility1')
    //   this.drawTimeoutId = null;
    //   // if (this.webglLow.gl.canvas.style.top !== '-10000px') {
    //   //   this.webglLow.gl.canvas.style.top = '-10000px';
    //   //   this.waitForFrames = 1;
    //   // }
    //   this.renderAllElementsToTiedCanvases();
    //   // this.centerDrawingLens();
    //   // this.webglLow.gl.canvas.style.visibility = 'visible';
    // }

  }, {
    key: "centerDrawingLens",
    value: function centerDrawingLens() {
      var fromTimeOut = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (fromTimeOut) {
        this.scrollingFast = false;
      }

      var viewPortHeight = window.innerHeight || 0;

      if (document.documentElement != null) {
        viewPortHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      }

      var newTop = window.pageYOffset + viewPortHeight / 2 - this.webglLow.gl.canvas.clientHeight / 2;

      if (newTop < 0) {
        newTop = 0;
      }

      var newTopInPx = "".concat(newTop, "px");

      if (this.webglLow.gl.canvas.style.top !== newTopInPx) {
        this.webglLow.gl.canvas.style.top = "".concat(newTop, "px");
        this.draw2DLow.canvas.style.top = "".concat(newTop, "px");
        this.updateHTMLElementTie();
      }

      this.oldScroll = window.pageYOffset;
    }
    /**
     * Force figure to draw on next available animation frame.
     */

  }, {
    key: "animateNextFrame",
    value: function animateNextFrame() {
      var draw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var fromWhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      this.fromWhere = fromWhere;

      if (!this.drawQueued) {
        if (draw) {
          this.drawQueued = true;
        }

        this.globalAnimation.queueNextFrame(this.draw.bind(this));
      }
    } // animateNextFrameContinuous(method: () => void) {
    //   this.globalAnimation.queueNextFrame((now) => {
    //     const t = performance.now();
    //     const lastTime = t - this.lastTime
    //     this.lastTime = t;
    //     method(now);
    //     this.draw(now);
    //     console.log(round(lastTime, 1), round(performance.now() - t, 1));
    //     this.animateNextFrameContinuous(method);
    //   });
    // }

  }, {
    key: "isAnimating",
    value: function isAnimating() {
      // console.log('asdf')
      return this.elements.isAnimating();
    }
  }, {
    key: "clientToPixel",
    value: function clientToPixel(clientLocation) {
      var canvas = this.canvasLow.getBoundingClientRect();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](clientLocation.x - canvas.left, clientLocation.y - canvas.top);
    }
  }, {
    key: "pixelToClient",
    value: function pixelToClient(pixelLocation) {
      var canvas = this.canvasLow.getBoundingClientRect();
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"](pixelLocation.x + canvas.left, pixelLocation.y + canvas.top);
    }
  }, {
    key: "debugShowTouchBorders",
    value: function debugShowTouchBorders(elements) {
      var _this7 = this;

      var lineOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var elems = this.elements.getElements(elements);
      elems.forEach(function (element, index) {
        var touchBorder = element.getBorder('figure', 'touchBorder');

        var polyline = _this7.primitives.polyline(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_5__["joinObjects"])({}, lineOptions, {
          points: touchBorder[0],
          close: true
        }));

        _this7.add("__touchBorder_".concat(index + startIndex), polyline);
      });
    }
  }]);

  return Figure;
}();

/* harmony default export */ __webpack_exports__["default"] = (Figure);

/***/ }),

/***/ "./src/js/figure/FigureCollections/Angle.js":
/*!**************************************************!*\
  !*** ./src/js/figure/FigureCollections/Angle.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/figure/FigureCollections/EquationLabel.js");
/* harmony import */ var _Equation_Equation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Equation/Equation */ "./src/js/figure/Equation/Equation.js");
/* harmony import */ var _geometries_arrow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geometries/arrow */ "./src/js/figure/geometries/arrow.js");
/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Animation/Animation */ "./src/js/figure/Animation/Animation.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import Figure from '../Figure';









// Angle is a class that manages:
//   A angle curve
//   Label
//   Arrows
//   Straight Lines
//
// The angle collection comprises:
//   * Positioned at 0, 0 in vertex space
//   * Curve from 0 to angle size (where 0 is along x axis in vertex space)
//   * Label in center of curve
//   * Arrows at ends of curve
//   * Straight lines forming the corner
//
// To give the angle a custom position and rotation from 0, the main class's
// transform is used:
//   - Translation for position
//   - Rotation for rotation
//
// An angle can be defined in two ways:
//   - Angle, rotation, position
//   - p1, p2, p3
var AngleLabel = /*#__PURE__*/function (_EquationLabel) {
  _inherits(AngleLabel, _EquationLabel);

  var _super = _createSuper(AngleLabel);

  function AngleLabel(equation, labelText, color, radius) {
    var _this;

    var curvePosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
    var offset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    var showRealAngle = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var units = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'degrees';
    var precision = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var autoHide = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
    var autoHideMax = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;
    var orientation = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 'horizontal';
    var location = arguments.length > 12 ? arguments[12] : undefined;
    var subLocation = arguments.length > 13 ? arguments[13] : undefined;
    var scale = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0.7;

    _classCallCheck(this, AngleLabel);

    _this = _super.call(this, equation, {
      label: labelText,
      color: color,
      scale: scale
    });
    _this.radius = radius;
    _this.curvePosition = curvePosition;
    _this.offset = offset;
    _this.showRealAngle = showRealAngle;
    _this.units = units;
    _this.orientation = orientation;
    _this.precision = precision;
    _this.autoHide = autoHide;
    _this.autoHideMax = autoHideMax;
    _this.location = location;
    _this.subLocation = subLocation;
    return _this;
  }

  return AngleLabel;
}(_EquationLabel__WEBPACK_IMPORTED_MODULE_4__["default"]);
/**
 * These properties are the same as the ones with the same names in
 * {@link COL_Angle}.
 * @property {TypeParsablePoint} [position]
 * @property {number} [startAngle]
 * @property {number} [angle]
 * @property {TypeParsablePoint} [p1]
 * @property {TypeParsablePoint} [p2]
 * @property {TypeParsablePoint} [p3]
 */


// export type CollectionsAngleAnimationManager =

/*
................###....##....##..######...##.......########
...............##.##...###...##.##....##..##.......##......
..............##...##..####..##.##........##.......##......
.............##.....##.##.##.##.##...####.##.......######..
.............#########.##..####.##....##..##.......##......
.............##.....##.##...###.##....##..##.......##......
.............##.....##.##....##..######...########.########
*/

/**
 * {@link FigureElementCollection} representing an angle.
 *
 * ![](./apiassets/advangle_examples.png)
 *
 * <p class="inline_gif"><img src="./apiassets/advangle_grow.gif" class="inline_gif_image"></p>
 *
 * <p class="inline_gif"><img src="./apiassets/advangle_move.gif" class="inline_gif_image"></p>
 *
 * This object defines a convient and powerful angle
 * {@link FigureElementCollection} that includes one or more curve annotations,
 * arrows, a label annotation that can self align and
 * some methods to make it convient to use dynamically.
 *
 * See {@link COL_Angle} for the options that can be used when creating the
 * angle.
 *
 * The object contains two additional animation steps `angle` and `pulseAngle`
 * that animate a change in angle, and animate a pulsing of the angle
 * respectively. The animation steps are available in
 * the animation manager ({@link FigureElement}.animations),
 * and in the animation builder
 * (<a href="#animationmanagernew">animations.new</a>
 * and <a href="#animationmanagerbuilder">animations.builder</a>).
 *
 * Some of the useful methods included in an collections angle are:
 * - <a href="#collectionsanglepulseangle">pulseAngle</a> - customize pulsing the
 *   angle without
 * - <a href="#collectionsanglesetmovable">setMovable</a> - overrides
 *    <a href="#figureelementsetmovable">FigureElement.setMovable</a> and
 *    allowing for more complex move options.
 *
 *
 * @see See {@link OBJ_AngleAnimationStep} for angle animation step options.
 *
 * See {@link OBJ_PulseAngleAnimationStep} for pulse angle animation step
 * options.
 *
 * To test examples below, append them to the
 * <a href="#drawing-boilerplate">boilerplate</a>.
 *
 * @example
 * // Angle with size label
 * figure.add({
 *   name: 'a',
 *   method: 'collections.angle',
 *   options: {
 *     angle: Math.PI / 4,
 *     label: null,
 *     curve: {
 *       radius: 0.5,
 *       width: 0.01,
 *     },
 *     corner: {
 *       width: 0.01,
 *       length: 1,
 *     },
 *   }
 * });
 *
 * @example
 * // Right angle, created from figure.collections
 * const a = figure.collections.angle({
 *   angle: Math.PI / 2,
 *   curve: {
 *     autoRightAngle: true,
 *     width: 0.01,
 *   },
 *   corner: {
 *     width: 0.01,
 *     length: 1,
 *   },
 * });
 * figure.add('a', a);
 *
 * @example
 * // Multi colored angle with arrows and an equation label
 * figure.add({
 *   name: 'a',
 *   method: 'collections.angle',
 *   options: {
 *     angle: Math.PI / 4 * 3,
 *     label: {
 *       text: {
 *         elements: {
 *           theta: { text: '\u03b8', color: [1, 0, 1, 1] },
 *         },
 *         forms: {
 *           0: { frac: ['theta', 'vinculum', '2']},
 *         },
 *       },
 *       offset: 0.05,
 *       location: 'inside',
 *       color: [0, 0, 1, 1],
 *     },
 *     curve: {
 *       radius: 0.5,
 *       width: 0.01,
 *     },
 *     arrow: 'barb',
 *     corner: {
 *       width: 0.01,
 *       length: 1,
 *       color: [0, 0.5, 0, 1],
 *     },
 *   }
 * });
 *
 * @example
 * // Multiple curve angle, without corner
 * const a = figure.collections.angle({
 *   angle: Math.PI / 4,
 *   curve: {
 *     num: 3,
 *     step: -0.03,
 *     radius: 0.5,
 *     width: 0.01,
 *   },
 *   label: {
 *     text: 'a',
 *     offset: 0.05,
 *   },
 * });
 * figure.add('a', a);
 *
 * @example
 * // Change angle animation
 * figure.add({
 *   name: 'a',
 *   method: 'collections.angle',
 *   options: {
 *     angle: Math.PI / 4,
 *     label: null,
 *     curve: {
 *       radius: 0.5,
 *       width: 0.01,
 *     },
 *     corner: {
 *       width: 0.01,
 *       length: 1,
 *     },
 *   }
 * });
 * figure.elements._a.animations.new()
 *   .angle({ start: Math.PI / 4, target: Math.PI / 4 * 3, duration: 3 })
 *   .start();
 *
 * @example
 * // Movable angle
 * figure.add({
 *   name: 'a',
 *   method: 'collections.angle',
 *   options: {
 *     angle: Math.PI / 4 * 3,
 *     label: {
 *       text: null,
 *       location: 'outside',
 *       orientation: 'horizontal',
 *       offset: 0.1,
 *       update: true,
 *       sides: 200,
 *     },
 *     curve: {
 *       radius: 0.3,
 *       fill: true,
 *     },
 *     corner: {
 *       width: 0.02,
 *       length: 1,
 *       color: [0.4, 0.4, 0.4, 1],
 *     },
 *   }
 * });
 * figure.elements._a.setMovable({
 *   startArm: 'rotation',
 *   endArm: 'angle',
 *   movePadRadius: 0.3,
 * });
 */
// $FlowFixMe
var CollectionsAngle = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsAngle, _FigureElementCollect);

  var _super2 = _createSuper(CollectionsAngle);

  _createClass(CollectionsAngle, [{
    key: "calculateAngleRotationPosition",
    // Figure elements
    // autoRightAngle: boolean;
    // rightAngleRange: number;
    // angle properties - pulic read/write
    // angle properties - private internal use only
    // equation: Object;
    value: function calculateAngleRotationPosition(options) {
      // console.log(this.lastLabelRotationOffset)
      var defaultOptions = {
        angle: 1,
        startAngle: this.startAngle
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, options);
      var angle = o.angle,
          startAngle = o.startAngle,
          position = o.position;

      if (position != null) {
        position = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(position);
      }

      if (o.p1 != null && o.p2 != null && o.p3 != null) {
        var p1 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.p1);
        var p2 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.p2);
        var p3 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.p3);
        position = p2._dup();
        var line21 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p2, p1);
        startAngle = line21.angle();
        angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngle"])(p1, p2, p3);
      } // this.startAngle = startAngle;


      this.nextStartAngle = startAngle;

      if (position != null) {
        this.nextPosition = position;
      }

      this.angle = angle; // this.startAngle = startAngle;
    }
    /**
     * @hideconstructor
     */

  }]);

  function CollectionsAngle(collections, isTouchDevice, animateNextFrame) {
    var _this2;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, CollectionsAngle);

    var defaultOptions = {
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      color: collections.primitives.defaultColor,
      direction: 1,
      curve: null,
      corner: null,
      sides: null,
      sideStart: null,
      sideStop: null,
      pulseAngle: {
        curve: 1.5,
        label: 1.5,
        arrow: 1.5,
        side: 1.5,
        corner: 1.5,
        thick: 1
      },
      mods: {},
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Angle').scale(1, 1).rotate(0).translate(0, 0),
      limits: collections.primitives.limits
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, options);
    _this2 = _super2.call(this, optionsToUse);

    _this2.setColor(optionsToUse.color);

    _this2.collections = collections;
    _this2.largerTouchBorder = optionsToUse.largerTouchBorder;
    _this2.isTouchDevice = isTouchDevice;
    _this2.autoUpdateSubscriptionId = 0;
    _this2.lastLabelRotationOffset = 0;

    if (optionsToUse.direction === 'positive') {
      _this2.direction = 1;
    } else if (optionsToUse.direction === 'negative') {
      _this2.direction = -1;
    } else {
      _this2.direction = optionsToUse.direction;
    }

    _this2.calculateAngleRotationPosition(optionsToUse);

    _this2.setNextPositionAndRotation(); // Setup default values for sides, arrows, curve and label


    _this2.side1 = null;
    _this2.side2 = null;
    _this2.curve = null;
    _this2.label = null; // If the curve is to be shown (and not just a label) then make it

    _this2._curve = null;

    if (optionsToUse.curve) {
      _this2.addCurve(optionsToUse.curve);
    } // Arrow related properties


    _this2._arrow1 = null;
    _this2._arrow2 = null;

    if (optionsToUse.arrow != null) {
      var width = 0.01;

      if (_this2.curve) {
        width = _this2.curve.width;
      }

      var autoHide = true;

      if (typeof optionsToUse.arrow !== 'string' && optionsToUse.arrow.autoHide != null) {
        autoHide = optionsToUse.arrow.autoHide;
      }

      var defaultArrowRadius = 0.1;

      if (_this2.curve) {
        defaultArrowRadius = _this2.curve.radius;
      }

      if (typeof optionsToUse.arrow !== 'string' && optionsToUse.arrow.radius != null) {
        defaultArrowRadius = optionsToUse.arrow.radius;
      }

      var curveOverlap = 0.3;

      if (typeof optionsToUse.arrow !== 'string' && optionsToUse.arrow.curveOverlap != null) {
        curveOverlap = optionsToUse.arrow.curveOverlap;
      }

      var arrowOptions = Object(_geometries_arrow__WEBPACK_IMPORTED_MODULE_6__["simplifyArrowOptions"])(optionsToUse.arrow, width); // $FlowFixMe

      _this2.arrow = arrowOptions;

      if (_this2.arrow == null) {
        return _possibleConstructorReturn(_this2);
      }

      var defaultO = {
        radius: defaultArrowRadius,
        autoHide: autoHide,
        curveOverlap: curveOverlap
      };

      if (_this2.arrow.start != null) {
        // $FlowFixMe
        _this2.arrow.start = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultO, _this2.arrow.start);
      }

      if (_this2.arrow.end != null) {
        // $FlowFixMe
        _this2.arrow.end = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultO, _this2.arrow.end);
      }

      _this2.addArrow('start');

      _this2.addArrow('end');
    } // Label


    if (optionsToUse.label || optionsToUse.label === null) {
      if (optionsToUse.label === null) {
        optionsToUse.label = {
          text: null
        };
      }

      if (typeof optionsToUse.label === 'string') {
        optionsToUse.label = {
          text: optionsToUse.label
        };
      }

      _this2.addLabel(optionsToUse.label);
    } // Sides


    var defaultSideLength = 0.5;

    if (_this2.curve) {
      defaultSideLength = _this2.curve.radius * 2;
    }

    var defaultSideWidth = 0.01;

    if (_this2.curve) {
      defaultSideWidth = _this2.curve.width;
    }

    var defaultSideOptions = {
      length: defaultSideLength,
      width: defaultSideWidth,
      color: _this2.color
    };

    if (optionsToUse.side1) {
      var sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, optionsToUse.side1);

      _this2.addSide(1, sideOptions.length, sideOptions.width, sideOptions.color);
    }

    if (optionsToUse.side2) {
      var _sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, optionsToUse.side2);

      _this2.addSide(2, _sideOptions.length, _sideOptions.width, _sideOptions.color);
    }

    if (optionsToUse.corner != null) {
      var cornerOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, {
        style: 'fill'
      }, optionsToUse.corner);

      _this2.addCorner(cornerOptions);
    } // Sides overrides side1 and side2


    if (optionsToUse.sides) {
      var sides = {};

      if (_typeof(optionsToUse.sides) === 'object') {
        sides = optionsToUse.sides;
      }

      var _sideOptions2 = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultSideOptions, sides);

      _this2.addSide(1, _sideOptions2.length, _sideOptions2.width, _sideOptions2.color);

      _this2.addSide(2, _sideOptions2.length, _sideOptions2.width, _sideOptions2.color);
    }

    _this2.pulseAngleDefaults = {
      curve: optionsToUse.pulseAngle.curve || 1.5,
      corner: optionsToUse.pulseAngle.corner || 1.5,
      label: optionsToUse.pulseAngle.label || 1.5,
      arrow: optionsToUse.pulseAngle.arrow || 1.5,
      duration: optionsToUse.pulseAngle.duration || 1.5,
      frequency: optionsToUse.pulseAngle.frequency || 0,
      thick: optionsToUse.pulseAngle.thick || 1
    };

    _this2.animations.angle = function () {
      for (var _len = arguments.length, opt = new Array(_len), _key = 0; _key < _len; _key++) {
        opt[_key] = arguments[_key];
      }

      var o = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, {
        element: _assertThisInitialized(_this2)
      }].concat(opt));
      var target;
      var start;
      var toSetup = true;

      o.callback = function (percentage) {
        if (toSetup) {
          if (o.start == null) {
            start = _this2.angle;
          } else {
            start = o.start;
          }

          if (o.target == null) {
            target = _this2.angle;
          } else {
            target = o.target;
          }

          toSetup = false;
        }

        var a = (target - start) * percentage + start;

        _this2.setAngle({
          angle: a
        });
      };

      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_7__["CustomAnimationStep"](o);
    };

    _this2.animations.customSteps.push({
      step: _this2.animations.angle.bind(_assertThisInitialized(_this2)),
      name: 'angle'
    });

    _this2.animations.pulseAngle = function () {
      for (var _len2 = arguments.length, opt = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        opt[_key2] = arguments[_key2];
      }

      var o = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, {
        element: _assertThisInitialized(_this2),
        duration: 1
      }].concat(opt));

      o.callback = function () {
        _this2.pulseAngle({
          curve: o.curve,
          label: o.label,
          arrow: o.arrow,
          corner: o.corner,
          duration: o.duration,
          frequency: o.frequency,
          thick: o.thick
        });
      };

      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_7__["TriggerAnimationStep"](o);
    };

    _this2.animations.customSteps.push({
      step: _this2.animations.pulseAngle.bind(_assertThisInitialized(_this2)),
      name: 'pulseAngle'
    });

    _this2.update();

    if (optionsToUse.mods != null && optionsToUse.mods !== {}) {
      _this2.setProperties(optionsToUse.mods);
    }

    return _this2;
  }

  _createClass(CollectionsAngle, [{
    key: "_getStateProperties",
    value: function _getStateProperties(options) {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(CollectionsAngle.prototype), "_getStateProperties", this).call(this, options)), ['angle', 'lastLabelRotationOffset']);
    }
  }, {
    key: "_fromState",
    value: function _fromState(state) {
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])(this, state);
      this.setAngle({
        angle: this.angle,
        rotationOffset: this.lastLabelRotationOffset
      });
      return this;
    }
    /**
     * Turn on and off auto label location and orientation updates when angle
     * transform changes. When an angle is created with a label, auto update
     * is turned off by default.
     *
     * Manual updates can be performed with
     * <a href="collectionsangle#udpatelabel">updateLabel</a>
     */

  }, {
    key: "setAutoUpdate",
    value: function setAutoUpdate() {
      var _this3 = this;

      var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (update) {
        this.autoUpdateSubscriptionId = this.subscriptions.add('setTransform', function () {
          _this3.updateLabel(_this3.getRotation()); // this.updateMovePads();

        });
      } else {
        this.subscriptions.remove('setTransform', this.autoUpdateSubscriptionId);
        this.autoUpdateSubscriptionId = -1;
      }
    }
  }, {
    key: "setNextPositionAndRotation",
    value: function setNextPositionAndRotation() {
      if (this.nextPosition != null) {
        this.transform.updateTranslation(this.nextPosition);
      }

      if (this.nextStartAngle != null) {
        this.transform.updateRotation(this.nextStartAngle);
        this.startAngle = this.nextStartAngle || 0;
      }

      this.nextPosition = null;
      this.nextStartAngle = null;
    }
    /**
     * Set the angle. The same direction and angle sign must be used as when
     * originally defined.
     */

  }, {
    key: "setAngle",
    value: function setAngle() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.calculateAngleRotationPosition(options);
      var corner = this.corner,
          _corner = this._corner;

      if (corner != null && _corner != null) {
        var points = this.getCornerPoints(corner.length);

        _corner.custom.updatePoints({
          points: points
        });
      }

      this.update();
    }
  }, {
    key: "getCornerPoints",
    value: function getCornerPoints(length) {
      return [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](length, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](length * Math.cos(this.angle), length * Math.sin(this.angle))];
    }
  }, {
    key: "addCorner",
    value: function addCorner(options) {
      var width = options.width,
          color = options.color,
          length = options.length,
          style = options.style;
      var corner = this.collections.primitives.polyline({
        width: width,
        color: color,
        points: this.getCornerPoints(length),
        cornerStyle: style
      });
      this.corner = {
        length: length,
        width: width,
        color: color,
        style: style
      };
      this.add('corner', corner);
    }
  }, {
    key: "addSide",
    value: function addSide(index) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.color;
      var line = this.collections.primitives.line({
        length: 1,
        width: width,
        angle: 0,
        color: color,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).rotate(0)
      }); // $FlowFixMe

      this["side".concat(index)] = {
        length: length,
        width: width
      };
      this.add("side".concat(index), line);
    }
  }, {
    key: "addLabel",
    value: function addLabel() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultLabelOptions = {
        text: null,
        radius: 0.4,
        curvePosition: 0.5,
        offset: 0.0001,
        showRealAngle: false,
        units: 'degrees',
        precision: 0,
        orientation: 'horizontal',
        autoHide: null,
        autoHideMax: null,
        scale: 0.7,
        color: this.color,
        location: 'outside',
        update: false
      };

      if (this.curve) {
        defaultLabelOptions.radius = Math.max(this.curve.radius, this.curve.radius + (this.curve.num - 1) * this.curve.step);
      }

      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultLabelOptions, options);

      if (optionsToUse.text === null) {
        optionsToUse.text = '';
        optionsToUse.showRealAngle = true;
      }

      this.label = new AngleLabel(this.collections, optionsToUse.text, optionsToUse.color, optionsToUse.radius, optionsToUse.curvePosition, optionsToUse.offset, optionsToUse.showRealAngle, optionsToUse.units, optionsToUse.precision, optionsToUse.autoHide, optionsToUse.autoHideMax, optionsToUse.orientation, optionsToUse.location, optionsToUse.subLocation, optionsToUse.scale);
      this.label.eqn.initialForm = null;

      if (optionsToUse.isTouchable != null) {
        this.label.eqn.isTouchable = optionsToUse.isTouchable;
      }

      if (optionsToUse.touchBorder != null) {
        this.label.eqn.touchBorder = optionsToUse.touchBorder;
      }

      if (optionsToUse.onClick != null) {
        this.label.eqn.onClick = optionsToUse.onClick;
      }

      if (this.label != null) {
        this.add('label', this.label.eqn);
      }

      this.setAutoUpdate(optionsToUse.update);
      this.updateLabel();
    }
  }, {
    key: "addCurve",
    value: function addCurve() {
      var curveOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultCurveOptions = {
        width: 0.01,
        sides: 100,
        radius: 0.5,
        num: 1,
        fill: false,
        step: 0,
        autoHide: null,
        autoHideMax: null,
        autoRightAngle: false,
        rightAngleRange: 1 / 180 * Math.PI
      };
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultCurveOptions, curveOptions);
      var direction = this.direction;

      if (this.angle < 0 && this.direction === -1) {
        direction = 1;
      } else if (this.angle < 0 && this.direction === 1) {
        direction = -1;
      }

      for (var i = 0; i < optionsToUse.num; i += 1) {
        var o = {
          sides: optionsToUse.sides,
          radius: optionsToUse.radius + i * optionsToUse.step,
          color: this.color,
          direction: direction,
          transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('AngleCurve').rotate(0) // dash: optionsToUse.dash,

        };

        if (optionsToUse.fill === false) {
          // $FlowFixMe
          o.line = {
            width: optionsToUse.width // dash: optionsToUse.dash,

          };
        }

        var curve = this.collections.primitives.polygon(o);
        this.curve = optionsToUse;
        var name = 'curve';

        if (i > 0) {
          name = "".concat(name).concat(i);
        }

        this.add(name, curve);
      } // Right Angle


      if (this.curve != null && this.curve.autoRightAngle) {
        var right = this.collections.collection();
        var rightLength = optionsToUse.radius * 0.707; // / Math.sqrt(2);

        right.add('line1', this.collections.primitives.line({
          p1: [rightLength, 0],
          length: rightLength + optionsToUse.width / 2,
          width: optionsToUse.width,
          angle: Math.PI / 2 * direction,
          color: this.color
        }));
        right.add('line2', this.collections.primitives.line({
          p1: [0, rightLength * direction],
          length: rightLength + optionsToUse.width / 2,
          width: optionsToUse.width,
          angle: 0,
          color: this.color
        }));
        this.add('curveRight', right);
      }
    }
  }, {
    key: "change",
    value: function change(options) {
      if (this._curve != null && options.radius != null) {
        this._curve.custom.update({
          radius: options.radius
        });
      }

      if (this.label != null) {
        if (options.curveRadius != null) {
          this.label.radius = options.curveRadius;
        }

        if (options.curvePosition != null) {
          this.label.curvePosition = options.curvePosition;
        }

        if (options.offset != null) {
          this.label.offset = options.offset;
        }
      }
    }
  }, {
    key: "addArrow",
    value: function addArrow(lineEnd) {
      // $FlowFixMe
      if (this.arrow[lineEnd] == null) {
        return;
      }

      var o = this.arrow[lineEnd];
      var a = this.collections.primitives.arrow(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, o, {
        // angle: r,
        color: this.color,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(0).translate(0, 0)
      })); // $FlowFixMe

      var arrowLength = Object(_geometries_arrow__WEBPACK_IMPORTED_MODULE_6__["getArrowLength"])(o)[1];
      var index = 1;

      if (lineEnd === 'end') {
        index = 2;
      } // $FlowFixMe


      this.arrow[lineEnd] = {
        height: arrowLength,
        radius: o.radius || 0,
        autoHide: o.autoHide,
        curveOverlap: o.curveOverlap
      };
      this.add("arrow".concat(index), a);
      this.update();
    }
  }, {
    key: "updateCurve",
    value: function updateCurve(primaryCurveAngle, angle, rotation, show) {
      var curve = this.curve;

      if (curve) {
        var direction = this.direction;

        if (this.angle < 0 && this.direction === -1) {
          direction = 1;
        } else if (this.angle < 0 && this.direction === 1) {
          direction = -1;
        }

        var r = rotation;

        if (this.direction === -1) {
          r *= -1;
        }

        if (this.angle < 0) {
          r *= -1;
        }

        for (var i = 0; i < curve.num; i += 1) {
          var name = '_curve';

          if (i > 0) {
            name = "_curve".concat(i);
          } // $FlowFixMe


          var element = this[name]; // console.log(element)

          if (element) {
            if (show) {
              element.show();

              if (i === 0) {
                var delta = 0;

                if (this.curve) {
                  var sideAngle = 2 * Math.PI / this.curve.sides;
                  var numSides = Math.floor(Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(primaryCurveAngle / sideAngle));
                  delta = primaryCurveAngle - numSides * sideAngle;
                }

                element.angleToDraw = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(primaryCurveAngle, '0to360');
                element.transform.updateRotation(r + direction * delta / 2);
              } else {
                var _delta = 0;

                if (this.curve) {
                  _delta = angle % (2 * Math.PI / this.curve.sides);
                }

                element.angleToDraw = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle, '0to360');
                element.transform.updateRotation(direction * _delta / 2);
              }
            } else {
              element.hide();
            }
          }
        }
      }
    }
  }, {
    key: "update",
    value: function update() {
      var labelRotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var _arrow1 = this._arrow1;
      var _arrow2 = this._arrow2;
      var arrow1Hide = false;
      var arrow2Hide = false;
      var rotationForArrow1 = 0;
      var fullCurveAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(this.angle, '-360to360');

      if (fullCurveAngle >= 0 && this.direction === -1) {
        fullCurveAngle = Math.PI * 2 - fullCurveAngle;
      } else if (fullCurveAngle < 0 && this.direction === 1) {
        fullCurveAngle = Math.abs(fullCurveAngle);
      } else if (fullCurveAngle < 0 && this.direction === -1) {
        fullCurveAngle = Math.PI * 2 - Math.abs(fullCurveAngle);
      }

      var curveAngle = fullCurveAngle;
      var trueCurveAngle = fullCurveAngle; // const arrow2LengthModifier = 0.5;
      // const arrowLengthMod = 0.9;

      var arrow1Angle = 0;
      var arrow2Angle = 0;

      if (this.arrow != null && this.arrow.start != null) {
        var start = this.arrow.start;
        var radius = start.radius || 0;
        arrow1Angle = start.height / radius * (1 - start.curveOverlap);
        curveAngle -= arrow1Angle;
        trueCurveAngle -= start.height / radius;
      }

      if (this.arrow != null && this.arrow.end != null) {
        var end = this.arrow.end;

        var _radius = end.radius || 0;

        arrow2Angle = end.height / _radius * (1 - end.curveOverlap);
        curveAngle -= arrow2Angle;
        trueCurveAngle -= end.height / _radius;
      }

      if (this.arrow != null && trueCurveAngle < 0) {
        if (this.arrow.start != null && this.arrow.start.autoHide) {
          var _radius2 = this.arrow.start.radius || 0;

          arrow1Hide = true;
          trueCurveAngle += this.arrow.start.height / _radius2;
          curveAngle += arrow1Angle;
        }

        if (this.arrow.end != null && this.arrow.end.autoHide) {
          var _radius3 = this.arrow.end.radius || 0;

          arrow2Hide = true;
          trueCurveAngle += this.arrow.end.height / _radius3;
          curveAngle += arrow2Angle;
        }
      }

      if (_arrow1 && this.arrow != null && this.arrow.start != null) {
        if (arrow1Hide) {
          _arrow1.hide();
        } else {
          _arrow1.show(); // $FlowFixMe


          _arrow1.transform.updateTranslation(this.arrow.start.radius, 0); // $FlowFixMe


          var arrowLengthAngle = this.arrow.start.height / this.arrow.start.radius;
          var curveToLine; // $FlowFixMe

          var _radius4 = this.arrow.start.radius || 0;

          if (this.angle > 0 && this.direction === 1 || this.angle < 0 && this.direction === -1) {
            curveToLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(_radius4, arrowLengthAngle), [_radius4, 0]).angle();
          } else {
            curveToLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(_radius4, -arrowLengthAngle), [_radius4, 0]).angle();
          }

          _arrow1.transform.updateRotation(curveToLine);

          rotationForArrow1 = arrow1Angle;
        }
      }

      if (_arrow2 && this.arrow != null && this.arrow.end != null) {
        if (arrow2Hide) {
          _arrow2.hide();
        } else {
          _arrow2.show(); // $FlowFixMe


          _arrow2.transform.updateTranslation(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(this.arrow.end.radius, this.angle)); // $FlowFixMe


          var _arrowLengthAngle = this.arrow.end.height / this.arrow.end.radius;

          var _curveToLine; // $FlowFixMe


          var _radius5 = this.arrow.start.radius || 0;

          if (this.angle > 0 && this.direction === 1 || this.angle > 0 && this.direction === -1) {
            _curveToLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(_radius5, this.angle - this.direction * _arrowLengthAngle), Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(_radius5, this.angle)).angle();
          } else {
            _curveToLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(_radius5, this.angle + this.direction * _arrowLengthAngle), Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(_radius5, this.angle)).angle();
          }

          _arrow2.transform.updateRotation(_curveToLine);

          rotationForArrow1 = arrow1Angle;
        }
      }

      if (labelRotationOffset != null) {
        this.lastLabelRotationOffset = labelRotationOffset;
      }

      this.setNextPositionAndRotation();
      var _curve = this._curve,
          curve = this.curve,
          _curveRight = this._curveRight;

      if (_curve != null && curve != null) {
        if (curve.autoHide != null && fullCurveAngle < curve.autoHide || curve.autoHideMax != null && fullCurveAngle > curve.autoHideMax) {
          if (_curveRight != null) {
            _curveRight.hide();
          }

          _curve.hide();

          if (_arrow1 != null) {
            _arrow1.hide();
          }

          if (_arrow2 != null) {
            _arrow2.hide();
          }
        } else if (curve != null && curve.autoRightAngle && fullCurveAngle >= Math.PI / 2 - curve.rightAngleRange / 2 && fullCurveAngle <= Math.PI / 2 + curve.rightAngleRange / 2) {
          if (_curveRight != null) {
            _curveRight.showAll();
          }

          _curve.hide();

          if (_arrow1 != null) {
            _arrow1.hide();
          }

          if (_arrow2 != null) {
            _arrow2.hide();
          }
        } else {
          if (_curveRight != null) {
            _curveRight.hide();
          }

          if (_arrow1 != null && arrow1Hide === false) {
            _arrow1.show();
          }

          if (_arrow2 != null && arrow2Hide === false) {
            _arrow2.show();
          } // _curve.show();


          curveAngle = Math.max(curveAngle, 0); // _curve.angleToDraw = curveAngle;
          // _curve.transform.updateRotation(rotationForArrow1);

          this.updateCurve(curveAngle, fullCurveAngle, rotationForArrow1, true);
        }
      }

      this.updateLabel();
      var _side1 = this._side1,
          side1 = this.side1;

      if (_side1 && side1) {
        // _side1.transform.updateRotation(this.rotation);
        _side1.transform.updateScale(side1.length, 1);
      }

      var _side2 = this._side2,
          side2 = this.side2;

      if (_side2 && side2) {
        _side2.transform.updateRotation(this.angle);

        _side2.transform.updateScale(side2.length, 1);
      }

      this.updateMovePads();
    }
  }, {
    key: "checkLabelForRightAngle",
    value: function checkLabelForRightAngle() {
      if (this.curve != null && this.curve.autoRightAngle === false) {
        return;
      }

      var label = this.label;
      var setRight = false;

      if (label != null) {
        var angle = parseFloat(label.getText());

        if (angle === 90) {
          setRight = true;
        }
      }

      if (setRight === false) {
        return;
      }

      var _curveRight = this._curveRight,
          _curve = this._curve,
          _arrow1 = this._arrow1,
          _arrow2 = this._arrow2;

      if (_curveRight != null) {
        _curveRight.showAll();
      }

      if (_curve != null) {
        _curve.hide();
      }

      if (_arrow1 != null) {
        _arrow1.hide();
      }

      if (_arrow2 != null) {
        _arrow2.hide();
      }
    }
    /**
     * Get the current angle in degrees or radians
     */

  }, {
    key: "getAngle",
    value: function getAngle() {
      var units = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'rad';

      if (units === 'deg') {
        return this.angle * 180 / Math.PI;
      }

      return this.angle;
    }
    /**
     * Set the label text
     */

  }, {
    key: "setLabel",
    value: function setLabel(text) {
      var label = this.label;

      if (label != null) {
        label.setText(text);
        label.showRealAngle = false;
      }

      this.updateLabel();
    }
    /**
     * Get the label text
     */

  }, {
    key: "getLabel",
    value: function getLabel() {
      if (this.label != null) {
        return this.label.getText();
      }

      return '';
    }
    /**
     * Set the label to be the real angle
     */

  }, {
    key: "setLabelToRealAngle",
    value: function setLabelToRealAngle() {
      var label = this.label;

      if (label != null) {
        label.showRealAngle = true;
      }

      this.updateLabel();
    }
    /**
     * Manually update the label orientations with a custom rotation offset.
     *
     * Automatic updating can be done with
     * <a href="collectionsangle#setautoupdate">setAutoUpdate</a>
     * @param {number | null} rotationOffset
     */

  }, {
    key: "updateLabel",
    value: function updateLabel() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getRotation();

      if (rotationOffset != null) {
        this.lastLabelRotationOffset = rotationOffset;
      }

      var _label = this._label,
          label = this.label;

      if (_label && label) {
        if (label.autoHide != null && label.autoHide > Math.abs(this.angle) || // $FlowFixMe
        label.autoHideMax != null && Math.abs(this.angle) > label.autoHideMax) {
          _label.hide();
        } else {
          _label.show();

          if (label.showRealAngle) {
            var _angle = this.angle;

            if (_angle >= 0 && this.direction === -1) {
              _angle = -(Math.PI * 2 - Math.abs(_angle));
            } else if (_angle < 0 && this.direction === -1) {
              _angle = Math.PI * 2 - Math.abs(_angle);
            } // angle = clipAngle(angle, this.clip);


            _angle = Math.abs(_angle);
            var angleText = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(_angle, label.precision).toFixed(label.precision);

            if (label.units === 'degrees') {
              var a = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(_angle * 180 / Math.PI, label.precision);

              if (a === 360) {
                a = 0;
              }

              angleText = a.toFixed(label.precision);
              angleText = "".concat(angleText, "\xB0");
            }

            label.setText(angleText);
          }

          var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(this.angle, '-360to360');
          var lineOffsetAngle = Math.PI / 2;

          if (angle < 0) {
            lineOffsetAngle = -Math.PI / 2;
          }

          if (angle >= 0 && this.direction === -1) {
            angle = -(Math.PI * 2 - angle);
          } else if (angle < 0 && this.direction === -1) {
            angle = Math.PI * 2 - Math.abs(angle);
          }

          var labelPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(label.radius, angle * label.curvePosition);
          var orientation = label.orientation,
              location = label.location;

          if (orientation === 'tangent') {
            orientation = 'baseToLine';
          }

          if (location === 'outside') {
            location = 'negative';

            if (this.direction === -1) {
              location = 'positive';
            }
          }

          if (location === 'inside') {
            location = 'positive';

            if (this.direction === -1) {
              location = 'negative';
            }
          }

          var lineAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle, '0to360') * label.curvePosition + lineOffsetAngle, '0to360');

          if (location === 'start') {
            labelPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](label.radius, 0);
            lineAngle = 0;
          }

          if (location === 'end') {
            labelPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(label.radius, angle);
            lineAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle, '0to360');
          }

          label.updateRotation(labelPosition, lineAngle, label.offset, location, label.subLocation, orientation, this.lastLabelRotationOffset == null ? 0 : this.lastLabelRotationOffset, 'oval', false, Math.PI / 2, -Math.PI / 2);
        }
      }
    }
    /**
     * Pulse the angle where each element can be pulsed in a custom way.
     *
     * The pulse scales of the curve, label, corner and arrows can all be defined
     * separately.
     */

  }, {
    key: "pulseAngle",
    value: function pulseAngle() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        curve: this.pulseAngleDefaults.curve,
        label: this.pulseAngleDefaults.label,
        arrow: this.pulseAngleDefaults.arrow,
        corner: this.pulseAngleDefaults.corner,
        done: null,
        duration: this.pulseAngleDefaults.duration,
        frequency: this.pulseAngleDefaults.frequency,
        when: 'nextFrame',
        thick: this.pulseAngleDefaults.thick
      };
      var p = this.getPosition('figure');
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])(defaultOptions, options);
      var done = o.done;

      var pulse = function pulse(elementName, oName, oScale, oThick) {
        var element = _this4.elements[elementName];

        if (element != null && element.isShown) {
          var pulseOptions;
          var defaultThick = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({
            num: o.thick
          }, o.thick > 1 ? oThick : oScale);

          if (typeof o[oName] === 'number') {
            pulseOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultThick, o, {
              scale: o[oName],
              callback: done
            });
          } else {
            pulseOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultThick, o, o[oName], {
              callback: done
            });
          }

          if (pulseOptions.num > 1 && pulseOptions.min == null) {
            pulseOptions.min = 1 / pulseOptions.scale;
          }

          element.pulse(pulseOptions);
          done = null;
        }
      };

      if (this._curve != null) {
        pulse('curve', 'curve', {}, {});
      }

      if (this._curveRight != null) {
        pulse('curveRight', 'curve', {}, {});
      }

      if (this.corner != null && this._corner != null) {
        // const cornerLength = this.corner.length || 0;
        pulse('corner', 'corner', {
          centerOn: p
        }, {
          centerOn: p,
          num: 1
        });
      }

      pulse('label', 'label', {
        centerOn: p
      }, {
        num: 1
      });

      if (this.arrow != null) {
        if (this._arrow1 != null) {
          pulse('arrow1', 'arrow', {
            centerOn: p
          }, {
            centerOn: this._arrow1.getPosition('figure'),
            num: 1
          });
        }

        if (this._arrow2 != null) {
          pulse('arrow2', 'arrow', {
            centerOn: p
          }, {
            centerOn: this._arrow2.getPosition('figure'),
            num: 1
          });
        }
      }

      this.animateNextFrame();
    }
  }, {
    key: "showAll",
    value: function showAll() {
      _get(_getPrototypeOf(CollectionsAngle.prototype), "showAll", this).call(this);

      this.update();
    }
    /**
     * Use this method to enable or disable movability of the line.
     *
     * @param {OBJ_MovableAngle | boolean} [movableOrOptions] `true` to
     * make movable, `false` to make not movable or use options to
     * set different kinds of movability.
     */
    // $FlowFixMe

  }, {
    key: "setMovable",
    value: function setMovable(movableOrOptions) {
      var defaultOptions = {
        movable: true,
        type: this.move.type,
        width: 0.5,
        movePadRadius: 0,
        startArm: null,
        endArm: null
      };
      var options;

      if (movableOrOptions === false) {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, {
          movable: false
        });
      } else if (movableOrOptions === true) {
        options = defaultOptions;
      } else {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, movableOrOptions);
      }

      var _options = options,
          movable = _options.movable,
          startArm = _options.startArm,
          endArm = _options.endArm,
          movePadRadius = _options.movePadRadius,
          width = _options.width;

      if (movable) {
        if (startArm != null && endArm != null) {
          if (startArm === 'rotation') {
            this.addRotPad(1 - movePadRadius, width, 'rotation');
          }

          if (endArm === 'rotation') {
            this.addAnglePad(1 - movePadRadius, width, 'rotation');
          }

          if (startArm === 'angle') {
            this.addRotPad(1 - movePadRadius, width, 'angle');
          }

          if (endArm === 'angle') {
            this.addAnglePad(1 - movePadRadius, width, 'angle');
          }
        } else if (startArm != null) {
          this.addRotPad(1 - movePadRadius, width, startArm);
        } else if (endArm != null) {
          this.addAnglePad(1 - movePadRadius, width, endArm);
        }

        if (movePadRadius > 0) {
          this.addMovePad(movePadRadius);
        }
      } else {
        this.isMovable = false;
        this.isTouchable = false;

        if (this._anglePad != null) {
          this._anglePad.setMovable(false);
        }

        if (this._rotPad != null) {
          this._rotPad.setMovable(false);
        }
      }

      this.updateMovePads();
    }
  }, {
    key: "getLength",
    value: function getLength() {
      if (this.corner != null && this.corner.length != null) {
        return this.corner.length;
      }

      if (this.curve != null && this.curve.radius != null) {
        return this.curve.radius;
      }

      if (this.label != null && this.label.radius != null) {
        return this.label.radius;
      }

      return 1;
    }
  }, {
    key: "addAnglePad",
    value: function addAnglePad() {
      var _this5 = this;

      var percentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
      var type = arguments.length > 2 ? arguments[2] : undefined;

      if (this._anglePad == null) {
        var length = this.getLength();
        var anglePad = this.collections.primitives.rectangle({
          offset: [length * (1 - percentLength), 0],
          // position: [length * (1 - percentLength), 0],
          xAlign: 'left',
          yAlign: 'middle',
          width: length * percentLength + width,
          height: width,
          color: [0, 0, 1, 0],
          border: [[]],
          touchBorder: 'buffer'
        });
        this.add('anglePad', anglePad);
        anglePad.setMovable();
        anglePad.move.type = 'rotation';
        anglePad.drawingObject.border = [[]];

        if (type === 'rotation') {
          // anglePad.move.element = this;
          anglePad.subscriptions.add('beforeSetTransform', function (transformToSet) {
            var nextR = transformToSet[0].r();
            var currentR = anglePad.getRotation();
            var deltaR = nextR - currentR;

            _this5.transform.updateRotation(_this5.getRotation() + deltaR);

            anglePad.cancelSetTransform = true;
          });
        } else {
          anglePad.subscriptions.add('setTransform', function () {
            var angle = anglePad.getRotation();

            if (_this5.angle > 0) {
              angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle, '0to360');
            } else {
              angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle, '-360to0');
            }

            _this5.setAngle({
              angle: angle
            });
          });
        }
      }
    }
  }, {
    key: "addRotPad",
    value: function addRotPad() {
      var _this6 = this;

      var percentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
      var type = arguments.length > 2 ? arguments[2] : undefined;

      if (this._rotPad == null) {
        var length = this.getLength();
        var rotPad = this.collections.primitives.rectangle({
          xAlign: 'left',
          yAlign: 'middle',
          width: length * percentLength + width,
          height: width,
          color: [1, 0, 1, 0],
          offset: [length * (1 - percentLength), 0],
          border: [[]],
          touchBorder: 'buffer'
        });
        this.add('rotPad', rotPad);
        rotPad.setMovable();
        rotPad.move.type = 'rotation';
        rotPad.drawingObject.border = [[]]; // rotPad.touchBorder = 'drawBuffer';

        if (type === 'angle') {
          rotPad.move.element = this;
          this.subscriptions.add('beforeSetTransform', function (transformToSet) {
            // $FlowFixMe
            var nextR = transformToSet[0].r();

            var currentR = _this6.getRotation();

            var deltaR = nextR - currentR;
            var angle = _this6.angle - deltaR;

            if (_this6.angle > 0) {
              angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle, '0to360');
            } else {
              angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle, '-360to0');
            }

            _this6.setAngle({
              angle: angle
            });
          });
        } else {
          rotPad.move.element = this;
        }
      }
    }
  }, {
    key: "addMovePad",
    value: function addMovePad() {
      var percentLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (this._movePad == null) {
        var length = this.getLength();
        var movePad = this.collections.primitives.polygon({
          radius: length * percentLength,
          sides: 8,
          fill: true,
          color: [1, 0, 0, 0],
          border: [[]],
          touchBorder: 'buffer'
        });
        this.add('movePad', movePad);
        movePad.setMovable();
        movePad.move.type = 'translation';
        movePad.drawingObject.border = [[]];
        movePad.move.element = this;
      }
    }
  }, {
    key: "updateMovePads",
    value: function updateMovePads() {
      if (this._anglePad != null) {
        this._anglePad.transform.updateRotation(this.angle);
      }
    }
  }]);

  return CollectionsAngle;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["FigureElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (CollectionsAngle);

/***/ }),

/***/ "./src/js/figure/FigureCollections/Axis.js":
/*!*************************************************!*\
  !*** ./src/js/figure/FigureCollections/Axis.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import Figure from '../Figure';





/*
...................###....##.....##.####..######.
..................##.##....##...##...##..##....##
.................##...##....##.##....##..##......
................##.....##....###.....##...######.
................#########...##.##....##........##
................##.....##..##...##...##..##....##
................##.....##.##.....##.####..######.
*/

/**
 * {@link FigureElementCollection} representing an Axis.
 *
 * This object defines an axis with an axis line, tick marks, labels,
 * grid lines and a title.
 *
 * See {@link COL_Axis} for the options that can be used when creating
 * the axis.
 *
 * An axis is drawn to a `length`. It will have values along its length
 * from `start` to `stop`. Ticks, grid lines and labels are all drawn
 * at axis value positions. All other dimensions, such as line lengths,
 * widths, positions, spaces and offsets are defined in draw space, or in the
 * same space as the `length` of the axis.
 *
 * The object contains additional methods that convert between axis values
 * and draw space positions, as well as a convenience method to report if a
 * value is within an axis.
 * - <a href="#collectionsaxisvaluetodraw">valueToDraw</a>
 * - <a href="#collectionsaxisdrawtovalue">drawToValue</a>
 * - <a href="#collectionsaxisinaxis">inAxis</a>
 *
 * To test examples below, append them to the
 * <a href="#drawing-boilerplate">boilerplate</a>.
 *
 * For more examples of axis labels and axis ticks, see {@link OBJ_AxisLabels}
 * and {@link OBJ_AxisTicks}.
 *
 * #### Example
 * ```javascript
 * // By default an axis is an 'x' axis
 * figure.add({
 *   name: 'x',
 *   method: 'collections.axis',
 *   options: {
 *     ticks: true,
 *   },
 * });
 * ```
 * ![](./apiassets/advaxis_ex1.png)
 *
 * #### Example
 * ```javascript
 * // An axis can also be created and then added to a figure
 * // An axis can have specific start and stop values
 * // An axis can be a y axis
 * const axis = figure.collections.axis({
 *   axis: 'y',
 *   start: -10,
 *   stop: 10,
 *   ticks: { step: 5 },
 * })
 * figure.add('axis', axis);
 * ```
 * ![](./apiassets/advaxis_ex2.png)
 *
 * #### Example
 * ```javascript
 * // An axis can have multiple sets of ticks and a title
 * figure.add({
 *   name: 'x',
 *   method: 'collections.axis',
 *   options: {
 *     ticks: [
 *       { step: 0.2, length: 0.1 },
 *       { step: 0.05, length: 0.05, offset: 0 },
 *     ],
 *     title: 'time (s)',
 *   },
 * });
 * ```
 * ![](./apiassets/advaxis_ex3.png)
 *
 * #### Example
 * ```javascript
 * // An axis line and ticks can be customized to be dashed
 * // and have arrows
 * figure.add({
 *   name: 'x',
 *   method: 'collections.axis',
 *   options: {
 *     length: 2.5,
 *     start: -130,
 *     stop: 130,
 *     line: {
 *       dash: [0.01, 0.01],
 *       arrow: 'barb',
 *     },
 *     ticks: {
 *       start: -100,
 *       stop: 100,
 *       step: 25,
 *       dash: [0.01, 0.01],
 *     },
 *     labels: { precision: 0 },
 *     title: {
 *       font: { style: 'italic' },
 *       text: 'x',
 *       position: [2.65, 0.03],
 *     },
 *   },
 * });
 * ```
 * ![](./apiassets/advaxis_ex4.png)
 *
 * #### Example
 * ```javascript
 * // An axis title can have grid lines extend from it, and titles with more
 * // formatting
 * figure.add({
 *   name: 'x',
 *   method: 'collections.axis',
 *   options: {
 *     stop: 2,
 *     ticks: { step: 0.5 },
 *     grid: [
 *       { step: 0.5, length: 1, color: [0.5, 0.5, 0.5, 1] },
 *       { step: 0.1, length: 1, dash: [0.01, 0.01], color: [0.7, 0.7, 0.7, 1] },
 *     ],
 *     title: {
 *       font: { color: [0.4, 0.4, 0.4, 1] },
 *       text: [
 *         'Total Time',
 *         {
 *           text: 'in seconds',
 *           font: { size: 0.1 },
 *           lineSpace: 0.12,
 *         },
 *       ],
 *     },
 *   },
 * });
 * ```
 * ![](./apiassets/advaxis_ex5.png)
 *
 *
 * @see {@link COL_Axis} for parameter descriptions
 *
 */
// $FlowFixMe
var CollectionsAxis = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsAxis, _FigureElementCollect);

  var _super = _createSuper(CollectionsAxis);

  // Figure elements

  /**
   * @hideconstructor
   */
  function CollectionsAxis(collections, optionsIn) {
    var _this;

    _classCallCheck(this, CollectionsAxis);

    var defaultOptions = {
      length: collections.primitives.defaultLength,
      angle: 0,
      start: 0,
      color: collections.primitives.defaultColor,
      font: collections.primitives.defaultFont,
      name: '',
      line: {},
      // grid: null,
      // ticks: null,
      show: true,
      axis: 'x',
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Axis').scale(1, 1).rotate(0).translate(0, 0),
      limits: collections.primitives.limits
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, optionsIn);
    _this = _super.call(this, options);
    _this.collections = collections;
    _this.autoStep = null;

    if (optionsIn.auto != null) {
      var _this$calcAuto = _this.calcAuto(optionsIn.auto),
          start = _this$calcAuto.start,
          stop = _this$calcAuto.stop,
          step = _this$calcAuto.step,
          precision = _this$calcAuto.precision;

      defaultOptions.start = start;
      defaultOptions.stop = stop;
      defaultOptions.ticks = {};
      defaultOptions.labels = {
        precision: precision
      };
      _this.autoStep = step;
    }

    options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, optionsIn);

    if (options.stop == null || options.stop <= options.start) {
      options.stop = options.start + 1;
    }

    _this.name = options.name;
    _this.defaultFont = options.font;

    if (optionsIn.font == null || optionsIn.font.color == null) {
      _this.defaultFont.color = options.color;
    }

    _this.showAxis = options.show;
    _this.startValue = options.start;
    _this.stopValue = options.stop;

    if (_this.startValue >= _this.stopValue) {
      _this.startValue = _this.stopValue - 1;
    }

    _this.length = options.length;
    _this.axis = options.axis;
    _this.angle = _this.axis === 'x' ? 0 : Math.PI / 2;
    _this.drawToValueRatio = (options.stop - options.start) / options.length;
    _this.valueToDrawRatio = 1 / _this.drawToValueRatio;

    if (options.ticks != null && options.labels === undefined) {
      options.labels = {};
    } // if (options.position != null) {
    //   this.transform.updateTranslation(getPoint(options.position));
    // }
    // if (options.transform != null) {
    //   this.transform = getTransform(options.transform);
    // }


    _this.setColor(options.color);

    _this.ticks = [];
    _this.grid = [];
    _this.labels = [];

    if (_this.showAxis && options.line != null && options.line !== false) {
      _this.addLine(options.line);
    }

    if (_this.showAxis && options.ticks != null && options.ticks !== false) {
      _this.addTicks(options.ticks, 'ticks');
    }

    if (_this.showAxis && options.labels != null && options.labels !== false) {
      _this.addLabels(options.labels);
    }

    if (_this.showAxis && options.title != null) {
      _this.addTitle(options.title);
    }

    if (_this.showAxis && options.grid != null && options.grid !== false) {
      _this.addTicks(options.grid, 'grid');
    }

    _this.reorder();

    return _this;
  }

  _createClass(CollectionsAxis, [{
    key: "addLine",
    value: function addLine(optionsInOrBool) {
      var optionsIn = optionsInOrBool;

      if (optionsInOrBool === true) {
        optionsIn = {};
      }

      var defaultOptions = {
        length: this.length,
        angle: this.angle,
        width: this.collections.primitives.defaultLineWidth,
        color: this.color
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, optionsIn);
      var line = this.collections.primitives.line(o);
      this.line = o;
      this.add('line', line);
    }
  }, {
    key: "reorder",
    value: function reorder() {
      var grid = [];
      var ticks = [];
      var line = [];
      this.drawOrder.forEach(function (elementName) {
        if (elementName.startsWith('grid')) {
          grid.push(elementName);
        }

        if (elementName.startsWith('tick')) {
          ticks.push(elementName);
        }

        if (elementName.startsWith('line')) {
          line.push(elementName);
        }
      });
      ticks = ticks.reverse();
      grid = grid.reverse();
      this.toBack(ticks);
      this.toBack(line);
      this.toBack(grid);
    }
  }, {
    key: "processTicks",
    value: function processTicks(name, o, index) {
      // let { start, stop } = this;
      var start = this.startValue;
      var stop = this.stopValue;
      var step;
      var values;

      if (o.start != null) {
        start = o.start;
      }

      if (o.stop != null) {
        stop = o.stop;
      }

      if (o.step != null) {
        step = o.step;
      }

      if (o.values != null) {
        values = o.values;
      }

      if (name === 'grid' && this.ticks.length >= index + 1) {
        if (o.start == null) {
          start = this.ticks[index].start;
        }

        if (o.stop == null) {
          stop = this.ticks[index].stop;
        }

        if (o.step == null) {
          step = this.ticks[index].step;
        }

        if (o.values == null) {
          values = this.ticks[index].values;
        }
      }

      if (step == null && this.autoStep != null && this.autoStep < (stop - start) / 2) {
        step = this.autoStep;
      } else if (step == null && index === 0) {
        step = (stop - start) / 5;
      } else if (step == null) {
        // $FlowFixMe
        step = this[name].step / 2;
      }

      return {
        start: start,
        stop: stop,
        step: step,
        values: values
      };
    }
  }, {
    key: "addTicks",
    value: function addTicks(optionsInOrBool) {
      var _this2 = this;

      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ticks';
      var optionsIn = optionsInOrBool;

      if (optionsInOrBool === true) {
        optionsIn = {};
      }

      var defaultOptions = {
        // start: this.startValue,
        // stop: this.stopValue,
        // step: (this.stopValue - this.startValue) / 5,
        width: this.line != null ? this.line.width : this.collections.primitives.defaultLineWidth,
        length: name === 'ticks' ? this.collections.primitives.defaultLineWidth * 10 : this.collections.primitives.defaultLineWidth * 50,
        angle: this.angle + Math.PI / 2,
        color: this.color
      };
      var optionsToUse;

      if (Array.isArray(optionsIn)) {
        optionsToUse = optionsIn;
      } else {
        optionsToUse = [optionsIn];
      } // $FlowFixMe


      this[name] = [];
      var elements = [];
      var lengthSign = this.axis === 'x' ? 1 : -1;
      optionsToUse.forEach(function (options, index) {
        var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, options);

        var _this2$processTicks = _this2.processTicks(name, o, index),
            start = _this2$processTicks.start,
            stop = _this2$processTicks.stop,
            step = _this2$processTicks.step,
            values = _this2$processTicks.values;

        o.start = start;
        o.stop = stop;
        o.step = step;
        o.length *= lengthSign;

        if (o.offset == null && name === 'ticks') {
          o.offset = _this2.axis === 'x' ? -o.length / 2 : o.length / 2;
        } else if (o.offset == null && name === 'grid') {
          var t = _this2.transform.t() || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

          if (_this2.axis === 'x') {
            o.offset = -t.y;
          } else {
            o.offset = -t.x;
          }
        }

        var num = Math.floor((o.stop + o.step / 10000 - o.start) / o.step);
        o.num = num;

        if (values == null) {
          o.values = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["range"])(o.start, o.stop, o.step);
        } else {
          o.values = values;
        }

        if (_this2.axis === 'x') {
          o.copy = [{
            to: o.values.map(function (v) {
              return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_this2.valueToDraw(v), 0);
            })
          }];
        } else {
          o.copy = [{
            to: o.values.map(function (v) {
              return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, _this2.valueToDraw(v));
            })
          }];
        } // $FlowFixMe


        o.copy[0].original = false;

        if (o.p1 == null) {
          o.p1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, o.offset * lengthSign).rotate(_this2.angle);
        }

        var ticks = _this2.collections.primitives.line(o);

        elements.push(ticks); // $FlowFixMe

        _this2[name].push(o);
      }); // Add elements in reverse to ensure first elements are drawn last and
      // will therefore overwrite later elements.

      elements.reverse();
      elements.forEach(function (element, index) {
        _this2.add("".concat(name).concat(index), element);
      });
    }
  }, {
    key: "addTitle",
    value: function addTitle(optionsIn) {
      var defaultOptions = {
        font: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, this.defaultFont, {
          size: this.defaultFont.size || 0.1 * 1.3
        }),
        justify: 'center',
        xAlign: 'center',
        yAlign: this.axis === 'x' ? 'top' : 'bottom',
        rotation: this.axis === 'x' ? 0 : Math.PI / 2,
        offset: [0, 0]
      };
      var optionsToUse = optionsIn;

      if (typeof optionsIn === 'string') {
        optionsToUse = {
          text: [optionsIn]
        };
      }

      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, optionsToUse);
      o.offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.offset);
      var bounds = this.getBoundingRect('draw');

      if (o.position == null) {
        if (this.axis === 'x') {
          o.position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.length / 2, bounds.bottom - o.font.size / 1.5).add(o.offset);
        } else {
          o.position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.left - o.font.size / 1.5, this.length / 2).add(o.offset);
        }
      }

      var title = this.collections.primitives.textLines(o);
      title.transform.updateRotation(o.rotation);
      this.add('title', title);
    }
  }, {
    key: "addLabels",
    value: function addLabels(optionsInOrBool) {
      var _this3 = this;

      var optionsIn = optionsInOrBool;

      if (optionsInOrBool === true) {
        optionsIn = {};
      }

      var defaultOptions = {
        text: null,
        precision: 1,
        values: null,
        format: 'decimal',
        // or 'exponent'
        font: this.defaultFont,
        xAlign: this.axis === 'x' ? 'center' : 'right',
        yAlign: this.axis === 'x' ? 'baseline' : 'middle',
        rotation: 0
      };
      var optionsToUse;

      if (Array.isArray(optionsIn)) {
        optionsToUse = optionsIn;
      } else {
        optionsToUse = [optionsIn];
      }

      this.labels = [];
      var bounds = this.getBoundingRect('draw');
      optionsToUse.forEach(function (options, index) {
        var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultOptions, options);

        if (typeof o.hide === 'number') {
          o.hide = [o.hide];
        }

        if (typeof o.values === 'number') {
          o.values = [o.values];
        }

        o.offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.offset);

        if (typeof o.text === 'string') {
          o.text = [o.text];
        } // Values where to put the labels - null is auto which is same as ticks


        var values = [];

        if (o.values == null && _this3.ticks.length > 0) {
          values = _this3.ticks[index].values;
        } else {
          values = o.values;
        }

        if (values == null) {
          values = [];
        } // Text for labels at each value - null is actual value


        if (o.text == null) {
          o.text = [];
          o.text = Array(values.length).map(function () {
            return null;
          });
        }

        if (o.space == null) {
          o.space = _this3.axis === 'x' ? o.font.size + _this3.collections.primitives.defaultLineWidth * 5 : _this3.collections.primitives.defaultLineWidth * 10;
        } // Generate the text objects


        var text = [];

        for (var i = 0; i < values.length; i += 1) {
          var location = void 0;

          var draw = _this3.valueToDraw(values[i]);

          if (_this3.axis === 'x') {
            location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](draw + o.offset.x, bounds.bottom - o.space + o.offset.y).rotate(-o.rotation);
          } else {
            location = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.left + o.offset.x - o.space, draw + o.offset.y).rotate(-o.rotation);
          }

          if (o.hide == null || o.hide != null && o.hide.indexOf(i) === -1) {
            var label = o.text[i];

            if (label == null) {
              label = values[i];
            }

            if (typeof label === 'number') {
              if (o.format === 'decimal') {
                label = "".concat(Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(label, o.precision).toFixed(o.precision));
              } else {
                label = "".concat(label.toExponential(o.precision));
              }
            }

            text.push({
              text: label,
              location: location
            });
          }
        }

        o.text = text;

        var labels = _this3.collections.primitives.text(o);

        labels.transform.updateRotation(o.rotation);

        _this3.add("labels".concat(index), labels);

        _this3.labels.push(o);
      });
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "calcAuto",
    value: function calcAuto(auto) {
      var _auto = _slicedToArray(auto, 2),
          min = _auto[0],
          max = _auto[1];

      var r = max - min;
      var order;

      if (r < 1) {
        order = Math.floor(Math.log10(r)); // eslint-disable-next-line yoda
      } else if (1 <= r && r < 3) {
        order = Math.floor(Math.log10(r / 3));
      } else {
        order = Math.ceil(Math.log10(r));
      } // let order = r < 10 ? Math.floor(Math.log10(r)) : Math.ceil(Math.log10(r));


      if (order === 0) {
        order = 1;
      }

      var factor = Math.pow(10, order - 1); // const newRange = Math.ceil(r / factor + 1) * factor;

      var newStart = Math.floor(min / factor) * factor;
      var newEnd = Math.ceil(max / factor) * factor;
      var newRange = newEnd - newStart; // const newEnd = newStart + newRange;

      var step;

      switch (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(newRange / factor)) {
        case 3:
        case 6:
          step = newRange / 3;
          break;

        case 4:
        case 8:
          step = newRange / 4;
          break;

        case 7:
          step = newRange / 7;
          break;

        case 9:
          step = newRange / 3;
          break;

        default:
          step = newRange / 5;
      }

      var precision = 0;

      if (order < 0) {
        precision = Math.abs(order) + 1;
      }

      return {
        start: Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(newStart),
        stop: Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(newEnd),
        step: Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(step),
        precision: Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(precision)
      };
    } // _getStateProperties(options: Object) {  // eslint-disable-line class-methods-use-this
    //   return [...super._getStateProperties(options),
    //     'length', 'angle', 'start', 'stop',
    //     'ticks', 'grid', 'labels', 'drawToValueRatio', 'valueToDraw',
    //   ];
    // }

    /**
     * Convert an axis value or values to a draw space position or positions.
     *
     * 'x' axes have a draw space position of 0 on the left end of the axis and
     * 'y' axes have a draw space position of 0 on the bottom end of the axis.
     *
     * @return {number} draw space position
     */

  }, {
    key: "valueToDraw",
    value: function valueToDraw(value) {
      var _this4 = this;

      if (typeof value === 'number') {
        // $FlowFixMe
        return (value - this.startValue) * this.valueToDrawRatio;
      }

      return value.map(function (v) {
        return (v - _this4.startValue) * _this4.valueToDrawRatio;
      });
    }
    /**
     * Convert an axis draw space value or values to an axis value or values.
     *
     * 'x' axes have a draw space position of 0 on the left end of the axis and
     * 'y' axes have a draw space position of 0 on the bottom end of the axis.
     *
     * @return {number} draw space position
     */

  }, {
    key: "drawToValue",
    value: function drawToValue(drawValue) {
      var _this5 = this;

      if (typeof drawValue === 'number') {
        // $FlowFixMe
        return drawValue * this.drawToValueRatio + this.startValue;
      }

      return drawValue.map(function (v) {
        return v * _this5.drawToValueRatio + _this5.startValue;
      });
    }
    /**
     * Check if a value is within the axis.
     *
     * @return {boolean} `true` if value is within length of axis.
     */

  }, {
    key: "inAxis",
    value: function inAxis(value) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var roundedValue = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(value, precision);

      if (roundedValue < this.startValue || roundedValue > this.stopValue) {
        return false;
      }

      return true;
    } // isInAxis(value: number) {
    //   if (value )
    // }

  }]);

  return CollectionsAxis;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["FigureElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (CollectionsAxis);

/***/ }),

/***/ "./src/js/figure/FigureCollections/EqnNavigator.js":
/*!*********************************************************!*\
  !*** ./src/js/figure/FigureCollections/EqnNavigator.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EqnNavigator; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _Equation_EquationForm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Equation/EquationForm */ "./src/js/figure/Equation/EquationForm.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Equation_Equation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Equation/Equation */ "./src/js/figure/Equation/Equation.js");
/* harmony import */ var _Recorder_Recorder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Recorder/Recorder */ "./src/js/figure/Recorder/Recorder.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







 // eslint-disable-next-line no-use-before-define
// export type TypeEquationNavigator = EquationNavigator;

function updateDescription(eqn, // subForm: string,
descriptionElement, index) {
  var setClicks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var prefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
  var element = descriptionElement;

  if (element == null) {
    return;
  }

  var form = null; // $FlowFixMe
  // form = eqn.eqn.formSeries[index][formType];
  // form = eqn.getForm(eqn.eqn.currentFormSeries[index], subForm);

  form = eqn.getCurrentForm();

  if (form == null) {
    return;
  }

  if (form.description == null) {
    if (element != null) {
      element.innerHTML = '';
    }

    return;
  }

  var monochrome = !setClicks;

  if (descriptionElement) {
    if (setClicks) {
      // eslint-disable-next-line no-param-reassign
      descriptionElement.innerHTML = _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["applyModifiers"]("".concat(prefix).concat(form.description), form.modifiers);
      _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["setOnClicks"](form.modifiers);
    } else {
      // eslint-disable-next-line no-param-reassign
      descriptionElement.innerHTML = _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_3__["applyModifiers"]("".concat(prefix).concat(form.description), form.modifiers, '', monochrome);
    }
  }
}

function enableTouch(element) {
  if (element) {
    element.classList.remove('figureone__eqn_nav__not_touchable');
  }
}

function disableTouch(element) {
  if (element) {
    element.classList.add('figureone__eqn_nav__not_touchable');
  }
}

function _updateButtons( // eslint-disable-next-line no-use-before-define
nav) {
  var includeNextPrevPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var nextPrefix = '';
  var prevPrefix = '';

  if (includeNextPrevPrefix) {
    nextPrefix = 'NEXT: ';
    prevPrefix = 'PREV: ';
  }

  var currentForm = nav.eqn.getCurrentForm();

  if (currentForm != null) {
    var index = nav.eqn.getFormIndex(currentForm);

    if (index === 0) {
      disableTouch(nav.refresh);
      disableTouch(nav.prev);
      disableTouch(nav.prevDescription);
      disableTouch(nav.description); // enableTouch(nav.nextDescription, true);
    } else {
      enableTouch(nav.refresh);
      enableTouch(nav.prev);
      enableTouch(nav.prevDescription);
      enableTouch(nav.description);
    }

    if (nav.eqn.eqn.currentFormSeries.length > 1) {
      enableTouch(nav.next);
      enableTouch(nav.nextDescription);

      if (nav.navType === '1Button') {
        enableTouch(nav.description);
      }
    } else {
      disableTouch(nav.next);
      disableTouch(nav.nextDescription);

      if (nav.navType === '1Button') {
        var next = nav.next;

        if (next) {
          next.classList.remove('figureone__eqn_nav__next_form');
          next.classList.remove('figureone__eqn_nav__reset');
          next.classList.remove('interactive_top_right');
        }
      }
    }

    var nextIndex = index + 1;

    if (nextIndex > nav.eqn.eqn.currentFormSeries.length - 1) {
      if (nav.nextDescription) {
        // eslint-disable-next-line no-param-reassign
        nav.nextDescription.innerHTML = 'RESTART from begining';
      }

      if (nav.navType === '1Button' && nav.eqn.eqn.currentFormSeries.length > 1) {
        var _next = nav.next;

        if (_next) {
          _next.classList.add('figureone__eqn_nav__reset');

          _next.classList.remove('figureone__eqn_nav__next_form');
        }
      }
    } else {
      updateDescription(nav.eqn, nav.nextDescription, nextIndex, false, nextPrefix);

      if (nav.navType === '1Button' && nav.eqn.eqn.currentFormSeries.length > 1) {
        var _next2 = nav.next;

        if (_next2) {
          _next2.classList.add('figureone__eqn_nav__next_form');

          _next2.classList.remove('figureone__eqn_nav__reset');
        }
      }
    }

    updateDescription(nav.eqn, nav.description, index, true); // nav.eqn.updateDescription(currentForm);

    var prevIndex = index - 1;

    if (prevIndex >= 0) {
      updateDescription(nav.eqn, nav.prevDescription, prevIndex, false, prevPrefix);
    } else if (nav.prevDescription) {
      // eslint-disable-next-line no-param-reassign
      nav.prevDescription.innerHTML = '';
    }
  }
} // eslint-disable-next-line no-use-before-define


function updateButtonsDescriptionOnly(nav) {
  var currentForm = nav.eqn.getCurrentForm();

  if (currentForm != null) {
    var index = nav.eqn.getFormIndex(currentForm);
    enableTouch(nav.description);
    updateDescription(nav.eqn, nav.description, index, true);
  }
}

// Nav3Line
function makeType3Line(prevMethod, refreshMethod, nextMethod, options) {
  var table = document.createElement('table');
  var prevGroup = document.createElement('tr');
  var currentGroup = document.createElement('tr');
  var nextGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var refresh = document.createElement('td');
  var next = document.createElement('td');
  var prevDescription = document.createElement('td');
  var description = document.createElement('td');
  var nextDescription = document.createElement('td');
  prevGroup.appendChild(prev);
  prevGroup.appendChild(prevDescription);
  nextGroup.appendChild(next);
  nextGroup.appendChild(nextDescription);
  currentGroup.appendChild(refresh);
  currentGroup.appendChild(description);
  table.appendChild(prevGroup);
  table.appendChild(currentGroup);
  table.appendChild(nextGroup);
  table.classList.add('figureone__eqn_nav__table');
  prevGroup.classList.add('figureone__eqn_nav__3line__prevRow');
  currentGroup.classList.add('figureone__eqn_nav__3line__currentRow');
  nextGroup.classList.add('figureone__eqn_nav__3line__nextRow');
  prev.classList.add('figureone__eqn_nav__3line__prevRow__button');
  refresh.classList.add('figureone__eqn_nav__3line__currentRow__button');
  next.classList.add('figureone__eqn_nav__3line__nextRow__button');
  prevDescription.classList.add('figureone__eqn_nav__3line__prevRow__description');
  description.classList.add('figureone__eqn_nav__3line__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  nextDescription.classList.add('figureone__eqn_nav__3line__nextRow__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // if (!Array.isArray(options)) {
  //   optionsToUse = [options];
  // }
  // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines) {
    prevGroup.classList.add('figureone__eqn_nav__3line__prev_twoLines');
    currentGroup.classList.add('figureone__eqn_nav__3line__current_twoLines');
    nextGroup.classList.add('figureone__eqn_nav__3line__next_twoLines');
  }

  prevGroup.onclick = prevMethod;
  currentGroup.onclick = refreshMethod;
  nextGroup.onclick = nextMethod;
  next.innerHTML = 'Next';
  prev.innerHTML = 'Prev';
  refresh.innerHTML = 'Refresh';
  return {
    table: table,
    prevGroup: prevGroup,
    currentGroup: currentGroup,
    nextGroup: nextGroup,
    prev: prev,
    refresh: refresh,
    next: next,
    prevDescription: prevDescription,
    description: description,
    nextDescription: nextDescription
  };
} // NavDescriptionOnly


function makeTypeDescriptionOnly(nextMethod) {
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var description = document.createElement('td');
  currentGroup.appendChild(description);
  table.appendChild(currentGroup);
  table.classList.add('figureone__eqn_nav__table');
  currentGroup.classList.add('figureone__eqn_nav__description_only__currentRow');
  description.classList.add('figureone__eqn_nav__description_only__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  currentGroup.onclick = nextMethod;
  return {
    table: table,
    currentGroup: currentGroup,
    description: description
  };
} // Nav1Button


function makeTypeOneButton(nextMethod) // options: TypeNavTypeOptions,  // can be: 'twoLines'
{
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var next = document.createElement('td');
  var description = document.createElement('td');
  currentGroup.appendChild(next);
  currentGroup.appendChild(description);
  table.appendChild(currentGroup);
  table.classList.add('figureone__eqn_nav__table');
  currentGroup.classList.add('figureone__eqn_nav__1button__currentRow');
  next.classList.add('figureone__eqn_nav__1button__button');
  description.classList.add('figureone__eqn_nav__1line__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  next.classList.add('interactive_top_right'); // const defaultOptions = {
  //   icons: true,
  // };
  // const optionsToUse = joinObjects({}, defaultOptions, options);

  next.onclick = nextMethod;
  description.onclick = nextMethod; // if (optionsToUse.icons) {

  next.classList.add('figureone__eqn_nav__next_form'); // }

  return {
    table: table,
    currentGroup: currentGroup,
    next: next,
    description: description
  };
} // Nav1Line


function makeType1Line(prevMethod, refreshMethod, nextMethod, options) // can be: 'twoLines'
{
  var table = document.createElement('table');
  var currentGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var next = document.createElement('td');
  var description = document.createElement('td');
  currentGroup.appendChild(prev);
  currentGroup.appendChild(description);
  currentGroup.appendChild(next);
  table.appendChild(currentGroup);
  table.classList.add('figureone__eqn_nav__table');
  currentGroup.classList.add('figureone__eqn_nav__1line__currentRow');
  prev.classList.add('figureone__eqn_nav__1line__prev__button');
  next.classList.add('figureone__eqn_nav__1line__next__button');
  description.classList.add('figureone__eqn_nav__1line__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines) {
    currentGroup.classList.add('figureone__eqn_nav__1line__current_twoLines');
  }

  prev.onclick = prevMethod;
  description.onclick = refreshMethod;
  next.onclick = nextMethod;

  if (optionsToUse.arrows) {
    var nextArrow = document.createElement('div');
    nextArrow.classList.add('figureone__eqn_nav__arrow_right');
    next.appendChild(nextArrow);
    var prevArrow = document.createElement('div');
    prevArrow.classList.add('figureone__eqn_nav__arrow_left');
    prev.appendChild(prevArrow);
  } else {
    next.innerHTML = 'Next';
    prev.innerHTML = 'Prev';
  }

  return {
    table: table,
    currentGroup: currentGroup,
    prev: prev,
    next: next,
    description: description
  };
} // Nav2Line


function makeType2Line(prevMethod, refreshMethod, nextMethod, options) {
  var table = document.createElement('table');
  var row = document.createElement('tr');
  var descriptionRows = document.createElement('tr');
  var currentGroup = document.createElement('tr');
  var prev = document.createElement('td');
  var next = document.createElement('td');
  var nextGroup = document.createElement('tr'); // const descriptionRows = document.createElement('td');
  // const descriptionRow = document.createElement('tr');
  // const nextDescriptionRow = document.createElement('tr');

  var description = document.createElement('td');
  var nextDescription = document.createElement('td');
  currentGroup.appendChild(description);
  nextGroup.appendChild(nextDescription);
  descriptionRows.appendChild(currentGroup);
  descriptionRows.appendChild(nextGroup);
  row.appendChild(prev);
  row.appendChild(descriptionRows);
  row.appendChild(next);
  table.appendChild(row);
  table.classList.add('figureone__eqn_nav__table');
  currentGroup.classList.add('figureone__eqn_nav__2lines__currentRow');
  nextGroup.classList.add('figureone__eqn_nav__2lines__nextRow');
  prev.classList.add('figureone__eqn_nav__2lines__prev__button');
  next.classList.add('figureone__eqn_nav__2lines__next__button');
  description.classList.add('figureone__eqn_nav__2lines__currentRow__description');
  description.classList.add('figureone__eqn_nav__description');
  nextDescription.classList.add('figureone__eqn_nav__2lines__nextRow__description');
  var defaultOptions = {
    forceTwoLines: false,
    arrows: false
  };
  var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // Use two lines to stop jittering when transitioning from one line to two
  // lines

  if (optionsToUse.forceTwoLines > -1) {
    currentGroup.classList.add('figureone__eqn_nav__2lines__current_twoLines');
  }

  prev.onclick = prevMethod;
  description.onclick = refreshMethod;
  next.onclick = nextMethod;
  nextDescription.onclick = nextMethod;

  if (optionsToUse.arrows) {
    var nextArrow = document.createElement('div');
    nextArrow.classList.add('figureone__eqn_nav__arrow_right');
    next.appendChild(nextArrow);
    var prevArrow = document.createElement('div');
    prevArrow.classList.add('figureone__eqn_nav__arrow_left');
    prev.appendChild(prevArrow);
  } else {
    next.innerHTML = 'Next';
    prev.innerHTML = 'Prev';
  }

  return {
    table: table,
    currentGroup: currentGroup,
    nextGroup: nextGroup,
    prev: prev,
    next: next,
    nextDescription: nextDescription,
    description: description
  };
}

// A Navigator is a FigureElementCollection that is a html table that has
// the possible html elements of:
//   next: a next form button
//   prev: a prev form button
//   refresh: a button that shows animation to current form again
//   description: description of current form
//   nextDescription: description of next form
//   prevDescription: description of prev form
//   nextGroup: a html parent that holds nextDescription and nextButton
//   prevGroup: a html parent that holds prevDescription and prevButton
//
// Equation navigators
// Extends equation
// export type Navigator = {
//   next: Element | TypeElementDefinition | TypeArrow,
//   prev: Element | TypeElementDefinition | TypeArrow,
//   description: Element | TypeTextLines,
//   type: 'equationOnly' | 'description' | '1Line' | '2LIne' | '3Line',
// }
var EqnNavigator = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(EqnNavigator, _FigureElementCollect);

  var _super = _createSuper(EqnNavigator);

  // setEquation: (Equation) => void;
  function EqnNavigator(shapes, // eqn: Equation,
  animateNextFrame) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, EqnNavigator);

    var defaultOptions = {
      offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      navType: 'twoLine',
      navTypeOptions: {
        forceTwoLines: false,
        arrows: false
      },
      xAlign: 'center',
      yAlign: 'middle',
      interactive: true,
      id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["generateUniqueId"])('id_figureone__equation_navigator_'),
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Eqn Nav').scale(1, 1).translate(0, 0),
      limits: shapes.limits
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options);
    _this = _super.call(this, optionsToUse); // super(shapes, eqnOptions);

    _this.shapes = shapes; // this.setEquation(equation);

    _this.prev = null;
    _this.next = null;
    _this.refresh = null;
    _this.description = null;
    _this.nextDescription = null;
    _this.prevDescription = null;
    _this.table = null;
    _this.prevGroup = null;
    _this.currentGroup = null;
    _this.nextGroup = null;
    _this.animateNextFrame = animateNextFrame;
    _this.recorder = new _Recorder_Recorder__WEBPACK_IMPORTED_MODULE_6__["Recorder"]();
    _this.options = optionsToUse;

    if (optionsToUse.equation != null) {
      // this.eqn = optionsToUse.equation;
      // this.eqn.onClick = this.clickNext.bind(this);
      // this.eqn.hasTouchableElements = true;
      // this.eqn.isTouchable = true;
      // this.eqn.touchInBoundingRect = true;
      _this.connectToEquation(optionsToUse.equation, optionsToUse.interactive);
    }

    _this.navType = optionsToUse.navType;
    var navigatorHTMLElement = null;

    if (_this.navType === '3Line') {
      navigatorHTMLElement = makeType3Line(_this.clickPrev.bind(_assertThisInitialized(_this)), _this.clickRefresh.bind(_assertThisInitialized(_this)), _this.clickNext.bind(_assertThisInitialized(_this)), optionsToUse.navTypeOptions);
    }

    if (_this.navType === 'description') {
      navigatorHTMLElement = makeTypeDescriptionOnly(_this.clickNext.bind(_assertThisInitialized(_this)));
    }

    if (_this.navType === '1Line') {
      navigatorHTMLElement = makeType1Line(_this.clickPrev.bind(_assertThisInitialized(_this)), _this.clickRefresh.bind(_assertThisInitialized(_this)), _this.clickNext.bind(_assertThisInitialized(_this)), optionsToUse.navTypeOptions);
    }

    if (_this.navType === '1Button') {
      navigatorHTMLElement = makeTypeOneButton(_this.clickNext.bind(_assertThisInitialized(_this)) // optionsToUse.navTypeOptions,
      );
    }

    if (_this.navType === '2Line') {
      navigatorHTMLElement = makeType2Line(_this.clickPrev.bind(_assertThisInitialized(_this)), _this.clickRefresh.bind(_assertThisInitialized(_this)), _this.clickNext.bind(_assertThisInitialized(_this)), optionsToUse.navTypeOptions);
    } // const eqnCollectionPosition = this.eqn.getPosition();


    if (navigatorHTMLElement != null) {
      var offsetToUse = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(optionsToUse.offset, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0));
      Object.assign(_assertThisInitialized(_this), navigatorHTMLElement);

      var table = _this.shapes.htmlElement(navigatorHTMLElement.table, "".concat(optionsToUse.id, "_table"), '', offsetToUse, optionsToUse.yAlign, optionsToUse.xAlign);

      _this.add('table', table);
    }

    return _this;
  }

  _createClass(EqnNavigator, [{
    key: "connectToEquation",
    value: function connectToEquation(eqn, interactive) {
      this.eqn = eqn;

      if (interactive) {
        this.eqn.onClick = this.clickNext.bind(this);
        this.eqn.hasTouchableElements = true;
        this.eqn.isTouchable = true; // this.eqn.touchInBoundingRect = true;
      } // this.setTransformCallback = () => {
      //   const p = this.getPosition();
      //   this.eqn.setPosition(p);
      // }

    } // const navigator = collections.collection(;
    // setEquation(eqn: Equation) {
    //   this.eqn = eqn;
    //   // this._eqn = [];
    //   this.add('eqn', eqn.collection);
    // }
    // setWidth(width) {
    // }

  }, {
    key: "clickNext",
    value: function clickNext() {
      if (this.onClick !== null && this.onClick !== undefined) {
        if (this.recorder.state === 'recording') {
          this.recorder.recordEvent('eqnNavClick', ['next', this.getPath()]);
        }

        this.fnMap.exec(this.onClick, this);
      }

      this.eqn.nextForm(1.5);
      this.updateButtons();
      this.animateNextFrame();
    }
  }, {
    key: "clickPrev",
    value: function clickPrev() {
      if (this.onClick !== null && this.onClick !== undefined) {
        if (this.recorder.state === 'recording') {
          this.recorder.recordEvent('eqnNavClick', ['prev', this.getPath()]);
        }

        this.fnMap.exec(this.onClick, this);
      }

      this.eqn.prevForm(1.5);
      this.updateButtons();
      this.animateNextFrame();
    }
  }, {
    key: "clickRefresh",
    value: function clickRefresh() {
      if (this.onClick !== null && this.onClick !== undefined) {
        if (this.recorder.state === 'recording') {
          this.recorder.recordEvent('eqnNavClick', ['refresh', this.getPath()]);
        }

        this.fnMap.exec(this.onClick, this);
      }

      var currentForm = this.eqn.getCurrentForm();

      if (currentForm != null) {
        var index = this.eqn.getFormIndex(currentForm);

        if (index > 0) {
          this.eqn.replayCurrentForm(1.5);
          this.animateNextFrame();
        }
      }

      this.updateButtons();
    }
  }, {
    key: "updateButtons",
    value: function updateButtons() {
      if (this.navType === 'equationOnly') {
        return;
      }

      if (this.navType === 'description') {
        updateButtonsDescriptionOnly(this);
      } else if (this.navType === '2Line') {
        _updateButtons(this, true);
      } else {
        _updateButtons(this);
      }
    }
  }, {
    key: "showForm",
    value: function showForm(formOrName) {
      this.show();
      this.eqn.showForm(formOrName); // this.showForm(formOrName, formType);

      if (this._table) {
        this._table.show();

        this.updateButtons();
      }
    }
  }]);

  return EqnNavigator;
}(_Element__WEBPACK_IMPORTED_MODULE_1__["FigureElementCollection"]);



/***/ }),

/***/ "./src/js/figure/FigureCollections/EquationLabel.js":
/*!**********************************************************!*\
  !*** ./src/js/figure/FigureCollections/EquationLabel.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EquationLabel; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Equation_Equation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Equation/Equation */ "./src/js/figure/Equation/Equation.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var DEBUG = false;

/**
 * Equation label
 */
var EquationLabel = /*#__PURE__*/function () {
  function EquationLabel(collections) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EquationLabel);

    var defaultOptions = {
      label: '',
      color: [0, 0, 1, 1],
      scale: 0.7,
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      xAlign: 'center',
      yAlign: 'middle'
    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, defaultOptions, options);
    var labelTextOrEquation = optionsToUse.label;
    var color = optionsToUse.color,
        scale = optionsToUse.scale,
        position = optionsToUse.position; // const { form } = optionsToUse;

    var yAlign = optionsToUse.yAlign,
        xAlign = optionsToUse.xAlign;
    var eqn;

    if (typeof labelTextOrEquation === 'string') {
      eqn = collections.equation({
        elements: {
          base: labelTextOrEquation
        },
        color: color,
        formDefaults: {
          alignment: {
            fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
            xAlign: xAlign,
            yAlign: yAlign
          }
        },
        scale: scale,
        forms: {
          base: ['base']
        },
        position: position
      });
      eqn.showForm('base');
    } else if (labelTextOrEquation instanceof _Equation_Equation__WEBPACK_IMPORTED_MODULE_2__["Equation"]) {
      eqn = labelTextOrEquation;
      eqn.showForm(Object.keys(eqn.eqn.forms)[0]);
    } else if (Array.isArray(labelTextOrEquation)) {
      var elements = {};
      var forms = {};
      var formSeries = [];
      labelTextOrEquation.forEach(function (labelText, index) {
        elements["_".concat(index)] = labelText;
        forms[index] = [labelText];
        formSeries.push("".concat(index));
      });
      eqn = collections.equation({
        elements: elements,
        forms: forms,
        color: color,
        position: position,
        formDefaults: {
          alignment: {
            fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
            xAlign: xAlign,
            yAlign: yAlign
          }
        },
        scale: scale,
        formSeries: formSeries
      });
      eqn.showForm('0');
    } else {
      var defaultEqnOptions = {
        color: color,
        formDefaults: {
          alignment: {
            fixTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
            xAlign: xAlign,
            yAlign: yAlign
          }
        },
        scale: scale // form,

      };
      eqn = collections.equation(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])(defaultEqnOptions, labelTextOrEquation)); // if (form == null) {

      eqn.showForm(Object.keys(eqn.eqn.forms)[0]);
    }

    this.eqn = eqn;
    this.width = 0;
    this.height = 0;
    this.aOffset = 0;
  } // TODO
  // setEqn() {
  // }


  _createClass(EquationLabel, [{
    key: "showForm",
    value: function showForm(formName) {
      this.eqn.showForm(formName);
    }
  }, {
    key: "setText",
    value: function setText(text) {
      var form = this.eqn.getCurrentForm();

      if (form != null) {
        var key = Object.keys(form.elements)[0]; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primitives
        // $FlowFixMe

        var textObject = form.elements[key].drawingObject;

        if (textObject != null) {
          textObject.setText(text); // $FlowFixMe

          form.elements[key].drawBorder = form.elements[key].drawingObject.textBorder; // $FlowFixMe

          form.elements[key].drawBorderBuffer = form.elements[key].drawingObject.textBorderBuffer;
        } // console.log(form)


        form.arrange(this.eqn.eqn.scale, this.eqn.eqn.formDefaults.alignment.xAlign, this.eqn.eqn.formDefaults.alignment.yAlign, this.eqn.eqn.formDefaults.alignment.fixTo);
      }
    }
  }, {
    key: "getText",
    value: function getText() {
      var textToReturn = '';
      var form = this.eqn.getCurrentForm();

      if (form != null) {
        var key = Object.keys(form.elements)[0]; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primitives
        // $FlowFixMe

        var textObject = form.elements[key].drawingObject; // This is ok to fix for flow because all the elements of the
        // simple equation created by Equationlabel will be Primitives
        // that are text objects

        if (textObject != null) {
          // $FlowFixMe
          textToReturn = textObject.text[0].text;
        }
      }

      return textToReturn;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "updateRotation",
    value: function updateRotation(position, lineAngle, offsetMag, location, subLocation, orientation) {
      var parentAngleOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var style = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'oval';
      var relativeToLine = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;
      var startThetaAngle = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : Math.PI * 2;
      var endThetaAngle = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : Math.PI;
      // Calculate the offsetAngle and label angle
      var offsetAngle = Math.PI / 2;
      var labelAngle = 0;

      if (location === 'start') {
        offsetAngle = -Math.PI;
      } else if (location === 'end') {
        offsetAngle = 0;
      } else {
        var offsetTop = Math.cos(lineAngle + parentAngleOffset) < 0 ? -Math.PI / 2 : Math.PI / 2;
        var offsetBottom = -offsetTop;
        var offsetLeft = Math.sin(lineAngle + parentAngleOffset) > 0 ? Math.PI / 2 : -Math.PI / 2;
        var offsetRight = -offsetLeft;

        if (location === 'top') {
          offsetAngle = offsetTop;
        }

        if (location === 'bottom') {
          offsetAngle = offsetBottom;
        }

        if (location === 'right') {
          offsetAngle = offsetRight;
        }

        if (location === 'left') {
          offsetAngle = offsetLeft;
        }

        if (location === 'positive') {
          offsetAngle = Math.PI / 2;
        }

        if (location === 'negative') {
          offsetAngle = -Math.PI / 2;
        }

        if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(Math.sin(lineAngle + parentAngleOffset), 4) === 0 && (location === 'left' || location === 'right')) {
          if (subLocation === 'top') {
            offsetAngle = offsetTop;
          }

          if (subLocation === 'bottom') {
            offsetAngle = offsetBottom;
          }
        }

        if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(Math.cos(lineAngle + parentAngleOffset), 4) === 0 && (location === 'top' || location === 'bottom')) {
          if (subLocation === 'right') {
            offsetAngle = offsetRight;
          }

          if (subLocation === 'left') {
            offsetAngle = offsetLeft;
          }
        }

        if (location === 'inside') {
          offsetAngle = -Math.PI / 2;
        }

        if (location === 'outside') {
          offsetAngle = Math.PI / 2;
        }
      }

      var parentAngle = parentAngleOffset;

      if (orientation === 'horizontal') {
        labelAngle = -lineAngle;
      }

      if (orientation === 'baseToLine') {
        parentAngle = 0;
        labelAngle = 0;

        if (offsetAngle < 0) {
          labelAngle = Math.PI;
        }
      }

      if (orientation === 'baseAway') {
        parentAngle = 0;
        labelAngle = Math.PI;

        if (offsetAngle < 0) {
          labelAngle = 0;
        }
      }

      if (orientation === 'upright') {
        parentAngle = 0;

        if (Math.cos(lineAngle + parentAngleOffset) < 0) {
          labelAngle = Math.PI;
        }
      } // half height and width of text


      var h = 0;
      var w = 0;
      var currentForm = this.eqn.getCurrentForm();
      var change = false;

      if (currentForm != null) {
        if (this.height !== currentForm.height) {
          this.height = currentForm.height;
          change = true;
        }

        if (this.width !== currentForm.width) {
          this.width = currentForm.width;
          change = true;
        }

        h = currentForm.height / 2;
        w = currentForm.width / 2;
      }

      var positionOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (style === 'oval') {
        positionOffset = this.getOvalOffset(labelAngle - parentAngle, h, w, offsetMag, offsetAngle, change, location, startThetaAngle, endThetaAngle);
      }

      var p;
      var r;
      p = position.add(positionOffset);
      r = labelAngle - parentAngle;

      if (relativeToLine === false) {
        p = position.add(positionOffset).rotate(lineAngle, position);
        r = labelAngle - parentAngle + lineAngle;
      }

      this.eqn.setPosition(p);
      this.eqn.transform.updateRotation(r);

      if (DEBUG) {
        // $FlowFixMe
        var e = this.eqn.parent._debugEllipse;

        if (e != null) {
          e.setPosition(p);
          e.setRotation(r);
        }
      }
    }
  }, {
    key: "getOvalOffset",
    value: function getOvalOffset(labelAngle, h, w, offsetMag, offsetAngle, change, location) {
      var startThetaAngle = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI * 2;
      var endThetaAngle = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Math.PI;

      // eslint-disable-next-line max-len
      var getR = function getR(a, b, angle) {
        return a * b / Math.sqrt(Math.pow(b * Math.cos(angle), 2) + Math.pow(a * Math.sin(angle), 2));
      }; // Create an oval around the label by:
      // * Find top corner of label
      // * Find distance (R) and angle to top corner
      // * The oval must go through this top corner
      // * Find 'a' and 'b' of the oval so that 'a' and 'b' are the width and
      //   height with the same offset (a = w + o), (b = h + o)
      // * To find 'o', make an oval with o = offsetMag and see how close
      //   its topCorner R is to the reference.
      // * If it doesn't reach the top corner reference, then step o in fifths
      //   of the delta until either 10 steps have occured, or the top corner
      //   is covered.


      if (change) {
        var topCornerAngle = Math.atan(h / w);
        var topCornerR = h / Math.sin(topCornerAngle) + offsetMag;
        var delta = topCornerR - getR(w + offsetMag, h + offsetMag, topCornerAngle);
        var i = 2;
        var testR = -1;
        var ovalOffset = 0;

        while (i < 33 && testR < topCornerR) {
          ovalOffset = delta * i * 0.1 + offsetMag;
          testR = getR(w + ovalOffset, h + ovalOffset, topCornerAngle);
          i += 1;
        }

        this.aOffset = ovalOffset;
      }

      var a = this.aOffset + w;
      var b = this.aOffset + h;
      var phi = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(labelAngle, '0to360');
      var theta;
      var xOffset = 0;
      var yOffset = 0;
      var R;

      if (location === 'start') {
        theta = startThetaAngle - phi;
        R = getR(a, b, theta);
        xOffset = -R * Math.cos(startThetaAngle);
        yOffset = -R * Math.sin(startThetaAngle);
      } else if (location === 'end') {
        theta = endThetaAngle - phi;
        R = getR(a, b, theta);
        xOffset = -R * Math.cos(endThetaAngle);
        yOffset = -R * Math.sin(endThetaAngle);
      } else {
        // Calculate the position
        // Refer to oval_math.pdf for working
        theta = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(Math.PI * 2 - Math.atan(-Math.pow(b, 2) / (Math.pow(a, 2) * Math.tan(phi))), '0to360');
        R = getR(a, b, theta);
        var sigma = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(phi + theta - Math.PI, '-180to180');

        if (sigma < 0) {
          sigma += Math.PI;
        }

        xOffset = R * Math.cos(sigma);
        yOffset = R * Math.sin(sigma);

        if (offsetAngle < 0) {
          yOffset = -yOffset;
          xOffset = -xOffset;
        }
      } // DEBUG ONLY


      if (DEBUG) {
        if (this.eqn.parent != null) {
          // $FlowFixMe
          if (this.eqn.parent._debugEllipse == null) {
            var _e = this.eqn.shapes.ellipse({
              width: 1,
              height: 0.5,
              color: [0, 0, 1, 0.6],
              sides: 50
            }); // $FlowFixMe


            this.eqn.parent.add('debugEllipse', _e);
          } // $FlowFixMe


          var e = this.eqn.parent._debugEllipse;

          if (e != null) {
            e.custom.update({
              width: a * 2,
              height: b * 2
            });
          }
        }
      }

      if (offsetMag === 0) {
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      }

      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xOffset, yOffset);
    }
  }]);

  return EquationLabel;
}();



/***/ }),

/***/ "./src/js/figure/FigureCollections/FigureCollections.js":
/*!**************************************************************!*\
  !*** ./src/js/figure/FigureCollections/FigureCollections.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FigureCollections; });
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DrawContext2D */ "./src/js/figure/DrawContext2D.js");
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Line */ "./src/js/figure/FigureCollections/Line.js");
/* harmony import */ var _Angle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Angle */ "./src/js/figure/FigureCollections/Angle.js");
/* harmony import */ var _PolyLine__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PolyLine */ "./src/js/figure/FigureCollections/PolyLine.js");
/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Axis */ "./src/js/figure/FigureCollections/Axis.js");
/* harmony import */ var _Trace__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Trace */ "./src/js/figure/FigureCollections/Trace.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/figure/FigureCollections/EquationLabel.js");
/* harmony import */ var _Plot__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Plot */ "./src/js/figure/FigureCollections/Plot.js");
/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Legend */ "./src/js/figure/FigureCollections/Legend.js");
/* harmony import */ var _Rectangle__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Rectangle */ "./src/js/figure/FigureCollections/Rectangle.js");
/* harmony import */ var _Equation_Equation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Equation/Equation */ "./src/js/figure/Equation/Equation.js");
/* harmony import */ var _EqnNavigator__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./EqnNavigator */ "./src/js/figure/FigureCollections/EqnNavigator.js");
/* harmony import */ var _SlideNavigator__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SlideNavigator */ "./src/js/figure/FigureCollections/SlideNavigator.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // import {
//   FigureElementCollection,
// } from '../Element';

 // import EquationNavigator from './EquationNavigator';


 // eslint-disable-next-line import/no-cycle













// import { Equation } from '../Equation/Equation';

/**
 * Built in figure collections.
 *
 * Provides advanced primitives the specific methods, animations and interactivity.
 */
var FigureCollections = /*#__PURE__*/function () {
  // equationFromFig: Object;

  /**
    * @hideconstructor
    */
  function FigureCollections(primitives, // equation: Object,
  isTouchDevice, animateNextFrame) {
    _classCallCheck(this, FigureCollections);

    this.webgl = primitives.webgl;
    this.draw2D = primitives.draw2D;
    this.limits = primitives.limits;
    this.primitives = primitives;
    this.isTouchDevice = isTouchDevice;
    this.animateNextFrame = animateNextFrame; // this.equationFromFig = equation;
  }
  /**
   * Create a {@link FigureElementCollection}.
   */


  _createClass(FigureCollections, [{
    key: "collection",
    value: function collection() {
      var transformOrPointOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]('collection').scale(1, 1).rotate(0).translate(0, 0),
        border: 'children',
        touchBorder: 'children',
        holeBorder: 'children',
        color: this.primitives.defaultColor,
        parent: null,
        limits: this.limits
      };
      var optionsToUse;

      for (var _len = arguments.length, moreOptions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        moreOptions[_key - 1] = arguments[_key];
      }

      if (transformOrPointOrOptions instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Point"]) {
        defaultOptions.transform.updateTranslation(transformOrPointOrOptions);
        optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(moreOptions));
      } else if (transformOrPointOrOptions instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Transform"]) {
        defaultOptions.transform = transformOrPointOrOptions._dup();
        optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(moreOptions));
      } else {
        optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}, defaultOptions, transformOrPointOrOptions].concat(moreOptions));
      } // if (optionsToUse.border != null) {
      //   optionsToUse.border = getBorder(optionsToUse.border);
      // }
      // if (optionsToUse.touchBorder != null) {
      //   optionsToUse.touchBorder = getBorder(optionsToUse.touchBorder);
      // }
      // if (optionsToUse.holeBorder != null) {
      //   optionsToUse.holeBorder = getBorder(optionsToUse.holeBorder);
      // }
      // console.log(optionsToUse.transform, transformOrPointOrOptions)


      var element = new _Element__WEBPACK_IMPORTED_MODULE_16__["FigureElementCollection"](optionsToUse);
      element.dimColor = this.primitives.defaultDimColor.slice(); // console.log(element)
      // element.setColor(color);

      if (optionsToUse.pulse != null && typeof element.pulseDefault !== 'function' && typeof element.pulseDefault !== 'string') {
        element.pulseDefault.scale = optionsToUse.pulse;
      }

      element.collections = this;
      return element;
    }
    /**
     * Create a {@link CollectionsLine}.
     */

  }, {
    key: "line",
    value: function line() {
      for (var _len2 = arguments.length, options = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        options[_key2] = arguments[_key2];
      }

      // const optionsToUse = Object.assign({}, ...options);
      // console.log(Object.assign({}, ...options))
      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _Line__WEBPACK_IMPORTED_MODULE_4__["default"](this, this.isTouchDevice, optionsToUse);
    }
    /**
     * Create a {@link CollectionsAngle}.
     */

  }, {
    key: "angle",
    value: function angle() {
      for (var _len3 = arguments.length, options = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        options[_key3] = arguments[_key3];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _Angle__WEBPACK_IMPORTED_MODULE_5__["default"](this, this.isTouchDevice, this.animateNextFrame, optionsToUse);
    }
  }, {
    key: "label",
    value: function label() {
      for (var _len4 = arguments.length, options = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        options[_key4] = arguments[_key4];
      }

      // const optionsToUse = Object.assign({}, ...options);
      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _EquationLabel__WEBPACK_IMPORTED_MODULE_9__["default"](this, optionsToUse);
    }
    /**
     * Create a {@link CollectionsPolyline}.
     */

  }, {
    key: "polyline",
    value: function polyline() {
      for (var _len5 = arguments.length, options = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        options[_key5] = arguments[_key5];
      }

      var optionsToUse = _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options));
      return new _PolyLine__WEBPACK_IMPORTED_MODULE_6__["default"](this, this.isTouchDevice, this.animateNextFrame, optionsToUse);
    }
    /**
     * Create a {@link CollectionsRectangle}.
     */

  }, {
    key: "rectangle",
    value: function rectangle() {
      for (var _len6 = arguments.length, options = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        options[_key6] = arguments[_key6];
      }

      return new _Rectangle__WEBPACK_IMPORTED_MODULE_12__["default"](this, _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options)));
    }
    /**
     * Create a {@link CollectionSlideNavigator}
     */

  }, {
    key: "slideNavigator",
    value: function slideNavigator() {
      for (var _len7 = arguments.length, options = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        options[_key7] = arguments[_key7];
      }

      return new _SlideNavigator__WEBPACK_IMPORTED_MODULE_15__["default"](this, _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options)));
    }
    /**
     * Create a {@link CollectionsAixs}.
     */

  }, {
    key: "axis",
    value: function axis() {
      for (var _len8 = arguments.length, options = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        options[_key8] = arguments[_key8];
      }

      return new _Axis__WEBPACK_IMPORTED_MODULE_7__["default"](this, _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options)));
    }
    /**
     * Create a {@link CollectionsTrace}.
     */

  }, {
    key: "trace",
    value: function trace() {
      for (var _len9 = arguments.length, options = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        options[_key9] = arguments[_key9];
      }

      return new _Trace__WEBPACK_IMPORTED_MODULE_8__["default"](this, _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options)));
    }
    /**
     * Create a {@link CollectionsPlot}.
     */

  }, {
    key: "plot",
    value: function plot() {
      for (var _len10 = arguments.length, options = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        options[_key10] = arguments[_key10];
      }

      return new _Plot__WEBPACK_IMPORTED_MODULE_10__["default"](this, _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options)));
    }
    /**
     * Create a {@link CollectionsLegend}.
     */

  }, {
    key: "plotLegend",
    value: function plotLegend() {
      for (var _len11 = arguments.length, options = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        options[_key11] = arguments[_key11];
      }

      return new _Legend__WEBPACK_IMPORTED_MODULE_11__["default"](this, _tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"].apply(void 0, [{}].concat(options)));
    }
    /**
     * Create a {@link Equation}.
     */

  }, {
    key: "equation",
    value: function equation(options) {
      var equation = new _Equation_Equation__WEBPACK_IMPORTED_MODULE_13__["Equation"](this.primitives, options);
      return equation;
    }
  }, {
    key: "addEquation",
    value: function addEquation(parent, name) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      // $FlowFixMe
      var equation = new _Equation_Equation__WEBPACK_IMPORTED_MODULE_13__["Equation"](this.primitives, options);
      parent.add(name, equation);
      return equation;
    }
  }, {
    key: "addNavigator",
    value: function addNavigator(parent, name, options) {
      var navNameToUse = name;
      var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, options);

      if (optionsToUse.equation == null) {
        // $FlowFixMe
        var equation = this.addEquation(parent, "".concat(name, "Eqn"), options);
        optionsToUse.equation = equation;
        navNameToUse = "".concat(name, "Nav");
      } else if (!(optionsToUse.equation instanceof _Equation_Equation__WEBPACK_IMPORTED_MODULE_13__["Equation"])) {
        // let methodPathToUse;
        var nameToUse; // let pathToUse;

        var eqnOptions;
        var elementModsToUse; // let addElementsToUse;

        var firstScenario;

        if (Array.isArray(optionsToUse.equation)) {
          var _optionsToUse$equatio = _slicedToArray(optionsToUse.equation, 7);

          nameToUse = _optionsToUse$equatio[1];
          eqnOptions = _optionsToUse$equatio[3];
          elementModsToUse = _optionsToUse$equatio[4];
          firstScenario = _optionsToUse$equatio[6];
        } else {
          nameToUse = optionsToUse.equation.name; // pathToUse = optionsToUse.equation.path;

          eqnOptions = optionsToUse.equation.options; // methodPathToUse = optionsToUse.equation.method;

          elementModsToUse = optionsToUse.equation.mods;
          firstScenario = optionsToUse.equation.scenario;
        }

        var _equation;

        if (Array.isArray(eqnOptions)) {
          _equation = this.addEquation.apply(this, [parent, nameToUse].concat(_toConsumableArray(eqnOptions)));
        } else {
          _equation = this.addEquation(parent, nameToUse, eqnOptions);
        }

        if (elementModsToUse != null && elementModsToUse !== {}) {
          _equation.setProperties(elementModsToUse);
        }

        if (firstScenario != null && firstScenario in _equation.scenarios) {
          _equation.setScenario(firstScenario);
        }

        optionsToUse.equation = _equation;
      } // $FlowFixMe


      var navigator = new _EqnNavigator__WEBPACK_IMPORTED_MODULE_14__["default"](this.primitives, this.animateNextFrame, optionsToUse);
      parent.add(navNameToUse, navigator);
      return navigator;
    }
  }, {
    key: "cursor",
    value: function cursor(optionsIn) {
      var defaultOptions = {
        color: this.primitives.defaultColor,
        width: 0.01,
        radius: 0.05
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])(defaultOptions, optionsIn);
      var cursor = this.collection();
      var polygon = {
        width: options.width,
        color: options.color,
        radius: options.radius,
        sides: 50
      };
      var up = this.primitives.polygon(polygon);
      var down = this.primitives.polygon(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, polygon));
      cursor.add('up', up);
      cursor.add('down', down);
      return cursor;
    }
  }]);

  return FigureCollections;
}();



/***/ }),

/***/ "./src/js/figure/FigureCollections/Legend.js":
/*!***************************************************!*\
  !*** ./src/js/figure/FigureCollections/Legend.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import Figure from '../Figure';

// import {
//   round,
// } from '../../tools/math';



/*
................##.......########..######...########.##....##.########.
................##.......##.......##....##..##.......###...##.##.....##
................##.......##.......##........##.......####..##.##.....##
................##.......######...##...####.######...##.##.##.##.....##
................##.......##.......##....##..##.......##..####.##.....##
................##.......##.......##....##..##.......##...###.##.....##
................########.########..######...########.##....##.########.
*/

/**
 * {@link FigureElementCollection} representing an legend.
 *
 * ![](./apiassets/advlegend_ex1.png)
 * ![](./apiassets/advlegend_ex2.png)
 *
 * ![](./apiassets/advlegend_ex3.png)
 * ![](./apiassets/advlegend_ex4.png)
 *
 * ![](./apiassets/advlegend_ex5.png)
 *
 * This object defines a legend in an {@link CollectionsPlot}.
 *
 * The legend includes traces, trace names and a frame. Each can be customized
 * using the {@link COL_PlotLegend} options object.
 *
 * To test examples below, append them to the
 * <a href="#drawing-boilerplate">boilerplate</a>.
 *
 * All examples below also use this power function to generate the traces:
 * ```javascript
 * const pow = (pow = 2, stop = 10, step = 0.05) => {
 *   const xValues = Fig.tools.math.range(0, stop, step);
 *   return xValues.map(x => new Fig.Point(x, x ** pow));
 * }
 * ```
 *
 * @example
 * // By default, the legend will appear in the top right corner
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: [
 *       { points: pow(2), name: 'Power 2' },
 *       { points: pow(2.5), name: 'Power 2.5' },
 *       {
 *         points: pow(3, 10, 0.5),
 *         name: 'Power 3',
 *         markers: { radius: 0.03, sides: 10 },
 *       },
 *     ],
 *     legend: true,
 *   },
 * });
 *
 * @example
 * // Change the line length, position and use a frame on the legend
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: [
 *       { points: pow(2), name: 'Power 2' },
 *       { points: pow(2.5), name: 'Power 2.5' },
 *       {
 *         points: pow(3, 10, 0.5),
 *         name: 'Power 3',
 *         markers: { radius: 0.03, sides: 10 },
 *       },
 *     ],
 *     legend: {
 *       length: 0.5,
 *       frame: [0.95, 0.95, 0.95, 1],
 *       position: [0.2, 1.8],
 *     },
 *   },
 * });
 *
 * @example
 * // Make a horizontal legend
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: [
 *       { points: pow(2), name: 'Power 2' },
 *       { points: pow(2.5), name: 'Power 2.5' },
 *       {
 *         points: pow(3, 10, 0.5),
 *         name: 'Power 3',
 *         markers: { radius: 0.03, sides: 10 },
 *       },
 *     ],
 *     legend: {
 *       offset: [0.9, 0],
 *       position: [-0.3, -0.5],
 *       frame: {
 *         line: { width: 0.005 },
 *         corner: { radius: 0.05, sides: 10 },
 *       },
 *     },
 *   },
 * });
 *
 * @example
 * // Customize legend trace text
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: [
 *       { points: pow(2), name: 'Power 2' },
 *       { points: pow(2.5), name: 'Power 2.5' },
 *       {
 *         points: pow(3, 10, 0.5),
 *         name: 'Power 3',
 *         markers: { radius: 0.03, sides: 10 },
 *       },
 *     ],
 *     legend: {
 *       offset: [0, -0.2],
 *       custom: {
 *         1: {
 *           font: { size: 0.1, style: 'italic', color: [1, 0, 0, 1] },
 *           text: {
 *             text: [
 *               'Power 2.5',
 *               {
 *                 text: 'Reference Trace',
 *                 font: { size: 0.06 },
 *                 lineSpace: 0.06,
 *               },
 *             ],
 *             justify: 'left',
 *           },
 *         },
 *       },
 *     },
 *   },
 * });
 *
 * @example
 * // Customize legend
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: [
 *       { points: pow(2), name: 'Power 2' },
 *       { points: pow(2.5), name: 'Power 2.5' },
 *       {
 *         points: pow(3, 10, 0.5),
 *         name: 'Power 3',
 *         markers: { radius: 0.03, sides: 10 },
 *       },
 *     ],
 *     legend: {
 *       fontColorIsLineColor: true,
 *       length: 0,
 *       custom: {
 *         0: { position: [2, 0.2] },
 *         1: { position: [2, 0.7] },
 *         'Power 3': { position: [2, 2] },
 *       }
 *     },
 *   },
 * });
 */
// $FlowFixMe
var CollectionsPlotLegend = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsPlotLegend, _FigureElementCollect);

  var _super = _createSuper(CollectionsPlotLegend);

  // Figure elements
  // _axis: ?CollectionsAxis;
  // _majorTicks: ?FigureElementPrimitive;
  // _minorTicks: ?FigureElementPrimitive;
  // _labels: ?FigureElementPrimitive;
  // _arrow1: ?FigureElementPrimitive;
  // _arrow2: ?FigureElementPrimitive;

  /**
   * @hideconstructor
   */
  function CollectionsPlotLegend(collections, optionsIn) {
    var _this;

    _classCallCheck(this, CollectionsPlotLegend);

    var defaultOptions = {
      font: collections.primitives.defaultFont,
      color: collections.primitives.defaultColor,
      fontColorIsLineColor: false,
      frame: false,
      custom: {},
      length: collections.primitives.defaultLength / 10,
      space: 0.05,
      position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('PlotLegend').scale(1, 1).rotate(0).translate(0, 0),
      limits: collections.primitives.limits
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
    _this = _super.call(this, options);

    _this.setPosition(0, 0);

    _this.collections = collections;
    _this.defaultFont = options.font;
    _this.defaultColor = options.color;
    _this.traces = options.traces;
    _this.toShow = _this.getTracesToShow(options);
    _this.offset = _this.getOffset(options);

    _this.addTraces(options);

    if (options.frame != null && options.frame !== false) {
      _this.addFrame(options.frame);

      _this.toBack('frame');
    }

    return _this;
  }

  _createClass(CollectionsPlotLegend, [{
    key: "getTraceIndex",
    value: function getTraceIndex(name) {
      if (typeof name === 'number') {
        return name;
      }

      for (var i = 0; i < this.traces.length; i += 1) {
        if (name === this.traces[i].name) {
          return i;
        }
      }

      return -1;
    }
  }, {
    key: "getTracesToShow",
    value: function getTracesToShow(o) {
      var _this2 = this;

      var toShow = _toConsumableArray(Array(this.traces.length).keys());

      if (o.show) {
        toShow = [];
        var showToUse = o.show;

        if (typeof showToUse === 'number') {
          showToUse = [showToUse];
        }

        showToUse.forEach(function (index) {
          var traceIndex = _this2.getTraceIndex(index);

          if (traceIndex !== -1) {
            toShow.push(traceIndex);
          }
        });
      }

      if (o.hide) {
        var hideToUse = o.hide;

        if (typeof hideToUse === 'number') {
          hideToUse = [hideToUse];
        }

        hideToUse.forEach(function (index) {
          var traceIndex = _this2.getTraceIndex(index);

          if (traceIndex !== -1 && toShow.indexOf(traceIndex) !== -1) {
            toShow.splice(traceIndex, 1);
          }
        });
      }

      return toShow;
    }
  }, {
    key: "getOffset",
    value: function getOffset(o) {
      var offsetArray = [];
      var offset = o.offset;

      if (offset == null) {
        offset = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, -this.defaultFont.size * 1.5)];
      }

      offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(offset);

      for (var i = 0; i < this.toShow.length; i += 1) {
        offsetArray.push(offset[i % offset.length]._dup());
      }

      return offsetArray;
    }
  }, {
    key: "addTraces",
    value: function addTraces(o) {
      var _this3 = this;

      var p = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      this.toShow.forEach(function (traceIndex, index) {
        var trace = _this3.traces[traceIndex]; // Get any trace specific customizations

        var custom = {}; // $FlowFixMe

        if (o.custom["".concat(index)] != null) {
          // $FlowFixMe
          custom = o.custom["".concat(index)]; // $FlowFixMe
        } else if (o.custom[trace.name] != null) {
          custom = o.custom[trace.name];
        }

        if (index === 0 && custom.position == null) {
          custom.position = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.position || [0, 0]);
        } // Trace specific options


        var oTrace = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
          length: o.length,
          font: o.font,
          fontColorIsLineColor: o.fontColorIsLineColor,
          offset: _this3.offset[index],
          space: o.space,
          text: trace.name
        }, custom); // Get final position of trace start

        if (oTrace.position != null) {
          p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(oTrace.position);
        } else {
          p = p.add(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(oTrace.offset));
        } // Add trace line (if exists)


        if (oTrace.length > 0 && trace.line != null) {
          var oLine = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, trace.line, {
            p1: p,
            length: oTrace.length,
            angle: 0
          });

          var line = _this3.collections.primitives.line(oLine);

          _this3.add("line".concat(traceIndex), line);
        } // Add trace marker (if exists)


        if (oTrace.length > 0 && trace.markers != null) {
          var oMarker = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, trace.markers, {
            position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p.x + oTrace.length / 2, p.y),
            // $FlowFixMe
            copy: trace.markers.copy.slice(0, -1)
          });

          var marker = _this3.collections.primitives.polygon(oMarker);

          _this3.add("marker".concat(traceIndex), marker);
        } // Add trace text


        var textOptions = {
          font: _this3.defaultFont,
          justify: 'center',
          xAlign: 'left',
          yAlign: 'middle',
          position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p.x + oTrace.length + oTrace.space, p.y)
        };

        if (custom.font != null) {
          textOptions.font = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, textOptions.font, custom.font);
        }

        var textOptionsToUse = oTrace.text;

        if (typeof oTrace.text === 'string') {
          textOptionsToUse = {
            text: [oTrace.text]
          };
        }

        if (typeof custom.text === 'string') {
          // $FlowFixMe
          custom.text = {
            text: [custom.text]
          };
        }

        var colorOverride = {};

        if (o.fontColorIsLineColor) {
          colorOverride = {
            font: {
              color: trace.color.slice()
            }
          };
        }

        var oText = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, textOptions, colorOverride, textOptionsToUse, custom.text); // o.offset = getPoint(o.offset);

        var traceName = _this3.collections.primitives.textLines(oText);

        _this3.add("trace".concat(traceIndex), traceName);
      });
    }
  }, {
    key: "addFrame",
    value: function addFrame(optionsIn) {
      var o = optionsIn;

      if (optionsIn === true) {
        o = {};
      } else if (Array.isArray(optionsIn)) {
        o = {
          fill: optionsIn
        };
      } // const bounds = this.getBoundingRect('draw');


      var defaultFrameOptions = {
        // space: Math.min(bounds.width, bounds.height) / 20,
        space: this.defaultFont.size // line: { width: 0.01 },

      };

      if (optionsIn.line == null && optionsIn.fill == null) {
        // $FlowFixMe
        defaultFrameOptions.line = {
          width: 0.01
        };
      }

      var oFrame = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultFrameOptions, o);

      if (oFrame.line != null && oFrame.line.color == null) {
        oFrame.line.color = this.defaultColor.slice();
      }

      var frame = this.collections.rectangle(oFrame);
      frame.surround(this, oFrame.space);
      this.add('frame', frame);
    } // _getStateProperties(options: Object) {  // eslint-disable-line class-methods-use-this
    //   return [...super._getStateProperties(options),
    //     'angle',
    //     'lastLabelRotationOffset',
    //   ];
    // }
    // _fromState(state: Object) {
    //   joinObjects(this, state);
    //   this.setAngle({
    //     angle: this.angle,
    //     rotationOffset: this.lastLabelRotationOffset,
    //   });
    //   return this;
    // }

  }]);

  return CollectionsPlotLegend;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (CollectionsPlotLegend);

/***/ }),

/***/ "./src/js/figure/FigureCollections/Line.js":
/*!*************************************************!*\
  !*** ./src/js/figure/FigureCollections/Line.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CollectionsLine; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _EquationLabel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EquationLabel */ "./src/js/figure/FigureCollections/EquationLabel.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Equation_Equation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Equation/Equation */ "./src/js/figure/Equation/Equation.js");
/* harmony import */ var _geometries_arrow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geometries/arrow */ "./src/js/figure/geometries/arrow.js");
/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Animation/Animation */ "./src/js/figure/Animation/Animation.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import Figure from '../Figure';
 // import {
//   mul,
// } from '../../tools/m2';




// import type { TypeLabelEquationOptions } from './EquationLabel';





// Line is a class that manages:
//   A straight line
//   Arrows
//   Label
//   Future: Dimension posts
//
// In the straight line draw space, the line is defined from 0,0 to 1,0 if
// solid, and 0,0 to maxLength,0 if dashed. The length is changed by scaling
// the solid line, and changing the number of points drawn for the dashed line.
// The straight line position transform is then used to position the horiztonal
// line to make its 'start', 'center', 'end' or number align at (0, 0).
//
// Arrows are defined in draw space so their tip is at (0, 0). Their position
// transform then places their tips at p1 and p2 of the line.
//
var LineLabel = /*#__PURE__*/function (_EquationLabel) {
  _inherits(LineLabel, _EquationLabel);

  var _super = _createSuper(LineLabel);

  function LineLabel(collections, labelText, color, offset) {
    var _this;

    var location = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'top';
    var subLocation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'left';
    var orientation = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'horizontal';
    var linePosition = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0.5;
    var scale = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0.7;
    var precision = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 1;

    _classCallCheck(this, LineLabel);

    _this = _super.call(this, collections, {
      label: labelText,
      color: color,
      scale: scale
    });
    _this.offset = offset;
    _this.location = location;
    _this.subLocation = subLocation;
    _this.orientation = orientation;
    _this.linePosition = linePosition;
    _this.precision = precision;
    return _this;
  }

  return LineLabel;
}(_EquationLabel__WEBPACK_IMPORTED_MODULE_3__["default"]);

function makeStraightLine(primitives, length, width, color, dash) {
  // $FlowFixMe
  var straightLine = primitives.line({
    p1: [0, 0],
    length: dash.length < 2 ? 1 : length,
    angle: 0,
    width: width,
    color: color,
    dash: dash,
    transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(0, 0) // touchBorder,

  });
  return straightLine;
}

function getLineFromOptions(options) {
  var defaultOptions = {
    p1: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
    length: 1,
    angle: 0,
    align: 'start',
    offset: 0
  };
  var line;
  var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options);

  if (o.p1 != null && o.p2 != null) {
    line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](o.p1, o.p2);
  } else {
    line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](o.p1, o.length, o.angle);
  }

  if (o.offset !== 0) {
    line = line.offset('positive', o.offset);
  }

  return line;
}
/**
 * Grow line animation step.
 *
 * @property {number} [start] line length to grow from (`current length`)
 * @property {number} [target] line length to grow to (`current length`)
 * @extends OBJ_CustomAnimationStep
 */


/*
...................##.......####.##....##.########
...................##........##..###...##.##......
...................##........##..####..##.##......
...................##........##..##.##.##.######..
...................##........##..##..####.##......
...................##........##..##...###.##......
...................########.####.##....##.########
*/
// A line is always defined as horiztonal with length 1 in vertex space
// The line's position and rotation is the line collection transform
// translation and rotation respectively.
// The line's length is the _line primative x scale.

/**
 * {@link FigureElementCollection} representing a line.
 *
 * <p class="inline_gif"><img src="./apiassets/advline_pulse.gif" class="inline_gif_image"></p>
 *
 * <p class="inline_gif"><img src="./apiassets/advline_grow.gif" class="inline_gif_image"></p>
 *
 * <p class="inline_gif"><img src="./apiassets/advline_multimove.gif" class="inline_gif_image"></p>
 *
 * This object defines a convient and powerful line
 * {@link FigureElementCollection} that includes a solid or dashed line,
 * arrows, a label annotation that can self align with line orientation, and
 * some methods to make it convient to use dynamically.
 *
 * See {@link COL_Line} for the options that can be used when creating the line.
 *
 * The object contains a two additional animation steps. `length`
 * animates changing the line length, and `pulseWidth` animates the
 * `pulseWidth` method. The animation steps are available in
 * the animation manager ({@link FigureElement}.animations),
 * and in the animation builder
 * (<a href="#animationmanagernew">animations.new</a>
 * and <a href="#animationmanagerbuilder">animations.builder</a>).
 *
 * Some of the useful methods included in an collections line are:
 * - <a href="#collectionslinepulsewidth">pulseWidth</a> - pulses the line without
 *   changing its length
 * - <a href="#collectionslinegrow">grow</a> - starts and animation that executes
 *   a single `length` animation
 *    step
 * - <a href="#collectionslinesetmovable">grow</a> - overrides
 *    <a href="#figureelementsetmovable">FigureElement.setMovable</a> and
 *    allowing for more complex move options.
 *
 * @see See {@link OBJ_LengthAnimationStep} for angle animation step options.
 *
 * See {@link OBJ_PulseWidthAnimationStep} for pulse angle animation step
 * options.
 *
 * To test examples below, append them to the
 * <a href="#drawing-boilerplate">boilerplate</a>.
 *
 *
 * @example
 * // Pulse an annotated line
 * figure.add({
 *   name: 'l',
 *   method: 'collections.line',
 *   options: {
 *     p1: [-1, 0],
 *     p2: [1, 0],
 *     arrow: 'triangle',
 *     label: {
 *       text: 'length',
 *       offset: 0.04,
 *     },
 *   },
 * });
 *
 * figure.elements._l.pulseWidth({ duration: 2 });
 *
 * @example
 * // Animate growing a line while showing it's length
 * figure.add({
 *   name: 'l',
 *   method: 'collections.line',
 *   options: {
 *     p1: [-1, 0],
 *     p2: [-0.5, 0],
 *     align: 'start',
 *     arrow: { end: { head: 'barb', scale: 2 } },
 *     label: {
 *       text: null,
 *       offset: 0.03,
 *       precision: 2,
 *       location: 'start'
 *     },
 *   },
 * });
 *
 * const l = figure.elements._l;
 * l.animations.new()
 *   .length({ start: 0.5, target: 2, duration: 2 })
 *   .start();
 *
 * @example
 * // Example showing dashed line with an equation label that stays horizontal
 * const l = figure.collections.line({
 *   p1: [0, 0],
 *   p2: [1.4, 0],
 *   align: 'start',
 *   label: {
 *     text: {                             // label text is an equation
 *       elements: {
 *         twopi: '2\u03C0',
 *       },
 *       forms: {
 *         base: ['twopi', ' ', { frac: ['a', 'vinculum', 'b'] } ]
 *       },
 *     },
 *     offset: 0.03,
 *     orientation: 'horizontal',          // keep label horizontal
 *     location: 'top',                    // keep label on top of line
 *   },
 *   dash: [0.08, 0.02, 0.02, 0.02],
 * });
 * figure.add('l', l);
 * l.setMovable({ type: 'centerTranslateEndRotation'})
 * l.setAutoUpdate();
 *
 */
// $FlowFixMe
var CollectionsLine = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsLine, _FigureElementCollect);

  var _super2 = _createSuper(CollectionsLine);

  // Figure elements

  /**
   * @hideconstructor
   */
  function CollectionsLine( // shapes: Object,
  // equation: Object,
  collections, isTouchDevice) {
    var _this2;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, CollectionsLine);

    var defaultOptions = {
      // position: new Point(0, 0),
      width: 0.01,
      align: 'start',
      color: collections.primitives.defaultColor,
      dash: [],
      mods: {},
      pulseWidth: {
        line: 6,
        label: 2,
        arrow: 3,
        duration: 1,
        frequency: 0
      },
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Line').scale(1, 1).rotate(0).translate(0, 0),
      limits: collections.primitives.limits // touchBorder: 'children',

    };
    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, options); // if (optionsToUse.touchBorder == null) {
    //   if (isTouchDevice) {
    //     optionsToUse.touchBorder = optionsToUse.width * 16;
    //   } else {
    //     optionsToUse.touchBorder = optionsToUse.width * 8;
    //   }
    // }

    _this2 = _super2.call(this, optionsToUse);

    _this2.setColor(optionsToUse.color); // this.shapes = shapes;
    // this.equation = equation;


    _this2.collections = collections; // this.touchBorder = optionsToUse.touchBorder;

    _this2.isTouchDevice = isTouchDevice;
    _this2.dash = optionsToUse.dash;
    _this2.width = optionsToUse.width;
    _this2.line = getLineFromOptions(optionsToUse);
    _this2.alignDraw = optionsToUse.align;
    _this2.localXPosition = 0;
    _this2.autoUpdateSubscriptionId = -1;
    _this2.lastParentRotationOffset = 0; // this.animateLengthToOptions = {
    //   initialLength: 0,
    //   deltaLength: 1,
    //   finishOnCancel: true,
    //   callback: null,
    //   onStepCallback: null,
    // };

    _this2.pulseWidthOptions = {
      oldCallback: null,
      oldTransformMethod: null
    }; // this.animateLengthToStepFunctionName = '_animateToLengthStep';
    // this.fnMap.add(this.animateLengthToStepFunctionName, this.animateLengthToStep.bind(this));
    // this.animateLengthToDoneFunctionName = '_animateToLengthDone';
    // this.fnMap.add(this.animateLengthToDoneFunctionName, this.animateLengthToDone.bind(this));
    // this.pulseWidthDoneCallbackName = '_pulseWidthDone';
    // this.fnMap.add(this.pulseWidthDoneCallbackName, this.pulseWidthDone.bind(this));
    // this.transform.updateTranslation(this.line.p1);
    // this.transform.updateRotation(this.line.angle);
    // Line is defined in vertex space as horiztonal along the x axis.
    // The reference will define how it is offset where:
    //    - start: line extends from 0 to length in x
    //    - end: line extends from -length to 0 in length
    //    - middle: line extends from -length / 2 to length / 2
    //    - percent: line extends from -length * % to length * (1 - %)
    // MultiMove means the line has a middle section that when touched
    // translates the line collection, and when the rest of the line is
    // touched then the line collection is rotated.

    _this2.multiMove = {
      midLength: 0,
      includeLabelInTouchBoundary: false // bounds: new RectBounds({
      //   left: -1, bottom: -1, top: 1, right: 1
      // }),
      // bounds: new Rect(-1, -1, 2, 2),

    };
    _this2.scaleTransformMethodName = '_transformMethod'; // If the line is to be shown (and not just a label) then make it

    _this2._line = null;

    if (_this2.width > 0) {
      var straightLine = makeStraightLine(_this2.collections.primitives, _this2.line.length(), _this2.width, optionsToUse.color, _this2.dash // this.maxLength,
      );

      var scaleTransformMethod = function scaleTransformMethod(s) {
        return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, s);
      };

      straightLine.fnMap.add(_this2.scaleTransformMethodName, scaleTransformMethod);

      _this2.add('line', straightLine);
    } // Arrow related properties


    _this2._arrow1 = null;
    _this2._arrow2 = null; // Label related properties

    _this2.label = null;
    _this2._label = null;
    _this2.showRealLength = false;

    if (optionsToUse.arrow != null) {
      var arrowOptions = Object(_geometries_arrow__WEBPACK_IMPORTED_MODULE_6__["simplifyArrowOptions"])(optionsToUse.arrow, _this2.width || 0.01); // $FlowFixMe

      _this2.arrow = arrowOptions;

      _this2.addArrow('start');

      _this2.addArrow('end');
    }

    _this2.setupLine();

    var defaultLabelOptions = {
      text: null,
      offset: 0.00001,
      location: 'positive',
      subLocation: 'left',
      orientation: 'horizontal',
      linePosition: 0.5,
      scale: 0.7,
      color: optionsToUse.color,
      precision: 1,
      update: false
    };

    if (optionsToUse.label !== undefined) {
      var labelOptions;

      if (typeof optionsToUse.label === 'string' || optionsToUse.label === null) {
        labelOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultLabelOptions, {
          text: optionsToUse.label
        });
      } else {
        labelOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultLabelOptions, optionsToUse.label);
      }

      if (labelOptions.text === null) {
        labelOptions.text = '';
        _this2.showRealLength = true;
      }

      _this2.addLabel(labelOptions.text, labelOptions.offset, labelOptions.location, labelOptions.subLocation, labelOptions.orientation, labelOptions.linePosition, labelOptions.scale, labelOptions.color, labelOptions.precision, labelOptions.update, labelOptions);
    }

    var defaultMoveOptions = {
      type: 'rotation',
      middleLength: 0.22,
      includeLabelInTouchBoundary: false
    };

    if (optionsToUse.move) {
      var moveOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultMoveOptions, optionsToUse.move);

      _this2.setMovable({
        movable: true,
        type: moveOptions.type,
        middleLength: moveOptions.middleLength
      });
    }

    _this2.pulseWidthDefaults = {
      line: optionsToUse.pulseWidth.line || 1,
      label: optionsToUse.pulseWidth.label || 1,
      arrow: optionsToUse.pulseWidth.arrow || 1,
      duration: optionsToUse.pulseWidth.duration || 1,
      frequency: optionsToUse.pulseWidth.frequency || 0
    };

    if (optionsToUse.mods != null && optionsToUse.mods !== {}) {
      _this2.setProperties(optionsToUse.mods);
    }

    _this2.animations.length = function () {
      for (var _len = arguments.length, opt = new Array(_len), _key = 0; _key < _len; _key++) {
        opt[_key] = arguments[_key];
      }

      var o = _tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"].apply(void 0, [{}, {
        element: _assertThisInitialized(_this2) // start: this.line.length(),
        // target: this.line.length(),

      }].concat(opt));
      var target;
      var start;
      var toSetup = true;

      o.callback = function (percentage) {
        if (toSetup) {
          if (o.start == null) {
            start = _this2.line.length();
          } else {
            start = o.start;
          }

          if (o.target == null) {
            target = _this2.line.length();
          } else {
            target = o.target;
          }

          toSetup = false;
        }

        var l = (target - start) * percentage + start;

        _this2.setLength(l);
      };

      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_7__["CustomAnimationStep"](o);
    };

    _this2.animations.pulseWidth = function () {
      for (var _len2 = arguments.length, opt = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        opt[_key2] = arguments[_key2];
      }

      var o = _tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"].apply(void 0, [{}, {
        element: _assertThisInitialized(_this2),
        duration: 1
      }].concat(opt));

      o.callback = function () {
        _this2.pulseWidth({
          line: o.line,
          label: o.label,
          arrow: o.arrow,
          duration: o.duration,
          frequency: o.frequency
        });
      };

      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_7__["TriggerAnimationStep"](o);
    };

    _this2.animations.customSteps.push({
      step: _this2.animations.length.bind(_assertThisInitialized(_this2)),
      name: 'length'
    });

    _this2.animations.customSteps.push({
      step: _this2.animations.pulseWidth.bind(_assertThisInitialized(_this2)),
      name: 'pulseWidth'
    }); // trigger(...options: Array<OBJ_TriggerAnimationStep>) {
    //   const optionsToUse = joinObjects({}, ...options);
    //   return new anim.TriggerAnimationStep(optionsToUse);
    // }


    return _this2;
  }

  _createClass(CollectionsLine, [{
    key: "_getStateProperties",
    value: function _getStateProperties(options) {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(CollectionsLine.prototype), "_getStateProperties", this).call(this, options)), ['line', 'align', // 'length',
      // 'position',
      'width', 'dash', 'animateLengthToOptions', 'pulseWidthOptions']);
    }
  }, {
    key: "_fromState",
    value: function _fromState(state) {
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])(this, state);
      this.setupLine(); // this.setLineDimensions();

      return this;
    }
  }, {
    key: "pulseWidthDone",
    value: function pulseWidthDone() {
      var line = this._line;

      if (line == null) {
        return;
      }

      if (this.pulseWidthOptions.oldTransformMethod) {
        line.pulseSettings.transformMethod = this.pulseWidthOptions.oldTransformMethod;
      }

      line.pulseSettings.callback = this.pulseWidthOptions.oldCallback;
    }
    /**
     * Pulse the line so that it's width pulses and its length doesn't change.
     *
     * The pulse scales of the line, label and arrows can all be defined
     * separately.
     */

  }, {
    key: "pulseWidth",
    value: function pulseWidth() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = {
        line: this.pulseWidthDefaults.line,
        label: this.pulseWidthDefaults.label,
        arrow: this.pulseWidthDefaults.arrow,
        done: null,
        duration: this.pulseWidthDefaults.duration,
        frequency: this.pulseWidthDefaults.frequency,
        when: 'nextFrame'
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])(defaultOptions, options);
      var done = o.done;
      var line = this._line;

      if (line != null) {
        line.stopPulsing();
        this.pulseWidthOptions = {
          oldTransformMethod: line.pulseSettings.transformMethod,
          oldCallback: line.pulseSettings.callback
        };
        line.pulseSettings.callback = this.pulseWidthDoneCallbackName;
        line.pulseSettings.transformMethod = this.scaleTransformMethodName;
        line.pulse({
          duration: o.duration,
          scale: o.line,
          frequency: o.frequency,
          callback: done,
          when: o.when
        });
        done = null;
      }

      var arrow1 = this._arrow1;
      var arrow2 = this._arrow2;

      if (arrow1 != null) {
        arrow1.pulse({
          duration: o.duration,
          scale: o.arrow,
          frequency: o.frequency,
          callback: done,
          when: o.when,
          centerOn: arrow1.getPosition('figure')
        });
        done = null;
      }

      if (arrow2 != null) {
        arrow2.pulse({
          duration: o.duration,
          scale: o.arrow,
          frequency: o.frequency,
          callback: done,
          when: o.when,
          centerOn: arrow2.getPosition('figure')
        });
        done = null;
      }

      var label = this._label;

      if (label != null) {
        // label.pulseScaleNow(o.duration, o.label, 0, done);
        var labelOptions;

        if (typeof o.label === 'number') {
          labelOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, o, {
            scale: o.label,
            callback: done
          });
        } else {
          labelOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, o, o.label, {
            callback: done
          });
        }

        label.pulse(labelOptions);
        done = null;
      }

      if (done != null) {
        done();
      }

      this.animateNextFrame();
    }
  }, {
    key: "addArrow",
    value: function addArrow(lineEnd) {
      if (this.arrow == null || this.arrow[lineEnd] == null) {
        return;
      }

      var o = this.arrow[lineEnd];
      var r = 0;
      var position = 1;

      if (lineEnd === 'start') {
        r = Math.PI;
        position = 0;
      }

      var a = this.collections.primitives.arrow(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, o, {
        angle: r,
        color: this.color,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(position)
      })); // $FlowFixMe

      var arrowLength = Object(_geometries_arrow__WEBPACK_IMPORTED_MODULE_6__["getArrowLength"])(o)[1];
      var index = 1;

      if (lineEnd === 'end') {
        index = 2;
      } // $FlowFixMe


      this["arrow".concat(index)] = {
        height: arrowLength
      };
      this.add("arrow".concat(index), a);
    }
    /**
     * Use this method to enable or disable movability of the line.
     *
     * @param {OBJ_MovableLine | boolean} [movableOrOptions] `true` to
     * make movable, `false` to make not movable or use options to
     * set different kinds of movability.
     */
    // $FlowFixMe

  }, {
    key: "setMovable",
    value: function setMovable(movableOrOptions) {
      var defaultOptions = {
        movable: true,
        type: this.move.type,
        middleLength: 0.333,
        includeLabelInTouchBoundary: false
      };
      var options;

      if (movableOrOptions === false) {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, {
          movable: false
        });
      } else if (movableOrOptions === true) {
        options = defaultOptions;
      } else {
        options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, movableOrOptions);
      }

      var _options = options,
          movable = _options.movable;

      if (movable) {
        var _options2 = options,
            includeLabelInTouchBoundary = _options2.includeLabelInTouchBoundary,
            type = _options2.type,
            middleLength = _options2.middleLength;
        this.multiMove.includeLabelInTouchBoundary = includeLabelInTouchBoundary;

        if (type === 'translation' || type === 'rotation' || type === 'scale') {
          this.move.type = type;

          _get(_getPrototypeOf(CollectionsLine.prototype), "setMovable", this).call(this, true);

          this.hasTouchableElements = true;

          if (this._line != null) {
            this._line.isTouchable = true;
            this._line.isMovable = false;
          }

          if (this._movePad) {
            this._movePad.isMovable = false;
          }
        } else if (type === 'centerTranslateEndRotation') {
          this.setMultiMovable(middleLength);
          this.updateMovePads();
        }
      } else {
        this.isMovable = false;
        this.isTouchable = false;

        if (this._line != null) {
          this._line.isTouchable = false;
          this._line.isMovable = false;
        }
      }
    } // getP1Position() {
    //   const matrix = this.spaceTransformMatrix('draw', 'figure');
    //   return new Point(this.localXPosition, 0).transformBy(matrix);
    // }
    // setMovableLength() {
    //   // const elements = ['line', 'arrow1', 'arrow2'];
    //   // if (this.multiMove.includeLabelInTouchBoundary) {
    //   //   elements.push('label');
    //   // }
    //   // const touchBorder = getBoundingBorder(this.getBorder('draw', 'touchBorder', elements));
    //   // const width = touchBorder[0].distance(touchBorder[1]);
    //   // const height = touchBorder[0].distance(touchBorder[3]);
    //   const r = 0.1;
    //   if (this._startPad == null) {
    //     const startPad = this.shapes.polygon({
    //       position: new Point(this.localXPosition, 0),
    //       radius: r,
    //       sides: 8,
    //       color: [0, 0, 1, 0.5],
    //     });
    //     // console.log(width, height)
    //     // startPad.transform.updateScale(width, height);
    //     // startPad.transform.updateTranslation(touchBorder[0]);
    //     this.add('startPad', startPad);
    //     startPad.setMovable();
    //     startPad.move.type = 'translation';
    //     // startPad.move.element = this;
    //     let flag = 5;
    //     startPad.subscriptions.add('setTransform', () => {
    //       if (flag === 0) {
    //         flag = 5;
    //         const matrix = this.spaceTransformMatrix('figure', 'local');
    //         const p = startPad.getPosition('figure').transformBy(matrix);
    //         // const p = startPad.getPosition('draw')
    //         // console.log(Math.round(p.x * 100) / 100 , Math.round(p.y * 100) / 100)
    //         this.setEndPoints(p, this.line.p2._dup());
    //       } else {
    //         flag -= 1;
    //       }
    //       // const p = startPad.getPosition('figure');
    //     });
    //     startPad.drawingObject.border = [[]];
    //   }
    //   this.hasTouchableElements = true;
    //   this.isTouchable = false;
    //   this.isMovable = false;
    //   // this.setLength(this.line.length());
    // }
    // Private

  }, {
    key: "setMultiMovable",
    value: function setMultiMovable(middleLengthPercent) {
      this.multiMove.midLength = middleLengthPercent;

      if (this._rotPad == null) {
        var rotPad = this.collections.primitives.rectangle({
          position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
          xAlign: 'left',
          yAlign: 'bottom',
          width: 1,
          height: 1,
          color: [0, 0, 1, 0.0005]
        });
        this.add('rotPad', rotPad);
        rotPad.setMovable();
        rotPad.move.type = 'rotation';
        rotPad.move.element = this;
        rotPad.drawingObject.border = [[]];
      }

      if (this._movePad == null) {
        var movePad = this.collections.primitives.rectangle({
          position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
          xAlign: 'left',
          yAlign: 'bottom',
          width: 1,
          height: 1,
          color: [0, 1, 0, 0.0005]
        });
        this.add('movePad', movePad);
        movePad.setMovable();
        movePad.move.type = 'translation';
        movePad.move.element = this;
        movePad.drawingObject.border = [[]];
      }

      this.hasTouchableElements = true;
      this.isTouchable = false;
      this.isMovable = false;
      this.setLength(this.line.length());
    }
    /**
     * Use this to manually update the rotation of the line collection.
     */

  }, {
    key: "updateMoveTransform",
    value: function updateMoveTransform() {
      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.transform._dup();
      var r = t.r(); // const { bounds } = this.move;
      // console.log('qqwer')

      if (r != null) {
        // const w = Math.abs(this.line.length() / 2 * Math.cos(r));
        // const h = Math.abs(this.line.length() / 2 * Math.sin(r));
        // if (bounds instanceof TransformBounds) {
        //   bounds.updateTranslation(new RectBounds({
        //     left: bounds.left + w,
        //     bottom: bounds.bottom + h,
        //     right: bounds.right - w,
        //     top: bounds.top - h,
        //   }));
        // }
        if (r > 2 * Math.PI) {
          this.transform.updateRotation(r - 2 * Math.PI);
        }

        if (r < 0) {
          this.transform.updateRotation(r + 2 * Math.PI);
        }
      }
    }
  }, {
    key: "addLabel",
    value: function addLabel(labelText, offset) {
      var location = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'top';
      var subLocation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'left';
      var orientation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'horizontal';
      var linePosition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.5;
      var scale = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.7;
      var color = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.color;
      var precision = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
      var update = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
      var otherOptions = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : {};
      this.label = new LineLabel(this.collections, labelText, color, offset, location, subLocation, orientation, linePosition, scale, precision);
      this.label.eqn.initialForm = null;

      if (otherOptions.isTouchable != null) {
        this.label.eqn.isTouchable = otherOptions.isTouchable;
      }

      if (otherOptions.touchBorder != null) {
        this.label.eqn.touchBorder = otherOptions.touchBorder;
      }

      if (otherOptions.onClick != null) {
        this.label.eqn.onClick = otherOptions.onClick;
      }

      if (this.label != null) {
        this.add('label', this.label.eqn);
      } // if (update) {
      //   this.subscriptions.add('setTransform', () => {
      //     this.updateLabel();
      //     this.updateMovePads();
      //   });
      // }


      this.setAutoUpdate(update);
      this.updateLabel();
      this.updateMovePads();
    }
    /**
     * Turn on and off auto label location and orientation updates when line
     * transform changes. When a line is created with a label, auto update
     * is turned off by default.
     */

  }, {
    key: "setAutoUpdate",
    value: function setAutoUpdate() {
      var _this3 = this;

      var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (update) {
        this.autoUpdateSubscriptionId = this.subscriptions.add('setTransform', function () {
          _this3.updateLabel();

          _this3.updateMovePads();
        });
      } else {
        // console.log(this.autoUpdateSubscriptionId)
        this.subscriptions.remove('setTransform', this.autoUpdateSubscriptionId);
        this.autoUpdateSubscriptionId = -1;
      }
    }
    /**
     * Get line length
     * @return {number}
     */

  }, {
    key: "getLength",
    value: function getLength() {
      return this.line.length();
    }
    /**
     * Get line angle
     * @param {'deg' | 'rad'} [units]
     * @return {number}
     */

  }, {
    key: "getAngle",
    value: function getAngle() {
      var units = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'rad';

      if (units === 'deg') {
        return this.line.angle() * 180 / Math.PI;
      }

      return this.line.angle();
    }
    /**
     * Change the text of the label
     */

  }, {
    key: "setLabel",
    value: function setLabel(text) {
      this.showRealLength = false;

      if (this.label != null) {
        this.label.setText(text);
      }

      this.updateLabel();
      this.updateMovePads();
    }
    /**
     * Get the text of the label
     */

  }, {
    key: "getLabel",
    value: function getLabel() {
      if (this.label != null) {
        return this.label.getText();
      }

      return '';
    }
    /**
     * Set the label to be the real length of the line
     */

  }, {
    key: "setLabelToRealLength",
    value: function setLabelToRealLength() {
      this.showRealLength = true;
      this.updateLabel();
      this.updateMovePads();
    }
    /**
     * Manually update the label orientations with a custom rotation offset.
     *
     * Automatic updating can be done with
     * <a href="collectionsline#setautoupdate">setAutoUpdate</a>
     * @param {number | null} rotationOffset
     */

  }, {
    key: "updateLabel",
    value: function updateLabel() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (rotationOffset != null) {
        this.lastParentRotationOffset = rotationOffset;
      }

      var label = this.label;

      if (label == null) {
        return;
      }

      var lineAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["normAngle"])(this.transform.r() || 0);

      if (this.showRealLength && this._label) {
        var labelToUse = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.line.length(), 2).toFixed(label.precision);
        var current = label.getText();

        if (current !== labelToUse) {
          label.setText(Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(this.line.length(), 2).toFixed(label.precision));
        }
      }

      var labelPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.localXPosition + label.linePosition * this.line.length(), 0);

      if (label.location === 'start') {
        labelPosition.x = this.localXPosition;
      }

      if (label.location === 'end') {
        labelPosition.x = this.localXPosition + this.line.length();
      }

      label.updateRotation(labelPosition, lineAngle, label.offset, label.location, label.subLocation, label.orientation, this.lastParentRotationOffset, 'oval', true, Math.PI * 2, Math.PI);
    } // updateLabelLegacy(parentRotationOffset: number = 0) {
    //   const { label } = this;
    //   if (label == null) {
    //     return;
    //   }
    //   const lineAngle = normAngle(this.transform.r() || 0);
    //   let labelAngle = 0;
    //   if (this.showRealLength && this._label) {
    //     const labelToUse = roundNum(this.line.length(), 2)
    //       .toFixed(label.precision);
    //     const current = label.getText();
    //     if (current !== labelToUse) {
    //       label.setText(roundNum(this.line.length(), 2)
    //         .toFixed(label.precision));
    //     }
    //   }
    //   const labelPosition = new Point(
    //     this.localXPosition + label.linePosition * this.line.length(),
    //     0,
    //   );
    //   let labelOffsetAngle = Math.PI / 2;
    //   const labelOffsetMag = label.offset;
    //   if (label.location === 'start' || label.location === 'end') {
    //     if (label.location === 'start') {
    //       labelPosition.x = this.localXPosition - label.offset;
    //       labelOffsetAngle = -Math.PI;
    //     }
    //     if (label.location === 'end') {
    //       labelPosition.x = this.localXPosition + this.line.length() + label.offset;
    //       labelOffsetAngle = 0;
    //     }
    //   } else {
    //     const offsetTop = Math.cos(lineAngle) < 0 ? -Math.PI / 2 : Math.PI / 2;
    //     const offsetBottom = -offsetTop;
    //     const offsetLeft = Math.sin(lineAngle) > 0 ? Math.PI / 2 : -Math.PI / 2;
    //     const offsetRight = -offsetLeft;
    //     if (label.location === 'top') {
    //       labelOffsetAngle = offsetTop;
    //     }
    //     if (label.location === 'bottom') {
    //       labelOffsetAngle = offsetBottom;
    //     }
    //     if (label.location === 'right') {
    //       labelOffsetAngle = offsetRight;
    //     }
    //     if (label.location === 'left') {
    //       labelOffsetAngle = offsetLeft;
    //     }
    //     if (label.location === 'positive') {
    //       labelOffsetAngle = Math.PI / 2;
    //     }
    //     if (label.location === 'negative') {
    //       labelOffsetAngle = -Math.PI / 2;
    //     }
    //     if (roundNum(Math.sin(lineAngle), 4) === 0
    //       && (label.location === 'left' || label.location === 'right')
    //     ) {
    //       if (label.subLocation === 'top') {
    //         labelOffsetAngle = offsetTop;
    //       }
    //       if (label.subLocation === 'bottom') {
    //         labelOffsetAngle = offsetBottom;
    //       }
    //     }
    //     if (roundNum(Math.cos(lineAngle), 4) === 0
    //       && (label.location === 'top' || label.location === 'bottom')
    //     ) {
    //       if (label.subLocation === 'right') {
    //         labelOffsetAngle = offsetRight;
    //       }
    //       if (label.subLocation === 'left') {
    //         labelOffsetAngle = offsetLeft;
    //       }
    //     }
    //     if (label.location === 'inside') {
    //       labelOffsetAngle = -Math.PI / 2;
    //     }
    //     if (label.location === 'outside') {
    //       labelOffsetAngle = Math.PI / 2;
    //     }
    //   }
    //   if (label.orientation === 'horizontal') {
    //     labelAngle = -lineAngle;
    //   }
    //   if (label.orientation === 'baseToLine') {
    //     labelAngle = 0;
    //     if (labelOffsetAngle < 0) {
    //       labelAngle = Math.PI;
    //     }
    //   }
    //   if (label.orientation === 'baseAway') {
    //     labelAngle = Math.PI;
    //     if (labelOffsetAngle < 0) {
    //       labelAngle = 0;
    //     }
    //   }
    //   if (label.orientation === 'upright') {
    //     if (Math.cos(lineAngle) < 0) {
    //       labelAngle = Math.PI;
    //     }
    //   }
    //   label.updateRotation(
    //     labelAngle - parentRotationOffset,
    //     labelPosition, labelOffsetMag, labelOffsetAngle,
    //   );
    // }

    /**
     * Set the length of the line
     */

  }, {
    key: "setLength",
    value: function setLength(length) {
      var align = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.alignDraw;
      var newLen = length;

      if (length === 0) {
        newLen = 0.0000001;
      }

      if (align === 'start') {
        this.line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](this.line.p1, newLen, this.line.angle());
      } else if (align === 'end') {
        this.line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](this.line.pointAtLength(this.line.length() - newLen), newLen, this.line.angle());
      } else if (align === 'center') {
        this.line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](this.line.pointAtLength((this.line.length() - newLen) / 2), newLen, this.line.angle());
      } else if (typeof align === 'number') {
        // console.log(align)
        this.line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](this.line.pointAtLength((this.line.length() - newLen) * align), newLen, this.line.angle());
      }

      this.alignDraw = align;
      this.setupLine();
    }
  }, {
    key: "setupLine",
    value: function setupLine() {
      var _this4 = this;

      var set = function set(key, x) {
        // $FlowFixMe
        if (_this4["_".concat(key)] != null) {
          // $FlowFixMe
          _this4["_".concat(key)].transform.updateTranslation(x);
        }
      };

      var xPosition = 0;

      var position = this.line.p1._dup(); // const { align } = this;


      var align = this.alignDraw;

      if (typeof align === 'number') {
        xPosition = -this.line.length() * align;
        position = this.line.pointAtPercent(align);
      } else if (align === 'end') {
        xPosition = -this.line.length();
        position = this.line.p2._dup();
      } else if (align === 'center') {
        xPosition = -this.line.length() / 2;
        position = this.line.pointAtPercent(0.5);
      }

      this.localXPosition = xPosition;
      set('arrow1', xPosition);
      set('arrow2', xPosition + this.line.length());
      var straightLineLength = this.line.length();
      var startOffset = 0;

      if (this.arrow1 && this._arrow1) {
        straightLineLength -= this.arrow1.height;
        startOffset = this.arrow1.height;
      }

      if (this.arrow2 && this._arrow2) {
        straightLineLength -= this.arrow2.height;
      }

      straightLineLength = Math.max(straightLineLength, 0);
      var line = this._line;

      if (line) {
        line.transform.updateTranslation(xPosition + startOffset);
        line.custom.updatePoints({
          p1: [0, 0],
          p2: [straightLineLength, 0],
          dash: this.dash
        }); // if (Array.isArray(this.dash) && this.dash.length > 0) {
        //   line.lengthToDraw = straightLineLength;
        //   line.drawBorder = [[
        //     new Point(0, -this.width / 2),
        //     new Point(straightLineLength, -this.width / 2),
        //     new Point(straightLineLength, this.width / 2),
        //     new Point(0, this.width / 2),
        //   ]];
        //   line.drawBorderBuffer = line.drawingObject.border;
        // } else {
        //   line.transform.updateScale(straightLineLength, 1);
        // }
      }

      this.transform.updateRotation(this.line.angle());
      this.transform.updateTranslation(position);
      this.updateLabel();
      this.updateMovePads();
    }
  }, {
    key: "updateMovePads",
    value: function updateMovePads() {
      if (this._movePad == null || this._rotPad == null) {
        return;
      }

      var elements = ['line', 'arrow1', 'arrow2'];

      if (this.multiMove.includeLabelInTouchBoundary) {
        elements.push('label');
      }

      var touchBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(this.getBorder('draw', 'touchBorder', elements));
      var width = touchBorder[0].distance(touchBorder[1]);
      var height = touchBorder[0].distance(touchBorder[3]);
      var movePad = this._movePad;

      if (movePad) {
        var midWidth = this.multiMove.midLength * this.line.length();
        movePad.transform.updateScale(midWidth, height); // const p = movePad.getPosition();

        movePad.setPosition(this.localXPosition + this.line.length() / 2 - midWidth / 2, touchBorder[0].y);
      }

      var rotPad = this._rotPad;

      if (rotPad) {
        rotPad.transform.updateScale(width, height); // const p = rotPad.getPosition();

        rotPad.setPosition(touchBorder[0].x, touchBorder[0].y);
      }

      var startPad = this._startPad;

      if (startPad) {
        startPad.transform.updateTranslation(this.localXPosition, 0);
      }
    }
    /**
     * Change the line position, length and angle using end points and an offset.
     *
     * For most lines, an offset of 0 will be desired, as this will position the
     * line ends to be at `p1` and `p2`.
     *
     * A non-positive offset will position the line in parallel with `p1` and `p2`
     * but some offset away. A positive offset will position the line on the side
     * it will rotate toward with positive rotation.
     */

  }, {
    key: "setEndPoints",
    value: function setEndPoints(p1, p2) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2).offset('positive', offset); // console.log(p, q)

      this.setupLine();
    } // animateLengthToStep(percent: number) {
    //   const { initialLength, deltaLength, onStepCallback } = this.animateLengthToOptions;
    //   this.setLength(initialLength + deltaLength * percent);
    //   if (onStepCallback != null) {
    //     this.fnMap.exec(onStepCallback, percent, initialLength + deltaLength * percent);
    //   }
    // }
    // animateLengthToDone() {
    //   const {
    //     initialLength, callback, deltaLength, finishOnCancel,
    //   } = this.animateLengthToOptions;
    //   if (finishOnCancel) {
    //     this.setLength(initialLength + deltaLength);
    //   }
    //   this.fnMap.exec(callback);
    // }
    // animateLengthTo(
    //   toLength: number = 1,
    //   time: number = 1,
    //   finishOnCancel: boolean = true,
    //   callback: ?(string | (() => void)) = null,
    //   onStepCallback: ?(string | ((number, number) => void)) = null,
    //   stop: ?boolean = true,
    // ) {
    //   if (stop) {
    //     this.stop();
    //   }
    //   this.animateLengthToOptions = {
    //     initialLength: this.line.length(),
    //     deltaLength: toLength - this.line.length(),
    //     callback,
    //     onStepCallback,
    //     finishOnCancel,
    //   };
    //   this.animations.new('Line Length')
    //     .custom({
    //       callback: this.animateLengthToStepFunctionName,
    //       duration: time,
    //     })
    //     .whenFinished(this.animateLengthToDoneFunctionName)
    //     .start();
    //   this.animateNextFrame();
    // }
    // /**
    //  * Grow the line from a length to the current length
    //  */
    // growLegacy(
    //   fromLength: number = 0,
    //   duration: number = 1,
    //   finishOnCancel: boolean = true,
    //   callback: ?(string | (() => void)) = null,
    //   onStepCallback: ?(number, number) => void = null,
    // ) {
    //   this.stop();
    //   const target = this.line.length();
    //   this.setLength(fromLength);
    //   this.animateLengthTo(target, duration, finishOnCancel, callback, onStepCallback);
    // }

    /**
     * Create a new animation that executes a single grow animation step.
     */

  }, {
    key: "grow",
    value: function grow(options) {
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, {
        start: 0
      }, options);
      this.animations["new"]().then(this.animations.length(o)).start();
    }
  }, {
    key: "showLineOnly",
    value: function showLineOnly() {
      this.show();

      if (this._line) {
        this._line.show();
      }

      if (this._arrow1) {
        this._arrow1.show();
      }

      if (this._arrow2) {
        this._arrow2.show();
      }

      if (this._label) {
        this._label.hideAll();
      }
    }
    /**
     * Return a geometric {@link Line} object that represents the line
     * @return {Line}
     */

  }, {
    key: "getLine",
    value: function getLine() // space: TypeSpace = 'local'
    {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](this.getP1(), this.getP2());
    }
    /**
     * Return the start point of the line
     * @return {Point}
     */

  }, {
    key: "getP1",
    value: function getP1() // space: TypeSpace = 'local'
    {
      // return this.line.p1._dup();
      // const matrix = this.spaceTransformMatrix('draw', space);
      // if (this._line != null) {
      //   matrix = mul(matrix, this._line.spaceTransformMatrix('draw', 'local'));
      //   // return this._line.getPosition(space);
      // }
      // return this.getPosition(space);
      // // if (space === 'draw') {
      // //   return this.line.p1._dup();
      // // }
      // // return this.line.p1.transformBy(this.spaceTransformMatrix('draw', space));
      // return new Point(0, 0).transformBy(matrix);
      return this.line.p1._dup();
    }
    /**
     * Return the end point of the line
     * @return {Point}
     */

  }, {
    key: "getP2",
    value: function getP2() // space: TypeSpace = 'local'
    {
      return this.line.p2._dup(); // if (space === 'draw') {
      //   return this.line.p2._dup();
      // }
      // return this.line.p2.transformBy(this.spaceTransformMatrix('draw', space));
      // return new Point(this.line.length(), 0)
      //   .transformBy(this.spaceTransformMatrix('draw', space));
    }
  }]);

  return CollectionsLine;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]); // export type TypeLine = CollectionsLine;
// export class MovableLine extends CollectionsLine {
//   // constructor(
//   //   fullLength: number,
//   //   endLength: number,
//   //   width: number,
//   //   boundary: Rect,
//   // ) {
//   // }
// }
// export type TypeMovableLine = MovableLine;




/***/ }),

/***/ "./src/js/figure/FigureCollections/Plot.js":
/*!*************************************************!*\
  !*** ./src/js/figure/FigureCollections/Plot.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import Figure from '../Figure';

// import {
//   round,
// } from '../../tools/math';



function cleanTraces(tracesIn) {
  var traces = [];

  if (!Array.isArray(tracesIn)) {
    traces = [tracesIn];
  } else if (tracesIn.length === 0) {
    traces = []; // $FlowFixMe
  } else if (Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["parsePoint"])(tracesIn[0]) instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
    traces = [{
      points: tracesIn
    }];
  } else {
    tracesIn.forEach(function (trace) {
      if (!Array.isArray(trace)) {
        traces.push(trace);
      } else {
        traces.push({
          points: trace
        });
      }
    });
  }

  var firstPoint = true;
  var result = {
    min: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
    max: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0)
  };
  traces.forEach(function (trace) {
    // $FlowFixMe
    for (var i = 0; i < trace.points.length; i += 1) {
      // $FlowFixMe
      var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(trace.points[i]); // eslint-disable-next-line no-param-reassign
      // trace.points[i] = p;

      result = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["comparePoints"])(p, result.min, result.max, firstPoint);
      firstPoint = false;
    }
  });
  var bounds = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](result.min.x, result.min.y, result.max.x - result.min.x, result.max.y - result.min.y); // $FlowFixMe

  return [traces, bounds];
}
/*
.............########..##........#######..########
.............##.....##.##.......##.....##....##...
.............##.....##.##.......##.....##....##...
.............########..##.......##.....##....##...
.............##........##.......##.....##....##...
.............##........##.......##.....##....##...
.............##........########..#######.....##...
*/

/**
 * {@link FigureElementCollection} representing a plot including axes, traces,
 * labels and titles.
 *
 * ![](./apiassets/advplot_ex1.png)
 * ![](./apiassets/advplot_ex2.png)
 *
 * ![](./apiassets/advplot_ex3.png)
 * ![](./apiassets/advplot_ex4.png)
 *
 * ![](./apiassets/advplot_ex5.png)
 * ![](./apiassets/advplot_ex6.png)
 *
 * This object provides convient and customizable plot functionality.
 *
 * At its simplist, just the points of the trace to be plotted need to be
 * passed in to get a plot with automatically generated axes, tick marks,
 * labels and grid lines.
 *
 * Additional options can be used to finely customize each of these, as well
 * as add and customize plot and axis titles, a legend, and a frame around the
 * entire plot.
 *
 * @see
 * See {@link COL_Axis}, {@link OBJ_AxisLabels}, {@link OBJ_AxisTicks},
 * {@link COL_Trace} and {@link COL_PlotLegend} for more examples of customizing
 * specific parts of the plot.
 *
 * To test examples below, append them to the
 * <a href="#drawing-boilerplate">boilerplate</a>.
 *
 * All examples below also use this power function to generate the traces:
 * ```javascript
 * const pow = (pow = 2, stop = 10, step = 0.05) => {
 *   const xValues = Fig.tools.math.range(0, stop, step);
 *   return xValues.map(x => new Fig.Point(x, x ** pow));
 * }
 * ```
 * @example
 * // Plot of single trace with auto axis scaling
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: pow(),
 *   },
 * });
 *
 * @example
 * // Multiple traces with a legend
 * // Some traces are customized beyond the default color to include dashes and
 * // markers
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     width: 2,                                    // Plot width in figure
 *     height: 2,                                   // Plot height in figure
 *     yAxis: { start: 0, stop: 100 },              // Customize y axis limits
 *     trace: [
 *       { points: pow(1.5), name: 'Power 1.5' },   // Trace names are for legend
 *       {                                          // Trace with only markers
 *         points: pow(2, 10, 0.5),
 *         name: 'Power 2',
 *         markers: { sides: 4, radius: 0.03 },
 *       },
 *       {                                          // Trace with markers and
 *         points: pow(3, 10, 0.5),                 // dashed line
 *         name: 'Power 3',
 *         markers: { radius: 0.03, sides: 10, line: { width: 0.005 } },
 *         line: { dash: [0.04, 0.01] },
 *       },
 *     ],
 *     legend: true,
 *   },
 * });
 *
 * @example > collections.plot.multiple.grids.simple.titles
 * // Multiple grids and simple titles
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     width: 2,
 *     height: 2,
 *     yAxis: {
 *       start: 0,
 *       stop: 100,
 *       grid: [
 *         { step: 20, width: 0.005, dash: [], color: [0.7, 0.7, 1, 1] },
 *         { step: 5, width: 0.005, dash: [0.01, 0.01], color: [1, 0.7, 0.7, 1] },
 *       ],
 *       title: 'velocity (m/s)',
 *     },
 *     xAxis: {
 *       grid: [
 *         { step: 2, width: 0.005, dash: [], color: [0.7, 0.7, 1, 1] },
 *         { step: 0.5, width: 0.005, dash: [0.01, 0.01], color: [1, 0.7, 0.7, 1] },
 *       ],
 *       title: 'time (s)',
 *     },
 *     trace: pow(3),
 *     title: 'Velocity over Time'
 *   },
 * });
 *
 * @example
 * // Hide axes
 * // Use plot frame and plot area
 * // Title has a subtitle
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     width: 2,
 *     height: 2,
 *     trace: pow(3),
 *     xAxis: { show: false },
 *     yAxis: { show: false },
 *     plotArea: [0.93, 0.93, 0.93, 1],
 *     frame: {
 *       line: { width: 0.005, color: [0.5, 0.5, 0.5, 1] },
 *       corner: { radius: 0.1, sides: 10 },
 *       space: 0.15,
 *     },
 *     title: {
 *       text: [
 *         'Velocity over Time',
 *         { text: 'For object A', lineSpace: 0.13, font: { size: 0.08 } },
 *       ],
 *       offset: [0, 0],
 *     }
 *   },
 * });
 *
 * @example
 * // Secondary y axis
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     width: 2,
 *     height: 2,
 *     trace: pow(2),
 *     yAxis: {
 *       title: {
 *         text: 'velocity (m/s)',
 *         rotation: 0,
 *         xAlign: 'right',
 *       },
 *     },
 *     xAxis: { title: 'time (s)' },
 *     axes: [
 *       {
 *         axis: 'y',
 *         start: 0,
 *         stop: 900,
 *         color: [1, 0, 0, 1],
 *         position: [2, 0],
 *         ticks: {
 *           step: 300,
 *           offset: 0,
 *           length: 0.05,
 *         },
 *         labels: {
 *           offset: [0.2, 0],
 *           precision: 0,
 *           xAlign: 'left',
 *         },
 *         title: {
 *           offset: [0.4, 0],
 *           xAlign: 'left',
 *           text: 'displacment (m)',
 *           rotation: 0,
 *         }
 *       },
 *     ],
 *     position: [-1, -1],
 *   },
 * });
 *
 * @example
 * // Cartesian axes crossing at the zero point
 * // Automatic layout doesn't support this, but axes, ticks, labels and titles
 * // can all be customized to create it.
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     width: 3,
 *     height: 3,
 *     trace: pow(2, 20),
 *     font: { size: 0.1 },
 *     xAxis: {
 *       start: -25,
 *       stop: 25,
 *       ticks: {
 *         start: -20,
 *         stop: 20,
 *         step: 5,
 *         length: 0.1,
 *         offset: -0.05
 *       },
 *       line: { arrow: 'barb' },
 *       position: [0, 1.5],
 *       labels: [
 *         {
 *           hide: 4,
 *           precision: 0,
 *           space: 0.1,
 *         },
 *         {
 *           values: 0,
 *           text: 'O',
 *           offset: [0, 0.165],
 *         },
 *       ],
 *       title: {
 *         text: 'x',
 *         offset: [1.65, 0.3],
 *         font: {
 *           style: 'italic',
 *           family: 'Times New Roman',
 *           size: 0.15,
 *         },
 *       },
 *     },
 *     yAxis: {
 *       start: -500,
 *       stop: 500,
 *       line: { arrow: 'barb' },
 *       ticks: {
 *         start: -400,
 *         stop: 400,
 *         step: 100,
 *         length: 0.1,
 *         offset: -0.05,
 *       },
 *       position: [1.5, 0],
 *       labels: {
 *         hide: 4,
 *         precision: 0,
 *         space: 0.03,
 *       },
 *       title: {
 *         text: 'y',
 *         offset: [0.35, 1.6],
 *         font: {
 *           style: 'italic',
 *           family: 'Times New Roman',
 *           size: 0.15,
 *         },
 *         rotation: 0,
 *       },
 *     },
 *     grid: false,
 *     position: [-1, -1],
 *   },
 * });
 *
 */
// $FlowFixMe


var CollectionsPlot = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsPlot, _FigureElementCollect);

  var _super = _createSuper(CollectionsPlot);

  // Figure elements
  // _axis: ?CollectionsAxis;
  // _majorTicks: ?FigureElementPrimitive;
  // _minorTicks: ?FigureElementPrimitive;
  // _labels: ?FigureElementPrimitive;
  // _arrow1: ?FigureElementPrimitive;
  // _arrow2: ?FigureElementPrimitive;
  // length: number;
  // angle: number;
  // start: number;
  // stop: number;

  /**
   * @hideconstructor
   */
  function CollectionsPlot(collections, optionsIn) {
    var _this;

    _classCallCheck(this, CollectionsPlot);

    var defaultOptions = {
      font: collections.primitives.defaultFont,
      color: collections.primitives.defaultColor,
      theme: 'classic',
      width: collections.primitives.limits.width / 3,
      height: collections.primitives.limits.width / 3,
      grid: [],
      xAlign: 'plotAreaLeft',
      yAlign: 'plotAreaBottom',
      limits: collections.primitives.limits,
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Plot').scale(1, 1).rotate(0).translate(0, 0)
    };

    if (optionsIn.color != null && (optionsIn.font == null || optionsIn.font != null && optionsIn.font.color == null)) {
      defaultOptions.font.color = optionsIn.color;
    }

    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn); // if (options.transform != null) {
    //   options.transform = getTransform(options.transform);
    // }
    // if (options.position != null) {
    //   options.transform.updateTranslation(getPoint(options.position));
    // }

    if (options.stop == null) {
      options.stop = options.start + 1;
    }

    _this = _super.call(this, options);
    _this.collections = collections;
    _this.defaultFont = options.font;
    _this.defaultColor = options.color;
    _this.width = options.width;
    _this.height = options.height;
    _this.theme = options.theme;
    _this.grid = options.grid;
    _this.xAxisShow = true;

    if (options.xAxis === false) {
      _this.xAxisShow = false;
    }

    _this.yAxisShow = true;

    if (options.yAxis === false) {
      _this.yAxisShow = false;
    }

    if (optionsIn.font == null || optionsIn.font.size == null) {
      _this.defaultFont.size = Math.min(_this.width, _this.height) / 20;
    }

    _this.setColor(options.color);

    _this.axes = [];
    _this.traces = [];

    var _cleanTraces = cleanTraces(options.trace),
        _cleanTraces2 = _slicedToArray(_cleanTraces, 2),
        traces = _cleanTraces2[0],
        bounds = _cleanTraces2[1];

    if (options.frame != null && options.frame !== false) {
      _this.addFrame(options.frame);
    }

    if (options.plotArea != null && options.plotArea !== false) {
      _this.addPlotArea(options.plotArea);
    }

    _this.addAxes([Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
      axis: 'x',
      name: 'x',
      auto: [bounds.left, bounds.right]
    }, options.xAxis != null ? options.xAxis : {})]);

    _this.addAxes([Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
      axis: 'y',
      name: 'y',
      auto: [bounds.bottom, bounds.top]
    }, options.yAxis != null ? options.yAxis : {})]);

    if (options.axes != null) {
      _this.addAxes(options.axes);
    }

    if (options.trace != null) {
      _this.addTraces(traces);
    }

    if (options.title != null) {
      _this.addTitle(options.title);
    }

    if (options.legend != null && options.legend !== false) {
      _this.addLegend(options.legend);
    } // if (options.border != null) {
    //   this.addBorder(options.border);
    // }


    if (_this.__frame != null && _this.frameSpace != null) {
      _this.__frame.surround(_assertThisInitialized(_this), _this.frameSpace);
    }

    return _this;
  }

  _createClass(CollectionsPlot, [{
    key: "getNonTraceBoundingRect",
    value: function getNonTraceBoundingRect() {
      var children = [];
      Object.keys(this.elements).forEach(function (elementName) {
        if (!elementName.startsWith('trace')) {
          children.push(elementName);
        }
      });
      return this.getBoundingRect('draw', 'border', children);
    }
  }, {
    key: "addAxes",
    value: function addAxes(axes) {
      var _this2 = this;

      var defaultOptions = {
        color: this.defaultColor,
        font: this.defaultFont,
        type: 'x'
      };
      axes.forEach(function (axisOptions) {
        var axisType;

        if (axisOptions.axis != null) {
          axisType = axisOptions.axis; // $FlowFixMe
        } else if (defaultOptions.axis != null) {
          axisType = defaultOptions.axis;
        }

        if (axisType === 'x') {
          // $FlowFixMe
          defaultOptions.length = _this2.width;
        } else {
          // $FlowFixMe
          defaultOptions.length = _this2.height;
        }

        var theme = _this2.getTheme(_this2.theme, axisType, axisOptions.color);

        var show = axisType === 'x' ? _this2.xAxisShow : _this2.yAxisShow; // $FlowFixMe

        defaultOptions.show = show;
        var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, theme.axis, axisOptions);

        if (Array.isArray(o.grid)) {
          for (var i = 0; i < o.grid.length; i += 1) {
            o.grid[i] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, theme.axis.grid, o.grid[i]);
          }
        }

        if (Array.isArray(o.ticks)) {
          for (var _i2 = 0; _i2 < o.ticks.length; _i2 += 1) {
            o.ticks[_i2] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, theme.axis.ticks, o.ticks[_i2]);
          }
        }

        if (o.name == null) {
          o.name = "axis_".concat(_this2.axes.length);
        }

        var axis = _this2.collections.axis(o);

        _this2.add(o.name, axis);

        _this2.axes.push(axis);
      });
    }
  }, {
    key: "addPlotArea",
    value: function addPlotArea(plotArea) {
      var defaultOptions = {
        width: this.width,
        height: this.height,
        xAlign: 'left',
        yAlign: 'bottom',
        position: [0, 0]
      };
      var o;

      if (Array.isArray(plotArea)) {
        // $FlowFixMe
        defaultOptions.fill = plotArea;
        o = defaultOptions;
      } else {
        o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, plotArea);
      }

      this.add('_plotArea', this.collections.rectangle(o));
    }
  }, {
    key: "addFrame",
    value: function addFrame(frame) {
      var defaultOptions = {
        width: this.width / 2,
        height: this.height / 2,
        xAlign: 'left',
        yAlign: 'bottom',
        position: [0, 0],
        space: Math.min(this.width, this.height) / 20
      };
      var optionsIn = frame;

      if (optionsIn === true) {
        optionsIn = {
          line: {
            width: this.collections.primitives.defaultLineWidth
          }
        };
      } else if (Array.isArray(optionsIn)) {
        optionsIn = {
          fill: optionsIn
        };
      }

      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      this.frameSpace = o.space;
      this.add('_frame', this.collections.rectangle(o));
    }
  }, {
    key: "getTraceIndex",
    value: function getTraceIndex(name) {
      if (typeof name === 'number') {
        return name;
      }

      for (var i = 0; i < this.traces.length; i += 1) {
        if (name === this.traces[i].name) {
          return i;
        }
      }

      return -1;
    }
  }, {
    key: "addLegend",
    value: function addLegend(legendOptions) {
      var optionsIn;

      if (legendOptions === true) {
        optionsIn = {};
      } else {
        optionsIn = legendOptions;
      }

      var defaultOptions = {
        traces: this.traces,
        lineTextSpace: this.width / 50,
        length: this.width / 10,
        position: [this.width + this.width / 20, this.height]
      };
      var theme = this.getTheme(this.theme).legend;
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, theme, optionsIn);
      var legend = this.collections.plotLegend(o);
      this.add('_legend', legend);
    }
  }, {
    key: "getAxis",
    value: function getAxis(name) {
      for (var i = 0; i < this.axes.length; i += 1) {
        if (this.axes[i].name === name) {
          return this.axes[i];
        }
      }

      return null;
    }
  }, {
    key: "getXAxis",
    value: function getXAxis() {
      for (var i = 0; i < this.axes.length; i += 1) {
        if (this.axes[i].axis === 'x') {
          return this.axes[i];
        }
      }

      return null;
    }
  }, {
    key: "getYAxis",
    value: function getYAxis() {
      for (var i = 0; i < this.axes.length; i += 1) {
        if (this.axes[i].axis === 'y') {
          return this.axes[i];
        }
      }

      return null;
    }
  }, {
    key: "pointToDraw",
    value: function pointToDraw(point) {
      var xAxisName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
      var yAxisName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'y';
      var xAxis = this.getAxis(xAxisName);
      var yAxis = this.getAxis(yAxisName);

      if (xAxis == null || yAxis == null) {
        return null;
      }

      var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(point);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xAxis.valueToDraw(p.x), yAxis.valueToDraw(p.y));
    }
  }, {
    key: "drawToPoint",
    value: function drawToPoint(point) {
      var xAxisName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
      var yAxisName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'y';
      var xAxis = this.getAxis(xAxisName);
      var yAxis = this.getAxis(yAxisName);

      if (xAxis == null || yAxis == null) {
        return null;
      }

      var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(point);
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](xAxis.drawToPoint(p.x), yAxis.drawToPoint(p.y));
    }
  }, {
    key: "addTraces",
    value: function addTraces(traces) {
      var _this3 = this;

      var theme = this.getTheme(this.theme);
      traces.forEach(function (traceOptions, index) {
        var defaultOptions = {
          xAxis: 'x',
          yAxis: 'y',
          color: theme.traceColors[index % theme.traceColors.length]
        };
        var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, traceOptions);

        if (o.name == null) {
          o.name = "trace_".concat(index);
        }

        o.xAxis = _this3.getAxis(o.xAxis);
        o.yAxis = _this3.getAxis(o.yAxis);

        var trace = _this3.collections.trace(o);

        _this3.add(o.name, trace);

        _this3.traces.push(trace);
      });
    }
  }, {
    key: "getTheme",
    value: function getTheme(name) {
      var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
      var defaultColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var length = axis === 'x' ? this.width : this.height;
      var gridLength = axis === 'x' ? this.height : this.width; // const minDimension = Math.min(
      //   this.collections.primitives.limits.width, this.collections.primitives.limits.height);

      var theme = {};

      if (name === 'classic') {
        var color = defaultColor == null ? [0.35, 0.35, 0.35, 1] : defaultColor;
        var tickLength = Math.min(this.width, this.height) / 30;
        var gridDash = this.collections.primitives.defaultLineWidth;
        theme = {
          axis: {
            color: color,
            line: {
              width: this.collections.primitives.defaultLineWidth
            },
            ticks: {
              width: this.collections.primitives.defaultLineWidth,
              length: tickLength,
              offset: -tickLength
            },
            font: {
              color: color
            },
            length: length,
            grid: {
              color: color,
              width: this.collections.primitives.defaultLineWidth / 2,
              length: gridLength,
              dash: [gridDash, gridDash]
            }
          },
          title: {
            font: {
              color: color
            }
          },
          legend: {
            color: color,
            font: {
              color: color
            }
          },
          traceColors: [[0, 0, 1, 1], [1, 0, 0, 1], [0, 0.7, 0, 1], [0.8, 0.8, 0.2, 1], [0.2, 0.8, 0.8, 1], [0.8, 0.2, 0.8, 1]]
        };
      }

      if (theme.axis != null && theme.axis.grid != null) {
        if (this.grid === false) {
          // $FlowFixMe
          delete theme.axis.grid; // theme.axis.grid = undefined;
        } else if (_typeof(this.grid) === 'object' || Array.isArray(this.grid)) {
          theme.axis.grid = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, theme.axis.grid, this.grid);
        }
      }

      return theme;
    }
  }, {
    key: "addTitle",
    value: function addTitle(optionsIn) {
      var defaultOptions = {
        font: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.defaultFont, {
          size: this.defaultFont.size * 1.5
        }),
        justify: 'center',
        xAlign: 'center',
        yAlign: 'bottom',
        offset: [0, 0]
      };
      var optionsToUse = optionsIn;

      if (typeof optionsIn === 'string') {
        optionsToUse = {
          text: [optionsIn]
        };
      }

      var theme = this.getTheme(this.theme).title;
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, theme, optionsToUse);
      o.offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.offset);
      var bounds = this.getNonTraceBoundingRect();

      if (o.position == null) {
        o.position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.width / 2 + o.offset.x, bounds.top + o.font.size * 0.5 + o.offset.y);
      }

      var title = this.collections.primitives.textLines(o);
      this.add('title', title);
    } // _getStateProperties(options: Object) {  // eslint-disable-line class-methods-use-this
    //   return [...super._getStateProperties(options),
    //     'angle',
    //     'lastLabelRotationOffset',
    //   ];
    // }
    // _fromState(state: Object) {
    //   joinObjects(this, state);
    //   this.setAngle({
    //     angle: this.angle,
    //     rotationOffset: this.lastLabelRotationOffset,
    //   });
    //   return this;
    // }

  }]);

  return CollectionsPlot;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (CollectionsPlot);

/***/ }),

/***/ "./src/js/figure/FigureCollections/PolyLine.js":
/*!*****************************************************!*\
  !*** ./src/js/figure/FigureCollections/PolyLine.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CollectionsPolyline; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _FigureCollections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FigureCollections */ "./src/js/figure/FigureCollections/FigureCollections.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





// import FigurePrimitives from '../FigurePrimitives/FigurePrimitives';
// eslint-disable-next-line import/no-cycle
 // import FigureEquation from '../Equation/FigureEquation';

function processArray(toProcess, defaultOptions, defaultLabelOptions, total) {
  if (Array.isArray(toProcess)) {
    var _out = [];

    for (var i = 0; i < total; i += 1) {
      var o = toProcess[i % toProcess.length];

      if (o.label != null) {
        _out.push(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, {
          label: defaultLabelOptions
        }, o));
      } else {
        _out.push(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, o));
      }
    }

    return _out;
  }

  var except = [];

  for (var _i = 0; _i < total; _i += 1) {
    except.push("".concat(_i));
  }

  var toProcessDefaults = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjectsWithOptions"])({
    except: except
  }, {}, toProcess);
  var labels = [];

  if (toProcessDefaults.label != null && toProcessDefaults.label.text != null && Array.isArray(toProcessDefaults.label.text)) {
    labels = toProcessDefaults.label.text;
  }

  if (toProcessDefaults.label === null) {
    toProcessDefaults.label = {
      text: null
    };
  } // console.log(toProcessDefaults, labels)


  var show;

  if (toProcessDefaults.show != null) {
    show = toProcessDefaults.show;
  } else if (total > 1) {
    show = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["range"])(0, total - 1, 1);
  } else {
    show = [0];
  }

  if (toProcessDefaults.hide != null) {
    toProcessDefaults.hide.forEach(function (index) {
      var i = show.indexOf(index);

      if (i !== -1) {
        show.splice(i, 1);
      }
    });
  }

  var out = [];

  for (var _i2 = 0; _i2 < total; _i2 += 1) {
    if (show.indexOf(_i2) === -1) {
      out.push(null);
    } else {
      var showIndex = show.indexOf(_i2);
      var index = show[showIndex];
      var indexOptions = {};

      if (toProcess["".concat(index)] != null) {
        indexOptions = toProcess["".concat(index)];
      }

      var labelDefaults = {};

      if (labels.length > 0) {
        var text = labels[showIndex % labels.length];
        labelDefaults = {
          label: {
            text: text
          }
        };
      } // console.log(labelDefaults)


      var _o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, toProcessDefaults, labelDefaults, indexOptions);

      if (_o.label != null) {
        out.push(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
          label: defaultLabelOptions
        }, _o));
      } else {
        out.push(_o);
      }
    }
  }

  return out;
}
/**
 * `'updatePoints'` subscription published whenever the Collections Polyline
 * points are updated. No payload is passed to subscriber.
 *
 * @typedef SUB_PolylineUpdatePoints
 */


/*
..........########...#######..##.......##....##.##.......####.##....##.########
..........##.....##.##.....##.##........##..##..##........##..###...##.##......
..........##.....##.##.....##.##.........####...##........##..####..##.##......
..........########..##.....##.##..........##....##........##..##.##.##.######..
..........##........##.....##.##..........##....##........##..##..####.##......
..........##........##.....##.##..........##....##........##..##...###.##......
..........##.........#######..########....##....########.####.##....##.########
*/

/* eslint-disable max-len */

/**
 * {@link FigureElementCollection} representing a polyline.
 *
 * ![](./apiassets/advpolyline_examples.png)
 *
 * <p class="inline_gif"><img src="./apiassets/advpolyline_movepolyline.gif" class="inline_gif_image"></p>
 *
 * <p class="inline_gif"><img src="./apiassets/advpolyline_movetri.gif" class="inline_gif_image"></p>
 *
 * This object defines a convient and powerful polyline
 * {@link FigureElementCollection} that includes a solid or dashed,
 * open or closed polyline, arrows, angle annotations for polyline corners,
 * side annotations for straight lines between points and move pads at polyline
 * points to dynamically adjust the polyline.
 *
 * See {@link COL_Polyline} for the options that can be used when creating the
 * line.
 *
 * Available subscriptions:
 *   - `'updatePoints'`: {@link SUB_PolylineUpdatePoints}
 *
 * @see
 * To test examples below, append them to the
 * <a href="#drawing-boilerplate">boilerplate</a>.
 *
 *
 * @example
 * // Polyline with angle annotations
 * figure.add({
 *   name: 'p',
 *   method: 'collections.polyline',
 *   options: {
 *     points: [[1, 0], [0, 0], [0.5, 1], [1.5, 1]],
 *     arrow: 'triangle',
 *     angle: {
 *       label: null,
 *       curve: {
 *         radius: 0.3,
 *       },
 *     },
 *   }
 * });
 *
 * @example
 * // Triangle with unknown angle
 * figure.add({
 *   name: 'p',
 *   method: 'collections.polyline',
 *   options: {
 *     points: [[1, 1], [1, 0], [0, 0]],
 *     close: true,
 *     side: {
 *       label: null,
 *     },
 *     angle: {
 *       label: {
 *         text: '?',
 *         offset: 0.05,
 *       },
 *       curve: {
 *         radius: 0.4,
 *       },
 *       show: [1],
 *     },
 *   }
 * });
 *
 * @example
 * // Dimensioned square
 * figure.add({
 *   name: 'p',
 *   method: 'collections.polyline',
 *   options: {
 *     points: [[0, 1], [1, 1], [1, 0], [0, 0]],
 *     close: true,
 *     side: {
 *       showLine: true,
 *       offset: 0.2,
 *       color: [0, 0, 1, 1],
 *       arrow: 'barb',
 *       width: 0.01,
 *       label: null,
 *       dash: [0.05, 0.02],
 *       0: { label: { text: 'a' } },    // Customize side 0
 *     },
 *     angle: {
 *       curve: {
 *         autoRightAngle: true,
 *         radius: 0.3,
 *       },
 *     },
 *   }
 * });
 *
 * @example
 * // User adjustable polyline
 * figure.add({
 *   name: 'p',
 *   method: 'collections.polyline',
 *   options: {
 *     points: [[-0.5, 1], [1, 1], [0, 0], [1, -0.5]],
 *     dash: [0.05, 0.02],
 *     pad: {
 *       radius: 0.2,
 *       color: [1, 0, 0, 0.5],    // make alpha 0 to hide pad
 *       isMovable: true,
 *     },
 *   },
 * });
 *
 * @example
 * // Annotations that automatically updates as user changes triangle
 * figure.add({
 *   name: 'p',
 *   method: 'collections.polyline',
 *   options: {
 *     points: [[-1, 1], [1, 1], [0, 0]],
 *     close: true,
 *     makeValid: {
 *       shape: 'triangle',
 *       hide: {
 *         minAngle: Math.PI / 8,
 *       },
 *     },
 *     side: {
 *       showLine: true,
 *       offset: 0.2,
 *       color: [0.3, 0.6, 1, 1],
 *       arrow: 'barb',
 *       width: 0.01,
 *       label: {
 *         text: null,
 *       },
 *     },
 *     angle: {
 *       label: null,
 *       curve: { radius: 0.25 },
 *     },
 *     pad: {
 *       radius: 0.4,
 *       color: [1, 0, 0, 0.005],
 *       isMovable: true,
 *     },
 *   },
 * });
 */

/* eslint-enable max-len */
var CollectionsPolyline = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsPolyline, _FigureElementCollect);

  var _super = _createSuper(CollectionsPolyline);

  /**
   * @hideconstructor
   */
  function CollectionsPolyline(collections, isTouchDevice, animateNextFrame) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, CollectionsPolyline);

    // $FlowFixMe
    var defaultOptions = {
      color: collections.primitives.defaultColor,
      // $FlowFixMe
      points: [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](1, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 1)],
      close: false,
      showLine: true,
      width: collections.primitives.defaultLineWidth,
      reverse: false,
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('PolyLine').scale(1, 1).rotate(0).translate(0, 0),
      makeValid: null,
      limits: collections.primitives.limits
    };

    if (options.makeValid != null && options.makeValid.shape != null && options.makeValid.shape === 'triangle') {
      defaultOptions.makeValid = {
        shape: 'triangle',
        hide: {
          minAngle: null,
          maxAngle: null,
          minSide: null
        }
      };
    }

    var optionsToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);
    _this = _super.call(this, optionsToUse);

    _this.setColor(optionsToUse.color);

    _this.collections = collections;
    _this.largerTouchBorder = optionsToUse.largerTouchBorder;
    _this.isTouchDevice = isTouchDevice;
    _this.animateNextFrame = animateNextFrame;
    _this.updatePointsCallback = null;
    _this.position = _this.getPosition();
    _this.close = optionsToUse.close;
    _this.options = optionsToUse;
    _this.reverse = optionsToUse.reverse;
    _this.makeValid = optionsToUse.makeValid;
    _this.points = optionsToUse.points.map(function (p) {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p);
    }); // Add Pads first as they should be on the bottom of the drawing

    if (optionsToUse.pad) {
      _this.addPads(optionsToUse.pad);
    } // Add Angles


    if (optionsToUse.angle) {
      _this.addAngles(optionsToUse.angle, optionsToUse.close);
    } // Add Line


    if (optionsToUse.showLine) {
      var line = _this.collections.primitives.polyline({
        points: _this.points,
        width: options.width,
        close: options.close,
        widthIs: options.widthIs,
        cornerStyle: options.cornerStyle,
        cornerSize: options.cornerSize,
        cornerSides: options.cornerSides,
        minAutoCornerAngle: options.minAutoCornerAngle,
        dash: options.dash,
        color: options.color,
        pulse: options.pulse,
        arrow: options.arrow,
        drawBorderBuffer: options.drawBorderBuffer,
        touchBorder: 'buffer'
      });

      _this.add('line', line);
    }

    if (optionsToUse.side) {
      _this.addSides(optionsToUse.side, optionsToUse.close);
    }

    return _this;
  }

  _createClass(CollectionsPolyline, [{
    key: "addPads",
    value: function addPads(pad) {
      var _this2 = this;

      var defaultPadOptions = {
        sides: 20,
        radius: 0.1,
        color: this.color,
        isMovable: false,
        boundary: 'figure'
      }; // const { pad } = optionsToUse;

      var pCount = this.points.length; // const padArray = makeArray(pad, pCount);

      var padArray = processArray(pad, defaultPadOptions, {}, pCount);

      for (var i = 0; i < pCount; i += 1) {
        if (padArray[i] != null) {
          (function () {
            var name = "pad".concat(i);
            var padOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
              transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(_this2.points[i])
            }, padArray[i]);

            var padShape = _this2.collections.primitives.polygon(padOptions); // $FlowFixMe


            var _padArray$i = padArray[i],
                isMovable = _padArray$i.isMovable,
                boundary = _padArray$i.boundary;

            if (isMovable) {
              padShape.onAdd = function () {
                padShape.setMovable();
              };

              if (boundary != null) {
                padShape.move.sizeInBounds = true;
                padShape.setMoveBounds(boundary);
              }

              var fnName = "_polyline_pad".concat(i);
              padShape.fnMap.add(fnName, function (transform) {
                var index = parseInt(padShape.name.slice(3), 10);
                var translation = transform.t();

                if (translation != null) {
                  _this2.points[index] = translation._dup();

                  _this2.updatePoints(_this2.points);
                }
              });
              padShape.setTransformCallback = fnName;
            }

            _this2.add(name, padShape);
          })();
        }
      }
    }
  }, {
    key: "addAngles",
    value: function addAngles(angle, close) {
      var defaultAngleOptions = {
        color: this.color,
        curve: {},
        autoRightAngle: true
      };
      var defaultAngleLabelOptions = {
        text: null,
        offset: 0.05
      };
      var pCount = this.points.length;

      if (close === false) {
        pCount -= 2;
      }

      var angleArray = processArray(angle, defaultAngleOptions, defaultAngleLabelOptions, pCount);

      for (var i = 0; i < pCount; i += 1) {
        var p1 = i;
        var p2 = i + 1;
        var p3 = i + 2;

        if (i === pCount - 2 && close) {
          p3 = 0;
        }

        if (i === pCount - 1 && close) {
          p2 = 0;
          p3 = 1;
        }

        if (angleArray[i] != null) {
          var name = "angle".concat(i);

          if (this.reverse) {
            var newP1 = p3;
            p3 = p1;
            p1 = newP1;
          }

          var angleOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
            p1: this.points[p1],
            p2: this.points[p2],
            p3: this.points[p3]
          }, angleArray[i]);
          var angleAnnotation = this.collections.angle(angleOptions);
          this.add(name, angleAnnotation);
        }
      }
    }
  }, {
    key: "addSides",
    value: function addSides(side, close) {
      var defaultSideOptions = {
        showLine: false,
        offset: 0,
        width: 0,
        color: this.color
      };
      var defaultSideLabelOptions = {
        offset: 0.1,
        text: null,
        location: 'outside',
        subLocation: 'top',
        orientation: 'horizontal',
        linePosition: 0.5,
        scale: 0.7
      };
      var pCount = this.points.length - 1;

      if (close) {
        pCount += 1;
      }

      var sideArray = processArray(side, defaultSideOptions, defaultSideLabelOptions, pCount);

      for (var i = 0; i < pCount; i += 1) {
        var j = i + 1;

        if (i === pCount - 1 && close) {
          j = 0;
        }

        if (sideArray[i] != null) {
          var name = "side".concat(i).concat(j);
          var sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
            p1: this.points[i],
            p2: this.points[j]
          }, sideArray[i]);

          if (this.reverse) {
            sideOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
              p1: this.points[j],
              p2: this.points[i]
            }, sideArray[i]);
          }

          var sideLine = this.collections.line(sideOptions);
          sideLine.custom.offset = sideOptions.offset;
          this.add(name, sideLine);
        }
      }
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties(options) {
      // eslint-disable-line class-methods-use-this
      return [].concat(_toConsumableArray(_get(_getPrototypeOf(CollectionsPolyline.prototype), "_getStateProperties", this).call(this, options)), ['points']);
    }
  }, {
    key: "_fromState",
    value: function _fromState(state) {
      Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(this, state);
      this.updatePoints(this.points);
      return this;
    }
  }, {
    key: "updateSideLabels",
    value: function updateSideLabels() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.options.side != null) {
        var pCount = this.points.length - 1;

        if (this.close) {
          pCount += 1;
        }

        for (var i = 0; i < pCount; i += 1) {
          var j = i + 1;

          if (i === pCount - 1 && this.close) {
            j = 0;
          }

          var name = "side".concat(i).concat(j);

          if (this.elements[name] != null) {
            var wasHidden = !this.elements[name].isShown;
            this.elements[name].updateLabel(rotationOffset);

            if (wasHidden) {
              this.elements[name].hide();
            }
          }
        }
      }
    }
  }, {
    key: "updateAngleLabels",
    value: function updateAngleLabels() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (this.options.angle != null) {
        var pCount = this.points.length;

        if (this.close === false) {
          pCount -= 2;
        }

        var firstIndex = 0;

        if (this.close === false) {
          firstIndex = 1;
        }

        for (var i = firstIndex; i < pCount + firstIndex; i += 1) {
          var name = "angle".concat(i);

          if (this.elements[name] != null) {
            var wasHidden = !this.elements[name].isShown;
            this.elements[name].updateLabel(rotationOffset);

            if (wasHidden) {
              this.elements[name].hide();
            }
          }
        }
      }
    }
    /**
     * Update the polyline with new point locations.
     *
     * Will publish {@link SUB_PolylineUpdatePoints} unless
     * `doNotPublishUpdatePoints` is `true`.
     */

  }, {
    key: "updatePoints",
    value: function updatePoints(newPointsIn) {
      var doNotPublishUpdatePoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var newPoints = newPointsIn.map(function (p) {
        return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p);
      });

      if (this._line != null) {
        this._line.custom.updatePoints({
          points: newPoints
        });
      } // Add Pads


      var pCount = this.points.length;

      if (this.options.pad) {
        for (var i = 0; i < pCount; i += 1) {
          var name = "pad".concat(i);

          if (this.elements[name]) {
            // if (this.elements[name].isMovable === false) {
            this.elements[name].transform.updateTranslation(newPoints[i]); // }
          }
        }
      }

      if (this.options.side != null) {
        pCount = this.points.length - 1;

        if (this.close) {
          pCount += 1;
        }

        for (var _i3 = 0; _i3 < pCount; _i3 += 1) {
          var j = _i3 + 1;

          if (_i3 === pCount - 1 && this.close) {
            j = 0;
          }

          var _name = "side".concat(_i3).concat(j);

          if (this.elements[_name] != null) {
            var wasHidden = !this.elements[_name].isShown;

            if (this.reverse) {
              this.elements[_name].setEndPoints(newPoints[j], newPoints[_i3], this.elements[_name].custom.offset);
            } else {
              this.elements[_name].setEndPoints(newPoints[_i3], newPoints[j], this.elements[_name].custom.offset);
            }

            if (wasHidden) {
              this.elements[_name].hide();
            }
          }
        }
      }

      this.points = newPoints;
      this.updateAngles();

      if (this.makeValid != null && this.makeValid.shape === 'triangle' && !doNotPublishUpdatePoints) {
        this.makeValidTriangle();
      }

      if (this.updatePointsCallback != null && !doNotPublishUpdatePoints) {
        this.fnMap.exec(this.updatePointsCallback);
        this.subscriptions.publish('updatePoints');
      }
    }
  }, {
    key: "updateAngles",
    value: function updateAngles() {
      if (this.options.angle == null) {
        return;
      }

      var pCount = this.points.length;

      if (this.close === false) {
        pCount -= 2;
      }

      for (var i = 0; i < pCount; i += 1) {
        var p1 = i;
        var p2 = i + 1;
        var p3 = i + 2;

        if (i === pCount - 2 && this.close) {
          p3 = 0;
        } // let j = i + 1;
        // let k = i - 1;


        if (i === pCount - 1 && this.close) {
          p2 = 0;
          p3 = 1;
        } // if (i === 0 && this.close) {
        //   k = pCount - 1;
        // }


        var name = "angle".concat(i);

        if (this.elements[name] != null) {
          var wasHidden = !this.elements[name].isShown;

          if (this.reverse) {
            var newP1 = p3;
            p3 = p1;
            p1 = newP1;
          }

          this.elements[name].setAngle({
            p1: this.points[p1],
            p2: this.points[p2],
            p3: this.points[p3]
          });

          if (wasHidden) {
            this.elements[name].hide();
          }
        }
      }
    }
  }, {
    key: "updateRotation",
    value: function updateRotation() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var i = 0; // $FlowFixMe

      var angle = this["_angle".concat(i)];

      while (angle != null) {
        angle.update(this.getRotation() + rotationOffset);
        i += 1; // $FlowFixMe

        angle = this["_angle".concat(i)];
      }

      i = 0; // $FlowFixMe

      var side = this["_side".concat(i).concat(i + 1)];

      while (side != null) {
        side.updateLabel(this.getRotation() + rotationOffset);
        i += 1; // $FlowFixMe

        side = this["_side".concat(i).concat(i + 1)];
      } // $FlowFixMe


      side = this["_side".concat(i, 0)];

      if (side != null) {
        side.updateLabel(this.getRotation() + rotationOffset);
      }
    }
    /**
     * Reverse points in the polyline.
     *
     * Will publish {@link SUBSCRIPTION_PolylineUpdatePoints} unless
     * `doNotPublishUpdatePoints` is `true`.
     *
     * @param {boolean} doNotPublishUpdatePoints if `true` the `updatePoints`
     * subscription will not be published.
     */

  }, {
    key: "reversePoints",
    value: function reversePoints() {
      var doNotPublishUpdatePoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var newPoints = [];

      for (var i = 0; i < this.points.length; i += 1) {
        newPoints.push(this.points[this.points.length - 1 - i]);
      }

      this.updatePoints(newPoints, doNotPublishUpdatePoints);
    }
    /**
     * The Collections Polyline is a {@link FigureElementCollection}, with a
     * transform that includes a translation, or position, transform element.
     *
     * Changing the position element of the transform would normally move
     * everything in the collection. This method instead changes the position
     * without moving everything by updating the polyline points with an
     * offset that is the opposite new position.
     *
     * As an example, if a rotation around the second point of a polyline is
     * desired, then setPositionWithoutMoving at the point before rotating.
     */

  }, {
    key: "setPositionWithoutMoving",
    value: function setPositionWithoutMoving(newPositionPointOrX) {
      var newPositionY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var newPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (typeof newPositionPointOrX === 'number') {
        newPosition.x = newPositionPointOrX;
        newPosition.y = newPositionY;
      } else {
        newPosition = newPositionPointOrX;
      }

      var currentPosition = this.getPosition();
      var delta = currentPosition.sub(newPosition);
      this.setPosition(newPosition);
      var newPoints = this.points.map(function (p) {
        return p.add(delta);
      });
      this.updatePoints(newPoints);
    }
    /**
     * The Collections Polyline is a {@link FigureElementCollection}, with a
     * transform that includes a rotation transform element.
     *
     * Changing the rotation element of the transform would normally rotate
     * everything in the collection. This method instead changes the rotation
     * without rotating everything by updating the polyline points with a
     * rotation that is the negative of the `newRotation`.
     */

  }, {
    key: "setRotationWithoutMoving",
    value: function setRotationWithoutMoving(newRotation) {
      var currentRotation = this.getRotation();
      var delta = currentRotation - newRotation;
      var deltaMatrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(delta).m();
      this.setRotation(newRotation);
      var newPoints = this.points.map(function (p) {
        return p.transformBy(deltaMatrix);
      });
      this.updatePoints(newPoints);
    }
    /**
     * The Collections Polyline is a {@link FigureElementCollection}, with a
     * transform that includes a scale transform element.
     *
     * Changing the scale element of the transform would normally scale
     * everything in the collection. This method instead changes the scale
     * without scaling everything by updating the polyline points with a
     * scale that is the inverse of the new scale.
     */

  }, {
    key: "setScaleWithoutMoving",
    value: function setScaleWithoutMoving(newScalePointOrX) {
      var newScaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var newScale = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (typeof newScalePointOrX === 'number') {
        newScale.x = newScalePointOrX;
        newScale.y = newScaleY;
      } else {
        newScale = newScalePointOrX;
      }

      var currentScale = this.getScale();
      var delta = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](currentScale.x / newScale.x, currentScale.y / newScale.y);
      var deltaMatrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(delta).m();
      this.setScale(newScale);
      var newPoints = this.points.map(function (p) {
        return p.transformBy(deltaMatrix);
      });
      this.updatePoints(newPoints);
    }
  }, {
    key: "setShow",
    value: function setShow(name, show) {
      for (var i = 0; i < this.drawOrder.length; i += 1) {
        var element = this.elements[this.drawOrder[i]];

        if (element.name.startsWith(name)) {
          if (show) {
            element.showAll();
          } else {
            element.hide();
          }
        }
      }
    }
    /**
     * Hide all angle annotations.
     */

  }, {
    key: "hideAngles",
    value: function hideAngles() {
      this.setShow('angle', false);
    }
    /**
     * Hide all side annotations.
     */

  }, {
    key: "hideSides",
    value: function hideSides() {
      this.setShow('side', false);
    }
    /**
     * Show all angle annotations.
     */

  }, {
    key: "showAngles",
    value: function showAngles() {
      this.setShow('angle', true);
    }
    /**
     * Hide all side annotations.
     */

  }, {
    key: "showSides",
    value: function showSides() {
      this.setShow('side', true);
    }
  }, {
    key: "updateLabels",
    value: function updateLabels() {
      var rotationOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getRotation();
      this.updateAngleLabels(rotationOffset);
      this.updateSideLabels(rotationOffset);
    }
  }, {
    key: "makeValidTriangle",
    value: function makeValidTriangle() {
      // $FlowFixMe
      var angle0 = this._angle0; // $FlowFixMe

      var angle1 = this._angle1; // $FlowFixMe

      var angle2 = this._angle2; // $FlowFixMe

      var side01 = this._side01; // $FlowFixMe

      var side12 = this._side12; // $FlowFixMe

      var side20 = this._side20;
      var anglePrecision = angle0.label.precision;
      var sidePrecision = side01.label.precision; // $FlowFixMe

      var clipAngle0 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle0.getAngle(), '0to360') * 180 / Math.PI;
      var clipAngle1 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle1.getAngle(), '0to360') * 180 / Math.PI;
      var clipAngle2 = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle2.getAngle(), '0to360') * 180 / Math.PI;
      var a0 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle0, anglePrecision);
      var a1 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle1, anglePrecision);
      var a2 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle2, anglePrecision);
      var s01 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side01.getLength(), sidePrecision);
      var s12 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side12.getLength(), sidePrecision);
      var s20 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side20.getLength(), sidePrecision); // Reverse the points if the angles are on the outside

      if (a0 > 90 && a1 > 90 && a2 > 90) {
        this.reverse = !this.reverse;
        this.updatePoints(this.points, false);
        a0 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle0.getAngle(), '0to360') * 180 / Math.PI, anglePrecision);
        a1 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle1.getAngle(), '0to360') * 180 / Math.PI, anglePrecision);
        a2 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["clipAngle"])(angle2.getAngle(), '0to360') * 180 / Math.PI, anglePrecision);
      } // else {
      // This is a weird case at the 0/360 transition


      if (a0 > 180) {
        a0 = 360 - angle0;
      }

      if (a1 > 180) {
        a1 = 360 - angle1;
      }

      if (a2 > 180) {
        a2 = 360 - angle2;
      } // Hide the angles if the triangle is thin or small enough
      // if (
      //   (angle0.label.autoHide > -1 && a0 > angle0.label.autoHide)
      //   || (angle0.label.autoHideMax != null && angle0.label.autoHideMax < a0)
      //   || (angle1.label.autoHide > -1 && a1 > angle1.label.autoHide)
      //   || (angle1.label.autoHideMax != null && angle1.label.autoHideMax < a1)
      //   || (angle2.label.autoHide > -1 && a2 > angle2.label.autoHide)
      //   || (angle2.label.autoHideMax != null && angle2.label.autoHideMax < a2)
      //   || s01 < 0.6 || s12 < 0.6 || s20 < 0.6
      // ) {
      // if (angle0.isShown) {
      // Make angles consistent with 180º


      var tot = a0 + a1 + a2;
      var diff = tot - 180; // If the angles are > 180, then find the closet angle
      // to rounding down and reduce it by diff
      // If the angles are < 180 then find the closes angle
      // to round down and round it down

      var remainders = [Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle0, anglePrecision + 1), Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle1, anglePrecision + 1), Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(clipAngle2, anglePrecision + 1)].map(function (a) {
        return a - Math.floor(a * Math.pow(10, anglePrecision)) / Math.pow(10, anglePrecision);
      });
      var angles = [a0, a1, a2];
      var indexToChange = 0;

      if (tot > 180) {
        indexToChange = remainders.reduce(function (iMax, x, i, arr) {
          return x > arr[iMax] ? i : iMax;
        }, 0);
      } else if (tot < 180) {
        indexToChange = remainders.reduce(function (iMin, x, i, arr) {
          return x < arr[iMin] ? i : iMin;
        }, 1);
      }

      angles[indexToChange] -= diff;
      a0 = angles[0];
      a1 = angles[1];
      a2 = angles[2];
      angle0.setLabel("".concat(a0.toFixed(anglePrecision), "\xBA"));
      angle1.setLabel("".concat(a1.toFixed(anglePrecision), "\xBA"));
      angle2.setLabel("".concat(a2.toFixed(anglePrecision), "\xBA"));
      angle0.checkLabelForRightAngle();
      angle1.checkLabelForRightAngle();
      angle2.checkLabelForRightAngle();

      if (this.makeValid != null) {
        var minSide = this.makeValid.hide.minSide;
        var _this$makeValid$hide = this.makeValid.hide,
            minAngle = _this$makeValid$hide.minAngle,
            maxAngle = _this$makeValid$hide.maxAngle;
        var hideAngles = false;

        if (minAngle != null) {
          minAngle *= 180 / Math.PI;

          if (a0 < minAngle || a1 < minAngle || a2 < minAngle) {
            hideAngles = true;
          }
        }

        if (maxAngle != null) {
          maxAngle *= 180 / Math.PI;

          if (a0 > maxAngle || a1 > maxAngle || a2 > maxAngle) {
            hideAngles = true;
          }
        }

        if (minSide != null && (s01 < minSide || s12 < minSide || s20 < minSide)) {
          hideAngles = true;
        }

        if (hideAngles) {
          this.hideAngles();
        }
      } // Make sides consistent with equilateral or isosceles


      if ((side01.isShown || side12.isShown || side20.isShown) && a0 > 0 && a0 < 180 && a1 > 0 && a1 < 180 && a2 > 0 && a2 < 180) {
        // s12 = round(
        //   s01 / Math.sin(a2 * Math.PI / 180) * Math.sin(a0 * Math.PI / 180),
        //   sidePrecision,
        // );
        // s20 = round(
        //   s01 / Math.sin(a2 * Math.PI / 180) * Math.sin(a1 * Math.PI / 180),
        //   sidePrecision,
        // );
        var leastSigStep = 1 / Math.pow(10, sidePrecision); // If Equilateral, make all sides equal

        if (a0 === 60 && a1 === 60 && a2 === 60) {
          s12 = s01;
          s20 = s01; // If Isosceles possibility 1:
        } else if (a0 === a1) {
          s20 = s12;

          if (s01 === s12) {
            var moreAccurate = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side01.getLength(), sidePrecision + 1);

            if (moreAccurate < s01) {
              s01 -= leastSigStep;
            } else {
              s01 += leastSigStep;
            }
          } // If Isosceles possibility 2:

        } else if (a0 === a2) {
          s01 = s12;

          if (s20 === s12) {
            var _moreAccurate = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side20.getLength(), sidePrecision + 1);

            if (_moreAccurate < s20) {
              s20 -= leastSigStep;
            } else {
              s20 += leastSigStep;
            }
          } // If Isosceles possibility 3:

        } else if (a1 === a2) {
          s20 = s01;

          if (s12 === s01) {
            var _moreAccurate2 = Object(_tools_math__WEBPACK_IMPORTED_MODULE_2__["round"])(side12.getLength(), sidePrecision + 1);

            if (_moreAccurate2 < s12) {
              s12 -= leastSigStep;
            } else {
              s12 += leastSigStep;
            }
          } // If these are not equilateral, or isosceles, then all sides must be different length

        }
      } // if (s01 === Infinity) {
      //   s01 = round(side01.getLength(), sidePrecision);
      // }
      // if (s12 === Infinity) {
      //   s12 = round(side12.getLength(), sidePrecision);
      // }
      // if (s20 === Infinity) {
      //   s20 = round(side20.getLength(), sidePrecision);
      // }


      side01.setLabel("".concat(s01.toFixed(sidePrecision)));
      side12.setLabel("".concat(s12.toFixed(sidePrecision)));
      side20.setLabel("".concat(s20.toFixed(sidePrecision))); // }
    } // _dup(exceptions: Array<string> = []) {
    //   return super._dup([...exceptions, ...['collections']]);
    // }

  }]);

  return CollectionsPolyline;
}(_Element__WEBPACK_IMPORTED_MODULE_3__["FigureElementCollection"]);



/***/ }),

/***/ "./src/js/figure/FigureCollections/Rectangle.js":
/*!******************************************************!*\
  !*** ./src/js/figure/FigureCollections/Rectangle.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Animation/Animation */ "./src/js/figure/Animation/Animation.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import Figure from '../Figure';

// import {
//   round,
// } from '../../tools/math';




/*
..........########..########..######..########
..........##.....##.##.......##....##....##...
..........##.....##.##.......##..........##...
..........########..######...##..........##...
..........##...##...##.......##..........##...
..........##....##..##.......##....##....##...
..........##.....##.########..######.....##...
*/

/* eslint-disable max-len */

/**
 * {@link FigureElementCollection} representing a rectangle.
 *
 * ![](./apiassets/advrectangle_ex1.png)
 * ![](./apiassets/advrectangle_ex2.png)
 *
 * <p class="inline_gif"><img src="./apiassets/advrectangle.gif" class="inline_gif_image"></p>
 *
 * <p class="inline_gif"><img src="./apiassets/advrectangle_button.gif" class="inline_gif_image"></p>
 *
 * This object defines a rectangle
 * {@link FigureElementCollection} that may include:
 * - border (line)
 * - fill
 * - label
 * - ability to surround another {@link FigureElement} with some space
 * - button behavior when clicked
 *
 * Surrounding another element can be executed through either the
 * <a href="#collectionsrectanglesurround">surround</a> method
 * or the {@link OBJ_SurroundAnimationStep} found in the in
 * the animation manager ({@link FigureElement}.animations),
 * and in the animation builder
 * (<a href="#animationmanagernew">animations.new</a>
 * and <a href="#animationmanagerbuilder">animations.builder</a>).
 *
 * Button behavior means the button will temporarily change a different color
 * when it is clicked. By default, the button will become a little more
 * transparent, but colors for the fill, label and border can also be
 * specified.
 *
 * @see
 *
 * See {@link COL_Rectangle} for setup options.
 *
 * See {@link OBJ_SurroundAnimationStep} for surround animation step options.
 *
 * To test examples below, append them to the
 * <a href="#drawing-boilerplate">boilerplate</a>.
 *
 * @example
 * // Simple rectangle
 * figure.add({
 *   name: 'rect',
 *   method: 'collections.rectangle',
 *   options: {
 *     width: 2,
 *     height: 1,
 *   },
 * });
 *
 * @example
 * // Round corner rectangle with fill and outside line
 * const rect = figure.collections.rectangle({
 *   width: 2,
 *   height: 1,
 *   line: {
 *     width: 0.02,
 *     widthIs: 'outside',
 *     dash: [0.1, 0.02],
 *   },
 *   corner: {
 *     radius: 0.2,
 *     sides: 10,
 *   },
 *   fill: [0.7, 0.7, 1, 1],
 * });
 * figure.add('rect', rect);
 *
 * @example
 * // Rectangle surrounds elements of an equation
 * figure.add([
 *   {
 *     name: 'rect',
 *     method: 'collections.rectangle',
 *     options: {
 *       color: [0.3, 0.3, 1, 1],
 *       line: { width: 0.01 },
 *     },
 *   },
 *   {
 *     name: 'eqn',
 *     method: 'equation',
 *     options: {
 *       forms: { 0: [{ frac: ['a', 'vinculum', 'b'] }, ' ', 'c'] },
 *       position: [1, 0],
 *       scale: 1.5,
 *     },
 *   }
 * ]);
 *
 * const rect = figure.getElement('rect');
 * const eqn = figure.getElement('eqn');
 *
 * rect.surround(eqn._a, 0.03);
 * rect.animations.new()
 *   .pulse({ delay: 1, scale: 1.5 })
 *   .surround({ target: eqn._b, space: 0.03, duration: 1 })
 *   .pulse({ delay: 1, scale: 1.5 })
 *   .surround({ target: eqn._c, space: 0.03, duration: 1 })
 *   .pulse({ delay: 1, scale: 1.5 })
 *   .start();
 *
 * @example
 * // Make a rectangle that behaves like a button
 * figure.add([
 *   {
 *     name: 'rect',
 *     method: 'collections.rectangle',
 *     options: {
 *       width: 0.5,
 *       height: 0.3,
 *       color: [0.3, 0.3, 0.3, 1],
 *       label: 'Save',
 *       corner: { radius: 0.05, sides: 10 },
 *       fill: [0.9, 0.9, 0.9, 1],
 *       button: {
 *         fill: [0.95, 0.95, 0.95, 1],
 *       },
 *     },
 *     mods: {
 *       isTouchable: true,
 *       onClick: () => console.log('clicked'),
 *     },
 *   },
 * ]);
 */

/* eslint-enable max-len */
// $FlowFixMe
var CollectionsRectangle = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsRectangle, _FigureElementCollect);

  var _super = _createSuper(CollectionsRectangle);

  /**
   * @hideconstructor
   */
  function CollectionsRectangle(collections, optionsIn) {
    var _this;

    _classCallCheck(this, CollectionsRectangle);

    // super(new Transform('Plot')
    //   .scale(1, 1)
    //   .rotate(0)
    //   .translate(0, 0), shapes.limits);
    var defaultOptions = {
      width: collections.primitives.defaultLength,
      height: collections.primitives.defaultLength / 2,
      xAlign: 'center',
      yAlign: 'middle',
      color: collections.primitives.defaultColor,
      border: 'children',
      touchBorder: 'border',
      holeBorder: [[]],
      corner: {
        radius: 0,
        sides: 1
      },
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Rectangle').scale(1, 1).rotate(0).translate(0, 0),
      limits: collections.primitives.limits // button: {},

    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);

    if (options.fill == null && options.line == null) {
      options.fill = collections.primitives.defaultColor.slice();
    }

    _this = _super.call(this, options);
    _this.collections = collections;
    _this._line = null;
    _this._fill = null;
    _this._label = null;
    _this.width = options.width;
    _this.height = options.height;
    _this.xAlign = options.xAlign;
    _this.yAlign = options.yAlign;
    _this.border = options.border;
    _this.touchBorder = options.touchBorder;
    _this.holeBorder = options.holeBorder;
    _this.corner = options.corner;
    _this.labelOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0); // if (options.position != null) {
    //   this.transform.updateTranslation(getPoint(options.position));
    // }
    // if (options.transform != null) {
    //   this.transform = getTransform(options.transform);
    // }

    _this.setColor(options.color);

    if (options.fill != null) {
      _this.addRect(options.fill, 'fill', true);
    }

    if (options.line != null) {
      _this.addRect(options.line, 'line', false);
    }

    if (options.label != null) {
      _this.addlabel(options.label);
    }

    if (options.button) {
      _this.addButtonBehavior(options.button);
    }

    _this.setPositions();

    _this.animations.surround = function () {
      for (var _len = arguments.length, opt = new Array(_len), _key = 0; _key < _len; _key++) {
        opt[_key] = arguments[_key];
      }

      var o = _tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"].apply(void 0, [{}, {
        element: _assertThisInitialized(_this),
        space: 0
      }].concat(opt));
      var startPosition;
      var startWidth;
      var startHeight;
      var targetPosition;
      var targetWidth;
      var targetHeight;
      var deltaPosition;
      var deltaWidth;
      var deltaHeight;
      var toSetup = true;

      o.callback = function (percentage) {
        if (toSetup) {
          if (o.start == null) {
            startPosition = _this.getPosition('local');
            startWidth = _this.width;
            startHeight = _this.height;
          } else {
            var _this$getSurround = _this.getSurround(o.start, o.space);

            var _this$getSurround2 = _slicedToArray(_this$getSurround, 3);

            startPosition = _this$getSurround2[0];
            startWidth = _this$getSurround2[1];
            startHeight = _this$getSurround2[2];
          }

          if (o.target == null) {
            targetPosition = _this.getPosition('local');
            targetWidth = _this.width;
            targetHeight = _this.height;
          } else {
            var _this$getSurround3 = _this.getSurround(o.target, o.space);

            var _this$getSurround4 = _slicedToArray(_this$getSurround3, 3);

            targetPosition = _this$getSurround4[0];
            targetWidth = _this$getSurround4[1];
            targetHeight = _this$getSurround4[2];
          }

          deltaPosition = targetPosition.sub(startPosition);
          deltaWidth = targetWidth - startWidth;
          deltaHeight = targetHeight - startHeight;
          toSetup = false;
        }

        var newWidth = startWidth + deltaWidth * percentage;
        var newHeight = startHeight + deltaHeight * percentage;
        var newPosition = startPosition.add(deltaPosition.scale(percentage));

        _this.setSurround(newPosition, newWidth, newHeight);
      };

      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_3__["CustomAnimationStep"](o);
    };

    _this.animations.customSteps.push({
      step: _this.animations.surround.bind(_assertThisInitialized(_this)),
      name: 'surround'
    });

    return _this;
  }

  _createClass(CollectionsRectangle, [{
    key: "addButtonBehavior",
    value: function addButtonBehavior(onClickColors) {
      var _this2 = this;

      var click = function click(name) {
        var element = _this2.elements[name];

        if (element == null) {
          return;
        }

        var currentColor = element.color.slice();
        var targetColor;

        if (Array.isArray(onClickColors)) {
          targetColor = onClickColors.slice(); // $FlowFixMe
        } else if (onClickColors !== true && onClickColors[name] != null) {
          targetColor = onClickColors[name].slice();
        }

        element.animations["new"]().trigger({
          callback: function callback() {
            if (targetColor == null) {
              element.opacity = 0.8;
            } else {
              element.setColor(targetColor);
            }
          },
          duration: 0.1
        }).trigger({
          callback: function callback() {
            if (targetColor == null) {
              element.opacity = 1;
            } else {
              element.setColor(currentColor);
            }
          }
        }).ifCanceledThenComplete().start(); // this.animateNextFrame();
      };

      this.subscriptions.add('onClick', function () {
        click('line');
        click('fill');
        click('label');
      });
    }
  }, {
    key: "addRect",
    value: function addRect(rectOptions, name, fill) {
      var defaultOptions = {
        width: this.width,
        height: this.height,
        xAlign: 'center',
        yAlign: 'middle',
        color: this.color,
        corner: this.corner
      };

      if (!fill) {
        // $FlowFixMe
        defaultOptions.line = {
          widthIs: 'inside',
          cornerStyle: 'auto',
          width: Math.max(Math.min(this.width, this.height) / 100, this.collections.primitives.defaultLineWidth)
        };

        if (defaultOptions.line.width > this.width || defaultOptions.line.width > this.height) {
          defaultOptions.line.widthIs = 'mid';
        }
      }

      var optionsIn;

      if (fill) {
        if (Array.isArray(rectOptions)) {
          optionsIn = {
            color: rectOptions
          };
        } else {
          optionsIn = {
            texture: rectOptions
          };
        }
      } else {
        optionsIn = {
          line: rectOptions
        };
      }

      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn); // $FlowFixMe

      this[name] = o;
      var rect = this.collections.primitives.rectangle(o);
      this.add(name, rect);
    }
  }, {
    key: "setPositions",
    value: function setPositions() {
      var bounds = {
        width: this.width,
        height: this.height
      };
      var position = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

      if (this.xAlign === 'left') {
        position.x += bounds.width / 2;
      } else if (this.xAlign === 'right') {
        position.x -= bounds.width / 2;
      } else if (typeof this.xAlign === 'number') {
        position.x = position.x + bounds.width / 2 - this.xAlign * bounds.width;
      }

      if (this.yAlign === 'bottom') {
        position.y += bounds.height / 2;
      } else if (this.yAlign === 'top') {
        position.y -= bounds.height / 2;
      } else if (typeof this.yAlign === 'number') {
        position.y = position.y + bounds.height / 2 - bounds.height * this.yAlign;
      }

      var _line = this._line,
          _fill = this._fill,
          _label = this._label;

      if (_line) {
        _line.setPosition(position);
      }

      if (_fill) {
        _fill.setPosition(position);
      }

      if (_label) {
        // const delta = _label.getPosition('local');
        _label.setPosition(position.add(this.labelOffset)); // const numLines = this._label.drawingObject.lines.length;
        // const numText = this._label.drawingObject.text.length;
        // if (numLines === 1 )
        // if (numLines === 1) {}
        // this._label.setPosition(position);

      } // return position;

    }
  }, {
    key: "addlabel",
    value: function addlabel(textOptions) {
      var defaultOptions = {
        font: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.collections.primitives.defaultFont),
        xAlign: 'center',
        yAlign: 'baseline',
        justify: 'center',
        color: this.color
      };
      defaultOptions.font.size = this.height * 0.4;
      defaultOptions.font.color = this.color;
      var optionsIn;

      if (typeof textOptions === 'string') {
        optionsIn = {
          text: textOptions
        };
      } else {
        optionsIn = textOptions;
      }

      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      this.labelOffset = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, -o.font.size / 2.5); // if (o.position == null) {
      //   o.position = new Point(0, -o.font.size / 2.5);
      // }
      // o.position = o.position.add(this.getAlignmentPosition());

      var label = this.collections.primitives.textLines(o);
      this.add('label', label);
    }
  }, {
    key: "getSurround",
    value: function getSurround(element) {
      var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var bounds;

      if (Array.isArray(element)) {
        var borders = [];
        element.forEach(function (e) {
          var b = e.getBorder('figure');
          borders.push.apply(borders, _toConsumableArray(b));
        });
        bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(borders, space);
      } else {
        bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(element.getBorder('figure'), space);
      }

      var matrix = this.spaceTransformMatrix('figure', 'draw');
      var scale = matrix[0];
      var newWidth = bounds.width * scale;
      var newHeight = bounds.height * scale;
      var center = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.left + bounds.width / 2, bounds.bottom + bounds.height / 2).transformBy(this.spaceTransformMatrix('figure', 'local'));
      var position = center;

      if (this.xAlign === 'left') {
        position.x -= newWidth / 2;
      } else if (this.xAlign === 'right') {
        position.x += newWidth / 2;
      } else if (typeof this.xAlign === 'number') {
        position.x = position.x - newWidth / 2 + this.xAlign * newWidth;
      }

      if (this.yAlign === 'bottom') {
        position.y -= newHeight / 2;
      } else if (this.yAlign === 'top') {
        position.y += newHeight / 2;
      } else if (typeof this.yAlign === 'number') {
        position.y = position.y - newHeight / 2 + newHeight * this.yAlign;
      }

      return [position, newWidth, newHeight];
    }
    /**
     * Surround element of elements with the rectangle.
     */

  }, {
    key: "surround",
    value: function surround(element) {
      var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      var _this$getSurround5 = this.getSurround(element, space),
          _this$getSurround6 = _slicedToArray(_this$getSurround5, 3),
          position = _this$getSurround6[0],
          width = _this$getSurround6[1],
          height = _this$getSurround6[2];

      this.setSurround(position, width, height);
    }
  }, {
    key: "setSurround",
    value: function setSurround(position, width, height) {
      this.width = width;
      this.height = height;

      if (this._line) {
        this._line.custom.updatePoints({
          width: width,
          height: height
        });
      }

      if (this._fill) {
        this._fill.custom.updatePoints({
          width: width,
          height: height
        });
      } // if (this._label) {
      //   this._label.
      // }


      this.setPositions();
      this.setPosition(position);
    }
    /**
     * Set button label.
     */

  }, {
    key: "setLabel",
    value: function setLabel(text) {
      if (this._label != null) {
        var textToUse;

        if (typeof text === 'string') {
          textToUse = {
            text: text
          };
        } else {
          textToUse = text;
        }

        this._label.custom.updateText(textToUse);
      }
    }
    /**
     * Get button label.
     */

  }, {
    key: "getLabel",
    value: function getLabel() {
      if (this._label != null) {
        // $FlowFixMe
        return this._label.drawingObject.text[0].text;
      }

      return '';
    }
  }]);

  return CollectionsRectangle;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (CollectionsRectangle);

/***/ }),

/***/ "./src/js/figure/FigureCollections/SlideNavigator.js":
/*!***********************************************************!*\
  !*** ./src/js/figure/FigureCollections/SlideNavigator.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _SlideNavigator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../SlideNavigator */ "./src/js/figure/SlideNavigator.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import Figure from '../Figure';
 // import {
//   round,
// } from '../../tools/math';





/*
.............##....##....###....##.....##
.............###...##...##.##...##.....##
.............####..##..##...##..##.....##
.............##.##.##.##.....##.##.....##
.............##..####.#########..##...##.
.............##...###.##.....##...##.##..
.............##....##.##.....##....###...
*/

/* eslint-disable max-len */

/**
 * {@link FigureElementCollection} that creates elements to work with {@link SlideNavigator}.
 *
 * <p class="inline_gif"><img src="./apiassets/slidenavigator1.gif" class="inline_gif_image"></p>
 *
 * <p class="inline_gif"><img src="./apiassets/slidenavigator2.gif" class="inline_gif_image"></p>
 *
 * <p class="inline_gif"><img src="./apiassets/slidenavigator3.gif" class="inline_gif_image"></p>
 *
 * This object defines a rectangle
 * {@link FigureElementCollection} that may include:
 * - previous button
 * - next button
 * - {@link OBJ_TextLines} object
 *
 *
 * @see
 *
 * See {@link SlideNavigator} for information about what a slide navigator is.
 *
 * To test examples below, append them to the
 * <a href="#equation-boilerplate">boilerplate</a>.
 *
 * @example
 * // At its simplest, the SlideNavigator can be used to navigate an equation
 * figure.add([
 *   {
 *     name: 'eqn',
 *     method: 'equation',
 *     options: {
 *       formDefaults: { alignment: { xAlign: 'center' } },
 *       forms: {
 *         0: ['a', '_ + ', 'b', '_ = ', 'c'],
 *         1: ['a', '_ + ', 'b', '_ - b_1', '_ = ', 'c', '_ - ', 'b_2'],
 *         2: ['a', '_ = ', 'c', '_ - ', 'b_2'],
 *       },
 *       formSeries: ['0', '1', '2'],
 *     },
 *   },
 *   {
 *     name: 'nav',
 *     method: 'collections.slideNavigator',
 *     options: {
 *       equation: 'eqn',
 *     },
 *   },
 * ]);
 *
 * @example
 * // Text can be used to describe each slide
 * figure.add([
 *   {
 *     name: 'eqn',
 *     method: 'equation',
 *     options: {
 *       formDefaults: { alignment: { xAlign: 'center' } },
 *       forms: {
 *         0: ['a', '_ + ', 'b', '_ = ', 'c'],
 *         1: ['a', '_ + ', 'b', '_ - b_1', '_ = ', 'c', '_ - ', 'b_2'],
 *         2: ['a', '_ = ', 'c', '_ - ', 'b_2'],
 *       },
 *     },
 *   },
 *   {
 *     name: 'nav',
 *     method: 'collections.slideNavigator',
 *     options: {
 *       equation: 'eqn',
 *       text: { position: [0, 0.3] },
 *       slides: [
 *         { text: 'Start with the equation', form: '0' },
 *         { text: 'Subtract b from both sides' },
 *         { form: '1' },
 *         { text: 'The b terms cancel on the left hand side' },
 *         { form: '2' },
 *       ],
 *     },
 *   },
 * ]);
 *
 * @example
 * // This example creates a story by evolving a description, a diagram
 * // and an equation.
 * figure.add([
 *   {   // Square drawing
 *     name: 'square',
 *     method: 'primitives.rectangle',
 *     options: {
 *       width: 0.4,
 *       height: 0.4,
 *       line: { width: 0.005 },
 *     },
 *   },
 *   {   // Side length label
 *     name: 'label',
 *     method: 'text',
 *     options: {
 *       yAlign: 'middle',
 *       position: [0.3, 0],
 *     },
 *   },
 *   {   // Equation
 *     name: 'eqn',
 *     method: 'equation',
 *     options: {
 *       elements: {
 *         eq1: '  =  ',
 *         eq2: '  =  ',
 *         eq3: '  =  ',
 *       },
 *       phrases: {
 *         sideSqrd: { sup: ['side', '_2'] },
 *         areaEqSide: [{ bottomComment: ['Area', 'square'] }, 'eq1', 'sideSqrd'],
 *       },
 *       formDefaults: { alignment: { xAlign: 'center' } },
 *       forms: {
 *         0: ['areaEqSide'],
 *         1: ['areaEqSide', 'eq2', { sup: ['_1', '_2_1'] }, 'eq3', '_1_1'],
 *         2: ['areaEqSide', 'eq2', { sup: ['_2_2', '_2_1'] }, 'eq3', '4'],
 *       },
 *       position: [0, -0.8],
 *     },
 *   },
 *   {   // Slide Navigator
 *     name: 'nav',
 *     method: 'collections.slideNavigator',
 *     options: {
 *       equation: 'eqn',
 *       nextButton: { type: 'arrow', position: [1.2, -0.8] },
 *       prevButton: { type: 'arrow', position: [-1.2, -0.8] },
 *       text: { position: [0, 0.7], font: { size: 0.12 } },
 *     },
 *   },
 * ]);
 *
 * const square = figure.getElement('square');
 * const label = figure.getElement('label');
 *
 * // Update the square size, and side label for any sideLength
 * const update = (sideLength) => {
 *   square.custom.updatePoints({ width: sideLength, height: sideLength });
 *   label.setPosition(sideLength / 2 + 0.1, 0);
 *   label.custom.updateText({ text: `${(sideLength / 0.4).toFixed(1)}` });
 * };
 *
 * // Add slides to the navigator
 * figure.getElement('nav').loadSlides([
 *   {
 *     text: 'The area of a square is the side length squared',
 *     form: '0',
 *     steadyStateCommon: () => update(0.4),
 *   },
 *   { text: 'So for side length of 1 we have and area of 1' },
 *   { form: '1' },
 *   { form: null, text: 'What is the area for side length 2?' },
 *   {
 *     transition: (done) => {
 *       square.animations.new()
 *         .custom({
 *           duration: 1,
 *           callback: p => update(0.4 + p * 0.4),
 *         })
 *         .whenFinished(done)
 *         .start();
 *     },
 *     steadyStateCommon: () => update(0.4),
 *   },
 *   { form: '2' },
 * ]);
 */

/* eslint-enable max-len */
var CollectionsSlideNavigator = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsSlideNavigator, _FigureElementCollect);

  var _super = _createSuper(CollectionsSlideNavigator);

  /**
   * @hideconstructor
   */
  function CollectionsSlideNavigator(collections, optionsIn) {
    var _this;

    _classCallCheck(this, CollectionsSlideNavigator);

    var defaultOptions = {
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('SlideNavigator').scale(1, 1).rotate(0).translate(0, 0),
      limits: collections.primitives.limits,
      // slides: [],
      color: collections.primitives.defaultColor
    };
    var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
    _this = _super.call(this, o);
    _this.collections = collections;
    _this._nextButton = null;
    _this._prevButton = null;
    _this._text = null;

    if (!o.prevButton !== null) {
      _this.addButton(o.prevButton || {}, 'Prev');
    }

    if (!o.nextButton !== null) {
      _this.addButton(o.nextButton || {}, 'Next');
    }

    if (!o.text !== null) {
      _this.addText(o.text || {});
    }

    _this.nav = new _SlideNavigator__WEBPACK_IMPORTED_MODULE_3__["default"]();
    _this.custom.options = o; // this.nav = new SlideNavigator(joinObjects({}, {
    //   collection: o.collection || this,
    //   slides: o.slides,
    //   equation: o.equation,
    //   equationDefaults: o.equationDefaults,
    //   prevButton: this._prevButton,
    //   nextButton: this._nextButton,
    //   text: this._text,
    // }));
    // if (o.collection == null) {
    //   this.nav.collection = null;
    // }

    _this.hasTouchableElements = true;

    _this.onAdd = function () {
      _this.nav.load({
        // $FlowFixMe
        collection: _this.parent,
        slides: o.slides,
        equation: o.equation,
        equationDefaults: o.equationDefaults,
        prevButton: _this._prevButton,
        nextButton: _this._nextButton,
        // $FlowFixMe
        text: _this._text
      });

      _this.nav.goToSlide(0); // if (this.nav.collection == null && this.parent != null) {
      //   this.nav.equations =
      //     Array.isArray(o.equation) ? o.equation : [o.equation];
      //   this.nav.collection = this.parent;
      //   this.nav.setEquations();
      //   this.nav.goToSlide(0);
      // }

    };

    return _this;
  }
  /**
   * Load slides into navigator
   */


  _createClass(CollectionsSlideNavigator, [{
    key: "loadSlides",
    value: function loadSlides(slides) {
      this.nav.slides = slides;
      this.nav.goToSlide(0);
    }
    /**
     * Jump to a specific slide.
     */

  }, {
    key: "goToSlide",
    value: function goToSlide(slideIndex) {
      this.nav.goToSlide(slideIndex);
    }
    /**
     * Progress to the next slide.
     */

  }, {
    key: "nextSlide",
    value: function nextSlide() {
      var ignoreTransition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.nav.nextSlide(ignoreTransition);
    }
    /**
     * Go to the previous slide.
     */

  }, {
    key: "prevSlide",
    value: function prevSlide() {
      this.nav.prevSlide();
    } // onAdd() {
    //   console.log('asdf', this.parent)
    //   if (this.nav.collection == null && this.parent != null) {
    //     this.nav.collection = this.parent;
    //     this.nav.setEquations();
    //   }
    // }

  }, {
    key: "addText",
    value: function addText(textOptions) {
      var defaultOptions = {
        font: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, this.collections.primitives.defaultFont),
        text: '',
        xAlign: 'center'
      }; // defaultOptions.font.size = this.collections.primti * 0.4;

      defaultOptions.font.color = this.color;
      var optionsIn;

      if (typeof textOptions === 'string') {
        optionsIn = {
          text: textOptions
        };
      } else {
        optionsIn = textOptions;
      }

      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
      var text = this.collections.primitives.textLines(o);
      text.isTouchable = true;
      this.add('text', text);
    }
  }, {
    key: "addButton",
    value: function addButton(options, type) {
      var button;

      if (options.type === 'arrow') {
        button = this.getArrowButton(options, type);
      } else {
        button = this.getRectangleButton(options, type);
      }

      button.isTouchable = true;

      if (type === 'Next') {
        this.add('nextButton', button);
      } else {
        this.add('prevButton', button);
      }
    }
  }, {
    key: "getRectangleButton",
    value: function getRectangleButton(options, type) {
      var length = this.collections.primitives.defaultLength;
      var x = type === 'Next' ? length / 3 : -length / 3;
      var defaultButtonOptions = {
        width: length / 3,
        height: length / 5,
        line: {
          width: this.collections.primitives.defaultLineWidth
        },
        corner: {
          radius: length / 30,
          sides: 10
        },
        button: true,
        label: type,
        position: [x, -length / 4]
      };
      var buttonOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultButtonOptions, options);
      return this.collections.rectangle(buttonOptions);
    }
  }, {
    key: "getArrowButton",
    value: function getArrowButton(options, type) {
      var length = this.collections.primitives.defaultLength / 4;
      var angle = 0;
      var x = length;

      if (type === 'Prev') {
        angle = Math.PI;
        x = -x;
      }

      var defaultButtonOptions = {
        head: 'triangle',
        length: length,
        width: length,
        angle: angle,
        position: [x, -length],
        align: 'mid'
      };
      var buttonOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultButtonOptions, options);
      return this.collections.primitives.arrow(buttonOptions);
    }
  }]);

  return CollectionsSlideNavigator;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (CollectionsSlideNavigator);

/***/ }),

/***/ "./src/js/figure/FigureCollections/Trace.js":
/*!**************************************************!*\
  !*** ./src/js/figure/FigureCollections/Trace.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

// import Figure from '../Figure';

// import {
//   round, range,
// } from '../../tools/math';



/**
 * {@link FigureElementCollection} representing a trace.
 *
 * ![](./apiassets/advtrace_ex1.png)
 * ![](./apiassets/advtrace_ex2.png)
 *
 * ![](./apiassets/advtrace_ex3.png)
 * ![](./apiassets/advtrace_ex4.png)
 *
 * ![](./apiassets/advtrace_ex5.png)
 * ![](./apiassets/advtrace_ex6.png)
 *
 * This object defines a trace in an {@link CollectionsPlot}.
 *
 * The trace includes all the points of the trace, and the axes that it
 * should be drawn against and is defined using the {@link COL_PlotTrace}
 * options object.
 *
 * To test examples below, append them to the
 * <a href="#drawing-boilerplate">boilerplate</a>.
 *
 * All examples below also use this power function to generate the traces:
 * ```javascript
 * const pow = (pow = 2, stop = 10, step = 0.05) => {
 *   const xValues = Fig.tools.math.range(0, stop, step);
 *   return xValues.map(x => new Fig.Point(x, x ** pow));
 * }
 * ```
 *
 * @example
 * // When plotting a single trace, just the points are required. By default
 * // the line will be solid, and it will be plotted against the 'x' and 'y' axes.
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: pow(),
 *   },
 * });
 *
 * @example
 * // Change the thickness and color of the line
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: {
 *       points: pow(),
 *       line: {
 *         width: 0.03,
 *         color: [0, 0.8, 0.4, 1],
 *       }
 *     },
 *   },
 * });
 *
 * @example
 * // Default Markers
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: {
 *       points: pow(2, 10, 1),
 *       markers: true,
 *     },
 *   },
 * });
 *
 * @example
 * // Custom Markers
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: {
 *       points: pow(2, 10, 1),
 *       markers: {
 *         radius: 0.035,
 *         sides: 20,
 *         line: { width: 0.01 },
 *       },
 *     },
 *   },
 * });
 *
 * @example
 * // Line and markers
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: {
 *       points: pow(2, 10, 1),
 *       line: { width: 0.01, dash: [0.02, 0.01] },
 *       markers: {
 *         radius: 0.035,
 *         sides: 20,
 *       },
 *     },
 *   },
 * });
 *
 * @example
 * // Use names in trace definitions to customize legend
 * figure.add({
 *   name: 'plot',
 *   method: 'collections.plot',
 *   options: {
 *     trace: [
 *       pow(2),
 *       { points: pow(2.5), name: 'Power 2.5' },
 *       {
 *         points: pow(3, 10, 1),
 *         name: 'Power 3',
 *         markers: { radius: 0.03 },
 *         line: { width: 0.01 },
 *       },
 *     ],
 *     legend: true,
 *   },
 * });
 */
// $FlowFixMe
var CollectionsTrace = /*#__PURE__*/function (_FigureElementCollect) {
  _inherits(CollectionsTrace, _FigureElementCollect);

  var _super = _createSuper(CollectionsTrace);

  // Figure elements

  /**
   * @hideconstructor
   */
  function CollectionsTrace(collections, optionsIn) {
    var _this;

    _classCallCheck(this, CollectionsTrace);

    var defaultOptions = {
      color: collections.primitives.defaultColor,
      font: {
        family: 'Times New Roman',
        size: 0.1,
        style: 'normal',
        weight: 'normal',
        color: collections.primitives.defaultColor,
        opacity: 1
      },
      name: '',
      transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('Trace').scale(1, 1).rotate(0).translate(0, 0),
      limits: collections.primitives.limits
    };
    var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);

    if (options.markers == null && options.line === undefined) {
      options.line = {};
    }

    _this = _super.call(this, options);
    _this.collections = collections;
    _this.defaultFont = options.font;
    _this.points = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(options.points);
    _this.xAxis = options.xAxis;
    _this.yAxis = options.yAxis;
    _this.name = options.name;

    _this.setColor(options.color);

    if (options.xSampleDistance == null) {
      options.xSampleDistance = (_this.xAxis.stopValue - _this.xAxis.startValue) / 4000;
    }

    if (options.ySampleDistance == null) {
      options.ySampleDistance = (_this.yAxis.stopValue - _this.yAxis.startValue) / 4000;
    }

    _this.xSampleDistance = options.xSampleDistance;
    _this.ySampleDistance = options.ySampleDistance;

    if (options.line != null) {
      _this.addLine(options.line);
    }

    if (options.markers != null) {
      _this.addMarkers(options.markers);
    }

    return _this;
  }
  /**
   * Update the trace with a new set of points.
   * @param {Array<TypeParsablePoint>} points
   */


  _createClass(CollectionsTrace, [{
    key: "update",
    value: function update(points) {
      this.removeLine();
      this.removeMarkers();
      this.points = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(points);

      if (this.line != null) {
        this.addLine(this.line);
      }

      if (this.markers != null) {
        this.markers.copy = [];
        this.addMarkers(this.markers);
      } // if (this._line != null) {
      //   this._line.updatePoints({ points: this.points });
      // }

    }
  }, {
    key: "pointToDraw",
    value: function pointToDraw(p) {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](this.xAxis.valueToDraw(p.x), this.yAxis.valueToDraw(p.y));
    }
  }, {
    key: "inAxes",
    value: function inAxes(p) {
      if (this.xAxis.inAxis(p.x) && this.yAxis.inAxis(p.y)) {
        return true;
      }

      return false;
    }
  }, {
    key: "intersect",
    value: function intersect(p1, p2) {
      if (p1.x < 0 && p2.x < 0) {
        return {
          result: false
        };
      }

      if (p1.y < 0 && p2.y < 0) {
        return {
          result: false
        };
      }

      if (p1.x > this.xAxis.length && p2.x > this.xAxis.length) {
        return {
          result: false
        };
      }

      if (p1.y > this.yAxis.length && p2.y > this.yAxis.length) {
        return {
          result: false
        };
      }

      var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
      var result = false;
      var intersect = [];
      var bounds = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([0, 0], [0, this.yAxis.length]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([this.xAxis.length, 0], [this.xAxis.length, this.yAxis.length]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([0, 0], [this.xAxis.length, 0]), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([0, this.yAxis.length], [this.xAxis.length, this.yAxis.length])];
      bounds.forEach(function (bound) {
        var i = line.intersectsWith(bound);

        if (i.withinLine) {
          result = true;
          intersect.push(i.intersect);
        }
      });
      return {
        result: result,
        intersect: intersect
      };
    }
  }, {
    key: "updatePoints",
    value: function updatePoints() {
      var _this2 = this;

      this.polylines = [];
      this.drawPoints = this.points.map(function (p) {
        return _this2.pointToDraw(p);
      });
      this.drawPoints = [];
      var sampling = false;

      if (this.xSampleDistance != null && this.ySampleDistance != null) {
        sampling = true;
      }

      var lastPoint;
      var drawIndexes = [];

      for (var i = 0; i < this.points.length; i += 1) {
        if (sampling && lastPoint != null) {
          if (Math.abs(this.points[i].x - lastPoint.x) >= this.xSampleDistance || Math.abs(this.points[i].y - lastPoint.y) >= this.ySampleDistance) {
            this.drawPoints.push(this.pointToDraw(this.points[i]));
            lastPoint = this.points[i];
            drawIndexes.push(i);
          }
        } else {
          this.drawPoints.push(this.pointToDraw(this.points[i]));
          lastPoint = this.points[i];
          drawIndexes.push(i);
        }
      }

      var inX = [];
      var inY = [];

      for (var _i = 0; _i < drawIndexes.length; _i += 1) {
        inX.push(this.xAxis.inAxis(this.points[drawIndexes[_i]].x));
        inY.push(this.yAxis.inAxis(this.points[drawIndexes[_i]].y));
      }

      var inLine = false;
      var polyline = [];

      for (var _i2 = 0; _i2 < this.drawPoints.length; _i2 += 1) {
        if (inX[_i2] && inY[_i2]) {
          inLine = true;
          polyline.push(this.drawPoints[_i2]);
        } // This point is the last point


        if (inLine && _i2 === this.drawPoints.length - 1) {
          this.polylines.push(polyline);
          polyline = []; // Next point is within axes
        } else if (inLine && inX[_i2 + 1] && inY[_i2 + 1]) {// this.polylines.push(polyline);
          // polyline
          // Next point leaving the axes
        } else if (inLine && (inX[_i2 + 1] === false || inY[_i2 + 1] === false)) {
          var intersect = this.intersect(this.drawPoints[_i2], this.drawPoints[_i2 + 1]);

          if (intersect.result) {
            var _polyline;

            (_polyline = polyline).push.apply(_polyline, _toConsumableArray(intersect.intersect));
          }

          this.polylines.push(polyline);
          polyline = [];
          inLine = false; // This point is out of axes, and next point is in axes
        } else if (inLine === false && inX[_i2 + 1] && inY[_i2 + 1]) {
          var _intersect = this.intersect(this.drawPoints[_i2], this.drawPoints[_i2 + 1]);

          if (_intersect.result) {
            var _polyline2;

            (_polyline2 = polyline).push.apply(_polyline2, _toConsumableArray(_intersect.intersect));
          } // This point is out of axes, and next point is out of axes, but
          // the line between points may cross over into the axes

        } else if (inLine === false && _i2 < this.drawPoints.length - 1) {
          var _intersect2 = this.intersect(this.drawPoints[_i2], this.drawPoints[_i2 + 1]);

          if (_intersect2.result) {
            this.polylines.push(_intersect2.intersect.map(function (p) {
              return p._dup();
            }));
          }
        }
      }
    }
  }, {
    key: "addLine",
    value: function addLine(options) {
      var _this3 = this;

      var defaultOptions = {
        color: this.color,
        width: this.collections.primitives.defaultLineWidth
      };
      this.updatePoints();
      this.line = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);
      this.polylines.forEach(function (points, index) {
        var line = _this3.collections.primitives.polyline(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, _this3.line, {
          points: points
        }));

        _this3.add("line".concat(index), line);
      });
    }
  }, {
    key: "removeLine",
    value: function removeLine() {
      var _this4 = this;

      var lines = this.drawOrder.filter(function (e) {
        return e.startsWith('line');
      });
      lines.forEach(function (elementName) {
        _this4.remove(elementName);
      });
    }
  }, {
    key: "removeMarkers",
    value: function removeMarkers() {
      var _this5 = this;

      // const index = this.drawOrder.indexOf('markers');
      // if (index !== -1) {
      //   this.remove('markers');
      // }
      var markers = this.drawOrder.filter(function (e) {
        return e.startsWith('markers');
      });
      markers.forEach(function (elementName) {
        _this5.remove(elementName);
      });
    }
  }, {
    key: "addMarkers",
    value: function addMarkers(options) {
      var _this6 = this;

      var defaultOptions = {
        radius: 0.02,
        color: this.color
      };
      var markers = this.points.filter(function (p) {
        return _this6.inAxes(p);
      });
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, options);
      this.markers = o;

      if (markers.length === 0) {
        return;
      }

      if (o.copy == null) {
        o.copy = [];
      } else if (Array.isArray(o.copy) === false) {
        o.copy = [o.copy];
      }

      o.copy.push({
        to: markers.map(function (p) {
          return _this6.pointToDraw(p);
        }),
        original: false
      });
      this.add('markers', this.collections.primitives.polygon(o));
    }
  }, {
    key: "_getStateProperties",
    value: function _getStateProperties(options) {
      // eslint-disable-line class-methods-use-this
      return _toConsumableArray(_get(_getPrototypeOf(CollectionsTrace.prototype), "_getStateProperties", this).call(this, options));
    } // _fromState(state: Object) {
    //   joinObjects(this, state);
    //   this.setAngle({
    //     angle: this.angle,
    //     rotationOffset: this.lastLabelRotationOffset,
    //   });
    //   return this;
    // }

  }]);

  return CollectionsTrace;
}(_Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementCollection"]);

/* harmony default export */ __webpack_exports__["default"] = (CollectionsTrace);

/***/ }),

/***/ "./src/js/figure/FigurePrimitives/FigurePrimitives.js":
/*!************************************************************!*\
  !*** ./src/js/figure/FigurePrimitives/FigurePrimitives.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FigurePrimitives; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/htmlGenerator */ "./src/js/tools/htmlGenerator.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _DrawContext2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DrawContext2D */ "./src/js/figure/DrawContext2D.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _DrawingObjects_DrawingObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../DrawingObjects/DrawingObject */ "./src/js/figure/DrawingObjects/DrawingObject.js");
/* harmony import */ var _Generic__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Generic */ "./src/js/figure/FigurePrimitives/Generic.js");
/* harmony import */ var _Text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Text */ "./src/js/figure/FigurePrimitives/Text.js");
/* harmony import */ var _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../DrawingObjects/TextObject/TextObject */ "./src/js/figure/DrawingObjects/TextObject/TextObject.js");
/* harmony import */ var _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../DrawingObjects/HTMLObject/HTMLObject */ "./src/js/figure/DrawingObjects/HTMLObject/HTMLObject.js");
/* harmony import */ var _geometries_lines_lines__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geometries/lines/lines */ "./src/js/figure/geometries/lines/lines.js");
/* harmony import */ var _geometries_polygon_polygon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geometries/polygon/polygon */ "./src/js/figure/geometries/polygon/polygon.js");
/* harmony import */ var _geometries_rectangle__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geometries/rectangle */ "./src/js/figure/geometries/rectangle.js");
/* harmony import */ var _geometries_ellipse__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geometries/ellipse */ "./src/js/figure/geometries/ellipse.js");
/* harmony import */ var _geometries_triangle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geometries/triangle */ "./src/js/figure/geometries/triangle.js");
/* harmony import */ var _geometries_arrow__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../geometries/arrow */ "./src/js/figure/geometries/arrow.js");
/* harmony import */ var _geometries_line__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../geometries/line */ "./src/js/figure/geometries/line.js");
/* harmony import */ var _geometries_copy_copy__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../geometries/copy/copy */ "./src/js/figure/geometries/copy/copy.js");
/* harmony import */ var _geometries_buffer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../geometries/buffer */ "./src/js/figure/geometries/buffer.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* eslint-disable no-param-reassign */
 // import {
//   round
// } from '../../tools/math';







 // import VertexObject from '../DrawingObjects/VertexObject/VertexObject';
// import {
//   PolyLine, PolyLineCorners,
// } from '../FigureElements/PolyLine';
// import Fan from '../FigureElements/Fan';
// import {
//   Polygon, PolygonFilled, PolygonLine,
// } from '../FigureElements/Polygon';
// import RadialLines from '../FigureElements/RadialLines';
// import HorizontalLine from '../FigureElements/HorizontalLine';
// import DashedLine from '../FigureElements/DashedLine';
// import RectangleFilled from '../FigureElements/RectangleFilled';
// import Rectangle from '../FigureElements/Rectangle';

 // import Box from '../FigureElements/Box';
// import type { TypeRectangleFilledReference } from '../FigureElements/RectangleFilled';
// import Lines from '../FigureElements/Lines';
// import Arrow from '../FigureElements/Arrow';
// import { AxisProperties } from '../FigureElements/Plot/AxisProperties';
// import Axis from '../FigureElements/Plot/Axis';

 // import {
//   FigureText, FigureFont, TextObject, LinesObject,
// } from '../DrawingObjects/TextObject/TextObject';









 // import type {
//   OBJ_Copy,
// } from './FigurePrimitiveTypes';



/**
 * Line style definition object.
 * @property {'mid' | 'outside' | 'inside' | 'positive' | 'negative' | number} [widthIs]
 * defines how the width is grown from the polyline's points. When using
 * `number`, 0 is the equivalent of 'inside' and 1 is the equivalent of
 * 'outside'.
 * @property {number} [width] line width
 * @property {TypeDash} [dash] select solid or dashed line
 * @property {TypeColor} [color] line color
 */

function parsePoints(options, keysToParsePointsOrPointArrays) {
  var parseKey = function parseKey(key) {
    var value = options[key];

    if (value == null) {
      return;
    }

    if (typeof value === 'string') {
      return;
    }

    if (typeof value === 'number') {
      return;
    }

    var processArray = function processArray(a) {
      for (var i = 0; i < a.length; i += 1) {
        if (Array.isArray(a[i]) && !(typeof a[i][0] === 'number')) {
          // eslint-disable-next-line no-param-reassign
          a[i] = processArray(a[i]);
        } else {
          // eslint-disable-next-line no-param-reassign
          a[i] = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(a[i]);
        }
      }

      return a;
    };

    if (Array.isArray(value) && !(typeof value[0] === 'number')) {
      // eslint-disable-next-line no-param-reassign
      options[key] = processArray(value); // value.map(p => getPoint(p));
    } else {
      // eslint-disable-next-line no-param-reassign
      options[key] = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(value);
    }
  };

  if (typeof keysToParsePointsOrPointArrays === 'string') {
    parseKey(keysToParsePointsOrPointArrays);
  } else {
    keysToParsePointsOrPointArrays.forEach(function (key) {
      return parseKey(key);
    });
  }
} // function processOptions(...optionsIn: Array<Object>) {
//   const options = joinObjects({}, ...optionsIn);
//   if (options.position != null) {
//     const p = getPoint(options.position);
//     if (options.transform == null) {
//       options.transform = new Transform('processOptions').translate(0, 0);
//     }
//     options.transform.updateTranslation(p);
//   }
//   return options;
// }


function setupPulse(element, options) {
  if (options.pulse != null) {
    if (typeof element.pulseDefault !== 'function' && typeof element.pulseDefault !== 'string') {
      if (typeof options.pulse === 'number') {
        // eslint-disable-next-line no-param-reassign
        element.pulseDefault.scale = options.pulse;
      } else {
        // eslint-disable-next-line no-param-reassign
        element.pulseDefault = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, element.pulseDefault, options.pulse);
      }
    }
  }
}
/**
 * Built in figure primitives.
 *
 * Including simple shapes, grid and text.
 */


var FigurePrimitives = /*#__PURE__*/function () {
  /**
    * @hideconstructor
    */
  function FigurePrimitives(webgl, draw2D, // draw2DFigures: Object,
  htmlCanvas, limits, spaceTransforms, animateNextFrame, defaultColor, defaultDimColor, defaultFont, defaultLineWidth, defaultLength) {
    _classCallCheck(this, FigurePrimitives);

    if (Array.isArray(webgl)) {
      this.webgl = webgl;
    } else {
      this.webgl = [webgl];
    }

    if (Array.isArray(draw2D)) {
      this.draw2D = draw2D;
    } else {
      this.draw2D = [draw2D];
    }
    /**
     * @private {htmlElement}
     */


    this.htmlCanvas = htmlCanvas;
    this.limits = limits;
    this.animateNextFrame = animateNextFrame;
    this.spaceTransforms = spaceTransforms;
    this.defaultColor = defaultColor;
    this.defaultDimColor = defaultDimColor;
    this.defaultFont = defaultFont;
    this.defaultLineWidth = defaultLineWidth;
    this.defaultLength = defaultLength; // this.draw2DFigures = draw2DFigures;
  }
  /**
   * {@link FigureElementPrimitive} that draws a generic shape.
   * @see {@link OBJ_Generic} for options and examples.
   */


  _createClass(FigurePrimitives, [{
    key: "generic",
    value: function generic() {
      var defaultOptions = {
        name: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["generateUniqueId"])('primitive_'),
        color: this.defaultColor,
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('generic').standard(),
        texture: {
          src: '',
          mapTo: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](-1, -1, 2, 2),
          mapFrom: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](0, 0, 1, 1),
          repeat: false,
          onLoad: this.animateNextFrame
        }
      };

      for (var _len = arguments.length, optionsIn = new Array(_len), _key = 0; _key < _len; _key++) {
        optionsIn[_key] = arguments[_key];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      options.transform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(options.transform);

      if (options.position != null) {
        options.position = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);
        options.transform.updateTranslation(options.position);
      }

      var element = Object(_Generic__WEBPACK_IMPORTED_MODULE_8__["default"])(this.webgl, options.color, options.transform, this.limits, options.texture.src, options.texture.mapTo, options.texture.mapFrom, options.texture.repeat, options.texture.onLoad, options.name);
      element.dimColor = this.defaultDimColor.slice();

      element.custom.updateGeneric = function update(updateOptions) {
        var o = updateOptions;

        if (o.copy != null && !Array.isArray(o.copy)) {
          o.copy = [o.copy];
        }

        if (o.points != null) {
          // $FlowFixMe
          o.points = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(o.points);
        }

        if (o.drawBorder != null) {
          // $FlowFixMe
          element.drawBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.drawBorder);
        } else if (o.points != null) {
          element.drawBorder = [o.points];
        }

        if (o.drawBorderBuffer != null) {
          // $FlowFixMe
          element.drawBorderBuffer = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.drawBorderBuffer);
        } else element.drawBorderBuffer = element.drawBorder;

        if (o.border != null) {
          // $FlowFixMe
          element.border = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.border);
        }

        if (o.touchBorder != null) {
          // $FlowFixMe
          element.touchBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.touchBorder);
        }

        if (o.holeBorder != null) {
          // $FlowFixMe
          element.holeBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.holeBorder);
        }

        element.drawingObject.change(o);
      };

      element.custom.updateGeneric(options);
      element.custom.updatePoints = element.custom.updateGeneric;
      setupPulse(element, options);
      return element;
    }
  }, {
    key: "getPolylineTris",
    value: function getPolylineTris(optionsIn) {
      var defaultOptions = {
        points: [[0, 0], [1, 0]],
        width: this.defaultLineWidth,
        color: this.defaultColor,
        close: false,
        widthIs: 'mid',
        cornerStyle: 'auto',
        cornerSize: 0.01,
        cornerSides: 10,
        cornersOnly: false,
        cornerLength: 0.1,
        minAutoCornerAngle: Math.PI / 7,
        dash: [],
        linePrimitives: false,
        lineNum: 1,
        drawBorder: 'negative',
        holeBorder: [[]],
        drawBorderBuffer: 0,
        simple: false
      };
      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, defaultOptions, optionsIn);

      if (o.linePrimitives === false) {
        o.lineNum = 2;
      }

      parsePoints(o, ['points', 'border', 'holeBorder', 'touchBorder']);
      var points;
      var drawBorder;
      var holeBorder;
      var drawBorderBuffer;

      if (o.simple) {
        var _makeFastPolyLine = Object(_geometries_lines_lines__WEBPACK_IMPORTED_MODULE_12__["makeFastPolyLine"])(o.points, o.width, o.close);

        var _makeFastPolyLine2 = _slicedToArray(_makeFastPolyLine, 4);

        points = _makeFastPolyLine2[0];
        drawBorder = _makeFastPolyLine2[1];
        drawBorderBuffer = _makeFastPolyLine2[2];
        holeBorder = _makeFastPolyLine2[3];
      } else if (o.cornersOnly) {
        var _makePolyLineCorners = Object(_geometries_lines_lines__WEBPACK_IMPORTED_MODULE_12__["makePolyLineCorners"])(o.points, o.width, o.close, o.cornerLength, o.widthIs, o.cornerStyle, o.cornerSize, o.cornerSides, o.minAutoCornerAngle, o.linePrimitives, o.lineNum, o.drawBorderBuffer);

        var _makePolyLineCorners2 = _slicedToArray(_makePolyLineCorners, 4);

        points = _makePolyLineCorners2[0];
        drawBorder = _makePolyLineCorners2[1];
        drawBorderBuffer = _makePolyLineCorners2[2];
        holeBorder = _makePolyLineCorners2[3];
      } else {
        var _makePolyLine = Object(_geometries_lines_lines__WEBPACK_IMPORTED_MODULE_12__["makePolyLine"])(o.points, o.width, o.close, o.widthIs, o.cornerStyle, o.cornerSize, o.cornerSides, o.minAutoCornerAngle, o.dash, o.linePrimitives, o.lineNum, o.drawBorder, o.drawBorderBuffer, o.hole, o.arrow);

        var _makePolyLine2 = _slicedToArray(_makePolyLine, 4);

        points = _makePolyLine2[0];
        drawBorder = _makePolyLine2[1];
        drawBorderBuffer = _makePolyLine2[2];
        holeBorder = _makePolyLine2[3];
      }

      if (Array.isArray(o.drawBorderBuffer)) {
        drawBorderBuffer = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.drawBorderBuffer);
      }

      if (Array.isArray(o.drawBorder)) {
        drawBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.drawBorder);
      }

      if (drawBorderBuffer == null) {
        drawBorderBuffer = drawBorder;
      }

      if (o.holeBorder == null) {
        o.holeBorder = holeBorder;
      }

      var drawType = 'triangles';

      if (o.linePrimitives) {
        drawType = 'lines';
      }

      if (o.simple) {
        drawType = 'strip';
      }

      return [o, points, drawBorder, drawBorderBuffer, drawType];
    }
    /**
     * {@link FigureElementPrimitive} that draws a polyline.
     * @see {@link OBJ_Polyline} for options and examples.
     */

  }, {
    key: "polyline",
    value: function polyline() {
      var _this = this;

      for (var _len2 = arguments.length, optionsIn = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        optionsIn[_key2] = arguments[_key2];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(optionsIn));
      var element = this.generic.apply(this, [{
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('polyline').standard(),
        border: 'draw',
        touchBorder: 'border',
        // $FlowFixMe
        holeBorder: [[]]
      }].concat(optionsIn));
      element.custom.options = {
        points: [[0, 0], [1, 0]],
        width: this.defaultLineWidth,
        color: this.defaultColor,
        close: false,
        widthIs: 'mid',
        cornerStyle: 'auto',
        cornerSize: 0.01,
        cornerSides: 10,
        cornersOnly: false,
        cornerLength: 0.1,
        minAutoCornerAngle: Math.PI / 7,
        dash: [],
        linePrimitives: false,
        lineNum: 1,
        drawBorder: 'line',
        holeBorder: [[]],
        drawBorderBuffer: 0
      };

      element.custom.updatePoints = function (updateOptions) {
        var _this$getPolylineTris = _this.getPolylineTris(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, element.custom.options, updateOptions)),
            _this$getPolylineTris2 = _slicedToArray(_this$getPolylineTris, 5),
            o = _this$getPolylineTris2[0],
            points = _this$getPolylineTris2[1],
            drawBorder = _this$getPolylineTris2[2],
            drawBorderBuffer = _this$getPolylineTris2[3],
            drawType = _this$getPolylineTris2[4];

        element.custom.options = o;
        element.custom.updateGeneric(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, o, {
          points: points,
          drawBorder: drawBorder,
          drawBorderBuffer: drawBorderBuffer,
          drawType: drawType
        }));
      };

      element.custom.updatePoints(options); // getTris(options);
      // setupPulse(element, options);

      return element;
    }
  }, {
    key: "getPolygonBorder",
    value: function getPolygonBorder(optionsIn) {
      var o = optionsIn;
      parsePoints(o, ['offset']);

      if (o.angleToDraw != null) {
        o.sidesToDraw = Math.floor(o.angleToDraw / (Math.PI * 2 / o.sides));
      }

      if (o.sidesToDraw == null) {
        o.sidesToDraw = o.sides;
      }

      if (o.sidesToDraw > o.sides) {
        o.sidesToDraw = o.sides;
      }

      var points = Object(_geometries_polygon_polygon__WEBPACK_IMPORTED_MODULE_13__["getPolygonPoints"])(o); // let { drawBorderBuffer } = o;

      var drawBorderOffset = 0;
      var drawBorder;

      if (o.line != null) {
        o.line = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, {
          width: this.defaultLineWidth,
          widthIs: 'mid'
        }, o.line);

        if (o.line.widthIs === 'inside' && o.direction === 1) {
          o.line.widthIs = 'positive';
        } else if (o.line.widthIs === 'inside' && o.direction === -1) {
          o.line.widthIs = 'negative';
        }

        if (o.line.widthIs === 'outside' && o.direction === 1) {
          o.line.widthIs = 'negative';
        } else if (o.line.widthIs === 'outside' && o.direction === -1) {
          o.line.widthIs = 'positive';
        }

        var _o$line = o.line,
            width = _o$line.width,
            widthIs = _o$line.widthIs;
        var dir = o.direction;

        if (dir === 1 && (widthIs === 'negative' || widthIs === 'outside') || dir === -1 && (widthIs === 'positive' || widthIs === 'inside')) {
          drawBorderOffset = width;
        } else if (widthIs === 'mid') {
          drawBorderOffset = width / 2;
        }

        if (drawBorderOffset > 0) {
          var cornerAngle = (o.sides - 2) * Math.PI / o.sides;
          drawBorderOffset /= Math.sin(cornerAngle / 2);
        }

        if (o.sidesToDraw === o.sides) {
          o.line.close = true;
        } else {
          o.line.close = false;
        }
      } else if (o.sidesToDraw !== o.sides && o.line == null) {
        points.push(o.offset);
      }

      if (drawBorderOffset === 0) {
        drawBorder = [points];
      } else {
        drawBorder = [Object(_geometries_polygon_polygon__WEBPACK_IMPORTED_MODULE_13__["getPolygonPoints"])(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, o, {
          radius: o.radius + drawBorderOffset
        }))];
      }

      return [o, points, drawBorder, 'triangles'];
    }
  }, {
    key: "genericBase",
    value: function genericBase(name, defaultOptions, optionsIn) {
      var _this2 = this;

      var element = this.generic({
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"](name).standard(),
        border: 'draw',
        touchBorder: 'border',
        // $FlowFixMe
        holeBorder: [[]]
      }, optionsIn);
      element.custom.options = defaultOptions;

      element.custom.getFill = function () {
        return [];
      }; // element.custom.getLine = () => [];


      element.custom.close = true;
      element.custom.skipConcave = true;
      element.custom.bufferOffset = 'negative';

      element.custom.getLine = function (o) {
        // $FlowFixMe
        if (!element.custom.close && o.drawBorder == null) {
          // $FlowFixMe
          o.drawBorder = 'line';
        }

        return _this2.getPolylineTris(o);
      };

      element.custom.getBorder = function () {
        return [];
      };

      element.custom.updatePoints = function (updateOptions) {
        var borderOptions = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, element.custom.options, updateOptions);

        var _element$custom$getBo = element.custom.getBorder(borderOptions),
            _element$custom$getBo2 = _slicedToArray(_element$custom$getBo, 2),
            o = _element$custom$getBo2[0],
            border = _element$custom$getBo2[1]; // console.log(element.custom.bufferOffset)
        // if (element.custom.bufferOffset === 'positive') {
        //   border.reverse();
        // }


        if (o.line == null) {
          var _element$custom$getFi = element.custom.getFill(border, o),
              _element$custom$getFi2 = _slicedToArray(_element$custom$getFi, 2),
              points = _element$custom$getFi2[0],
              drawType = _element$custom$getFi2[1];

          element.custom.options = o;
          element.custom.updateGeneric(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, o, {
            points: points,
            drawBorder: border,
            drawBorderBuffer: Object(_geometries_buffer__WEBPACK_IMPORTED_MODULE_20__["getBufferBorder"])([border], o.drawBorderBuffer, element.custom.skipConcave, element.custom.bufferOffset),
            drawType: drawType
          }));
        } else {
          if (o.line.widthIs == null) {
            o.line.widthIs = 'mid';
          }

          if (element.custom.close) {
            o.line.close = true;
          }

          var bufferOffsetToUse = 'negative';

          if (element.custom.bufferOffset === 'positive' && o.line.close) {
            o.line.drawBorder = 'positive';
            bufferOffsetToUse = 'positive';
          } // console.log(o)


          var _element$custom$getLi = element.custom.getLine(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, o.line, {
            points: border
          })),
              _element$custom$getLi2 = _slicedToArray(_element$custom$getLi, 5),
              polylineOptions = _element$custom$getLi2[0],
              _points = _element$custom$getLi2[1],
              drawBorder = _element$custom$getLi2[2],
              _drawType = _element$custom$getLi2[4];

          element.custom.options = o;
          element.custom.options.line = polylineOptions;

          if (element.custom.bufferOffset === 'positive') {
            drawBorder.reverse();
          } // const drawBorder = newDrawBorder;
          // console.log(element.custom.bufferOffset)
          // console.log(newDrawBorder)
          // const drawBorder = [];
          // for (let i = 0; i < newDrawBorder[0].length; i += 1) {
          //   if (
          //     i === 0
          //     || (
          //       i < newDrawBorder[0].length - 1
          //       && drawBorder.slice(-1)[0].isNotEqualTo(newDrawBorder[0][i])
          //     )
          //     || (
          //       i === newDrawBorder[0].length - 1
          //       && drawBorder[0].isNotEqualTo(newDrawBorder[0][i])
          //     )
          //   ) {
          //     drawBorder.push(newDrawBorder[0][i]);
          //   }
          // }
          // console.log(drawBorder)


          var drawBorderBuffer = Object(_geometries_buffer__WEBPACK_IMPORTED_MODULE_20__["getBufferBorder"])(drawBorder, o.drawBorderBuffer, element.custom.skipConcave, bufferOffsetToUse); // console.log(drawBorder, drawBorderBuffer);

          element.custom.updateGeneric(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, o, {
            points: _points,
            drawBorder: drawBorder,
            drawBorderBuffer: drawBorderBuffer,
            drawType: _drawType
          }));
        }
      };

      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws a regular polygon.
     * @see {@link OBJ_Polygon} for options and examples.
     */

  }, {
    key: "polygon",
    value: function polygon() {
      var _this3 = this;

      for (var _len3 = arguments.length, options = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        options[_key3] = arguments[_key3];
      }

      var element = this.genericBase('polygon', {
        radius: 1,
        sides: 4,
        direction: 1,
        rotation: 0,
        offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0)
      }, _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));

      element.custom.getBorder = function (o) {
        var border = _this3.getPolygonBorder(o);

        if (o.sidesToDraw !== o.sides) {
          element.custom.close = false;
        } else {
          element.custom.close = true;
        }

        element.custom.skipConcave = false;

        if (o.direction === -1) {
          element.custom.bufferOffset = 'positive';
        } else {
          element.custom.bufferOffset = 'negative';
        }

        return border;
      };

      element.custom.getFill = function (border, fillOptions) {
        return [Object(_geometries_polygon_polygon__WEBPACK_IMPORTED_MODULE_13__["getTrisFillPolygon"])(fillOptions.offset, border, fillOptions.sides, fillOptions.sidesToDraw), 'triangles'];
      }; // element.custom.getLine = (o: OBJ_PolyLineTris) => this.getPolylineTris(o);
      // $FlowFixMe


      element.drawingObject.getPointCountForAngle = function (angle) {
        var optionsToUse = element.custom.options;
        var sidesToDraw = Math.floor(_tools_math__WEBPACK_IMPORTED_MODULE_5__["round"](angle, 8) / _tools_math__WEBPACK_IMPORTED_MODULE_5__["round"](Math.PI * 2, 8) * optionsToUse.sides);

        if (optionsToUse.line == null) {
          return sidesToDraw * 3;
        }

        if (optionsToUse.line && optionsToUse.line.linePrimitives) {
          return sidesToDraw * optionsToUse.line.lineNum * 2;
        }

        return sidesToDraw * 6;
      };

      element.custom.updatePoints(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws a star.
     * @see {@link OBJ_Star} for options and examples.
     */

  }, {
    key: "star",
    value: function star() {
      var _this4 = this;

      for (var _len4 = arguments.length, options = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        options[_key4] = arguments[_key4];
      }

      var element = this.genericBase('star', {
        radius: 1,
        sides: 5,
        direction: 1,
        rotation: 0,
        offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0)
      }, _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));

      element.custom.getBorder = function (o) {
        if (o.innerRadius == null) {
          o.innerRadius = o.radius / 3;
        }

        o.rotation += Math.PI / 2;
        o.sidesToDraw = o.sides;

        var result = _this4.getPolygonBorder(o);

        result[0].rotation -= Math.PI / 2;
        return result;
      };

      element.custom.getFill = function (border, fillOptions) {
        return [Object(_geometries_polygon_polygon__WEBPACK_IMPORTED_MODULE_13__["getTrisFillPolygon"])(fillOptions.offset, border, fillOptions.sides, fillOptions.sidesToDraw), 'triangles'];
      };

      element.custom.updatePoints(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws a rectangle.
     * @see {@link OBJ_Rectangle} for options and examples.
     */

  }, {
    key: "rectangle",
    value: function rectangle() {
      for (var _len5 = arguments.length, options = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        options[_key5] = arguments[_key5];
      }

      var element = this.genericBase('rectangle', {
        width: this.defaultLength,
        height: this.defaultLength / 2,
        xAlign: 'center',
        yAlign: 'middle',
        corner: {
          radius: 0,
          sides: 1
        },
        offset: [0, 0]
      }, _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));

      element.custom.getBorder = function (o) {
        if (o.line != null && o.line.widthIs === 'inside') {
          o.line.widthIs = 'positive';
        }

        if (o.line != null && o.line.widthIs === 'outside') {
          o.line.widthIs = 'negative';
        }

        if (o.offset != null) {
          o.offset = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.offset);
        }

        return [o, Object(_geometries_rectangle__WEBPACK_IMPORTED_MODULE_14__["getRectangleBorder"])(o)];
      };

      element.custom.getFill = function (border) {
        return [Object(_geometries_rectangle__WEBPACK_IMPORTED_MODULE_14__["rectangleBorderToTris"])(border), 'triangles'];
      }; // element.custom.getLine = (o: OBJ_PolyLineTris) => this.getPolylineTris(o);


      element.custom.updatePoints(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws an ellipse.
     * @see {@link OBJ_Ellipse} for options and examples.
     */

  }, {
    key: "ellipse",
    value: function ellipse() {
      for (var _len6 = arguments.length, options = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        options[_key6] = arguments[_key6];
      }

      var element = this.genericBase('ellipse', {
        width: this.defaultLength,
        height: this.defaultLength / 2,
        xAlign: 'center',
        yAlign: 'middle',
        sides: 20
      }, _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));

      element.custom.getBorder = function (o) {
        if (o.line != null && o.line.widthIs === 'inside') {
          o.line.widthIs = 'positive';
        }

        if (o.line != null && o.line.widthIs === 'outside') {
          o.line.widthIs = 'negative';
        }

        return [o, Object(_geometries_ellipse__WEBPACK_IMPORTED_MODULE_15__["getEllipseBorder"])(o)];
      };

      element.custom.getFill = function (border) {
        return [Object(_geometries_ellipse__WEBPACK_IMPORTED_MODULE_15__["ellipseBorderToTris"])(border), 'triangles'];
      }; // element.custom.getLine = (o: OBJ_PolyLineTris) => this.getPolylineTris(o);


      element.custom.updatePoints(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws a triangle.
     * @see {@link OBJ_Triangle} for options and examples.
     */

  }, {
    key: "triangle",
    value: function triangle() {
      for (var _len7 = arguments.length, options = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        options[_key7] = arguments[_key7];
      }

      var element = this.genericBase('triangle', {
        width: this.defaultLength,
        height: this.defaultLength,
        // xAlign: 'centroid',
        // yAlign: 'centroid',
        top: 'center',
        direction: 1,
        rotation: 0
      }, _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));

      element.custom.getBorder = function (o) {
        if (o.xAlign == null) {
          if (o.points != null) {
            o.xAlign = 'points';
          } else {
            o.xAlign = 'centroid';
          }
        }

        if (o.yAlign == null) {
          if (o.points != null) {
            o.yAlign = 'points';
          } else {
            o.yAlign = 'centroid';
          }
        } // if (o.line != null && o.line.widthIs === 'inside') {
        //   o.line.widthIs = 'positive';
        // }
        // if (o.line != null && o.line.widthIs === 'outside') {
        //   o.line.widthIs = 'negative';
        // }
        // if (o.direction === -1) {
        //   element.custom.bufferOffset = 'positive';
        // } else {
        //   element.custom.bufferOffset = 'negative';
        // }


        var border = Object(_geometries_triangle__WEBPACK_IMPORTED_MODULE_16__["getTriangleBorder"])(o);

        if (o.direction === -1 || Object(_geometries_triangle__WEBPACK_IMPORTED_MODULE_16__["getTriangleDirection"])(border) === -1) {
          border.reverse();
        }

        return [o, border];
      }; // element.custom.getBorder = (o: OBJ_Triangle_Defined) => [
      //   o, ...getTriangleBorder(o),
      // ];


      element.custom.getFill = function (border) {
        return [border, 'triangles'];
      };

      element.custom.updatePoints(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws a line.
     * @see {@link OBJ_Arrow} for options and examples.
     */

  }, {
    key: "arrow",
    value: function arrow() {
      for (var _len8 = arguments.length, options = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        options[_key8] = arguments[_key8];
      }

      var element = this.genericBase('arrow', {
        length: this.defaultLength / 2,
        width: this.defaultLength / 2,
        head: 'triangle',
        sides: 20,
        radius: this.defaultLength / 4,
        rotation: 0,
        angle: 0,
        tail: false,
        drawPosition: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0) // barb: this.defaultLength / 8,

      }, _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));

      element.custom.getBorder = function (o) {
        if (o.line != null && o.line.widthIs === 'inside') {
          o.line.widthIs = 'positive';
        }

        if (o.line != null && o.line.widthIs === 'outside') {
          o.line.widthIs = 'negative';
        }

        var optionsWithDefaultArrow = Object(_geometries_arrow__WEBPACK_IMPORTED_MODULE_17__["defaultArrowOptions"])(o);

        var _getArrow = Object(_geometries_arrow__WEBPACK_IMPORTED_MODULE_17__["getArrow"])(optionsWithDefaultArrow),
            _getArrow2 = _slicedToArray(_getArrow, 2),
            border = _getArrow2[0],
            borderBuffer = _getArrow2[1];

        return [optionsWithDefaultArrow, border, borderBuffer];
      };

      element.custom.getFill = function (border, o) {
        return [Object(_geometries_arrow__WEBPACK_IMPORTED_MODULE_17__["getArrowTris"])(border, o), 'triangles'];
      };

      element.custom.updatePoints(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options)));
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws a grid.
     * @see {@link OBJ_Grid} for options and examples.
     */

  }, {
    key: "grid",
    value: function grid() {
      for (var _len9 = arguments.length, optionsIn = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        optionsIn[_key9] = arguments[_key9];
      }

      var element = this.generic.apply(this, [{
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('grid').standard(),
        border: 'draw',
        touchBorder: 'border',
        // $FlowFixMe
        holeBorder: [[]]
      }].concat(optionsIn));
      element.custom.options = {
        bounds: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Rect"](this.limits.left + this.limits.width / 4, this.limits.bottom + this.limits.height / 4, this.limits.width / 2, this.limits.height / 2),
        line: {
          linePrimitives: false,
          width: this.defaultLineWidth,
          lineNum: 2,
          dash: []
        }
      };

      var getTris = function getTris(points) {
        return Object(_geometries_lines_lines__WEBPACK_IMPORTED_MODULE_12__["makePolyLine"])(points, element.custom.options.line.width, false, 'mid', 'auto', // cornerStyle doesn't matter
        0.1, // cornerSize doesn't matter
        1, // cornerSides,
        Math.PI / 7, // minAutoCornerAngle,
        element.custom.options.line.dash, element.custom.options.line.linePrimitives, element.custom.options.line.lineNum, [[]], 0);
      };

      element.custom.updatePoints = function (updateOptions) {
        var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, element.custom.options, updateOptions);
        element.custom.options = o; // Prioritize Num over Step. Only define Num from Step if Num is undefined.

        var bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getRect"])(o.bounds);
        var xStep = o.xStep,
            xNum = o.xNum,
            yStep = o.yStep,
            yNum = o.yNum;
        var width = o.line.width;

        if (o.line.linePrimitives && o.line.lineNum === 1) {
          width = 0;
        }

        var totWidth = bounds.width;
        var totHeight = bounds.height;

        if (xStep != null && xNum == null) {
          xNum = xStep === 0 ? 1 : 1 + Math.floor((totWidth + xStep * 0.1) / xStep);
        }

        if (yStep != null && yNum == null) {
          yNum = yStep === 0 ? 1 : 1 + Math.floor((totHeight + yStep * 0.1) / yStep);
        }

        if (xNum == null) {
          xNum = 2;
        }

        if (yNum == null) {
          yNum = 2;
        }

        xStep = xNum < 2 ? 0 : totWidth / (xNum - 1);
        yStep = yNum < 2 ? 0 : totHeight / (yNum - 1);
        var start = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](bounds.left, bounds.bottom);
        var xLineStart = start.add(-width / 2, 0);
        var xLineStop = start.add(totWidth + width / 2, 0);
        var yLineStart = start.add(0, -width / 2);
        var yLineStop = start.add(0, totHeight + width / 2);
        var xTris = [];
        var yTris = [];

        if (xNum > 0) {
          var _getTris = getTris([yLineStart, yLineStop]),
              _getTris2 = _slicedToArray(_getTris, 1),
              yLine = _getTris2[0];

          yTris = Object(_geometries_copy_copy__WEBPACK_IMPORTED_MODULE_19__["copyPoints"])(yLine, [{
            along: 'x',
            num: xNum - 1,
            step: xStep
          }]);
        }

        if (yNum > 0) {
          var _getTris3 = getTris([xLineStart, xLineStop]),
              _getTris4 = _slicedToArray(_getTris3, 1),
              xLine = _getTris4[0];

          xTris = Object(_geometries_copy_copy__WEBPACK_IMPORTED_MODULE_19__["copyPoints"])(xLine, [{
            along: 'y',
            num: yNum - 1,
            step: yStep
          }]);
        }

        var border = [start.add(-width / 2, -width / 2), start.add(totWidth + width / 2, -width / 2), start.add(totWidth + width / 2, totHeight + width / 2), start.add(-width / 2, totHeight + width / 2)];
        var drawBorder;

        if (o.drawBorder != null) {
          drawBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(o.drawBorder);
        } else {
          drawBorder = [border];
        }

        var drawBorderBuffer = o.drawBorderBuffer;

        if (typeof o.drawBorderBuffer === 'number') {
          drawBorderBuffer = drawBorder;

          if (o.drawBorderBuffer !== 0) {
            var buf = o.drawBorderBuffer;
            drawBorderBuffer = [[border[0].add(-buf, -buf), border[1].add(buf, -buf), border[2].add(buf, buf), border[3].add(-buf, buf)]];
          }
        }

        element.custom.updateGeneric(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, o, {
          points: [].concat(_toConsumableArray(xTris), _toConsumableArray(yTris)),
          drawBorder: drawBorder,
          drawBorderBuffer: drawBorderBuffer,
          drawType: o.line.linePrimitives ? 'lines' : 'triangles'
        }));
      };

      element.custom.updatePoints(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(optionsIn)));
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws a line.
     * @see {@link OBJ_Line} for options and examples.
     */

  }, {
    key: "line",
    value: function line() {
      for (var _len10 = arguments.length, options = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        options[_key10] = arguments[_key10];
      }

      // $FlowFixMe
      var element = this.polyline(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, {
        transform: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('line').standard()
      }].concat(options, [{
        points: [[0, 0], [0, 1]],
        dash: [],
        arrow: null
      }]))); // $FlowFixMe

      var joinedOptions = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(options));
      element.custom.options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, element.custom.options, {
        p1: [0, 0],
        angle: 0,
        length: this.defaultLength,
        width: this.defaultLineWidth
      }); // element.custom.setupLine = (p, o) => {
      //   if (o.dash.length > 1) {
      //     const maxLength = p[0].distance(p[1]);
      //     const dashCumLength = [];
      //     let cumLength = 0;
      //     if (o.dash) {
      //       let dashToUse = o.dash;
      //       let offset = 0;
      //       if (o.dash % 2 === 1) {
      //         dashToUse = o.dash.slice(1);
      //         [offset] = o.dash;
      //         // cumLength = offset;
      //       }
      //       while (cumLength < maxLength) {
      //         for (let i = 0; i < dashToUse.length && cumLength < maxLength; i += 1) {
      //           let length = dashToUse[i];
      //           if (length + cumLength > maxLength) {
      //             length = maxLength - cumLength;
      //           }
      //           cumLength += length;
      //           dashCumLength.push(cumLength);
      //         }
      //       }
      //       element.custom.dashCumLength = dashCumLength;
      //       element.custom.maxLength = maxLength;
      //     }
      //   }
      // };

      element.custom.updatePolyline = element.custom.updatePoints;

      element.custom.updatePoints = function (updateOptions) {
        var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, element.custom.options, updateOptions);

        var _getLine = Object(_geometries_line__WEBPACK_IMPORTED_MODULE_18__["default"])(o),
            _getLine2 = _slicedToArray(_getLine, 3),
            updatedPoints = _getLine2[0],
            updatedBorder = _getLine2[1],
            updatedTouchBorder = _getLine2[2]; // element.custom.setupLine(updatedPoints, o);


        element.custom.updatePolyline(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, o, {
          points: updatedPoints,
          border: updatedBorder,
          touchBorder: updatedTouchBorder,
          holeBorder: o.holeBorder
        }));
      }; // element.drawingObject.getPointCountForLength = (drawLength: number = this.maxLength) => {
      //   if (drawLength >= element.custom.maxLength) { // $FlowFixMe
      //     return element.drawingObject.numPoints;
      //   }
      //   if (drawLength < element.custom.dashCumLength[0]) {
      //     return 0;
      //   }
      //   for (let i = 0; i < element.custom.dashCumLength.length; i += 1) {
      //     const cumLength = element.custom.dashCumLength[i];
      //     if (cumLength > drawLength) {
      //       return (Math.floor((i - 1) / 2) + 1) * 6;
      //     }
      //   } // $FlowFixMe
      //   return element.drawingObject.numPoints;
      // };


      element.custom.updatePoints(joinedOptions);
      return element;
    }
  }, {
    key: "textGL",
    value: function textGL(options) {
      return Object(_Text__WEBPACK_IMPORTED_MODULE_9__["default"])(this.webgl, this.limits, options);
    }
    /*
    .......########.########.##.....##.########
    ..........##....##........##...##.....##...
    ..........##....##.........##.##......##...
    ..........##....######......###.......##...
    ..........##....##.........##.##......##...
    ..........##....##........##...##.....##...
    ..........##....########.##.....##....##...
    */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "parseTextOptions",
    value: function parseTextOptions() {
      var defaultOptions = {
        text: '',
        font: {
          family: this.defaultFont.family,
          style: this.defaultFont.style,
          size: this.defaultFont.size,
          weight: this.defaultFont.weight
        },
        xAlign: 'left',
        yAlign: 'baseline',
        border: 'draw',
        touchBorder: 'buffer',
        defaultTextTouchBorder: 0
      };

      for (var _len11 = arguments.length, optionsIn = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
        optionsIn[_key11] = arguments[_key11];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn)); // Make default color

      if (options.color == null && options.font.color != null) {
        options.color = options.font.color;
      }

      if (options.font.color == null && options.color != null) {
        options.font.color = options.color;
      }

      if (options.color == null) {
        options.color = this.defaultFont.color;
      } // // Define standard transform if no transform was input
      // if (options.transform == null) {
      //   options.transform = new Transform('text').standard();
      // } else {
      //   options.transform = getTransform(options.transform);
      // }
      // // Override transform if position is defined
      // if (options.position != null) {
      //   const p = getPoint(options.position);
      //   options.transform.updateTranslation(p);
      // }


      if (options.text != null && !Array.isArray(options.text)) {
        options.text = [options.text];
      }

      if (options.line != null && !Array.isArray(options.line)) {
        options.line = [options.line];
      }

      if (options.lines != null && !Array.isArray(options.lines)) {
        options.lines = [options.lines];
      }

      if (options.touchBorder != null && Array.isArray(options.touchBorder)) {
        // parsePoints(options, ['touchBorder']);
        options.touchBorder = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(options.touchBorder);
      }

      if (options.border != null && Array.isArray(options.border)) {
        // parsePoints(options, ['border']);
        options.border = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBorder"])(options.border);
      }

      return options;
    }
  }, {
    key: "genericTextPrimitive",
    value: function genericTextPrimitive(drawingObject, optionsIn) {
      var options = optionsIn; // Define standard transform if no transform was input

      if (options.transform == null) {
        options.transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]('text').standard();
      } else {
        options.transform = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTransform"])(options.transform);
      } // Override transform if position is defined


      if (options.position != null) {
        var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);
        options.transform.updateTranslation(p);
      }

      var element = new _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementPrimitive"](drawingObject, options.transform, options.color, this.limits);
      setupPulse(element, options);

      if (options.mods != null && options.mods !== {}) {
        element.setProperties(options.mods);
      }

      element.custom.updateBorders = function (o) {
        element.drawBorder = element.drawingObject.textBorder;

        if (o.drawBorder != null) {
          element.drawBorder = o.drawBorder;
        }

        element.drawBorderBuffer = element.drawingObject.textBorderBuffer;

        if (o.drawBorderBuffer != null) {
          element.drawBorderBuffer = o.drawBorderBuffer;
        }

        if (o.border != null) {
          element.border = o.border;
        }

        if (o.touchBorder != null) {
          element.touchBorder = o.touchBorder;
        }
      }; // $FlowFixMe


      element.getBorderPointsSuper = element.getBorderPoints; // $FlowFixMe

      element.getBorderPoints = function () {
        var border = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'border';

        if (border === 'border') {
          // $FlowFixMe
          return element.getBorderPointsSuper(border);
        }

        if (border === 'touchBorder') {
          if (element.touchBorder === 'draw') {
            return element.drawBorder;
          }

          if (element.touchBorder === 'buffer') {
            return element.drawBorderBuffer;
          }

          if (element.touchBorder === 'border') {
            return element.getBorderPoints('border');
          }

          if (element.touchBorder === 'rect') {
            return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(element.drawBorderBuffer)];
          }

          if (Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["isBuffer"])(element.touchBorder)) {
            var b = element.drawBorderBuffer; // $FlowFixMe

            return [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingBorder"])(b, element.touchBorder)];
          }

          return element.touchBorder;
        }

        return element.holeBorder;
      };

      element.custom.setText = function (o) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        element.drawingObject.setText(o, index);
        element.custom.updateBorders({});
      };

      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws a line of text.
     * @see {@link OBJ_TextLine} for options and examples.
     */

  }, {
    key: "textLine",
    value: function textLine() {
      var _this5 = this;

      for (var _len12 = arguments.length, optionsIn = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
        optionsIn[_key12] = arguments[_key12];
      }

      var options = this.parseTextOptions.apply(this, [{
        border: 'rect',
        touchBorder: 'rect'
      }].concat(optionsIn));
      var to = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_10__["TextLineObject"](this.draw2D);
      to.loadText(options);
      var element = this.genericTextPrimitive(to, options);
      element.custom.options = to;

      element.custom.updateText = function (o) {
        // $FlowFixMe
        element.drawingObject.clear();

        var parsed = _this5.parseTextOptions({
          border: 'rect',
          touchBorder: 'rect'
        }, element.custom.options, o); // $FlowFixMe


        element.drawingObject.loadText(parsed);
        element.custom.options = parsed;
        element.custom.updateBorders({});
      };

      element.custom.updateBorders(options);
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws text lines.
     * @see {@link OBJ_TextLines} for options and examples.
     */

  }, {
    key: "textLines",
    value: function textLines() {
      var _this6 = this;

      for (var _len13 = arguments.length, optionsIn = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        optionsIn[_key13] = arguments[_key13];
      }

      var joinedOptions = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}].concat(optionsIn));
      var to = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_10__["TextLinesObject"](this.draw2D);
      var element = this.genericTextPrimitive(to, joinedOptions);
      element.custom.options = joinedOptions;

      element.custom.updateText = function (oIn) {
        // $FlowFixMe
        element.drawingObject.clear();
        var oToUse = oIn; // $FlowFixMe

        if (oIn.length === 1 && typeof oIn[0] === 'string') {
          oToUse = [{
            text: [optionsIn[0]]
          }];
        }

        var o = _this6.parseTextOptions({
          border: 'rect',
          touchBorder: 'rect'
        }, element.custom.options, oToUse);

        if (o.justify == null) {
          o.justify = 'left';
        }

        if (o.lineSpace == null) {
          o.lineSpace = o.font.size * 1.2;
        }

        element.custom.options = o; // $FlowFixMe

        element.drawingObject.loadText(o);
        element.custom.updateBorders(o);
      };

      element.custom.updateText(joinedOptions);
      return element;
    }
    /**
     * {@link FigureElementPrimitive} that draws text.
     * @see {@link OBJ_Text} for options and examples.
     */

  }, {
    key: "text",
    value: function text() {
      var _this7 = this;

      var options = this.parseTextOptions.apply(this, arguments);
      var to = new _DrawingObjects_TextObject_TextObject__WEBPACK_IMPORTED_MODULE_10__["TextObject"](this.draw2D);
      to.loadText(options);
      var element = this.genericTextPrimitive(to, options);
      element.custom.options = options;

      element.custom.updateText = function (o) {
        // $FlowFixMe
        element.drawingObject.clear(); // $FlowFixMe

        element.drawingObject.loadText(_this7.parseTextOptions(element.custom.options, o));
        element.custom.updateBorders({});
      };

      element.custom.updateBorders(options);
      return element;
    }
  }, {
    key: "html",
    value: function html(optionsIn) {
      var defaultOptions = {
        classes: '',
        position: [0, 0],
        xAlign: 'center',
        yAlign: 'middle',
        wrap: true,
        id: "id__temp_".concat(Math.round(Math.random() * 10000))
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"])({}, defaultOptions, optionsIn);
      options.element = optionsIn.element;
      var element;
      var parent;

      if (options.wrap || Array.isArray(options.element)) {
        element = document.createElement('div');
        element.setAttribute('id', options.id);

        if (Array.isArray(options.element)) {
          options.element.forEach(function (e) {
            return element.appendChild(e);
          });
        } else {
          element.appendChild(options.element);
        }

        this.htmlCanvas.appendChild(element);
        parent = this.htmlCanvas;
      } else {
        element = options.element;
        var id = element.getAttribute('id');

        if (id === '') {
          element.setAttribute('id', options.id);
        } else {
          options.id = id;
        }

        parent = element.parentElement;
      }

      if (parent == null) {
        parent = this.htmlCanvas;
      }

      var hT = new _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_11__["default"]( // $FlowFixMe
      parent, options.id, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), options.yAlign, options.xAlign);
      var p = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.position);
      var figureElement = new _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementPrimitive"](hT, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(p.x, p.y), [1, 1, 1, 1], this.limits);
      return figureElement;
    }
  }, {
    key: "htmlElement",
    value: function htmlElement(elementToAdd) {
      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "id__temp_".concat(Math.round(Math.random() * 10000));
      var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var location = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);
      var yAlign = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'middle';
      var xAlign = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'left';
      var element = document.createElement('div');

      if (classes && element) {
        var classArray = classes.split(' ');
        classArray.forEach(function (c) {
          return element.classList.add(c.trim());
        });
      }

      if (Array.isArray(elementToAdd)) {
        elementToAdd.forEach(function (e) {
          return element.appendChild(e);
        });
      } else {
        element.appendChild(elementToAdd);
      }

      element.style.position = 'absolute';
      element.setAttribute('id', id);
      this.htmlCanvas.appendChild(element);
      var hT = new _DrawingObjects_HTMLObject_HTMLObject__WEBPACK_IMPORTED_MODULE_11__["default"](this.htmlCanvas, id, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), yAlign, xAlign);
      var figureElement = new _Element__WEBPACK_IMPORTED_MODULE_2__["FigureElementPrimitive"](hT, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().scale(1, 1).translate(location.x, location.y), [1, 1, 1, 1], this.limits); // console.log('html', figureElement.transform.mat, location)
      // figureElement.setFirstTransform();

      return figureElement;
    } // htmlText(
    //   textInput: string,
    //   id: string = generateUniqueId('id__html_text_'),
    //   classes: string = '',
    //   location: Point = new Point(0, 0),
    //   yAlign: 'top' | 'bottom' | 'middle' = 'middle',
    //   xAlign: 'left' | 'right' | 'center' = 'left',
    // ) {
    //   // const inside = document.createTextNode(textInput);
    //   const inside = document.createElement('div');
    //   inside.innerHTML = textInput;
    //   return this.htmlElement(inside, id, classes, location, yAlign, xAlign);
    // }

  }, {
    key: "htmlImage",
    value: function htmlImage() {
      var defaultOptions = {
        id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["generateUniqueId"])('id__html_image_'),
        classes: '',
        position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        yAlign: 'middle',
        xAlign: 'left',
        src: '' // color: this.defaultColor,

      };

      for (var _len14 = arguments.length, optionsIn = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
        optionsIn[_key14] = arguments[_key14];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      var image = document.createElement('img');
      image.src = options.src; // setHTML(inside, options.text, options.modifiers);

      var id = options.id,
          classes = options.classes,
          position = options.position,
          yAlign = options.yAlign,
          xAlign = options.xAlign;
      var element = this.htmlElement(image, id, classes, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(position), yAlign, xAlign);

      if (options.color != null) {
        element.setColor(options.color);
      } // if (options.pulse != null) {
      //   if (typeof element.pulseDefault !== 'function') {
      //     element.pulseDefault.scale = options.pulse;
      //   }
      // }


      setupPulse(element, options);
      return element;
    }
  }, {
    key: "htmlText",
    value: function htmlText() {
      var defaultOptions = {
        text: '',
        id: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_6__["generateUniqueId"])('id__html_text_'),
        classes: '',
        position: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
        yAlign: 'middle',
        xAlign: 'left' // color: this.defaultColor,

      };

      for (var _len15 = arguments.length, optionsIn = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
        optionsIn[_key15] = arguments[_key15];
      }

      var options = _tools_tools__WEBPACK_IMPORTED_MODULE_6__["joinObjects"].apply(void 0, [{}, defaultOptions].concat(optionsIn));
      var inside = document.createElement('div'); // const htmlText = toHTML(options.textInput, '', '', options.color);
      // console.log(options.textInput, htmlText)

      Object(_tools_htmlGenerator__WEBPACK_IMPORTED_MODULE_1__["setHTML"])(inside, options.text, options.modifiers);
      var id = options.id,
          classes = options.classes,
          position = options.position,
          yAlign = options.yAlign,
          xAlign = options.xAlign;
      var element = this.htmlElement(inside, id, classes, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(position), yAlign, xAlign);

      if (options.color != null) {
        element.setColor(options.color);
      }

      setupPulse(element, options);
      return element;
    } // lines(
    //   linePairs: Array<Array<Point>>,
    //   numLinesThick: number = 1,
    //   color: TypeColor,
    //   transform: Transform | Point = new Transform(),
    // ) {
    //   return Lines(this.webgl, linePairs, numLinesThick, color, transform, this.limits);
    // }
    // gridLegacy(...optionsIn: Array<TypeGridOptions>) {
    //   const defaultOptions = {
    //     bounds: new Rect(-1, -1, 2, 2),
    //     xStep: 0.1,
    //     yStep: 0.1,
    //     xOffset: 0,
    //     yOffset: 0,
    //     numLinesThick: 1,
    //     color: this.defaultColor,
    //     position: null,
    //     transform: new Transform('grid').standard(),
    //   };
    //   const options = joinObjects({}, defaultOptions, ...optionsIn);
    //   if (options.position != null) {
    //     const point = getPoint(options.position);
    //     options.transform.updateTranslation(point);
    //   }
    //   const linePairs = [];
    //   // const xLimit = tools.roundNum(bounds.righ + xStep);
    //   const {
    //     bounds, xStep, xOffset, yStep, yOffset, color, numLinesThick, transform,
    //   } = options;
    //   if (options.xStep !== 0) {
    //     for (let x = bounds.left + xOffset; tools.roundNum(x, 8) <= bounds.right; x += xStep) {
    //       linePairs.push([new Point(x, bounds.top), new Point(x, bounds.bottom)]);
    //     }
    //   }
    //   if (yStep !== 0) {
    //     for (let y = bounds.bottom + yOffset; tools.roundNum(y, 8) <= bounds.top; y += yStep) {
    //       linePairs.push([new Point(bounds.left, y), new Point(bounds.right, y)]);
    //     }
    //   }
    //   const element = this.lines(linePairs, numLinesThick, color, transform);
    //   if (options.pulse != null && typeof element.pulseDefault !== 'function') {
    //     element.pulseDefault.scale = options.pulse;
    //   }
    //   return element;
    // }
    // horizontalLine(
    //   start: Point,
    //   length: number,
    //   width: number,
    //   rotation: number,
    //   color: TypeColor,
    //   transform: Transform | Point = new Transform(),
    // ) {
    //   return HorizontalLine(
    //     this.webgl, start, length, width,
    //     rotation, color, transform, this.limits,
    //   );
    // }
    // dashedLine(...optionsIn: Array<{
    //   start?: Point,
    //   length?: number,
    //   width?: number,
    //   rotation?: number,
    //   dashStyle?: Array<number>,
    //   color?: TypeColor,
    //   transform?: Transform,
    //   position?: Point,
    //   pulse?: number,
    // }>) {
    //   const defaultOptions = {
    //     start: [0, 0],
    //     length: 1,
    //     width: 0.01,
    //     rotation: 0,
    //     dashStyle: [0.1, 0.1],
    //     transform: new Transform('dashedLine').scale(1, 1).rotate(0).translate(0, 0),
    //     position: null,
    //   };
    //   const options = joinObjects({}, defaultOptions, ...optionsIn);
    //   if (options.position != null) {
    //     options.transform.updateTranslation(getPoint(options.position));
    //   }
    //   const element = DashedLine(
    //     this.webgl, getPoint(options.start), options.length, options.width,
    //     options.rotation, options.dashStyle, options.color,
    //     options.transform, this.limits,
    //   );
    //   setupPulse(element, options);
    //   return element;
    // }
    // dashedLine(
    //   start: Point,
    //   length: number,
    //   width: number,
    //   rotation: number,
    //   dashStyle: Array<number>,
    //   color: TypeColor,
    //   transform: Transform | Point = new Transform(),
    // ) {
    //   return DashedLine(
    //     this.webgl, start, length, width,
    //     rotation, dashStyle, color, transform, this.limits,
    //   );
    // }
    // box(...optionsIn: Array<{
    //   width?: number,
    //   height?: number,
    //   fill?: boolean,
    //   lineWidth?: number,
    //   colors?: Array<number>,
    //   transform?: Transform,
    //   position?: TypeParsablePoint,
    //   pulse?: number,
    // }>) {
    //   const defaultOptions = {
    //     width: 1,
    //     height: 1,
    //     fill: false,
    //     lineWidth: 0.01,
    //     color: this.defaultColor,
    //     transform: new Transform().scale(1, 1).rotate(0).translate(0, 0),
    //     position: null,
    //   };
    //   const options = joinObjects({}, defaultOptions, ...optionsIn);
    //   if (options.position != null) {
    //     options.transform.updateTranslation(getPoint(options.position));
    //   }
    //   if (typeof options.reference !== 'string') {
    //     options.reference = getPoint(options.reference);
    //   }
    //   const element = Box(
    //     this.webgl, options.width, options.height, options.lineWidth,
    //     options.fill, options.color, options.transform, this.limits,
    //   );
    //   setupPulse(element, options);
    //   return element;
    // }
    // radialLines(...optionsIn: Array<{
    //   innerRadius?: number,
    //   outerRadius?: number,
    //   width?: number,
    //   dAngle?: number,
    //   angle?: number,
    //   color?: TypeColor,
    //   transform?: Transform,
    //   position?: Point,
    //   pulse?: number,
    // }>) {
    //   const defaultOptions = {
    //     innerRadius: 0,
    //     outerRadius: 1,
    //     width: 0.05,
    //     dAngle: Math.PI / 4,
    //     angle: Math.PI * 2,
    //     transform: new Transform().standard(),
    //   };
    //   const options = joinObjects({}, defaultOptions, ...optionsIn);
    //   if (options.position != null) {
    //     options.transform.updateTranslation(getPoint(options.position));
    //   }
    //   const element = RadialLines(
    //     this.webgl, options.innerRadius, options.outerRadius,
    //     options.width, options.dAngle, options.angle, options.color,
    //     options.transform, this.limits,
    //   );
    //   setupPulse(element, options);
    //   return element;
    // }
    // repeatPatternVertex(...optionsIn: Array<TypeRepeatPatternVertex>) {
    //   const defaultOptions = {
    //     element: null,
    //     xNum: 2,
    //     yNum: 2,
    //     xStep: 1,
    //     yStep: 1,
    //     transform: new Transform('repeatPattern').standard(),
    //   };
    //   const options = joinObjects({}, defaultOptions, ...optionsIn);
    //   if (options.position != null) {
    //     options.transform.updateTranslation(getPoint(options.position));
    //   }
    //   const {
    //     element, transform, xNum, yNum, xStep, yStep,
    //   } = options;
    //   if (element == null) {
    //     return this.collection();
    //   }
    //   const copy = element._dup();
    //   const { drawingObject } = element;
    //   // console.log(element.drawingObject.points)
    //   if (drawingObject instanceof VertexObject) {
    //     copy.transform = transform._dup();
    //     const newPoints = [];
    //     const { points } = drawingObject;
    //     for (let x = 0; x < xNum; x += 1) {
    //       for (let y = 0; y < yNum; y += 1) {
    //         for (let p = 0; p < points.length; p += 2) {
    //           newPoints.push(new Point(
    //             points[p] + x * xStep,
    //             points[p + 1] + y * yStep,
    //           ));
    //           // console.log(points[p], points[p+1], newPoints.slice(-1))
    //         }
    //       }
    //     }
    //     // console.log(newPoints)
    //     copy.drawingObject.changeVertices(newPoints);
    //   }
    //   if (options.pulse != null && typeof element.pulseDefault !== 'function') {
    //     copy.pulseDefault.scale = options.pulse;
    //   }
    //   return copy;
    // }
    // repeatPattern(
    //   element: FigureElementPrimitive,
    //   xNum: number,
    //   yNum: number,
    //   xStep: number,
    //   yStep: number,
    //   transform: Transform | Point = new Transform(),
    // ) {
    //   let group;
    //   if (transform instanceof Transform) {
    //     group = this.collection({ transform });
    //   } else {
    //     group = this.collection({ transform: new Transform().translate(transform) });
    //   }
    //   let t = element.transform.t();
    //   let transformToUse = element.transform._dup();
    //   if (t === null) {
    //     t = new Point(0, 0);
    //     transformToUse = transformToUse.translate(0, 0);
    //   }
    //   if (t) {
    //     for (let x = 0; x < xNum; x += 1) {
    //       for (let y = 0; y < yNum; y += 1) {
    //         const copy = element._dup();
    //         copy.transform = transformToUse._dup();
    //         copy.transform.updateTranslation(t.x + xStep * x, t.y + yStep * y);
    //         group.add(`xy${x}${y}`, copy);
    //       }
    //     }
    //   }
    //   return group;
    // }
    // eslint-disable-next-line class-methods-use-this
    // repeatPatternVertexLegacy(
    //   element: FigureElementPrimitive,
    //   xNum: number,
    //   yNum: number,
    //   xStep: number,
    //   yStep: number,
    //   transform: Transform | Point = new Transform(),
    // ) {
    //   const copy = element._dup();
    //   const { drawingObject } = element;
    //   // console.log(element.drawingObject.points)
    //   if (drawingObject instanceof VertexObject) {
    //     copy.transform = transform._dup();
    //     const newPoints = [];
    //     const { points } = drawingObject;
    //     for (let x = 0; x < xNum; x += 1) {
    //       for (let y = 0; y < yNum; y += 1) {
    //         for (let p = 0; p < points.length; p += 2) {
    //           newPoints.push(new Point(
    //             points[p] + x * xStep,
    //             points[p + 1] + y * yStep,
    //           ));
    //           // console.log(points[p], points[p+1], newPoints.slice(-1))
    //         }
    //       }
    //     }
    //     // console.log(newPoints)
    //     copy.drawingObject.changeVertices(newPoints);
    //   }
    //   return copy;
    // }
    //   axes(...optionsIn: Array<{
    //     width?: number,
    //     height?: number,
    //     limits?: Rect,
    //     yAxisLocation?: number,
    //     xAxisLocation?: number,
    //     stepX?: number,
    //     stepY?: number,
    //     fontSize?: number,
    //     showGrid?: boolean,
    //     color?: TypeColor,
    //     fontColor?: Array<number>,
    //     gridColor?: Array<number>,
    //     location?: Transform | Point,
    //     decimalPlaces?: number,
    //     lineWidth?: number,
    //     pulse?: number,
    //   }>) {
    //     const defaultOptions = {
    //       width: 1,
    //       height: 1,
    //       limits: new Rect(-1, -1, 2, 2),
    //       yAxisLocation: 0,
    //       xAxisLocation: 0,
    //       stepX: 0.1,
    //       stepY: 0.1,
    //       fontSize: 0.13,
    //       showGrid: true,
    //       color: this.defaultColor,
    //       location: new Transform(),
    //       decimalPlaces: 1,
    //       lineWidth: 0.01,
    //     };
    //     const options = joinObjects({}, defaultOptions, ...optionsIn);
    //     if (options.fontColor == null) {
    //       options.fontColor = options.color.slice();
    //     }
    //     if (options.gridColor == null) {
    //       options.gridColor = options.color.slice();
    //     }
    //     const {
    //       width, lineWidth, limits, color, stepX, decimalPlaces,
    //       yAxisLocation, xAxisLocation, fontSize, height, stepY,
    //       location, showGrid, gridColor, fontColor,
    //     } = options;
    //     const xProps = new AxisProperties('x', 0);
    //     xProps.minorTicks.mode = 'off';
    //     xProps.minorGrid.mode = 'off';
    //     xProps.majorGrid.mode = 'off';
    //     xProps.length = width;
    //     xProps.width = lineWidth;
    //     xProps.limits = { min: limits.left, max: limits.right };
    //     xProps.color = color.slice();
    //     xProps.title = '';
    //     xProps.majorTicks.start = limits.left;
    //     xProps.majorTicks.step = stepX;
    //     xProps.majorTicks.length = lineWidth * 5;
    //     xProps.majorTicks.offset = -xProps.majorTicks.length / 2;
    //     xProps.majorTicks.width = lineWidth * 2;
    //     xProps.majorTicks.labelMode = 'off';
    //     xProps.majorTicks.color = color.slice();
    //     xProps.majorTicks.labels = tools.range(
    //       xProps.limits.min,
    //       xProps.limits.max,
    //       stepX,
    //     ).map(v => v.toFixed(decimalPlaces)).map((v) => {
    //       if (v === yAxisLocation.toString() && yAxisLocation === xAxisLocation) {
    //         return `${v}     `;
    //       }
    //       return v;
    //     });
    //     // xProps.majorTicks.labels[xProps.majorTicks.labels / 2] = '   0';
    //     xProps.majorTicks.labelOffset = new Point(
    //       0,
    //       xProps.majorTicks.offset - fontSize * 0.1,
    //     );
    //     xProps.majorTicks.labelsHAlign = 'center';
    //     xProps.majorTicks.labelsVAlign = 'top';
    //     xProps.majorTicks.fontColor = fontColor.slice();
    //     xProps.majorTicks.fontSize = fontSize;
    //     xProps.majorTicks.fontWeight = '400';
    //     const xAxis = new Axis(
    //       this.webgl, this.draw2D, xProps,
    //       new Transform().scale(1, 1).rotate(0)
    //         .translate(0, xAxisLocation - limits.bottom * height / 2),
    //       this.limits,
    //     );
    //     const yProps = new AxisProperties('x', 0);
    //     yProps.minorTicks.mode = 'off';
    //     yProps.minorGrid.mode = 'off';
    //     yProps.majorGrid.mode = 'off';
    //     yProps.length = height;
    //     yProps.width = xProps.width;
    //     yProps.limits = { min: limits.bottom, max: limits.top };
    //     yProps.color = xProps.color;
    //     yProps.title = '';
    //     yProps.rotation = Math.PI / 2;
    //     yProps.majorTicks.step = stepY;
    //     yProps.majorTicks.start = limits.bottom;
    //     yProps.majorTicks.length = xProps.majorTicks.length;
    //     yProps.majorTicks.offset = -yProps.majorTicks.length / 2;
    //     yProps.majorTicks.width = xProps.majorTicks.width;
    //     yProps.majorTicks.labelMode = 'off';
    //     yProps.majorTicks.color = color.slice();
    //     yProps.majorTicks.labels = tools.range(
    //       yProps.limits.min,
    //       yProps.limits.max,
    //       stepY,
    //     ).map(v => v.toFixed(decimalPlaces)).map((v) => {
    //       if (v === xAxisLocation.toString() && yAxisLocation === xAxisLocation) {
    //         return '';
    //       }
    //       return v;
    //     });
    //     // yProps.majorTicks.labels[3] = '';
    //     yProps.majorTicks.labelOffset = new Point(
    //       yProps.majorTicks.offset - fontSize * 0.2,
    //       0,
    //     );
    //     yProps.majorTicks.labelsHAlign = 'right';
    //     yProps.majorTicks.labelsVAlign = 'middle';
    //     yProps.majorTicks.fontColor = xProps.majorTicks.fontColor;
    //     yProps.majorTicks.fontSize = fontSize;
    //     yProps.majorTicks.fontWeight = xProps.majorTicks.fontWeight;
    //     const yAxis = new Axis(
    //       this.webgl, this.draw2D, yProps,
    //       new Transform().scale(1, 1).rotate(0)
    //         .translate(yAxisLocation - limits.left * width / 2, 0),
    //       this.limits,
    //     );
    //     let transform = new Transform();
    //     if (location instanceof Point) {
    //       transform = transform.translate(location.x, location.y);
    //     } else {
    //       transform = location._dup();
    //     }
    //     const xy = this.collection(transform);
    //     if (showGrid) {
    //       const gridLines = this.grid({
    //         bounds: new Rect(0, 0, width, height),
    //         xStep: tools.roundNum(stepX * width / limits.width, 8),
    //         yStep: tools.roundNum(stepY * height / limits.height, 8),
    //         numThickLines: 1,
    //         // linePrimitives: true,
    //         // lineNum: 2,
    //         width: options.lineWidth * 0.6,
    //         color: gridColor,
    //         transform: new Transform().scale(1, 1).rotate(0).translate(0, 0),
    //       });
    //       xy.add('grid', gridLines);
    //     }
    //     xy.add('y', yAxis);
    //     xy.add('x', xAxis);
    //     if (
    //       options.pulse != null
    //       && typeof xy.pulseDefault !== 'function'
    //       && typeof xy.pulseDefault !== 'string'
    //     ) {
    //       xy.pulseDefault.scale = options.pulse;
    //     }
    //     return xy;
    //   }
    //   parallelMarks(...optionsIn: Array<{
    //     num?: number,
    //     width?: number,
    //     length?: number,
    //     angle?: number,
    //     step?: number,
    //     rotation?: number,
    //     color?: TypeColor,
    //     pulse?: number,
    //     transform?: Transform,
    //     position?: Point,
    //   }>) {
    //     const defaultOptions = {
    //       width: 0.01,
    //       num: 1,
    //       length: 0.1,
    //       angle: Math.PI / 4,
    //       step: 0.04,
    //       rotation: 0,
    //       color: this.defaultColor,
    //       transform: new Transform().scale(1, 1).rotate(0).translate(0, 0),
    //       position: null,
    //     };
    //     const options = joinObjects({}, defaultOptions, ...optionsIn);
    //     if (options.position != null) {
    //       options.transform.updateTranslation(getPoint(options.position));
    //     }
    //     const x = options.length * Math.cos(options.angle);
    //     const y = options.length * Math.sin(options.angle);
    //     const wx = Math.abs(options.width * Math.cos(options.angle + Math.PI / 2));
    //     const wy = options.width * Math.sin(options.angle + Math.PI / 2);
    //     const single = [
    //       new Point(0, 0),
    //       new Point(0 - x, 0 - y),
    //       new Point(-x - wx, -y + wy),
    //       new Point(-Math.abs(options.width / Math.cos(options.angle + Math.PI / 2)), 0),
    //       new Point(-x - wx, y - wy),
    //       new Point(0 - x, 0 + y),
    //     ];
    //     const collection = this.collection(
    //       options.transform,
    //     );
    //     collection.setColor(options.color);
    //     if (
    //       options.pulse != null
    //       && typeof collection.pulseDefault !== 'function'
    //       && typeof collection.pulseDefault !== 'string'
    //     ) {
    //       collection.pulseDefault.scale = options.pulse;
    //     }
    //     const start = -((options.num - 1) / 2) * options.step;
    //     for (let i = 0; i < options.num; i += 1) {
    //       const points = single.map(
    //         p => (new Point(p.x + start + i * options.step, p.y)).rotate(options.rotation),
    //       );
    //       collection.add(`${i}`, this.fan({
    //         points,
    //         color: options.color,
    //       }));
    //     }
    //     return collection;
    //   }
    //   marks(...optionsIn: Array<{
    //     num?: number,
    //     width?: number,
    //     length?: number,
    //     angle?: number,
    //     step?: number,
    //     rotation?: number,
    //     color?: TypeColor,
    //     pulse?: number,
    //     transform?: Transform,
    //     position?: Point,
    //   }>) {
    //     const defaultOptions = {
    //       width: 0.01,
    //       num: 1,
    //       length: 0.2,
    //       angle: Math.PI / 2,
    //       step: 0.04,
    //       rotation: 0,
    //       color: this.defaultColor,
    //       transform: new Transform().scale(1, 1).rotate(0).translate(0, 0),
    //       position: null,
    //     };
    //     const options = joinObjects({}, defaultOptions, ...optionsIn);
    //     if (options.position != null) {
    //       options.transform.updateTranslation(getPoint(options.position));
    //     }
    //     const single = [
    //       new Point(options.length / 2, options.width / 2),
    //       new Point(options.length / 2, -options.width / 2),
    //       new Point(-options.length / 2, -options.width / 2),
    //       new Point(-options.length / 2, options.width / 2),
    //     ];
    //     const collection = this.collection(
    //       options.transform,
    //     );
    //     collection.setColor(options.color);
    //     if (
    //       options.pulse != null
    //       && typeof collection.pulseDefault !== 'function'
    //       && typeof collection.pulseDefault !== 'string'
    //     ) {
    //       collection.pulseDefault.scale = options.pulse;
    //     }
    //     const start = -((options.num - 1) / 2) * options.step;
    //     for (let i = 0; i < options.num; i += 1) {
    //       const t = new Transform()
    //         .rotate(options.angle)
    //         .translate(start + i * options.step, 0)
    //         .rotate(options.rotation);
    //       const points = single.map(
    //         p => (p._dup().transformBy(t.matrix())),
    //       );
    //       collection.add(`${i}`, this.fan({
    //         points,
    //         color: options.color,
    //       }));
    //     }
    //     return collection;
    //   }

  }]);

  return FigurePrimitives;
}();



/***/ }),

/***/ "./src/js/figure/FigurePrimitives/Generic.js":
/*!***************************************************!*\
  !*** ./src/js/figure/FigurePrimitives/Generic.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Generic; });
/* harmony import */ var _DrawingObjects_VertexObject_VertexGeneric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexGeneric */ "./src/js/figure/DrawingObjects/VertexObject/VertexGeneric.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/figure/webgl/webgl.js");



 // import type { CPY_Step } from '../geometries/copy/copy';

function Generic(webgl, // vertices: Array<Point>,
// border: Array<Array<Point>> | 'points' | 'rect',
// touchBorder: Array<Array<Point>> | 'rect' | 'border' | 'none',
// holeBorder: Array<Array<Point>> | 'none',
// drawType: 'triangles' | 'strip' | 'fan' | 'lines',
color, transformOrLocation, figureLimits) {
  var textureLocation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
  var textureVertexSpace = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Rect"](-1, -1, 2, 2);
  var textureCoords = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Rect"](0, 0, 1, 1);
  var textureRepeat = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var onLoad = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
  var name = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : '';
  var generic = new _DrawingObjects_VertexObject_VertexGeneric__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, // vertices,
  // border,
  // touchBorder,
  // holeBorder,
  // drawType,
  textureLocation, Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["getRect"])(textureVertexSpace), Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["getRect"])(textureCoords), textureRepeat);

  if (textureLocation) {
    generic.onLoad = onLoad;
  }

  var transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]();

  if (transformOrLocation instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"]) {
    transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  } else {
    transform = transformOrLocation._dup();
  } // $FlowFixMe


  return new _Element__WEBPACK_IMPORTED_MODULE_1__["FigureElementPrimitive"](generic, transform, color, figureLimits, null, name);
}

/***/ }),

/***/ "./src/js/figure/FigurePrimitives/Text.js":
/*!************************************************!*\
  !*** ./src/js/figure/FigurePrimitives/Text.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DrawingObjects_VertexObject_VertexText__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DrawingObjects/VertexObject/VertexText */ "./src/js/figure/DrawingObjects/VertexObject/VertexText.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Element */ "./src/js/figure/Element.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _webgl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/webgl */ "./src/js/figure/webgl/webgl.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");






function Text(webgl, figureLimits, optionsIn) {
  var defaultOptions = {
    position: new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](0, 0),
    color: [1, 0, 0, 1]
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_4__["joinObjects"])({}, defaultOptions, optionsIn);

  if (options.transform == null) {
    options.transform = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Transform"]('Text').translate(0, 0);
  }

  if (options.position != null) {
    options.transform.updateTranslation(options.position);
  }

  var vertexText = new _DrawingObjects_VertexObject_VertexText__WEBPACK_IMPORTED_MODULE_0__["default"](webgl, options); // let transform = new Transform();
  // if (transformOrLocation instanceof Point) {
  //   transform = transform.translate(transformOrLocation.x, transformOrLocation.y);
  // } else {
  //   transform = transformOrLocation._dup();
  // }

  return new _Element__WEBPACK_IMPORTED_MODULE_1__["FigureElementPrimitive"](vertexText, options.transform, options.color, figureLimits);
}

/* harmony default export */ __webpack_exports__["default"] = (Text);

/***/ }),

/***/ "./src/js/figure/Gesture.js":
/*!**********************************!*\
  !*** ./src/js/figure/Gesture.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/g2 */ "./src/js/tools/g2.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var Gesture = /*#__PURE__*/function () {
  function Gesture(figure) {
    _classCallCheck(this, Gesture);

    this.figure = figure; // Override these if you want to use your own touch handlers

    this.start = this.figure.touchDownHandler.bind(this.figure);
    this.end = this.figure.touchUpHandler.bind(this.figure);
    this.move = this.figure.touchMoveHandler.bind(this.figure);
    this.free = this.figure.touchFreeHandler.bind(this.figure);
    this.toggleCursor = this.figure.toggleCursor.bind(this.figure);
    this.binds = {
      mouseDownHandler: this.mouseDownHandler.bind(this),
      mouseUpHandler: this.mouseUpHandler.bind(this),
      mouseMoveHandler: this.mouseMoveHandler.bind(this),
      touchStartHandler: this.touchStartHandler.bind(this),
      touchEndHandler: this.touchEndHandler.bind(this),
      touchMoveHandler: this.touchMoveHandler.bind(this)
    };
    this.addEvent('mousedown', this.binds.mouseDownHandler, false);
    this.addEvent('mouseup', this.binds.mouseUpHandler, false);
    this.addEvent('mousemove', this.binds.mouseMoveHandler, false);
    this.addEvent('touchstart', this.binds.touchStartHandler, false);
    this.addEvent('touchend', this.binds.touchEndHandler, false);
    this.addEvent('touchmove', this.binds.touchMoveHandler, false);
    this.enable = true;
  }

  _createClass(Gesture, [{
    key: "addEvent",
    value: function addEvent(event, method, flag) {
      this.figure.gestureCanvas.addEventListener(event, method.bind(this), flag);
    }
  }, {
    key: "removeEvent",
    value: function removeEvent(event, method, flag) {
      this.figure.gestureCanvas.removeEventListener(event, method.bind(this), flag);
    }
  }, {
    key: "startHandler",
    value: function startHandler(point) {
      if (this.enable) {
        this.mouseDown = true;
        this.previousPoint = point;
        return this.start(point);
      }

      return false;
    }
  }, {
    key: "endHandler",
    value: function endHandler() {
      this.mouseDown = false;
      this.end();
    }
  }, {
    key: "moveHandler",
    value: function moveHandler(event, point) {
      if (this.enable && this.mouseDown) {
        var disableEvent = this.move(this.previousPoint, point);

        if (disableEvent) {
          event.preventDefault();
        }

        this.previousPoint = point;
      } else {
        this.free(point);
      }
    }
  }, {
    key: "touchStartHandler",
    value: function touchStartHandler(event) {
      var touch = event.touches[0];
      var disableEvent = this.startHandler(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](touch.clientX, touch.clientY));

      if (disableEvent) {
        event.preventDefault();
      }
    }
  }, {
    key: "mouseDownHandler",
    value: function mouseDownHandler(event) {
      var disableEvent = this.startHandler(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](event.clientX, event.clientY));

      if (disableEvent) {
        event.preventDefault();
      }
    }
  }, {
    key: "touchMoveHandler",
    value: function touchMoveHandler(event) {
      var touch = event.touches[0];
      this.moveHandler(event, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](touch.clientX, touch.clientY));
    }
  }, {
    key: "mouseMoveHandler",
    value: function mouseMoveHandler(event) {
      this.moveHandler(event, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](event.clientX, event.clientY));
    }
  }, {
    key: "mouseUpHandler",
    value: function mouseUpHandler() {
      this.endHandler();
    }
  }, {
    key: "touchEndHandler",
    value: function touchEndHandler() {
      this.endHandler();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeEvent('mousedown', this.binds.mouseDownHandler, false);
      this.removeEvent('mouseup', this.binds.mouseUpHandler, false);
      this.removeEvent('mousemove', this.binds.mouseMoveHandler, false);
      this.removeEvent('touchstart', this.binds.touchStartHandler, false);
      this.removeEvent('touchend', this.binds.touchEndHandler, false);
      this.removeEvent('touchmove', this.binds.touchMoveHandler, false);
    }
  }]);

  return Gesture;
}();

/* harmony default export */ __webpack_exports__["default"] = (Gesture);

/***/ }),

/***/ "./src/js/figure/Recorder/Recorder.js":
/*!********************************************!*\
  !*** ./src/js/figure/Recorder/Recorder.js ***!
  \********************************************/
/*! exports provided: Recorder, getIndexOfEarliestTime, download, getIndexOfLatestTime, getNextIndexForTime, getPrevIndexForTime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Recorder", function() { return Recorder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIndexOfEarliestTime", function() { return getIndexOfEarliestTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIndexOfLatestTime", function() { return getIndexOfLatestTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNextIndexForTime", function() { return getNextIndexForTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrevIndexForTime", function() { return getPrevIndexForTime; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/math */ "./src/js/tools/math.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "download", function() { return _tools_tools__WEBPACK_IMPORTED_MODULE_2__["download"]; });

/* harmony import */ var _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/GlobalAnimation */ "./src/js/figure/webgl/GlobalAnimation.js");
/* harmony import */ var _recorder_worker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./recorder.worker */ "./src/js/figure/Recorder/recorder.worker.js");
/* harmony import */ var _recorder_worker__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_recorder_worker__WEBPACK_IMPORTED_MODULE_4__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import type { Transform } from '../tools/g2';



 // import type { FigureElement } from './Element';



function getIndexOfEarliestTime(recordedData, index) {
  if (index < 1) {
    return index;
  }

  var i = index;
  var same = true;
  var time = recordedData[index][0];

  while (i > 0 && same) {
    var prevTime = recordedData[i - 1][0];

    if (prevTime !== time) {
      same = false;
    } else {
      i -= 1;
    }
  }

  return i;
}

function getIndexOfLatestTime(recordedData, index) {
  var time = recordedData[index][0];
  var i = index;
  var loop = true;

  while (loop) {
    if (i === recordedData.length - 1) {
      loop = false;
    } else if (recordedData[i + 1][0] === time) {
      i += 1;
    } else {
      loop = false;
    }
  }

  return Math.max(i, index);
}

function getIndexRangeForTime(recordedData, time) {
  var startSearch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var endSearch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : recordedData.length - 1;

  if (recordedData.length === 0) {
    return [-1, -1];
  }

  var startTime = parseFloat(recordedData[startSearch][0]);

  if (time === startTime) {
    return [startSearch, startSearch];
  }

  if (time < startTime) {
    return [-1, startSearch];
  }

  var endTime = parseFloat(recordedData[endSearch][0]);

  if (time === endTime) {
    return [endSearch, endSearch];
  }

  if (time > endTime) {
    return [endSearch, -1];
  }

  var searchRange = endSearch - startSearch;

  if (searchRange < 2) {
    return [startSearch, endSearch];
  }

  var midSearch = startSearch + Math.floor(searchRange / 2);
  var midTime = parseFloat(recordedData[midSearch][0]);

  if (time === midTime) {
    return [midSearch, midSearch];
  }

  if (time < midTime) {
    return getIndexRangeForTime(recordedData, time, startSearch, midSearch);
  }

  return getIndexRangeForTime(recordedData, time, midSearch, endSearch);
}

function getNextIndexForTime(recordedData, time) {
  var startSearch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var endSearch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : recordedData.length - 1;
  var earliestTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var nextIndex = getIndexRangeForTime(recordedData, time, startSearch, endSearch)[1]; // console.log(nextIndex)

  if (earliestTime) {
    return getIndexOfEarliestTime(recordedData, nextIndex);
  }

  return getIndexOfLatestTime(recordedData, nextIndex);
}

function getPrevIndexForTime(recordedData, time) {
  var startSearch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var endSearch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : recordedData.length - 1;
  var earliestTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var prevIndex = getIndexRangeForTime(recordedData, time, startSearch, endSearch)[0];

  if (earliestTime) {
    return getIndexOfEarliestTime(recordedData, prevIndex);
  }

  return getIndexOfLatestTime(recordedData, prevIndex);
} // function getTimeToIndex(
//   recordedData: TypeEvents | TypeStateDiffs,
//   eventIndex: number,
//   time: number,
// ) {
//   if (eventIndex === -1 || eventIndex > recordedData.length - 1) {
//     return -1;
//   }
//   const nextTime = recordedData[eventIndex][0];
//   return nextTime - time;
// }


var Recorder = /*#__PURE__*/function () {
  // performance.now() - deltaToNow = video time
  // The current video time location
  // The duration of the video
  // The precision with which to record numbers
  // in seconds
  // playbackStoppedCallback: ?() =>void;
  // All slides, events and states are relative to 0, where 0 is the start of a recording.
  // Slides, events and states do not have to have a 0 time,
  // maybe the first event will not happen till 1s in
  function Recorder() {
    var singleton = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _classCallCheck(this, Recorder);

    // If the instance alread exists, then don't create a new instance.
    // If it doesn't, then setup some default values.
    if (singleton) {
      if (!Recorder.instance) {
        this.initialize();
      }

      return Recorder.instance;
    }

    this.initialize();
  }

  _createClass(Recorder, [{
    key: "initialize",
    value: function initialize() {
      this.subscriptions = new _tools_tools__WEBPACK_IMPORTED_MODULE_2__["SubscriptionManager"]();
      this.events = {};
      this.eventsCache = {};
      this.reset(); // default recording values

      this.precision = 4;
      this.stateTimeStep = 1;
      this.audio = null; // this.playbackStoppedCallback = null;

      this.worker = null;
      this.pauseState = null;
      this.settings = {
        pause: 'freeze',
        play: 'instant'
      };
    } // ////////////////////////////////////
    // ////////////////////////////////////
    // Time
    // ////////////////////////////////////
    // ////////////////////////////////////

  }, {
    key: "timeStamp",
    value: function timeStamp() {
      // eslint-disable-line class-methods-use-this
      return new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_3__["default"]().now();
    }
  }, {
    key: "now",
    value: function now() {
      // eslint-disable-line class-methods-use-this
      return Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])((this.timeStamp() - this.videoToNowDelta) / 1000, 8);
    }
  }, {
    key: "getCurrentTime",
    value: function getCurrentTime() {
      if (this.state !== 'idle') {
        return this.now();
      }

      return this.currentTime;
    }
  }, {
    key: "getDeltaTime",
    value: function getDeltaTime() {
      var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var currentTime = this.getCurrentTime();
      var newTime = currentTime + delta;

      if (newTime > this.duration) {
        return this.duration;
      }

      if (newTime < 0) {
        return 0;
      }

      return newTime;
    }
  }, {
    key: "setCurrentTime",
    value: function setCurrentTime(time) {
      this.currentTime = time;
      this.subscriptions.publish('timeUpdate', [time]);
    }
  }, {
    key: "setVideoToNowDeltaTime",
    value: function setVideoToNowDeltaTime() {
      var videoSeekTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.videoToNowDelta = this.timeStamp() - videoSeekTime * 1000;
    }
  }, {
    key: "calcDuration",
    value: function calcDuration() {
      var _this = this;

      var cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var eventsTime = 0;
      var eventsCacheTime = 0;
      var statesTime = 0;
      var statesCacheTime = 0;
      var audioTime = 0;
      Object.keys(this.events).forEach(function (eventName) {
        var event = _this.events[eventName];

        if (event.list.length > 0) {
          eventsTime = Math.max(eventsTime, event.list[event.list.length - 1][0]);
        }
      });
      Object.keys(this.eventsCache).forEach(function (eventName) {
        var event = _this.eventsCache[eventName];

        if (event.list.length > 0) {
          eventsCacheTime = Math.max(eventsCacheTime, event.list[event.list.length - 1][0]);
        }
      });

      if (this.states.diffs.length > 0) {
        var _this$states$diffs = _slicedToArray(this.states.diffs[this.states.diffs.length - 1], 1);

        statesTime = _this$states$diffs[0];
      }

      if (this.statesCache.diffs.length > 0) {
        var _this$statesCache$dif = _slicedToArray(this.statesCache.diffs[this.statesCache.diffs.length - 1], 1);

        statesCacheTime = _this$statesCache$dif[0];
      } // eslint-disable-next-line no-restricted-globals


      if (this.audio != null && !isNaN(this.audio.duration)) {
        audioTime = this.audio.duration;
      }

      if (cache) {
        return Math.max(eventsCacheTime, statesCacheTime);
      }

      return Math.max(eventsTime, eventsCacheTime, statesTime, statesCacheTime, audioTime);
    } // ////////////////////////////////////
    // ////////////////////////////////////
    // Initialization
    // ////////////////////////////////////
    // ////////////////////////////////////

  }, {
    key: "reset",
    value: function reset() {
      var _this2 = this;

      this.states = new _tools_tools__WEBPACK_IMPORTED_MODULE_2__["ObjectTracker"](this.precision);
      this.statesCache = new _tools_tools__WEBPACK_IMPORTED_MODULE_2__["ObjectTracker"](this.precision);
      Object.keys(this.events).forEach(function (eventName) {
        _this2.events[eventName].list = [];
      }); // this.events.list = [];

      this.eventsCache = {};
      this.stateIndex = -1;
      this.eventIndex = {};
      this.stopTimeouts();
      this.videoToNowDelta = 0;
      this.state = 'idle';
      this.isAudioPlaying = false; // this.currentTime = 0;

      this.setCurrentTime(0);
      this.duration = 0;
      this.reference = '__base';
      this.lastRecordTimeCount = 0;
      this.lastRecordTime = null;
      this.eventsToPlay = [];
      this.lastSeekTime = null;
    }
  }, {
    key: "loadAudio",
    value: function loadAudio(audio) {
      var _this3 = this;

      this.audio = audio;

      this.audio.onloadedmetadata = function () {
        _this3.duration = _this3.calcDuration();
      };

      this.subscriptions.publish('audioLoaded');
    }
  }, {
    key: "loadEvents",
    value: function loadEvents(encodedEventsList) {
      var _this4 = this;

      var isMinified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      // $FlowFixMe
      var lists = this.decodeEvents(encodedEventsList, isMinified); // Loading, Decoding, Enconding events and states is a flow mess
      // $FlowFixMe

      Object.keys(lists).forEach(function (eventName) {
        if (_this4.events[eventName] == null) {
          return;
        } // $FlowFixMe


        _this4.events[eventName].list = lists[eventName];
      });
      this.duration = this.calcDuration();
      this.subscriptions.publish('eventsLoaded');
    }
  }, {
    key: "loadStates",
    value: function loadStates(statesIn) {
      var isMinified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var isObjectForm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      this.states = this.decodeStates(statesIn, isMinified, isObjectForm);
      this.duration = this.calcDuration();
      this.subscriptions.publish('statesLoaded');
    }
  }, {
    key: "encodeEvents",
    value: function encodeEvents() {
      var minifyEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var lists = {};
      var events = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(this.events); // $FlowFixMe

      Object.keys(events).forEach(function (eventName) {
        // $FlowFixMe
        lists[eventName] = events[eventName].list;
      });

      if (minifyEvents) {
        return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["minify"])(lists);
      }

      return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(lists);
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "decodeEvents",
    value: function decodeEvents(lists) {
      var isMinified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (isMinified) {
        return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["unminify"])(lists);
      }

      return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(lists);
    }
  }, {
    key: "encodeStates",
    value: function encodeStates() {
      var minifyStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var asObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.precision;
      var states;

      if (asObject) {
        states = this.states.toObj();
      } else {
        states = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(this.states);
      }

      if (minifyStates) {
        return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["minify"])(states, precision);
      }

      return states;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "decodeStates",
    value: function decodeStates(statesIn) {
      var isMinified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var asObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var statesToUse = statesIn;

      if (isMinified) {
        statesToUse = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["unminify"])(statesIn);
      }

      if (asObject) {
        var states1 = new _tools_tools__WEBPACK_IMPORTED_MODULE_2__["ObjectTracker"]();
        states1.setFromObj(statesToUse);
        statesToUse = states1;
      }

      var states = new _tools_tools__WEBPACK_IMPORTED_MODULE_2__["ObjectTracker"]();
      states.diffs = statesToUse.diffs;
      states.baseReference = statesToUse.baseReference;
      states.references = statesToUse.references;
      states.precision = statesToUse.precision;
      return states;
    } // ////////////////////////////////////
    // ////////////////////////////////////
    // Editing
    // ////////////////////////////////////
    // ////////////////////////////////////
    // Remove selected events in time range
    // set all state diffs to be the same in time range
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "clearListOrDiffs",
    value: function clearListOrDiffs(listOrDiffs, startTime, stopTime) {
      var startIndex = getNextIndexForTime(listOrDiffs, startTime);
      var stopIndex = getPrevIndexForTime(listOrDiffs, stopTime);
      var newListOrDiffs = [];

      if (startIndex > 0) {
        // $FlowFixMe
        newListOrDiffs = listOrDiffs.slice(0, startIndex);
      }

      if (stopIndex > -1 && stopIndex + 1 <= listOrDiffs.length - 1) {
        newListOrDiffs = [].concat(_toConsumableArray(newListOrDiffs), _toConsumableArray(listOrDiffs.slice(stopIndex + 1)));
      }

      return newListOrDiffs;
    }
  }, {
    key: "clear",
    value: function clear(startTime, stopTime) {
      var _this5 = this;

      Object.keys(this.events).forEach(function (eventName) {
        var event = _this5.events[eventName]; // $FlowFixMe

        event.list = _this5.clearListOrDiffs(event.list, startTime, stopTime);
      }); // $FlowFixMe

      this.states.diffs = this.clearListOrDiffs(this.states.diffs, startTime, stopTime);
    } // ////////////////////////////////////
    // ////////////////////////////////////
    // Recording
    // ////////////////////////////////////
    // ////////////////////////////////////

  }, {
    key: "startRecording",
    value: function startRecording() {
      var fromTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var whilePlaying = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      // if (fromTime > 0) {
      this.state = 'recording';
      this.lastSeekTime = null;
      this.setVideoToNowDeltaTime(fromTime);

      if (this.states.diffs.length > 0) {
        this.setToTime(fromTime, true);
      }

      this.states.precision = this.precision;

      if (fromTime === 0 && this.states.baseReference == null) {
        this.states.setBaseReference(this.figure.getState({
          precision: this.precision,
          ignoreShown: true
        }));
      }

      this.startWorker();

      if (this.worker != null) {
        this.worker.postMessage({
          message: 'reset',
          payload: {
            baseReference: this.states.baseReference,
            references: this.states.references
          }
        });
      }

      this.eventsCache = {}; // this.figure.unpause();

      this.lastRecordTime = null;
      this.duration = this.calcDuration();
      this.queueRecordState(fromTime % this.stateTimeStep);
      this.eventsToPlay = whilePlaying; // this.initializePlayback(fromTime);

      this.startEventsPlayback(fromTime);
      this.startAudioPlayback(fromTime);
      this.subscriptions.publish('startRecording');
      this.startRecordingTime = fromTime;
      this.startTimeUpdates(); // console.log('recorder is', this.state);
    }
  }, {
    key: "startWorker",
    value: function startWorker() {
      if (this.worker == null) {
        this.worker = new _recorder_worker__WEBPACK_IMPORTED_MODULE_4___default.a();
        this.worker.addEventListener('message', this.parseMessage.bind(this));
      }
    } // $FlowFixMe

  }, {
    key: "parseMessage",
    value: function parseMessage(event) {
      var _event$data = event.data,
          message = _event$data.message,
          payload = _event$data.payload; // if (message === 'duration')

      if (message === 'cache') {
        this.statesCache = new _tools_tools__WEBPACK_IMPORTED_MODULE_2__["ObjectTracker"]();
        this.statesCache.diffs = payload.diffs;
        this.statesCache.baseReference = payload.baseReference;
        this.statesCache.references = payload.references;
        this.mergeEventsCache();
        this.mergeStatesCache();
        this.duration = this.calcDuration();

        if (this.duration % 1 > 0) {
          var lastIndex = this.states.diffs.length - 1;

          var _this$states$diffs$la = _slicedToArray(this.states.diffs[lastIndex], 3),
              ref = _this$states$diffs$la[1],
              diff = _this$states$diffs$la[2];

          this.states.diffs.push([Math.ceil(this.duration), ref, Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(diff), 0]);
        }

        this.duration = this.calcDuration(); // console.log(this)
      }
    }
  }, {
    key: "addCurrentStateAsReference",
    value: function addCurrentStateAsReference() {
      this.referenceIndex += 1;
      this.reference = "ref".concat(this.referenceIndex);
      var state = this.figure.getState({
        precision: this.precision,
        ignoreShown: true
      });

      if (this.state === 'recording') {
        // this.statesCache.addReference(state, this.reference);
        if (this.worker != null) {
          this.worker.postMessage({
            message: 'addReference',
            payload: {
              state: state,
              refName: this.reference,
              basedOn: '__base'
            }
          });
        }
      } else {
        this.states.addReference(state, this.reference);
      }
    }
  }, {
    key: "getCacheStartTime",
    value: function getCacheStartTime() {
      var _this6 = this;

      var time = null;

      if (this.statesCache.diffs.length > 0) {
        time = this.statesCache.diffs[0][0]; // eslint-disable-line prefer-destructuring
      }

      Object.keys(this.eventsCache).forEach(function (eventName) {
        var event = _this6.eventsCache[eventName];

        if (event.list.length > 0) {
          var _event$list$ = _slicedToArray(event.list[0], 1),
              eventTime = _event$list$[0];

          if (time == null) {
            time = eventTime;
          } else {
            time = Math.min(eventTime, time);
          }
        }
      });
      return time;
    }
  }, {
    key: "getCacheEndTime",
    value: function getCacheEndTime() {
      return this.calcDuration(true);
    }
  }, {
    key: "getMergedCacheArray",
    value: function getMergedCacheArray(eventListOrStatesDiff, cacheArray) {
      // const startTime = this.getCacheStartTime();
      // const endTime = this.getCacheEndTime();
      var startTime = this.startRecordingTime;
      var endTime = this.currentTime;

      if (startTime == null || endTime === 0) {
        return [];
      }

      var sliceStart = getPrevIndexForTime(eventListOrStatesDiff, startTime);

      if (sliceStart > -1 && eventListOrStatesDiff[sliceStart][0] === startTime) {
        sliceStart = getIndexOfEarliestTime(eventListOrStatesDiff, sliceStart) - 1;

        if (sliceStart < 0) {
          sliceStart = -1;
        }
      }

      var sliceEnd = getNextIndexForTime(eventListOrStatesDiff, endTime);

      if (sliceEnd > -1 && eventListOrStatesDiff[sliceEnd][0] === endTime) {
        sliceEnd = getIndexOfLatestTime(eventListOrStatesDiff, sliceEnd) + 1;

        if (sliceEnd > eventListOrStatesDiff.length - 1) {
          sliceEnd = -1;
        }
      } // console.log(sliceStart, sliceEnd)


      var beforeEvents = [];
      var afterEvents = [];

      if (sliceStart >= 0) {
        beforeEvents = eventListOrStatesDiff.slice(0, sliceStart + 1);
      }

      if (sliceEnd >= 0) {
        afterEvents = eventListOrStatesDiff.slice(sliceEnd);
      }

      return [].concat(_toConsumableArray(beforeEvents), _toConsumableArray(cacheArray), _toConsumableArray(afterEvents));
    }
  }, {
    key: "mergeEventsCache",
    value: function mergeEventsCache() {
      var _this7 = this;

      // Object.keys(this.eventsCache).forEach((eventName) => {
      //   const merged = this.getMergedCacheArray(
      //     this.events[eventName].list, this.eventsCache[eventName].list,
      //   );
      //   if (merged.length === 0) {
      //     return;
      //   }
      //   this.events[eventName].list = merged;
      // });
      var allEventNames = {};
      Object.keys(this.events).forEach(function (eventName) {
        allEventNames[eventName] = null;
      });
      Object.keys(this.eventsCache).forEach(function (eventName) {
        allEventNames[eventName] = null;
      });
      Object.keys(allEventNames).forEach(function (eventName) {
        var eventsCacheList = [];

        if (_this7.eventsCache[eventName] != null) {
          eventsCacheList = _this7.eventsCache[eventName].list;
        }

        var eventsList = [];

        if (_this7.events[eventName] != null) {
          eventsList = _this7.events[eventName].list;
        } // console.log(eventName)


        var merged = _this7.getMergedCacheArray( // $FlowFixMe
        eventsList, eventsCacheList);

        if (merged.length === 0) {
          return;
        } // $FlowFixMe


        _this7.events[eventName].list = merged;
      });
    }
  }, {
    key: "mergeStatesCache",
    value: function mergeStatesCache() {
      var merged = this.getMergedCacheArray( // $FlowFixMe
      this.states.diffs, this.statesCache.diffs);

      if (merged.length === 0) {
        return;
      } // $FlowFixMe


      this.states.diffs = merged; // this.states.baseReference = duplicate(this.statesCache.baseReference);
      // $FlowFixMe

      this.states.references = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["duplicate"])(this.statesCache.references);
    }
  }, {
    key: "stopTimeouts",
    value: function stopTimeouts() {
      // if (this.timeoutID != null) {
      //   clearTimeout(this.timeoutID);
      //   this.timeoutID = null;
      // }
      new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_3__["default"]().clearTimeout(this.timeoutID);
      new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_3__["default"]().clearTimeout(this.timeUpdatesTimeoutID);
      this.timeoutID = null;
      this.timeUpdatesTimeoutID = null; // if (this.timeUpdatesTimeoutID != null) {
      //   clearTimeout(this.timeUpdatesTimeoutID);
      //   this.timeUpdatesTimeoutID = null;
      // }
    }
  }, {
    key: "stopRecording",
    value: function stopRecording() {
      // this.currentTime = this.getCurrentTime();
      this.setCurrentTime(this.getCurrentTime());
      this.state = 'idle';
      this.stopTimeouts(); // $FlowFixMe

      this.worker.postMessage({
        message: 'get'
      });

      if (this.audio) {
        this.audio.pause();
        this.isAudioPlaying = false;
      }

      this.lastSeekTime = null;
      this.subscriptions.publish('stopRecording'); // this.mergeEventsCache();
      // this.mergeStatesCache();
      // this.duration = this.calcDuration();
      // if (this.duration % 1 > 0) {
      //   const lastIndex = this.states.diffs.length - 1;
      //   const [, ref, diff] = this.states.diffs[lastIndex];
      //   this.states.diffs.push([Math.ceil(this.duration), ref, duplicate(diff), 0]);
      // }
      // this.duration = this.calcDuration();
      // console.log(this)
    }
  }, {
    key: "addEventType",
    value: function addEventType(eventName, playbackAction) {
      var setOnSeek = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      this.events[eventName] = {
        setOnSeek: setOnSeek,
        list: [],
        playbackAction: playbackAction
      };
      this.eventIndex[eventName] = -1; // this.timeoutID[eventName] = null;
    }
  }, {
    key: "recordState",
    value: function recordState(state) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getCurrentTime();
      // const now = this.now();
      var now = time;

      if (this.lastRecordTime == null || now > this.lastRecordTime) {
        this.lastRecordTime = now;
        this.lastRecordTimeCount = 0;
      } // const start = performance.now();
      // if (this.worker != null) {
      //   this.worker.postMessage(state);
      // }


      if (this.worker != null) {
        this.worker.postMessage({
          message: 'add',
          payload: {
            now: now,
            state: state,
            reference: this.reference,
            lastRecordTimeCount: this.lastRecordTimeCount
          }
        });
      } // this.statesCache.add(now, state, this.reference, this.lastRecordTimeCount);
      // console.log('add', performance.now() - start);
      // this.duration = this.calcDuration();
      // if (now > this.duration) {
      //   this.duration = now;
      // }


      this.lastRecordTimeCount += 1;

      if (now > this.duration) {
        this.duration = now;
      }
    }
  }, {
    key: "recordCurrentState",
    value: function recordCurrentState() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getCurrentTime();
      // const start = performance.now();
      // if (window.asdf) {
      //   console.log('recording state', time);
      // }
      var state = this.figure.getState({
        precision: this.precision,
        ignoreShown: true
      }); // const start1 = performance.now();
      // const str = JSON.stringify(state);
      // console.log('stringify', str.length, performance.now() - start);
      // console.log(state)
      // console.log(str)
      // const unStr = JSON.parse(str)
      // console.log(unStr)
      // console.log(unStr == state)

      this.recordState(state, time); // console.log('recordState', performance.now() - start);
    }
  }, {
    key: "recordCurrentStateAsReference",
    value: function recordCurrentStateAsReference(refName, basedOn) {
      var state = this.figure.getState({
        precision: this.precision,
        ignoreShown: true
      });

      if (this.worker != null) {
        this.worker.postMessage({
          message: 'addReference',
          payload: {
            state: state,
            refName: refName,
            basedOn: basedOn
          }
        });
      } // this.statesCache.addReference(this.figure.getState({
      //   precision: this.precision,
      //   ignoreShown: true,
      // }), refName, basedOn);

    }
  }, {
    key: "recordEvent",
    value: function recordEvent(eventName, payload) {
      var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.now();

      // console.log(time)
      if (this.events[eventName] == null) {
        return;
      }

      if (this.eventsCache[eventName] == null) {
        this.eventsCache[eventName] = {
          list: []
        };
      } // const now = this.now();


      if (this.lastRecordTime == null || time > this.lastRecordTime) {
        this.lastRecordTime = time;
        this.lastRecordTimeCount = 0;
      }

      this.eventsCache[eventName].list.push([time, payload, this.lastRecordTimeCount]);
      this.lastRecordTimeCount += 1;

      if (time > this.duration) {
        this.duration = time;
      }
    } // States are recorded every second

  }, {
    key: "queueRecordState",
    value: function queueRecordState() {
      var _this8 = this;

      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      // console.log(time)
      var recordAndQueue = function recordAndQueue() {
        if (_this8.state === 'recording') {
          if (_this8.figure.getIsInTransition() === false) {
            _this8.recordCurrentState();
          }

          _this8.queueRecordState(_this8.stateTimeStep - _this8.getCurrentTime() % _this8.stateTimeStep);
        }
      };

      if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(time, 4) === 0) {
        recordAndQueue();
        return;
      } // if (time < 1) {
      //   return
      // }


      this.timeoutID = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_3__["default"]().setTimeout(function () {
        recordAndQueue();
      }, Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(time * 1000, 0));
    }
  }, {
    key: "save",
    value: function save() {
      var dateStr = new Date().toISOString();
      var location = window.location.pathname.replace('/', '_');
      var encodedStates = this.encodeStates();
      var encodedEvents = this.encodeEvents();

      if (encodedStates != null) {
        Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["download"])("".concat(dateStr, " ").concat(location, ".vidstates.json"), JSON.stringify(encodedStates));
      }

      if (encodedEvents != null) {
        Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["download"])("".concat(dateStr, " ").concat(location, ".videvents.json"), JSON.stringify(encodedEvents));
      }
    }
  }, {
    key: "show",
    value: function show() {
      var toJsonHtml = function toJsonHtml(obj) {
        var s = JSON.stringify(obj, null, 2);
        s = s.replace(/\n/g, '<br>');
        s = s.replace(/ /g, '&nbsp');
        return s;
      };

      var wnd = window.open('about:blank', '', '_blank'); // this.slides.forEach((slide) => {
      //   wnd.document.write(JSON.stringify(slide), '<br>');
      // });

      wnd.document.write('<br><br>');
      wnd.document.write("// ".concat('/'.repeat(500), "<br>"));
      wnd.document.write("// ".concat('/'.repeat(500), "<br>"));
      wnd.document.write('<br><br>'); // Object.keys(this.events).forEach((eventName) => {
      //   const event = this.events[eventName];
      //   // const rounded = event.map((e) => {
      //   //   if (typeof e === 'number') {
      //   //     return round(e, this.precision);
      //   //   }
      //   //   return e;
      //   // });
      //   wnd.document.write('<br><br>');
      //   wnd.document.write(`${eventName}`);
      //   wnd.document.write(JSON.stringify(event, null, 2), '<br>');
      // });

      wnd.document.write(toJsonHtml(this.events), '<br>');
      wnd.document.write('<br><br>');
      wnd.document.write("// ".concat('/'.repeat(500), "<br>"));
      wnd.document.write("// ".concat('/'.repeat(500), "<br>"));
      wnd.document.write('<br><br>');
      wnd.document.write(toJsonHtml(this.states.diffs), '<br>');
      wnd.document.write(toJsonHtml(this.states.references), '<br>'); // this.states.diffs.forEach((state) => {
      //   wnd.document.write(JSON.stringify(state, null, 2), '<br>');
      // });
    } // ////////////////////////////////////
    // ////////////////////////////////////
    // Seeking
    // ////////////////////////////////////
    // ////////////////////////////////////

  }, {
    key: "seekToPercent",
    value: function seekToPercent(percentTime) {
      var duration = this.calcDuration();
      this.seek(duration * percentTime);
    }
  }, {
    key: "seek",
    value: function seek(timeIn) {
      // console.log('called seek', timeIn)
      this.pauseState = null;
      var time = timeIn;

      if (time < 0) {
        time = 0;
      }

      if (this.states.diffs.length === 0) {
        return;
      }

      if (this.state === 'recording') {
        this.stopRecording();
      } else if (this.state === 'playing') {
        this.pausePlayback('freeze');
      } // console.log(time)


      this.setToTime(time); // this.figure.pause({
      //   animation: 'freeze',
      //   pulse: 'freeze',
      //   movingFreely: 'freeze',
      // });

      this.figure.stop('freeze'); // console.log('last seek time', this.lastSeekTime)
    }
  }, {
    key: "setToTime",
    value: function setToTime(timeIn) {
      var _this9 = this;

      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (timeIn === 0 && this.states.diffs.length > 0) {
        this.stateIndex = 0;
      } else {
        // $FlowFixMe
        this.stateIndex = getPrevIndexForTime(this.states.diffs, timeIn);
      } // console.log(this.stateIndex)


      var stateTime = 0;
      var stateTimeCount = 0;

      if (this.stateIndex !== -1) {
        var _this$states$diffs$th = _slicedToArray(this.states.diffs[this.stateIndex], 4);

        stateTime = _this$states$diffs$th[0];
        stateTimeCount = _this$states$diffs$th[3];
      }

      if (stateTime === this.lastSeekTime && !force) {
        // console.log('setting to time - no change');
        return;
      }

      var time = stateTime;
      this.lastSeekTime = stateTime; // console.log('setting to time', timeIn, stateTime);
      // For each eventName, if it is to be set on seek, then get the previous
      // index (or multiple indexes if multiple are set for the same time)
      // and add them to an eventsToExecuteArray

      var eventsToSetBeforeState = [];
      var eventsToSetAfterState = [];
      Object.keys(this.events).forEach(function (eventName) {
        var event = _this9.events[eventName];

        if (event.setOnSeek === false) {
          return;
        }

        var firstIndex = getPrevIndexForTime(event.list, time);

        if (firstIndex === -1) {
          return;
        }

        var lastIndex = getIndexOfLatestTime(event.list, getPrevIndexForTime(event.list, timeIn)); // const lastIndex = getIndexOfLatestTime(event.list, firstIndex);

        for (var i = firstIndex; i <= lastIndex; i += 1) {
          var _event$list$i = _slicedToArray(event.list[i], 3),
              eventTime = _event$list$i[0],
              timeCount = _event$list$i[2];

          if (_this9.stateIndex === -1 || eventTime < stateTime || eventTime === stateTime && timeCount < stateTimeCount) {
            eventsToSetBeforeState.push([eventName, i, eventTime, timeCount]);
          } else if (eventTime > stateTime || eventTime === stateTime && timeCount > stateTimeCount) {
            eventsToSetAfterState.push([eventName, i, eventTime, timeCount]);
          }
        }
      });

      var sortTimes = function sortTimes(arrayToSort) {
        return arrayToSort.sort(function (a, b) {
          if (a[2] < b[2] || a[2] === b[2] && a[3] < b[3]) {
            return -1;
          }

          if (a[2] > b[2] || a[2] === b[2] && a[3] > b[3]) {
            return 1;
          }

          return 0;
        });
      }; // console.log(eventsToSetBeforeState);
      // Sort the eventsToSet arrays in time


      sortTimes(eventsToSetBeforeState);
      sortTimes(eventsToSetAfterState);

      var playEvents = function playEvents(events) {
        events.forEach(function (event) {
          var _event = _slicedToArray(event, 2),
              eventName = _event[0],
              index = _event[1]; // if (eventName === 'slide') {
          //   debugger;
          // }


          _this9.setEvent(eventName, index);
        });
      }; // console.log('before')


      playEvents(eventsToSetBeforeState); // console.log('state')
      // console.log(this.stateIndex)

      if (this.stateIndex !== -1) {
        this.setState(this.stateIndex);
      } // console.log('after')


      playEvents(eventsToSetAfterState); // console.log('done')

      if (this.audio) {
        this.audio.currentTime = time;
      }

      this.setCurrentTime(time); // this.currentTime = time;

      this.setCursor(time);
      this.figure.animateNextFrame(); // console.log(this.figure.getElement('a').getRotation())
    }
  }, {
    key: "setCursor",
    value: function setCursor(time) {
      var cursorState = this.getCursorState(time);

      if (cursorState == null) {
        return;
      }

      var show = cursorState.show,
          up = cursorState.up,
          position = cursorState.position;

      if (show && up) {
        this.figure.showCursor('up', position);
      } else if (show && up === false) {
        this.figure.showCursor('down', position);
      } else {
        this.figure.showCursor('hide');
      }
    }
  }, {
    key: "getCursorState",
    value: function getCursorState(atTime) {
      if (this.events.touch == null || this.events.cursor == null || this.events.cursorMove == null) {
        return null;
      }

      var cursorIndex = getPrevIndexForTime(this.events.cursor.list, atTime);
      var touchIndex = getPrevIndexForTime(this.events.touch.list, atTime);
      var cursorMoveIndex = getPrevIndexForTime(this.events.cursorMove.list, atTime);
      var touchUp = null;
      var showCursor = null;
      var cursorPosition = null;
      var cursorTime = null;
      var cursorTimeCount = null;

      if (touchIndex !== -1) {
        var event = this.events.touch.list[touchIndex]; // $FlowFixMe

        var _event2 = _slicedToArray(event, 3),
            time = _event2[0],
            _event2$ = _slicedToArray(_event2[1], 3),
            upOrDown = _event2$[0],
            x = _event2$[1],
            y = _event2$[2],
            timeCount = _event2[2];

        if (upOrDown === 'down') {
          touchUp = false;
          cursorTime = time;
          cursorTimeCount = timeCount; // $FlowFixMe

          cursorPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x, y);
        } else {
          touchUp = true;
        }
      }

      if (cursorIndex !== -1) {
        var _event3 = this.events.cursor.list[cursorIndex]; // $FlowFixMe

        var _event4 = _slicedToArray(_event3, 3),
            _time = _event4[0],
            _event4$ = _slicedToArray(_event4[1], 3),
            showOrHide = _event4$[0],
            _x = _event4$[1],
            _y = _event4$[2],
            _timeCount = _event4[2];

        if (showOrHide === 'show') {
          showCursor = true;

          if (cursorTime == null || _time > cursorTime // $FlowFixMe
          || _time === cursorTime && _timeCount > cursorTimeCount) {
            cursorTime = _time;
            cursorTimeCount = _timeCount; // $FlowFixMe

            cursorPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_x, _y);
          }
        } else {
          showCursor = false;
        }
      }

      if (cursorMoveIndex !== -1) {
        var _event5 = this.events.cursorMove.list[cursorMoveIndex]; // $FlowFixMe

        var _event6 = _slicedToArray(_event5, 3),
            _time2 = _event6[0],
            _event6$ = _slicedToArray(_event6[1], 2),
            _x2 = _event6$[0],
            _y2 = _event6$[1],
            _timeCount2 = _event6[2];

        if (cursorTime == null || _time2 > cursorTime // $FlowFixMe
        || _time2 === cursorTime && _timeCount2 > cursorTimeCount) {
          // $FlowFixMe
          cursorPosition = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](_x2, _y2);
        }
      }

      return {
        show: showCursor == null ? false : showCursor,
        up: touchUp == null ? true : touchUp,
        position: cursorPosition == null ? new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0) : cursorPosition
      };
    } // ////////////////////////////////////
    // ////////////////////////////////////
    // Playback
    // ////////////////////////////////////
    // ////////////////////////////////////

  }, {
    key: "startPlayback",
    value: function startPlayback() {
      var _this10 = this;

      var fromTimeIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.lastSeekTime || 0;
      var forceStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var fromTime = fromTimeIn;

      if (fromTimeIn == null || fromTimeIn >= this.duration) {
        fromTime = 0;
      }

      if (events == null) {
        this.eventsToPlay = Object.keys(this.events);
      } else {
        this.eventsToPlay = events;
      } // this.figure.unpause();
      // this.setVideoToNowDeltaTime(this.currentTime);


      var stateToStartFrom = this.getStateForTime(fromTime);

      if (!forceStart && this.pauseState != null) {
        stateToStartFrom = this.pauseState;
      }

      var finished = function finished() {
        if (_this10.pauseState == null) {
          _this10.setToTime(fromTime, true);
        } else {
          // this.figure.setState(this.pauseState, 'instant');
          _this10.pauseState = null;
        }

        _this10.state = 'playing';

        _this10.setVideoToNowDeltaTime(fromTime); // this.currentTime = fromTime;


        _this10.setCurrentTime(fromTime);

        _this10.startTimeUpdates();

        _this10.startEventsPlayback(fromTime);

        _this10.startAudioPlayback(fromTime);

        _this10.figure.animateNextFrame();

        if (_this10.areEventsPlaying() === false && _this10.isAudioPlaying === false) {
          _this10.finishPlaying();
        }

        _this10.subscriptions.publish('playbackStarted');
      }; // console.log(this.settings.play)


      this.figure.setState(stateToStartFrom, this.settings.play);

      if (this.figure.state.preparingToSetState) {
        this.state = 'preparingToPlay';
        this.subscriptions.publish('preparingToPlay');
        this.figure.subscriptions.add('stateSet', finished, 1); // console.log(this.figure.subscriptions.subscriptions.stateSet)
      } else {
        finished();
      }
    }
  }, {
    key: "getPlaySettings",
    value: function getPlaySettings() {
      var onResume = {
        how: 'instant',
        maxDuration: 6,
        velocity: {
          position: 2,
          rotation: Math.PI * 2 / 2,
          scale: 1,
          opacity: 0.8,
          color: 0.8
        },
        allDurationsSame: true,
        zeroDurationThreshold: 0.00001,
        // minDuration: 0,
        duration: 0
      }; // console.log(resumeSettings)

      if (typeof this.settings.play === 'string') {
        onResume.how = this.settings.play;
      } else {
        onResume = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, onResume, this.settings.play); // velocity trumps duration by default, but if only duration is defined by the
        // user, then remove velocity;
        // if (this.settings.resume.duration != null && this.settings.resume.velocity == null) {
        //   onResume.velocity = undefined;
        // }
      }

      if (onResume.how === 'dissolve') {
        var defaultDuration = {
          dissolveIn: 0.8,
          dissolveOut: 0.8,
          delay: 0.2
        };

        if (onResume.duration === 0) {
          onResume.duration = defaultDuration;
        } else if (typeof onResume.duration === 'number') {
          onResume.duration = {
            dissolveOut: onResume.duration / 10 * 4.5,
            dissolveIn: onResume.duration / 10 * 4.5,
            delay: onResume.duration / 10 * 1
          };
        } else {
          onResume.duration = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_2__["joinObjects"])({}, defaultDuration, onResume.duration);
        }
      } else if (onResume.duration != null && typeof onResume.duration !== 'number') {
        onResume.duration = 1;
      }

      return onResume;
    }
  }, {
    key: "resumePlayback",
    value: function resumePlayback() {
      this.startPlayback(this.currentTime, false);
    } // resumePlayback(delta: number = 0) {
    //   if (delta > 0) {
    //     this.pauseState = null;
    //   }
    //   const resumeTime = Math.min(
    //     Math.max(this.currentTime + delta, 0),
    //     this.duration,
    //   );
    //   this.startPlayback(resumeTime, false);
    // }

  }, {
    key: "startAudioPlayback",
    value: function startAudioPlayback(fromTime) {
      var _this11 = this;

      if (this.audio) {
        this.isAudioPlaying = true;
        this.audio.currentTime = fromTime;
        this.audio.play();

        var audioEnded = function audioEnded() {
          _this11.isAudioPlaying = false;

          if (_this11.state === 'playing') {
            _this11.finishPlaying();
          }
        };

        var audio = this.audio;

        if (audio != null) {
          audio.removeEventListener('ended', audioEnded.bind(this), false);
          audio.addEventListener('ended', audioEnded.bind(this), false);
        }
      }
    }
  }, {
    key: "startTimeUpdates",
    value: function startTimeUpdates() {
      var _this12 = this;

      this.timeUpdatesTimeoutID = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_3__["default"]().setTimeout(function () {
        _this12.setCurrentTime(_this12.getCurrentTime());

        _this12.subscriptions.publish('timeUpdate', [_this12.getCurrentTime()]);

        _this12.startTimeUpdates();
      }, 100);
    }
  }, {
    key: "startEventsPlayback",
    value: function startEventsPlayback(fromTime) {
      var _this13 = this;

      this.eventsToPlay.forEach(function (eventName) {
        if (_this13.events[eventName].list.length === 0) {
          return;
        }

        var event = _this13.events[eventName];
        var index = getNextIndexForTime(event.list, fromTime);

        if (index === -1) {
          _this13.eventIndex[eventName] = -1;
          return;
        }

        var _event$list$index = _slicedToArray(event.list[index], 1),
            eventTime = _event$list$index[0];

        if (eventTime === fromTime) {
          index = getIndexOfLatestTime(event.list, index) + 1;
        }

        if (index > event.list.length - 1) {
          _this13.eventIndex[eventName] = -1;
        } else {
          _this13.eventIndex[eventName] = index;
        }
      });
      var nextEventName = this.getNextEvent();

      if (this.events[nextEventName] != null) {
        this.playbackEvent(nextEventName);
      }
    }
  }, {
    key: "getNextEvent",
    value: function getNextEvent() {
      var _this14 = this;

      var nextEventName = '';
      var nextTime = null;
      var nextTimeCount = null;
      this.eventsToPlay.forEach(function (eventName) {
        if (_this14.eventIndex[eventName] == null || _this14.eventIndex[eventName] === -1 || _this14.events[eventName].list.length <= _this14.eventIndex[eventName]) {
          return;
        }

        var _this14$events$eventN = _slicedToArray(_this14.events[eventName].list[_this14.eventIndex[eventName]], 3),
            time = _this14$events$eventN[0],
            timeCount = _this14$events$eventN[2];

        if (nextTime == null || time < nextTime // $FlowFixMe
        || time === nextTime && timeCount < nextTimeCount) {
          nextTime = time;
          nextTimeCount = timeCount;
          nextEventName = eventName;
        }
      });
      return nextEventName;
    }
  }, {
    key: "playbackEvent",
    value: function playbackEvent(eventName) {
      var index = this.eventIndex[eventName];
      var delay = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(this.events[eventName].list[index][0] - this.getCurrentTime(), 8);

      if (delay > 0.0001) {
        this.timeoutID = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_3__["default"]().setTimeout(this.playbackEvent.bind(this, eventName), Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(delay * 1000, 0));
        return;
      } // const index = this.eventIndex[eventName];


      this.setEvent(eventName, index);
      this.figure.animateNextFrame();

      if (index + 1 === this.events[eventName].list.length) {
        this.eventIndex[eventName] = -1;

        if (this.areEventsPlaying() === false && this.isAudioPlaying === false) {
          this.finishPlaying();
          return;
        }
      } else {
        this.eventIndex[eventName] = index + 1;
      }

      var nextEvent = this.getNextEvent();

      if (nextEvent != null && this.events[nextEvent]) {
        this.playbackEvent(nextEvent);
      }
    }
  }, {
    key: "areEventsPlaying",
    value: function areEventsPlaying() {
      // const eventNames = Object.keys(this.eventIndex)
      for (var i = 0; i < this.eventsToPlay.length; i += 1) {
        var _eventName = this.eventsToPlay[i];

        if (this.eventIndex[_eventName] < this.events[_eventName].list.length && this.eventIndex[_eventName] > -1) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "finishPlaying",
    value: function finishPlaying() {
      var _this15 = this;

      if (this.areEventsPlaying()) {
        return false;
      }

      var remainingTime = this.duration - this.getCurrentTime();

      if (remainingTime > 0.0001) {
        this.timeoutID = new _webgl_GlobalAnimation__WEBPACK_IMPORTED_MODULE_3__["default"]().setTimeout(function () {
          _this15.finishPlaying();
        }, Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["round"])(remainingTime * 1000, 0));
        return false;
      }

      if (this.isAudioPlaying) {
        return false;
      } // this.pausePlayback('cancel');
      // this.currentTime = this.getCurrentTime();


      this.setCurrentTime(this.getCurrentTime()); // console.log(this.currentTime)

      this.stop();
      return true;
    } // clearPlaybackTimeouts() {
    //   this.timeoutID = null;
    // }
    // animateToState() {
    // }

  }, {
    key: "stop",
    value: function stop() {
      this.stopTimeouts();

      if (this.audio) {
        this.audio.pause();
        this.isAudioPlaying = false;
      }

      this.state = 'idle';
      this.subscriptions.publish('playbackStopped');
    } // On pause, animations and pauses can complete and clear:
    // Complete  Clear
    // True      True     Animations finish and nextFrame nothing will happen
    // True      False    Animations finish and nextFrame nothing will happen
    //                    as by completing animations they will naturally clear
    // False     True     Animations freeze and nextFrame nothing will happen
    // False     False    Animations freeze and nextFrame will continue
    //
    // Pulse
    // True      True     Pulse finish and nextFrame nothing will happen
    // True      False    Pulse finish and nextFrame nothing will happen
    //                    as by completing animations they will naturally clear
    // False     True     Pulse freeze and nextFrame nothing will happen
    // False     False    Pulse freeze and nextFrame will continue

  }, {
    key: "pausePlayback",
    value: function pausePlayback() {
      var _this16 = this;

      var how = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.settings.pause;
      // this.currentTime = this.getCurrentTime();
      this.setCurrentTime(this.getCurrentTime());
      this.pauseState = this.figure.getState({
        precision: this.precision,
        ignoreShown: true
      });

      var pause = function pause() {
        _this16.state = 'idle';

        _this16.subscriptions.publish('playbackStopped'); // this.figure.stop();

      };

      this.stopTimeouts();

      if (this.audio) {
        this.audio.pause();
        this.isAudioPlaying = false;
      }

      this.figure.subscriptions.add('stopped', pause, 1);
      this.figure.stop(how);

      if (this.figure.state.preparingToStop) {
        this.subscriptions.publish('preparingToPause');
        this.state = 'preparingToPause'; // console.log('recorder prep to pause')
        // this.figure.subscriptions.add('animationsFinished', pause, 1);
      } // if (this.figure.isAnimating()) {
      //   this.subscriptions.publish('preparingToPause');
      //   this.state = 'preparingToPause';
      //   // console.log('recorder prep to pause')
      //   this.figure.subscriptions.add('animationsFinished', pause, 1);
      // } else {
      //   pause();
      // }

    }
  }, {
    key: "setEvent",
    value: function setEvent(eventName, index) {
      var event = this.events[eventName];

      if (event == null) {
        return;
      } // $FlowFixMe


      event.playbackAction(event.list[index][1], event.list[index][0]);
    } // queuePlaybackState(delay: number = 0) {
    //   const incrementIndexAndPlayState = () => {
    //     if (this.state === 'playing') {
    //       this.stateIndex += 1;
    //       this.playbackState();
    //     }
    //   }
    //   if (delay === 0) {
    //     incrementIndexAndPlayState();
    //     return;
    //   }
    //   this.nextStateTimeout = setTimeout(incrementIndexAndPlayState, delay);
    // }
    // playbackState() {
    //   if (this.stateIndex > this.states.diffs.length - 1) {
    //     this.finishPlaying();
    //     return;
    //   }
    //   this.setState(this.stateIndex);
    //   this.figure.animateNextFrame();
    //   if (this.stateIndex + 1 === this.states.diffs.length) {
    //     this.finishPlaying();
    //     return;
    //   }
    //   const nextTime = (this.states.diffs[this.stateIndex + 1][0] - this.getCurrentTime()) * 1000;
    //   this.queuePlaybackState(nextTime);
    // }

  }, {
    key: "setState",
    value: function setState(index) {
      if (index > this.states.diffs.length - 1) {
        return;
      }

      var state = this.states.getFromIndex(index);
      this.figure.setState(state);
    }
  }, {
    key: "getState",
    value: function getState(index) {
      if (index > this.states.diffs.length - 1) {
        return {};
      }

      return this.states.getFromIndex(index);
    }
  }, {
    key: "getStateForTime",
    value: function getStateForTime(timeIn) {
      var stateIndex;

      if (timeIn === 0 && this.states.diffs.length > 0) {
        stateIndex = 0;
      } else {
        // $FlowFixMe
        stateIndex = getPrevIndexForTime(this.states.diffs, timeIn);
      }

      return this.getState(stateIndex);
    }
  }]);

  return Recorder;
}();



/***/ }),

/***/ "./src/js/figure/Recorder/parseState.js":
/*!**********************************************!*\
  !*** ./src/js/figure/Recorder/parseState.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Animation/Animation */ "./src/js/figure/Animation/Animation.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");



function assignAsLinkOnly(obj) {
  if (obj != null) {
    // eslint-disable-next-line no-param-reassign
    obj._assignAsLinkOnly = true;
  }

  return obj;
}

function parseState(state, figure) {
  if (typeof state === 'number') {
    return state;
  }

  if (typeof state === 'string') {
    return state;
  }

  if (typeof state === 'boolean') {
    return state;
  }

  if (state == null) {
    return state;
  }

  if (Array.isArray(state)) {
    var _out = [];
    state.forEach(function (stateElement) {
      _out.push(parseState(stateElement, figure));
    });
    return _out;
  }

  if (state.f1Type != null) {
    if (state.f1Type === 'rect') {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getRect"])(state);
    }

    if (state.f1Type === 'p') {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getPoint"])(state);
    }

    if (state.f1Type === 'tf') {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getTransform"])(state);
    }

    if (state.f1Type === 't') {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Translation"](state);
    }

    if (state.f1Type === 's') {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Scale"](state);
    }

    if (state.f1Type === 'r') {
      return new _tools_g2__WEBPACK_IMPORTED_MODULE_1__["Rotation"](state);
    }

    if (state.f1Type === 'l') {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getLine"])(state);
    }

    if (state.f1Type === 'rangeBounds') {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBounds"])(state);
    }

    if (state.f1Type === 'rectBounds') {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBounds"])(state);
    }

    if (state.f1Type === 'lineBounds') {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBounds"])(state);
    }

    if (state.f1Type === 'transformBounds') {
      return Object(_tools_g2__WEBPACK_IMPORTED_MODULE_1__["getBounds"])(state);
    }

    if (state.f1Type === 'de') {
      return assignAsLinkOnly(figure.getElement(state.state));
    }

    if (state.f1Type === 'positionAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["PositionAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'rotationAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["RotationAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'scaleAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["ScaleAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'transformAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["TransformAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'scenarioAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["ScenarioAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'colorAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["ColorAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'opacityAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["OpacityAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'pulseAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["PulseAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'customAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["CustomAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'delayAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["DelayAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'parallelAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["ParallelAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'serialAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["SerialAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'triggerAnimationStep') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["TriggerAnimationStep"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }

    if (state.f1Type === 'animationBuilder') {
      return new _Animation_Animation__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]()._fromState(parseState(state.state, figure), figure.getElement.bind(figure));
    }
  }

  var out = {};
  Object.keys(state).forEach(function (property) {
    // console.log('prop', state, property)
    // if (property === 'element') {
    //   console.log(state[property].name)
    // }
    // console.log(property)
    out[property] = parseState(state[property], figure);
  });
  return out;
}

/* harmony default export */ __webpack_exports__["default"] = (parseState);

/***/ }),

/***/ "./src/js/figure/Recorder/recorder.worker.js":
/*!***************************************************!*\
  !*** ./src/js/figure/Recorder/recorder.worker.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function() {
  return new Worker("/static/workers/" + "d938525d8a3791514061.worker.js");
};

/***/ }),

/***/ "./src/js/figure/Recorder/state.js":
/*!*****************************************!*\
  !*** ./src/js/figure/Recorder/state.js ***!
  \*****************************************/
/*! exports provided: setState, getState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setState", function() { return setState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getState", function() { return getState; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// import {
//   PositionAnimationStep, AnimationBuilder,
// } from './Animation/Animation';
// import type Figure from './Figure';
// import {
//   getPoint, getTransform, getRect, getLine, Translation, Rotation, Scale,
// } from '../tools/g2';
// import parseState from './parseState';
 // import parseState from './parseState';

function getState(obj, stateProperties, optionsIn) // precision: number = 5,
// payload: any,
{
  // const stateProperties = this._getStateProperties();
  // const path = this.getPath();
  var defaultOptions = {
    precision: 5,
    ignoreShown: false,
    min: false
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])({}, defaultOptions, optionsIn);
  var precision = options.precision;
  var state = {};

  var processValue = function processValue(value) {
    if (typeof value === 'string') {
      return value;
    }

    if (typeof value === 'number') {
      return value;
    }

    if (typeof value === 'boolean') {
      return value;
    }

    if (value == null) {
      return value;
    }

    if (value._def != null) {
      return value._def(precision);
    }

    if (value._state != null) {
      return value._state(options);
    }

    if (Array.isArray(value)) {
      var dupArray = [];
      value.forEach(function (v) {
        // console.log('array v', v);
        dupArray.push(processValue(v));
      });
      return dupArray;
    } // if (value._getState != null) {
    //   console.log('v', value)
    //   return value._getState();
    // }


    if (value._dup != null) {
      return value._dup();
    }

    var out = {};
    var keys = Object.keys(value);

    if (value._stateKeys) {
      keys = value._stateKeys();
    }

    var keysToUse = keys;

    if (value._excludeStateKeys) {
      keysToUse = [];

      var excludedKeys = value._excludeStateKeys();

      keys.forEach(function (key) {
        if (excludedKeys.indexOf(key) === -1) {
          keysToUse.push(key);
        }
      });
    }

    keysToUse.forEach(function (key) {
      out[key] = processValue(value[key]);
    });
    return out; // return joinObjects({}, value);
  }; // console.log(stateProperties)


  stateProperties.forEach(function (prop) {
    var processPath = function processPath(currentState, currentObj, remainingPath) {
      var _remainingPath = _slicedToArray(remainingPath, 1),
          nextLevel = _remainingPath[0];

      if (remainingPath.length === 1) {
        return [currentState, currentObj, remainingPath[0]];
      }

      if (currentState[nextLevel] == null) {
        currentState[nextLevel] = {}; // eslint-disable-line no-param-reassign
      }

      if (currentObj[nextLevel] == null) {
        return null;
      }

      return processPath(currentState[nextLevel], currentObj[nextLevel], remainingPath.slice(1));
    };

    var result = processPath(state, obj, prop.split('.'));

    if (result == null) {
      return;
    }

    var _result = _slicedToArray(result, 3),
        statePath = _result[0],
        objPath = _result[1],
        remainingProp = _result[2];

    statePath[remainingProp] = processValue(objPath[remainingProp]);
  });
  return state;
} // function parseState(state: Object, figure: Figure) {
//   if (typeof state === 'number') {
//     return state;
//   }
//   if (typeof state === 'string') {
//     return state;
//   }
//   if (typeof state === 'boolean') {
//     return state;
//   }
//   if (state == null) {
//     return state;
//   }
//   if (Array.isArray(state)) {
//     const out = [];
//     state.forEach((stateElement) => {
//       out.push(parseState(stateElement, figure));
//     });
//     return out;
//   }
//   if (state.f1Type != null) {
//     if (state.f1Type === 'rect') {
//       return getRect(state);
//     }
//     if (state.f1Type === 'p') {
//       return getPoint(state);
//     }
//     if (state.f1Type === 'tf') {
//       return getTransform(state);
//     }
//     if (state.f1Type === 't') {
//       return new Translation(state);
//     }
//     if (state.f1Type === 's') {
//       return new Scale(state);
//     }
//     if (state.f1Type === 'r') {
//       return new Rotation(state);
//     }
//     if (state.f1Type === 'l') {
//       return getLine(state);
//     }
//     if (state.f1Type === 'de') {
//       return figure.getElement(state.state);
//     }
//     if (state.f1Type === 'positionAnimationStep') {
//       return new PositionAnimationStep()._fromState(
//         parseState(state.state, figure),
//         figure.getElement.bind(figure),
//       );
//     }
//     if (state.f1Type === 'animationBuilder') {
//       return new AnimationBuilder()._fromState(
//         parseState(state.state, figure),
//         figure.getElement.bind(figure),
//       );
//     }
//   }
//   const out = {};
//   Object.keys(state).forEach((property) => {
//     out[property] = parseState(state[property], figure);
//   });
//   return out;
// }
// function assignStateToObject(
//   state: Object,
//   obj: Object,
//   exceptIn: Array<string> | string = [],
//   parentPath: string = '',
//   figure: Figure,
// ) {
//   const except = typeof exceptIn === 'string' ? [exceptIn] : exceptIn;
//   Object.keys(state).forEach((key) => {
//     const keyPath = parentPath !== '' ? `${parentPath}.${key}` : key;
//     if (except.indexOf(keyPath) !== -1) {
//       return;
//     }
//     const value = state[key];
//     if (typeof value === 'number'
//       || typeof value === 'boolean'
//       || typeof value === 'string'
//       || value == null
//       || typeof value === 'function'
//       || Array.isArray(value)
//     ) {
//       // Only assign the value if:
//       //    * Value is not undefined OR
//       //    * Value is undefined and toObject[key] is undefined
//       if (value !== undefined || obj[key] === undefined) {
//         obj[key] = value;
//       }
//       return;
//     }
//     if (value.f1Type != null) {
//       obj[key] = parseState(value, figure);
//       return;
//     }
//     // If the fromObject[key] value is an object, but the toObject[key] value
//     // is not an object, but then make toObject[key] an empty object
//     const toValue = obj[key];
//     if (typeof toValue === 'number'
//       || typeof toValue === 'boolean'
//       || typeof toValue === 'string'
//       || toValue == null
//       || typeof toValue === 'function'
//       || Array.isArray(toValue)
//     ) {
//       // eslint-disable-next-line no-param-reassign
//       obj[key] = {};
//     }
//     assignStateToObject(value, obj[key], except, keyPath, figure);
//   });
// }


function setState(obj, stateIn) {
  Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])(obj, stateIn); // assignStateToObject(stateIn, obj, [], '', figure);
  // const state = getDef(stateIn);
  // Object.keys(state).forEach((prop) => {
  //   const value = state[prop];
  //   if (
  //     typeof value === 'string'
  //     || typeof value === 'number'
  //     || typeof value === 'boolean'
  //     || value === null) {
  //   ) {
  //     obj[prop] = value;
  //   }
  //   if (Array.isArray(value) && Array.isArray) {
  //     for (let i = 0; i < value.length; i += 1)
  //   }
  //   if (obj[prop] != null && obj[prop]._setState != null) {
  //     obj[prop]._setState(getDef(state[prop]));
  //   } else {
  //     setState(obj[prop], def())
  //   }
  // });
} // function setState(obj: Object, state: Object) {
//   const processValue = (value) => {
//     if (
//       typeof value === 'number'
//       || typeof value === 'string'
//       || typeof value === 'boolean'
//       || value == null
//     ) {
//       return value;
//     }
//     if (Array.isArray(value)) {
//       const out = [];
//       value.forEach((v) => {
//         out.push(processValue);
//       });
//       return out;
//     }
//     if (value._setState)
//   };
//   Object.keys(state).forEach((prop) => {
//     const value = state[prop];
//     if (
//       typeof value === 'number'
//       || typeof value === 'string'
//       || typeof value === 'boolean'
//       || value == null
//     ) {
//       obj[prop] = value; // eslint-disable-line no-param-reassign
//       return;
//     }
//     if (Array.isArray(value)) {
//       for (let i = 0; i < obj[prop].length; i += 1) {
//         // eslint-disable-next-line no-param-reassign
//         obj[prop][i] = setState(obj[prop][i], value);
//       }
//       return;
//     }
//     if (obj[prop]._setState != null) {
//       obj[prop]._setState(value);
//       return;
//     }
//     obj[prop] = setState(obj[prop], value); // eslint-disable-line no-param-reassign
//   });
// }




/***/ }),

/***/ "./src/js/figure/SlideNavigator.js":
/*!*****************************************!*\
  !*** ./src/js/figure/SlideNavigator.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SlideNavigator; });
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _Element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Element */ "./src/js/figure/Element.js");
/* harmony import */ var _Equation_Equation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Equation/Equation */ "./src/js/figure/Equation/Equation.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



 // enterStateCommon
// enterState
// showCommon
// show
// transition
// showForm
// steadyStateCommon
// steadyState
// leaveStateCommon
// leaveState

/**
 * Last slide shown
 *
 * `'next'` | `'prev'` | number
 */

/**
 * Slide Navigator
 *
 * It is sometimes useful to break down a visualization into easier to consume
 * parts.
 *
 * For example, a complex figure or concept can be made easier if built up
 * from a simple begining. Each step along the way might change the elements
 * within the figure, or the form of an equation, and be accompanied by a
 * corresponding description giving context, reasoning or next steps.
 *
 * An analogy to this is a story or presentation, where each step along the way
 * is a presentation slide.
 *
 * This class is a simple slide navigator, providing a convenient way to define
 * slides and step through them.
 *
 * {@link CollectionsSlideNavigator} creates the navigation buttons, and
 * `textElement` automatically, and will usually be more convenient than
 * manually creating thema (unless custom buttons are needed).
 *
 * @see {@link CollectionsSlideNavigator} for examples.
 */
var SlideNavigator = /*#__PURE__*/function () {
  /**
   * @param {OBJ_SlideNavigator | null} options use `null` to load options later
   * with the `load` method. Options should only be loaded when an instantiated
   * {@link FigureElementCollection} is available for the `collections`
   * property.
   */
  function SlideNavigator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, SlideNavigator);

    if (options != null) {
      this.load(options);
    }
  }
  /**
   * Load options after object instantiation. Usefull for if the
   * `collection`, `prevButton`, `nextButton`, `equation` and/or `text` figure
   * elements are not available at instantiation.
   *
   * @param {OBJ_SlideNavigator} options
   */


  _createClass(SlideNavigator, [{
    key: "load",
    value: function load(options) {
      var _this = this;

      var o = options;

      if (o.collection instanceof _Element__WEBPACK_IMPORTED_MODULE_1__["FigureElementCollection"]) {
        this.collection = o.collection;
      } else if (o.collection != null && o.collection.elements != null) {
        this.collection = o.collection.elements;
      }

      if (o.slides != null) {
        this.slides = o.slides;
      }

      if (typeof o.text === 'string') {
        this.textElement = this.collection.getElement(o.text);
      } else if (o.text != null) {
        this.textElement = o.text;
      } else {
        this.textElement = null;
      }

      var equations = [];

      if (Array.isArray(o.equation)) {
        equations = o.equation;
      } else if (o.equation != null) {
        equations = [o.equation];
      }

      this.setEquations(equations);
      this.equationDefaults = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])({}, {
        duration: 1,
        animate: 'move'
      }, o.equationDefaults || {});

      if (o.prevButton) {
        this.prevButton = this.collection.getElement(o.prevButton);
      }

      if (o.nextButton) {
        this.nextButton = this.collection.getElement(o.nextButton);
      }

      this.currentSlideIndex = 0;
      this.inTransition = false;
      var prevButton = this.prevButton,
          nextButton = this.nextButton;

      if (prevButton != null) {
        prevButton.onClick = this.prevSlide.bind(this);
      }

      if (nextButton != null) {
        nextButton.onClick = this.nextSlide.bind(this, false);
      }

      if (this.slides == null && this.equations.length === 1) {
        var _this$equations = _slicedToArray(this.equations, 1),
            equation = _this$equations[0];

        if (equation instanceof _Equation_Equation__WEBPACK_IMPORTED_MODULE_2__["Equation"]) {
          var eqn = equation.eqn;

          if (eqn.currentFormSeries != null && eqn.currentFormSeries.length > 0) {
            this.slides = [];
            eqn.currentFormSeries.forEach(function (f) {
              return _this.slides.push({
                form: "".concat(f)
              });
            });
          }
        }
      }
    }
  }, {
    key: "setEquations",
    value: function setEquations(equationsIn) {
      var _this2 = this;

      var equations = [];
      equationsIn.forEach(function (e) {
        var element = _this2.collection.getElement(e);

        if (element != null) {
          equations.push(element);
        }
      });
      this.equations = equations;
    }
  }, {
    key: "getProperty",
    value: function getProperty(property, indexIn) {
      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var index = indexIn;
      var prop = this.slides[index][property];

      while (prop === undefined && index > 0) {
        index -= 1;
        prop = this.slides[index][property];
      }

      if (prop === undefined) {
        return defaultValue;
      }

      return prop;
    }
  }, {
    key: "getText",
    value: function getText(index) {
      return this.getProperty('text', index, '');
    }
  }, {
    key: "getForm",
    value: function getForm(index) {
      var forms = this.getProperty('form', index, null);

      if (forms === undefined) {
        return [];
      }

      if (!Array.isArray(forms)) {
        return [forms];
      }

      return forms;
    }
  }, {
    key: "getFromForm",
    value: function getFromForm(index) {
      var fromForm = this.slides[index].fromForm;

      if (fromForm === undefined) {
        return [];
      }

      if (Array.isArray(fromForm)) {
        return fromForm;
      }

      return [fromForm];
    }
  }, {
    key: "showForms",
    value: function showForms(forms) {
      var hideOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      for (var i = 0; i < this.equations.length; i += 1) {
        var e = this.collection.getElement(this.equations[i]);

        if (e != null) {
          if (forms.length > i && forms[i] != null) {
            if (!hideOnly) {
              // $FlowFixMe
              e.showForm(forms[i]);
            }
          } else {
            e.hide();
          }
        }
      }
    }
  }, {
    key: "setSteadyState",
    value: function setSteadyState(from) {
      var index = this.currentSlideIndex;
      var slide = this.slides[index];
      var form = this.getForm(index);
      this.showForms(form);
      this.getProperty('steadyStateCommon', index, function () {})(index, from);

      if (slide.steadyState != null) {
        slide.steadyState(index, from);
      }

      var prevButton = this.prevButton,
          nextButton = this.nextButton;

      if (prevButton != null) {
        if (this.currentSlideIndex === 0) {
          prevButton.setOpacity(0.7);
          prevButton.isTouchable = false;
        } else if (prevButton.isTouchable === false) {
          prevButton.setOpacity(1);
          prevButton.isTouchable = true;
        }
      }

      if (nextButton != null) {
        if (this.currentSlideIndex === this.slides.length - 1) {
          // $FlowFixMe
          nextButton.setLabel('Restart');
        } else {
          // $FlowFixMe
          nextButton.setLabel('Next');
        }
      }
    }
  }, {
    key: "transition",
    value: function transition(from) {
      var _this3 = this;

      var done = function done() {
        _this3.setSteadyState(from);

        _this3.inTransition = false;
      };

      if (from !== 'prev') {
        return done();
      }

      this.inTransition = true;
      var slide = this.slides[this.currentSlideIndex];

      if (typeof slide.transition === 'function') {
        return slide.transition(done, this.currentSlideIndex, from);
      }

      var forms = this.getForm(this.currentSlideIndex);
      var fromForms = this.getFromForm(this.currentSlideIndex);

      if (forms.length === 0 || fromForms.length === 0) {
        return done();
      }

      for (var i = 0; i < this.equations.length; i += 1) {
        var e = this.collection.getElement(this.equations[i]);

        if (e != null && e instanceof _Equation_Equation__WEBPACK_IMPORTED_MODULE_2__["Equation"] && forms.length > i && fromForms.length > i && forms[i] != null && fromForms[i] !== forms[i]) {
          var form = forms[i];
          var fromForm = fromForms[i];

          if (fromForm === null) {
            e.showForm(form);
            e.animations["new"]().dissolveIn(0.4) // .inParallel([
            //   e.animations.dissolveIn({ duration: 0.2 }),
            //   e.animations.trigger({
            //     callback: () => {
            //       e.showForm(form);
            //     },
            //   }),
            // ])
            .whenFinished(done).start();
            done = null;
          } else if (fromForm !== null) {
            var _this$equationDefault = this.equationDefaults,
                animate = _this$equationDefault.animate,
                duration = _this$equationDefault.duration;
            e.animations["new"]().goToForm({
              target: form,
              animate: animate,
              duration: duration
            }).whenFinished(done).start();
            done = null;
          }
        }
      }

      if (done != null) {
        return done();
      }

      return null;
    }
  }, {
    key: "setText",
    value: function setText(index) {
      var textElement = this.textElement;

      if (textElement == null) {
        return;
      }

      var mods = this.getProperty('modifiers', index, {});
      var commonMods = this.getProperty('modifiersCommon', index, {});
      var text = this.getText(index) || ' ';
      textElement.custom.updateText({
        text: text,
        modifiers: Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__["joinObjects"])({}, commonMods, mods)
      });
    }
  }, {
    key: "showElements",
    value: function showElements(index) {
      var showCommon = this.getProperty('showCommon', index, []);
      var show = this.slides[index].show || [];
      this.collection.show(showCommon);
      this.collection.show(show);

      if (show != null && Array.isArray(show)) {
        this.collection.show();
      }

      if (this.nextButton != null) {
        this.nextButton.showAll();
      }

      if (this.prevButton != null) {
        this.prevButton.showAll();
      }

      if (this.textElement != null) {
        this.textElement.showAll();
      }
    }
  }, {
    key: "hideElements",
    value: function hideElements(index) {
      var hideCommon = this.getProperty('hideCommon', index, []);
      var hide = this.slides[index].hide || [];
      this.collection.hide(hideCommon);
      this.collection.hide(hide);
    }
    /**
     * @param {number} index slide index to go to
     * @param {'next' | 'prev' | number} from this should generally not be used
     * and will be set automatically
     */

  }, {
    key: "goToSlide",
    value: function goToSlide(index, from) {
      if (this.slides == null || this.slides.length === 0) {
        return;
      }

      var fromToUse = from;

      if (fromToUse == null) {
        fromToUse = this.currentSlideIndex;

        if (index === this.currentSlideIndex + 1) {
          fromToUse = 'prev';
        } else if (index === this.currentSlideIndex - 1) {
          fromToUse = 'next';
        }
      } // Leave States


      this.getProperty('leaveStateCommon', this.currentSlideIndex, function () {})(this.currentSlideIndex, index);

      if (this.slides[this.currentSlideIndex].leaveState != null) {
        this.slides[this.currentSlideIndex].leaveState(this.currentSlideIndex, index);
      } // Reset and Set Text


      this.collection.stop('complete');
      var textElement = this.textElement;

      if (textElement != null) {
        this.setText(index);

        if (fromToUse === 'prev') {
          var oldText = this.getText(this.currentSlideIndex);
          var newText = this.getText(index);

          if (JSON.stringify(newText) !== JSON.stringify(oldText)) {
            textElement.animations["new"]().dissolveIn(0.2).start();
          }
        }
      } // Enter new slide


      this.currentSlideIndex = index;
      var slide = this.slides[index];
      this.collection.hideAll();
      this.showElements(index);
      this.hideElements(index);
      this.collection.setScenarios(this.getProperty('scenarioCommon', index, []));
      this.collection.setScenarios(slide.scenario || []);
      this.getProperty('enterStateCommon', index, function () {})(index, fromToUse);

      if (slide.enterState != null) {
        slide.enterState(index, fromToUse);
      }

      var fromForm = this.getFromForm(index);
      this.showForms(fromForm); // Move to transition

      this.transition(fromToUse);
    }
    /**
     * Progress to next slide.
     *
     * @param {boolean} ignoreTransition when `false`, if the slide is still in
     * a transition when nextSlide is called, then the transition will skip
     * through to the end, without moving to the next slide - effectively skipping
     * through to the steady state of the current slide. If `true`, then the
     * transition will instantly complete, setState and leaveStates called and the
     * next slide will be progressed to.
     */

  }, {
    key: "nextSlide",
    value: function nextSlide() {
      var ignoreTransition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.inTransition) {
        this.collection.stop('complete');

        if (!ignoreTransition) {
          return;
        }
      }

      var nextSlideIndex = (this.currentSlideIndex + 1) % this.slides.length;
      this.goToSlide(nextSlideIndex);
      this.collection.animateNextFrame();
    }
    /**
     * Progress to the previous slide.
     */

  }, {
    key: "prevSlide",
    value: function prevSlide() {
      this.collection.stop('complete');
      var prevSlideIndex = this.currentSlideIndex - 1;

      if (prevSlideIndex < 0) {
        prevSlideIndex = this.slides.length - 1;
      }

      this.goToSlide(prevSlideIndex);
      this.collection.animateNextFrame();
    }
  }]);

  return SlideNavigator;
}();



/***/ }),

/***/ "./src/js/figure/geometries/arrow.js":
/*!*******************************************!*\
  !*** ./src/js/figure/geometries/arrow.js ***!
  \*******************************************/
/*! exports provided: getTriangleArrow, getBarbArrow, getArrow, getArrowLength, simplifyArrowOptions, defaultArrowOptions, getArrowTris */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTriangleArrow", function() { return getTriangleArrow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBarbArrow", function() { return getBarbArrow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrow", function() { return getArrow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrowLength", function() { return getArrowLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "simplifyArrowOptions", function() { return simplifyArrowOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultArrowOptions", function() { return defaultArrowOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrowTris", function() { return getArrowTris; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _polygon_polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygon/polygon */ "./src/js/figure/geometries/polygon/polygon.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }





function orientArrow( // points: Array<Point>,
border, touchBorder, tail, length, joinLength, options) {
  var matrix; // console.log(options.drawPosition)

  if (options.align === 'start') {
    matrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(length, 0).rotate(options.angle).translate(options.drawPosition).matrix();
  } else if (options.align === 'tip') {
    matrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(options.angle).translate(options.drawPosition).matrix();
  } else if (options.align === 'mid') {
    matrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(length / 2, 0).rotate(options.angle).translate(options.drawPosition).matrix();
  } else {
    matrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(joinLength, 0).rotate(options.angle).translate(options.drawPosition).matrix();
  } // const line = new Line(start, end);
  // const matrix = new Transform().rotate(line.angle()).translate(start).matrix();
  // const newPoints: Array<Point> = points.map(p => p.transformBy(matrix));


  var newBorder = border.map(function (p) {
    return p.transformBy(matrix);
  });
  var newTouchBorder = touchBorder.map(function (p) {
    return p.transformBy(matrix);
  });
  var newTail = tail.map(function (p) {
    return p.transformBy(matrix);
  });
  return [// newPoints,
  newBorder, newTouchBorder, newTail // points.length,
  ];
}

function getTouchBorder(l, w, buffer) {
  return [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-l - buffer, -w / 2 - buffer), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](buffer, -w / 2 - buffer), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](buffer, w / 2 + buffer), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-l - buffer, w / 2 + buffer)];
}

function dup(pnts) {
  return pnts.map(function (p) {
    return p._dup();
  });
}
/*
.########.########..####....###....##....##..######...##.......########
....##....##.....##..##....##.##...###...##.##....##..##.......##......
....##....##.....##..##...##...##..####..##.##........##.......##......
....##....########...##..##.....##.##.##.##.##...####.##.......######..
....##....##...##....##..#########.##..####.##....##..##.......##......
....##....##....##...##..##.....##.##...###.##....##..##.......##......
....##....##.....##.####.##.....##.##....##..######...########.########
*/
//                    ...............
//                    A              |\
//                    :              |  \
//                    :              |    \
//                    :              |      \
//                    :              |        \
//            width   :              |          \
//                    :              |            \
//                    :              |              \  (0, 0)
//    . . . . . . . . : . . . . . . .| . . . . . . . * . . . . . . . . . . . .
//                    :         end  |              / tip
//                    :              |            /
//                    :              |          /
//                    :              |        /
//                    :              |      /
//                    :              |    /
//                    :              |  /   length
//                    V..............|/<------------->
//
//


function getTriangleArrowTail(o) {
  var t = 0;

  if (typeof o.tail === 'number') {
    t = o.tail;
  }

  t = Math.max(0, t);
  var headX = -o.length;

  if (t > 0) {
    headX = -(o.length - t);
  }

  var tailX = -o.length;
  return [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, o.tailWidth / 2), headX, tailX];
}

function getTriangleArrowLength(o) {
  return [o.length, o.length, o.length];
}

function getTriangleDefaults(o) {
  var length = o.length,
      width = o.width,
      tailWidth = o.tailWidth,
      scale = o.scale;
  scale = scale == null ? 1 : scale;

  if (width == null) {
    if (tailWidth != null) {
      width = tailWidth * 6 * scale;
    } else if (length != null) {
      width = length;
    } else {
      width = 1;
    }
  }

  if (length == null) {
    length = width;
  }

  if (tailWidth == null) {
    tailWidth = width / 6 / scale;
  }

  return {
    width: width,
    length: length,
    tailWidth: tailWidth
  };
}

function getTriangleArrow(options) {
  var length = options.length,
      drawBorderBuffer = options.drawBorderBuffer,
      tailWidth = options.tailWidth,
      width = options.width,
      tail = options.tail;

  var _getTriangleArrowTail = getTriangleArrowTail(options),
      _getTriangleArrowTail2 = _slicedToArray(_getTriangleArrowTail, 3),
      backIntersect = _getTriangleArrowTail2[0],
      headX = _getTriangleArrowTail2[1],
      tailX = _getTriangleArrowTail2[2];

  var arrowBorder; // let points: Array<Point>;

  if (tail === false || backIntersect.x >= headX) {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, width / 2)];
  } else {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2)]; // points = [
    //   arrowBorder[4]._dup(), arrowBorder[2]._dup(), arrowBorder[3]._dup(),
    //   arrowBorder[6]._dup(), arrowBorder[0]._dup(), arrowBorder[1]._dup(),
    //   arrowBorder[6]._dup(), arrowBorder[1]._dup(), arrowBorder[5]._dup(),
    // ];
  }

  var joinTail = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2)];
  var touchBorder = arrowBorder;

  if (drawBorderBuffer > 0) {
    touchBorder = getTouchBorder(length, width, drawBorderBuffer);
  }

  return [arrowBorder, touchBorder, joinTail];
}

function getTriangleTris(b) {
  if (b.length === 3) {
    return dup(b);
  }

  return dup([b[4], b[2], b[3], b[6], b[0], b[1], b[6], b[1], b[5]]);
}
/*
.......########..########.##.....##....########.########..####
.......##.....##.##.......##.....##.......##....##.....##..##.
.......##.....##.##.......##.....##.......##....##.....##..##.
.......########..######...##.....##.......##....########...##.
.......##...##...##........##...##........##....##...##....##.
.......##....##..##.........##.##.........##....##....##...##.
.......##.....##.########....###..........##....##.....##.####
*/


function getReverseTriTail(o) {
  var hLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([-o.length, o.tailWidth / 2], 1, 0);
  var headTop = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([-o.length, 0], [0, o.width / 2]);
  var i = hLine.intersectsWith(headTop).intersect || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.length, o.tailWidth / 2);
  var t = 0;

  if (typeof o.tail === 'number') {
    t = o.tail;
  }

  t = Math.max(i.x, t);
  var headX = -o.length;

  if (t > 0) {
    headX = -(o.length - t);
    headTop = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([headX, 0], [0, o.width / 2]);
    i = hLine.intersectsWith(headTop).intersect || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.length + t, o.tailWidth / 2);
  }

  var tailX = -o.length;

  if (t < 0) {
    if (-o.length - t >= i.x) {
      tailX = i.x;
    } else {
      tailX = -o.length - t;
    }
  }

  return [i, headX, tailX];
}

function getReverseTriLength(o) {
  var _getReverseTriTail = getReverseTriTail(o),
      _getReverseTriTail2 = _slicedToArray(_getReverseTriTail, 3),
      tailX = _getReverseTriTail2[2];

  return [o.length, -tailX, o.length];
}

function getReverseTriDefaults(o) {
  var length = o.length,
      width = o.width,
      tailWidth = o.tailWidth,
      scale = o.scale;
  scale = scale == null ? 1 : scale;

  if (width == null) {
    if (tailWidth != null) {
      width = tailWidth * 6 * scale;
    } else if (length != null) {
      width = length;
    } else {
      width = 1;
    }
  }

  if (length == null) {
    length = width;
  }

  if (tailWidth == null) {
    tailWidth = width / 6 / scale;
  }

  return {
    width: width,
    length: length,
    tailWidth: tailWidth
  };
}

function getReverseTriangleArrow(options) {
  var length = options.length,
      drawBorderBuffer = options.drawBorderBuffer,
      tailWidth = options.tailWidth,
      width = options.width,
      tail = options.tail;

  var _getReverseTriTail3 = getReverseTriTail(options),
      _getReverseTriTail4 = _slicedToArray(_getReverseTriTail3, 3),
      intersect = _getReverseTriTail4[0],
      headX = _getReverseTriTail4[1],
      tailX = _getReverseTriTail4[2];

  var arrowBorder; // let points;

  if (tail === false || tailX >= intersect.x) {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, 0)]; // points = arrowBorder.map(p => p._dup());
  } else if (tailX > headX) {
    var vLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([tailX, -tailWidth / 2], [tailX, 0]);
    var topLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([-length, 0], [0, width / 2]);
    var i = vLine.intersectsWith(topLine).intersect || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2);
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](intersect.x, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](i.x, i.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](i.x, -i.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](intersect.x, -tailWidth / 2)]; // points = [
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[2]._dup(),
    //   arrowBorder[0]._dup(), arrowBorder[2]._dup(), arrowBorder[8]._dup(),
    //   arrowBorder[8]._dup(), arrowBorder[2]._dup(), arrowBorder[3]._dup(),
    //   arrowBorder[8]._dup(), arrowBorder[3]._dup(), arrowBorder[7]._dup(),
    //   arrowBorder[6]._dup(), arrowBorder[4]._dup(), arrowBorder[5]._dup(),
    // ];
  } else {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](intersect.x, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](intersect.x, -tailWidth / 2)]; // points = [
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[2]._dup(),
    //   arrowBorder[0]._dup(), arrowBorder[2]._dup(), arrowBorder[5]._dup(),
    //   arrowBorder[2]._dup(), arrowBorder[3]._dup(), arrowBorder[4]._dup(),
    //   arrowBorder[5]._dup(), arrowBorder[2]._dup(), arrowBorder[4]._dup(),
    // ];
  }

  var joinTail = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2)];
  var touchBorder = arrowBorder;

  if (drawBorderBuffer > 0) {
    touchBorder = getTouchBorder(length, width, drawBorderBuffer);
  }

  return [arrowBorder, touchBorder, joinTail];
}

function getReverseTriangleTris(b) {
  if (b.length === 3) {
    return dup(b);
  }

  if (b.length === 9) {
    return dup([b[0], b[1], b[2], b[0], b[2], b[8], b[8], b[2], b[3], b[8], b[3], b[7], b[6], b[4], b[5]]);
  }

  return dup([b[0], b[1], b[2], b[0], b[2], b[5], b[2], b[3], b[4], b[5], b[2], b[4]]);
}
/*
.............########.....###....########..########.
.............##.....##...##.##...##.....##.##.....##
.............##.....##..##...##..##.....##.##.....##
.............########..##.....##.########..########.
.............##.....##.#########.##...##...##.....##
.............##.....##.##.....##.##....##..##.....##
.............########..##.....##.##.....##.########.
*/


function getBarbTail(o) {
  var t = 0;

  if (typeof o.tail === 'number') {
    t = o.tail;
  }

  t = Math.max(-o.barb, t);
  var headX = -o.length;

  if (t > 0) {
    headX = -(o.length - t);
  }

  var tailX = -o.length;

  if (t < 0) {
    if (-t < o.barb) {
      tailX = -o.length - t;
    } else {
      tailX = headX + o.barb;
    }
  }

  if (o.tail === false) {
    tailX = headX + o.barb;
  }

  var line1 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([tailX, o.tailWidth / 2], 1, 0);
  var back = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([headX + o.barb, 0], [headX, o.width / 2]);
  var backIntersect = line1.intersectsWith(back);
  var i = backIntersect.intersect || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, o.tailWidth / 2);

  if (backIntersect.withinLine === false) {
    i = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX + o.barb, o.tailWidth / 2);
  }

  return [i, headX, tailX];
}

function getBarbLength(o) {
  var _getBarbTail = getBarbTail(o),
      _getBarbTail2 = _slicedToArray(_getBarbTail, 3),
      tailX = _getBarbTail2[2];

  return [o.length, -tailX, o.length];
}

function getBarbDefaults(o) {
  var length = o.length,
      width = o.width,
      tailWidth = o.tailWidth,
      barb = o.barb,
      scale = o.scale;
  scale = scale == null ? 1 : scale;

  if (width == null) {
    if (tailWidth != null) {
      width = tailWidth * 6 * scale;
    } else if (length != null) {
      width = length;
    } else if (barb != null) {
      width = barb * 6 * scale;
    } else {
      width = 1;
    }
  }

  if (length == null) {
    length = width;
  }

  if (tailWidth == null) {
    tailWidth = width / 6 / scale;
  }

  if (barb == null) {
    barb = tailWidth * scale;
  }

  return {
    width: width,
    length: length,
    barb: barb,
    tailWidth: tailWidth
  };
}

function getBarbArrow(options) {
  var length = options.length,
      drawBorderBuffer = options.drawBorderBuffer,
      tailWidth = options.tailWidth,
      barb = options.barb,
      width = options.width,
      tail = options.tail;

  var _getBarbTail3 = getBarbTail(options),
      _getBarbTail4 = _slicedToArray(_getBarbTail3, 3),
      backIntersect = _getBarbTail4[0],
      headX = _getBarbTail4[1],
      tailX = _getBarbTail4[2];

  var arrowBorder; // let points;

  if (tail === false || backIntersect.x >= headX + barb) {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length + barb, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, width / 2)]; // points = [
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[2]._dup(),
    //   arrowBorder[0]._dup(), arrowBorder[2]._dup(), arrowBorder[3]._dup(),
    // ];
  } else {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](backIntersect.x, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](backIntersect.x, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2)]; // points = [
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[5]._dup(),
    //   arrowBorder[0]._dup(), arrowBorder[5]._dup(), arrowBorder[6]._dup(),
    //   arrowBorder[2]._dup(), arrowBorder[3]._dup(), arrowBorder[1]._dup(),
    //   arrowBorder[5]._dup(), arrowBorder[1]._dup(), arrowBorder[3]._dup(),
    //   arrowBorder[5]._dup(), arrowBorder[3]._dup(), arrowBorder[4]._dup(),
    // ];
  }

  var joinTail = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2)];
  var touchBorder = arrowBorder;

  if (drawBorderBuffer > 0) {
    touchBorder = getTouchBorder(length, width, drawBorderBuffer);
  }

  return [arrowBorder, touchBorder, joinTail];
}

function getBarbTris(b) {
  if (b.length === 4) {
    return dup([b[0], b[1], b[2], b[0], b[2], b[3]]);
  }

  return dup([b[0], b[1], b[5], b[0], b[5], b[6], b[2], b[3], b[1], b[5], b[1], b[3], b[5], b[3], b[4]]);
}
/*
................########..########..######..########
................##.....##.##.......##....##....##...
................##.....##.##.......##..........##...
................########..######...##..........##...
................##...##...##.......##..........##...
................##....##..##.......##....##....##...
................##.....##.########..######.....##...
*/


function getRectTail(o) {
  var t = 0;

  if (typeof o.tail === 'number') {
    t = o.tail;
  }

  t = Math.max(0, t);
  var headX = -o.length;

  if (t > 0) {
    headX = -(o.length - t);
  }

  var tailX = -o.length;
  return [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, o.tailWidth / 2), headX, tailX];
}

function getRectLength(o) {
  if (o.align === 'mid') {
    return [o.length / 2, o.length / 2, o.length];
  }

  return [o.length, o.length, o.length];
}

function getRectDefaults(o) {
  var length = o.length,
      width = o.width,
      tailWidth = o.tailWidth,
      scale = o.scale;
  scale = scale == null ? 1 : scale;

  if (width == null) {
    if (tailWidth != null) {
      width = tailWidth * 6 * scale;
    } else if (length != null) {
      width = length;
    } else {
      width = 1;
    }
  }

  if (length == null) {
    length = width;
  }

  if (tailWidth == null) {
    tailWidth = width / 6 / scale;
  }

  return {
    width: width,
    length: length,
    tailWidth: tailWidth
  };
}

function getBarDefaults(o) {
  var length = o.length,
      width = o.width,
      tailWidth = o.tailWidth,
      scale = o.scale;
  scale = scale == null ? 1 : scale;

  if (width == null) {
    if (tailWidth != null) {
      width = tailWidth * 6 * scale;
    } else if (length != null) {
      width = length * 6;
    } else {
      width = 1;
    }
  }

  if (length == null) {
    length = width / 6;
  }

  if (tailWidth == null) {
    tailWidth = width / 6 / scale;
  }

  return {
    width: width,
    length: length,
    tailWidth: tailWidth
  };
}

function getRectArrow(options) {
  var length = options.length,
      drawBorderBuffer = options.drawBorderBuffer,
      tailWidth = options.tailWidth,
      width = options.width,
      tail = options.tail;

  var _getRectTail = getRectTail(options),
      _getRectTail2 = _slicedToArray(_getRectTail, 3),
      backIntersect = _getRectTail2[0],
      headX = _getRectTail2[1],
      tailX = _getRectTail2[2];

  var arrowBorder; // let points;

  if (tail === false || backIntersect.x >= headX) {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-length, width / 2)]; // points = [
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[2]._dup(),
    //   arrowBorder[0]._dup(), arrowBorder[2]._dup(), arrowBorder[3]._dup(),
    // ];
  } else {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, -width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, width / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2)]; // points = [
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[6]._dup(),
    //   arrowBorder[0]._dup(), arrowBorder[6]._dup(), arrowBorder[7]._dup(),
    //   arrowBorder[2]._dup(), arrowBorder[3]._dup(), arrowBorder[4]._dup(),
    //   arrowBorder[2]._dup(), arrowBorder[4]._dup(), arrowBorder[5]._dup(),
    // ];
  }

  var joinTail = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2)];
  var touchBorder = arrowBorder;

  if (drawBorderBuffer > 0) {
    touchBorder = getTouchBorder(length, width, drawBorderBuffer);
  }

  return [arrowBorder, touchBorder, joinTail];
}

function getRectTris(b) {
  if (b.length === 4) {
    return dup([b[0], b[1], b[2], b[0], b[2], b[3]]);
  }

  return dup([b[0], b[1], b[6], b[0], b[6], b[7], b[2], b[3], b[4], b[2], b[4], b[5]]);
}
/*
..........             ...##.......####.##....##.########
..........             ...##........##..###...##.##......
..........             ...##........##..####..##.##......
..........             ...##........##..##.##.##.######..
..........             ...##........##..##..####.##......
..........             ...##........##..##...###.##......
..........             ...########.####.##....##.########
*/
//              |
//              |           \      00000000000000
//              |             \  00000000000000
//              |              00000000000000
//              |            00000000000000
//              |          00000000000000
//              |        00000000000000
//              |      00000000000000  \
//              |    00000000000000      \ LineWidth
//              |  00000000000000   o
//           -- |00000000000000       o   theta
//           A  |  0000000000          o
//         b |  |    000000             o
//           V  |    g 00               o
//           --- -------------------------------
//              |       |
//              |<----->|
//                  a
//
// theta = atan(height / width)
//
// angle g = 180 - theta - 90
// b = lineWidth * sin(g)
// a = lineWidth * cos(g)


function getLineTail(o) {
  var t = 0;

  if (typeof o.tail === 'number') {
    t = o.tail;
  }

  var theta = Math.atan(o.width / 2 / o.length);
  var g = Math.PI - theta - Math.PI / 2;
  var a = o.tailWidth * Math.cos(g);
  var headX = -o.length;
  var tailX = -o.length;

  if (t > 0) {
    headX = -(o.length - t);
  }

  var topOutsideLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([headX + a, o.width / 2], [0, 0]);
  var topInsideLine = topOutsideLine.offset('bottom', o.tailWidth);
  var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([headX, o.tailWidth / 2], 1, 0);
  var outsideIntersect = topOutsideLine.intersectsWith(line).intersect || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, o.tailWidth / 2);
  var insideIntersect = topInsideLine.intersectsWith(line).intersect || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](headX, o.tailWidth / 2);

  if (insideIntersect.x < -o.length) {
    insideIntersect = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.length, o.tailWidth / 2);
  }

  var zeroPoint;
  var insideIntersectWithZero = topInsideLine.intersectsWith(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([-o.length, 0], 1, 0));

  if (!insideIntersectWithZero) {
    zeroPoint = -o.length;
  } else {
    zeroPoint = insideIntersectWithZero.intersect.x;
  }

  if (!insideIntersectWithZero.isWithinLine || o.tail === false) {
    tailX = -o.length;
  }

  var stubTail = false;

  if (t < 0) {
    if (-o.length - t > insideIntersect.x) {
      tailX = insideIntersect.x;
      stubTail = true;
    } else {
      tailX = -o.length - t;
    }
  }

  if (o.tail === false) {
    tailX = zeroPoint;
  }

  return [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideIntersect.x, o.tailWidth / 2), headX, tailX, zeroPoint, topOutsideLine.p1, topInsideLine.p1, stubTail, insideIntersect];
}

function getLineLength(o) {
  var _getLineTail = getLineTail(o),
      _getLineTail2 = _slicedToArray(_getLineTail, 3),
      tailX = _getLineTail2[2];

  return [o.length, -tailX, o.length];
}

function getLineDefaults(o) {
  var length = o.length,
      width = o.width,
      tailWidth = o.tailWidth,
      scale = o.scale;
  scale = scale == null ? 1 : scale;

  if (width == null) {
    if (tailWidth != null) {
      width = tailWidth * 6 * scale;
    } else if (length != null) {
      width = length;
    } else {
      width = 1;
    }
  }

  if (length == null) {
    length = width;
  }

  if (tailWidth == null) {
    tailWidth = width / 6 / scale;
  }

  return {
    width: width,
    length: length,
    tailWidth: tailWidth
  };
}

function getLineArrow(options) {
  var length = options.length,
      drawBorderBuffer = options.drawBorderBuffer,
      tailWidth = options.tailWidth,
      width = options.width,
      tail = options.tail;

  var _getLineTail3 = getLineTail(options),
      _getLineTail4 = _slicedToArray(_getLineTail3, 8),
      frontIntersect = _getLineTail4[0],
      tailX = _getLineTail4[2],
      zeroPoint = _getLineTail4[3],
      outsideTop = _getLineTail4[4],
      insideTop = _getLineTail4[5],
      stubTail = _getLineTail4[6],
      insideIntersect = _getLineTail4[7];

  var arrowBorder; // let points;

  if (tail === false || frontIntersect.x <= tailX) {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideTop.x, -outsideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideTop.x, outsideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideTop.x, insideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](zeroPoint, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideTop.x, -insideTop.y)]; // points = [
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[5]._dup(),
    //   arrowBorder[5]._dup(), arrowBorder[1]._dup(), arrowBorder[4]._dup(),
    //   arrowBorder[4]._dup(), arrowBorder[1]._dup(), arrowBorder[3]._dup(),
    //   arrowBorder[3]._dup(), arrowBorder[1]._dup(), arrowBorder[2]._dup(),
    // ];
  } else if (stubTail) {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideTop.x, -outsideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideTop.x, outsideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideTop.x, insideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideIntersect.x, insideIntersect.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideIntersect.x, -insideIntersect.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideTop.x, -insideTop.y)]; // points = [
    //   arrowBorder[3]._dup(), arrowBorder[1]._dup(), arrowBorder[2]._dup(),
    //   arrowBorder[3]._dup(), arrowBorder[4]._dup(), arrowBorder[1]._dup(),
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[6]._dup(),
    //   arrowBorder[6]._dup(), arrowBorder[1]._dup(), arrowBorder[5]._dup(),
    //   arrowBorder[5]._dup(), arrowBorder[1]._dup(), arrowBorder[4]._dup(),
    // ];
  } else {
    arrowBorder = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideTop.x, -outsideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](outsideTop.x, outsideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideTop.x, insideTop.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideIntersect.x, insideIntersect.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideIntersect.x, -insideIntersect.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](insideTop.x, -insideTop.y)]; // points = [
    //   arrowBorder[0]._dup(), arrowBorder[1]._dup(), arrowBorder[8]._dup(),
    //   arrowBorder[8]._dup(), arrowBorder[1]._dup(), arrowBorder[7]._dup(),
    //   arrowBorder[7]._dup(), arrowBorder[1]._dup(), arrowBorder[4]._dup(),
    //   arrowBorder[4]._dup(), arrowBorder[1]._dup(), arrowBorder[2]._dup(),
    //   arrowBorder[3]._dup(), arrowBorder[4]._dup(), arrowBorder[2]._dup(),
    //   arrowBorder[5]._dup(), arrowBorder[7]._dup(), arrowBorder[4]._dup(),
    //   arrowBorder[6]._dup(), arrowBorder[7]._dup(), arrowBorder[5]._dup(),
    // ];
  }

  var joinTail = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](tailX, -tailWidth / 2)];
  var touchBorder = arrowBorder;

  if (drawBorderBuffer > 0) {
    touchBorder = getTouchBorder(length, width, drawBorderBuffer);
  }

  return [arrowBorder, touchBorder, joinTail];
}

function getLineTris(b) {
  if (b.length === 6) {
    return dup([b[0]._dup(), b[1]._dup(), b[5]._dup(), b[5]._dup(), b[1]._dup(), b[4]._dup(), b[4]._dup(), b[1]._dup(), b[3]._dup(), b[3]._dup(), b[1]._dup(), b[2]._dup()]);
  }

  if (b.length === 7) {
    return dup([b[3]._dup(), b[1]._dup(), b[2]._dup(), b[3]._dup(), b[4]._dup(), b[1]._dup(), b[0]._dup(), b[1]._dup(), b[6]._dup(), b[6]._dup(), b[1]._dup(), b[5]._dup(), b[5]._dup(), b[1]._dup(), b[4]._dup()]);
  }

  return dup([b[0]._dup(), b[1]._dup(), b[8]._dup(), b[8]._dup(), b[1]._dup(), b[7]._dup(), b[7]._dup(), b[1]._dup(), b[4]._dup(), b[4]._dup(), b[1]._dup(), b[2]._dup(), b[3]._dup(), b[4]._dup(), b[2]._dup(), b[5]._dup(), b[7]._dup(), b[4]._dup(), b[6]._dup(), b[7]._dup(), b[5]._dup()]);
}
/*
.......########...#######..##.......##....##..######....#######..##....##
.......##.....##.##.....##.##........##..##..##....##..##.....##.###...##
.......##.....##.##.....##.##.........####...##........##.....##.####..##
.......########..##.....##.##..........##....##...####.##.....##.##.##.##
.......##........##.....##.##..........##....##....##..##.....##.##..####
.......##........##.....##.##..........##....##....##..##.....##.##...###
.......##.........#######..########....##.....######....#######..##....##
*/


function getPolygonTail(o) {
  if (o.tail === false) {
    return Object(_polygon_polygon__WEBPACK_IMPORTED_MODULE_2__["getPolygonPoints"])({
      radius: o.radius,
      sides: o.sides,
      sidesToDraw: o.sides,
      rotation: 0,
      offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.radius, 0),
      direction: 1
    });
  }

  var t = 0;

  if (typeof o.tail === 'number') {
    t = o.tail;
  }

  t = Math.max(0, t);
  var topTheta = Math.PI - Math.asin(o.tailWidth / 2 / o.radius);
  var bottomTheta = Math.PI + Math.asin(o.tailWidth / 2 / o.radius);
  var sideAngle = Math.PI * 2 / o.sides;
  var topSideNum = Math.floor(topTheta / sideAngle);
  var bottomSideNum = Math.floor(bottomTheta / sideAngle);
  var points = Object(_polygon_polygon__WEBPACK_IMPORTED_MODULE_2__["getPolygonPoints"])({
    radius: o.radius,
    sides: o.sides,
    sidesToDraw: o.sides,
    rotation: 0,
    offset: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.radius, 0),
    direction: 1
  });
  var topSide = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](points[topSideNum], points[topSideNum + 1]);
  var bottomSide = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](points[bottomSideNum], points[bottomSideNum + 1]);
  var hLineTop = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([-o.radius, o.tailWidth / 2], 1, 0);
  var hLineBottom = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"]([-o.radius, -o.tailWidth / 2], 1, 0);
  var topIntersect = hLineTop.intersectsWith(topSide).intersect || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.radius, o.tailWidth / 2);
  var bottomIntersect = hLineBottom.intersectsWith(bottomSide).intersect || new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.radius, -o.tailWidth / 2);
  var outline = [topIntersect, new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.radius * 2 - t, o.tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-o.radius * 2 - t, -o.tailWidth / 2), bottomIntersect].concat(_toConsumableArray(points.slice(bottomSideNum + 1)), _toConsumableArray(points.slice(0, topSideNum + 1)));
  return outline;
}

function getPolygonLength(o) {
  var t = 0;

  if (typeof o.tail === 'number') {
    t = Math.max(0, o.tail);
  }

  if (o.align === 'mid') {
    if (o.tail === false) {
      return [o.radius, o.radius, o.radius * 2 + t];
    }

    return [o.radius, o.radius, o.radius * 2 + t];
  }

  if (typeof o.tail === 'boolean') {
    return [o.radius * 2, o.radius * 2, o.radius * 2];
  }

  var l = o.radius * 2 + t;
  return [l, l, l];
}

function getPolygonDefaults(o) {
  var radius = o.radius,
      tailWidth = o.tailWidth,
      scale = o.scale,
      sides = o.sides;
  scale = scale == null ? 1 : scale;

  if (radius == null) {
    if (tailWidth != null) {
      radius = tailWidth * 3 * scale;
    } else {
      radius = 1;
    }
  }

  if (tailWidth == null) {
    tailWidth = radius / 3 / scale;
  }

  if (sides == null) {
    sides = 30;
  }

  return {
    radius: radius,
    tailWidth: tailWidth,
    sides: sides
  };
}

function getPolygonArrow(options) {
  var drawBorderBuffer = options.drawBorderBuffer,
      tailWidth = options.tailWidth,
      radius = options.radius,
      tail = options.tail;
  var outline = getPolygonTail(options); // const points: Array<Point> = [];
  // for (let i = 1; i < outline.length; i += 1) {
  //   points.push(new Point(-radius, 0));
  //   points.push(outline[i - 1]);
  //   points.push(outline[i]);
  // }
  // points.push(new Point(-radius, 0));
  // points.push(outline[outline.length - 1]);
  // points.push(outline[0]);

  var t = 0;
  var tailJoin;

  if (tail === false) {
    tailJoin = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-radius * 2, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-radius * 2, -tailWidth / 2)];
  } else {
    if (typeof tail === 'number') {
      t = Math.max(tail, 0);
    }

    tailJoin = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-radius * 2 - t, tailWidth / 2), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](-radius * 2 - t, -tailWidth / 2)];
  }

  var touchBorder = outline;

  if (drawBorderBuffer > 0) {
    touchBorder = getTouchBorder(radius * 2 + t, radius * 2, drawBorderBuffer);
  }

  return [outline, touchBorder, tailJoin];
}

function getPolygonTris(b) {
  var points = [];

  for (var i = 1; i < b.length; i += 1) {
    points.push(b[0]);
    points.push(b[i - 1]);
    points.push(b[i]);
  } // console.log(points)
  // points.push(new Point(-radius, 0));
  // points.push(b[b.length - 1]);
  // points.push(b[0]);


  return points;
}

function getArrowLength(options) {
  var head = options.head,
      length = options.length;

  if (head === 'circle' || head === 'polygon') {
    return getPolygonLength(options);
  }

  if (head === 'line') {
    // const line = new Line([0, -width / 2], [length, 0]);
    // const horizontal = new Line([0, -tailWidth], [length, -tailWidth]);
    // const i = horizontal.intersectsWith(line).intersect;
    // return length - i.x;
    return getLineLength(options);
  }

  if (head === 'reverseTriangle') {
    return getReverseTriLength(options);
  }

  if (head === 'triangle') {
    return getTriangleArrowLength(options);
  }

  if (head === 'barb') {
    return getBarbLength(options);
  }

  if (head === 'rectangle' || head === 'bar') {
    return getRectLength(options);
  } // if (head === 'triangle' && reverse) {
  //   return 0;
  // }


  return [length, length, length];
}

function getArrow(options) {
  // let points;
  var border;
  var touchBorder;
  var tail;
  var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, options);

  if (o.drawPosition != null) {
    o.drawPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(o.drawPosition);
  }

  if (o.tailWidth > 0 && o.width < o.tailWidth) {
    o.width = o.tailWidth * 0.001;
  }

  if (o.head === 'barb') {
    var _getBarbArrow = getBarbArrow(o);

    var _getBarbArrow2 = _slicedToArray(_getBarbArrow, 3);

    border = _getBarbArrow2[0];
    touchBorder = _getBarbArrow2[1];
    tail = _getBarbArrow2[2];
  } else if (o.head === 'rectangle' || o.head === 'bar') {
    var _getRectArrow = getRectArrow(o);

    var _getRectArrow2 = _slicedToArray(_getRectArrow, 3);

    border = _getRectArrow2[0];
    touchBorder = _getRectArrow2[1];
    tail = _getRectArrow2[2];
  } else if (o.head === 'line') {
    var _getLineArrow = getLineArrow(o);

    var _getLineArrow2 = _slicedToArray(_getLineArrow, 3);

    border = _getLineArrow2[0];
    touchBorder = _getLineArrow2[1];
    tail = _getLineArrow2[2];
  } else if (o.head === 'polygon' || o.head === 'circle') {
    var _getPolygonArrow = getPolygonArrow(o);

    var _getPolygonArrow2 = _slicedToArray(_getPolygonArrow, 3);

    border = _getPolygonArrow2[0];
    touchBorder = _getPolygonArrow2[1];
    tail = _getPolygonArrow2[2];
  } else if (o.head === 'reverseTriangle') {
    var _getReverseTriangleAr = getReverseTriangleArrow(o);

    var _getReverseTriangleAr2 = _slicedToArray(_getReverseTriangleAr, 3);

    border = _getReverseTriangleAr2[0];
    touchBorder = _getReverseTriangleAr2[1];
    tail = _getReverseTriangleAr2[2];
  } else {
    var _getTriangleArrow = getTriangleArrow(o);

    var _getTriangleArrow2 = _slicedToArray(_getTriangleArrow, 3);

    border = _getTriangleArrow2[0];
    touchBorder = _getTriangleArrow2[1];
    tail = _getTriangleArrow2[2];
  }

  var _getArrowLength = getArrowLength(o),
      _getArrowLength2 = _slicedToArray(_getArrowLength, 3),
      joinLength = _getArrowLength2[1],
      fullLength = _getArrowLength2[2];

  var _orientArrow = orientArrow(border, touchBorder, tail, fullLength, joinLength, o),
      _orientArrow2 = _slicedToArray(_orientArrow, 3),
      newBorder = _orientArrow2[0],
      borderBuffer = _orientArrow2[1],
      newTail = _orientArrow2[2]; // const { line } = o;
  // let lineDelta = 0;
  // if (line != null && line.widthIs === 'mid') {
  //   lineDelta = line.width / 2;
  // }
  // if (line != null && (line.widthIs === 'outside' || line.widthIs === 'negative')) {
  //   lineDelta = line.width;
  // }
  // const increaseArrowByOffset = (pnts: Array<Point>, delta) => {
  //   // if (delta > 0.01) {
  //   //   debugger;
  //   // }
  //   const [, outline] = makePolyLine(
  //     pnts, delta, true, 'negative', 'auto', 0.1,
  //     10, Math.PI / 7, [], false,
  //     2, 'negative', 0, [],
  //   );
  //   // return [outline[0][0], outline[0][1], outline[0][3]];
  //   return outline[0];
  // };
  // let outline: Array<Point>;
  // if (lineDelta > 0) {
  //   outline = increaseArrowByOffset(newBorder, lineDelta);
  // } else {  // $FlowFixMe
  //   outline = newBorder.map(p => p._dup());
  // }
  // const borderOut = [outline];
  // const { drawBorderBuffer } = o;
  // let borderBuffer = drawBorderBuffer;
  // if (typeof drawBorderBuffer === 'number') {
  //   borderBuffer = [increaseArrowByOffset(border, lineDelta + drawBorderBuffer)];
  // }
  // let pointsToUse = newPoints;
  // if (line != null) {
  //   pointsToUse = newBorder;
  // }


  return [newBorder, [borderBuffer], newTail];
}

function getArrowTris(border, options) {
  if (options.head === 'triangle') {
    return getTriangleTris(border);
  }

  if (options.head === 'reverseTriangle') {
    return getReverseTriangleTris(border);
  }

  if (options.head === 'barb') {
    return getBarbTris(border);
  }

  if (options.head === 'rectangle' || options.head === 'bar') {
    return getRectTris(border);
  }

  if (options.head === 'polygon' || options.head === 'circle') {
    return getPolygonTris(border);
  } // if (options.head === 'line') {


  return getLineTris(border); // }
}

function defaultArrowOptions(o) {
  var defaults = {
    align: 'tip',
    tail: false,
    angle: 0,
    drawPosition: new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0),
    scale: 1
  };

  if (o.head === 'triangle' || o.head == null) {
    return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaults, o, getTriangleDefaults(o), {
      head: 'triangle'
    });
  }

  if (o.head === 'polygon' || o.head === 'circle') {
    return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaults, o, getPolygonDefaults(o));
  }

  if (o.head === 'barb') {
    return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaults, o, getBarbDefaults(o));
  }

  if (o.head === 'reverseTriangle') {
    return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaults, o, getReverseTriDefaults(o));
  }

  if (o.head === 'bar') {
    return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaults, o, getBarDefaults(o));
  }

  if (o.head === 'line') {
    return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaults, o, getLineDefaults(o));
  }

  return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaults, o, getRectDefaults(o));
}

function simplifyArrowOptions(arrowIn, tailWidth) {
  var includeTailByDefault = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (arrowIn == null) {
    return undefined;
  }

  var arrow;

  if (typeof arrowIn === 'string') {
    // $FlowFixMe
    arrow = {
      // $FlowFixMe
      start: arrowIn,
      // $FlowFixMe
      end: arrowIn
    };
  } else {
    arrow = arrowIn;
  }

  var optionsForBoth = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjectsWithOptions"])({
    except: ['end', 'start']
  }, {}, arrow);
  var out = {};

  var processEnd = function processEnd(startOrEnd) {
    if (typeof arrow[startOrEnd] === 'string') {
      // $FlowFixMe
      arrow[startOrEnd] = {
        // $FlowFixMe
        head: arrow[startOrEnd]
      };
    }

    if (Object.keys(optionsForBoth).length > 0) {
      if (arrow[startOrEnd] == null) {
        arrow[startOrEnd] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, optionsForBoth);
      } else {
        arrow[startOrEnd] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, optionsForBoth, arrow[startOrEnd]);
      }
    }

    if (arrow[startOrEnd] != null || arrow.start == null && arrow.end == null) {
      var defaults = {}; // let defaultTailWidth = {};

      if (tailWidth != null) {
        defaults.tailWidth = tailWidth;
      }

      if (includeTailByDefault) {
        defaults.tail = true;
      }

      var o = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjectsWithOptions"])({
        except: ['end', 'start']
      }, defaults, arrow[startOrEnd]);
      out[startOrEnd] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultArrowOptions(o), o);
      out[startOrEnd].drawPosition = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(out[startOrEnd].drawPosition);
    }
  };

  processEnd('start');
  processEnd('end');

  if (Object.keys(out).length > 0) {
    return out;
  }

  return undefined;
}

 // // Draw examples of arrows
// const figure = new Fig.Figure({ limits: [-3, -3, 6, 6]});
// let y = 3;
// let yStep = -0.7;
// let xs = [-1, 0, 1];
// let xStep = 1;
// let index = 0;
// const addArrow = (name, head, length, tail = false, align = 'tip', sides = 100) => {
//   if (index % 3 === 0) {
//     y += yStep;
//   }
//   x = xs[index % 3];
//   index += 1;
//   return {
//     name,
//     method: 'shapes.arrow',
//     options: {
//       head,
//       length,
//       radius: 0.25,
//       tail,
//       position: [x, y],
//       width: 0.5,
//       tailWidth: 0.1,
//       sides,
//       align,
//     },
//   };
// }
// figure.add([
//   addArrow('t1', 'triangle', 0.5, false, 'tip'),
//   addArrow('t2', 'triangle', 0.5, 0),
//   addArrow('t3', 'triangle', 0.7, 0.2),
//   addArrow('b1', 'barb', 0.5, false, 'tip'),
//   addArrow('b2', 'barb', 0.5, 0),
//   addArrow('b3', 'barb', 0.7, 0.2),
//   addArrow('l1', 'line', 0.5, false, 'tip'),
//   addArrow('l2', 'line', 0.5, 0),
//   addArrow('l3', 'line', 0.7, 0.2),
//   addArrow('bar1', 'bar', 0.1, false, 'tip'),
//   addArrow('bar2', 'bar', 0.1, 0),
//   addArrow('bar3', 'bar', 0.7, 0.6),
//   addArrow('c1', 'circle', 1, false, 'tip'),
//   addArrow('c2,', 'circle', 1, 0),
//   addArrow('c3', 'circle', 1, 0.2),
//   addArrow('p1', 'polygon', 1, false, 'tip', 6),
//   addArrow('p2', 'polygon', 1, 0, 'tip', 6),
//   addArrow('p3', 'polygon', 1, 0.2, 'tip', 6),
//   addArrow('rt1', 'reverseTriangle', 0.5, false, 'tip'),
//   addArrow('rt2', 'reverseTriangle', 0.5, 0),
//   addArrow('rt3', 'reverseTriangle', 0.7, 0.2),
// ])

/***/ }),

/***/ "./src/js/figure/geometries/buffer.js":
/*!********************************************!*\
  !*** ./src/js/figure/geometries/buffer.js ***!
  \********************************************/
/*! exports provided: getBufferBorder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBufferBorder", function() { return getBufferBorder; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



function getBufferBorder(bordersIn, buffer) {
  var skipConcave = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var bufferOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'negative';

  if (typeof buffer !== 'number') {
    return buffer;
  }

  if (buffer === 0) {
    return bordersIn;
  }

  var drawBorderBuffers = [];
  bordersIn.forEach(function (borderIn) {
    // First remove all points that are >180º
    var border = [];
    var borderIndex = [];

    for (var i = 0; i < borderIn.length; i += 1) {
      var prevPoint = void 0;
      var nextPoint = void 0;

      if (i === 0) {
        prevPoint = borderIn[borderIn.length - 1];
      } else {
        prevPoint = borderIn[i - 1];
      }

      if (i === borderIn.length - 1) {
        var _borderIn = _slicedToArray(borderIn, 1);

        nextPoint = _borderIn[0];
      } else {
        nextPoint = borderIn[i + 1];
      }

      var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngle"])(nextPoint, borderIn[i], prevPoint);

      if ((skipConcave && angle < Math.PI || skipConcave === false) && (border.length === 0 || borderIn[i].isNotEqualTo(border[border.length - 1]))) {
        border.push(borderIn[i]);
        borderIndex.push(i);
      }
    }

    var drawBorderBuffer = [];
    var offsetLines = [];

    for (var _i2 = 0; _i2 < border.length; _i2 += 1) {
      var line = void 0;

      if (_i2 === 0) {
        line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](border[border.length - 1], border[0]);
      } else {
        line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](border[_i2 - 1], border[_i2]);
      } // console.log(bufferOffset)
      // offsetLines.push(line.offset('negative', buffer));


      offsetLines.push(line.offset(bufferOffset, buffer));
    }

    for (var _i3 = 0; _i3 < offsetLines.length; _i3 += 1) {
      var prevLine = void 0; // let nextLine;

      if (_i3 === 0) {
        prevLine = offsetLines[offsetLines.length - 1];
      } else {
        prevLine = offsetLines[_i3 - 1];
      }

      var currentLine = offsetLines[_i3];
      var intersect = currentLine.intersectsWith(prevLine);

      if (intersect.intersect != null) {
        var borderPoint = void 0;

        if (_i3 === 0) {
          borderPoint = border[border.length - 1];
        } else {
          borderPoint = border[_i3 - 1];
        }

        if (intersect.intersect.distance(borderPoint) > buffer * 1.2) {
          var borderToBuffer = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](borderPoint, intersect.intersect);
          var perpLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](borderToBuffer.pointAtLength(buffer * 1.2), 1, borderToBuffer.angle() + Math.PI / 2);
          var prevIntersect = prevLine.intersectsWith(perpLine);
          var nextIntersect = currentLine.intersectsWith(perpLine);

          if (prevIntersect.intersect != null && nextIntersect.intersect != null) {
            drawBorderBuffer.push(prevIntersect.intersect);
            drawBorderBuffer.push(nextIntersect.intersect);
          } else {
            drawBorderBuffer.push(intersect.intersect);
          }
        } else {
          drawBorderBuffer.push(intersect.intersect);
        }
      }
    }

    drawBorderBuffers.push(drawBorderBuffer);
  });
  return drawBorderBuffers;
}



/***/ }),

/***/ "./src/js/figure/geometries/copy/copy.js":
/*!***********************************************!*\
  !*** ./src/js/figure/geometries/copy/copy.js ***!
  \***********************************************/
/*! exports provided: copyPoints, copyStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPoints", function() { return copyPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyStep", function() { return copyStep; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* eslint-disable camelcase */


/* eslint-disable max-len */

/**
 *
 * ![](./apiassets/copy.png)
 *
 * Copy Step options object
 *
 * A copy step defines how to copy existing points.
 *
 * An array of copy steps will cumulatively copy points from an original set of
 * points.
 *
 * So, if there are two copy steps then:
 * - the first step will copy the original points
 * - the second step will copy the original points and the first copy of the
 *   points
 *
 * For example, a grid of a shape can be made with two copy steps. The first
 * replicates the shape along the x axis, creating a line of shapes. The second
 * copy step then replicates the line of shapes in the y axis, creating a grid
 * of shapes.
 *
 * Each copy step appends its copied points onto an array of points that
 * started with the original points. By default, copy steps operate on all
 * points created in previous steps. However, the properties `start` and `end`
 * can be used to make the current step only operate on a subset of the points.
 *
 * `start` and `end` refer to the indexes of the copy steps where the original
 * points is at index 0, and the first copy step is at index 1. Copy step
 * arrays can also include *marker strings* which make defining `start` and
 * `end` more convient (see the third example below). These marker strings
 * can be used as `start` and `end` values. Marker strings are included
 * in the copy step indexing.
 *
 * There are two main ways to make a copy, either copy the points `to` a
 * location, or copy the points `along` a path.
 *
 * When using the `to` property, if a {@link Point} is defined
 * then the points will be copied to that point. If a {@link Transform} is
 * defined, then a copy of the points will be transformed by that transform. An
 * array of points and transforms can be defined to make multiple copies of the
 * points.
 *
 * When using the `along` property, the points are copied a number (`num`) of
 * times along a path with some `step`. The paths can be horiztonal (`'x'`),
 * vertical (`'y'`), at an angle (`number`) or through a `'rotation'` around
 * a `center` point.
 *
 * When copying along a line (`along` is `'x'`, `y'` or a `number`), then
 * `step` will be the distance offset along the line.
 *
 * When copying along a rotation (`along` is `'rotation'`), then `step` will be
 * the angular step in radians.
 *
 * Any step can use the `original` property - but it will only operate on the
 * last step that uses it. When `original` is `false`, then all points before
 * that copy step will not be included in the returned Point array.
 *
 * @property {TypeParsablePoint | TypeParsableTransform | Array<TypeParsablePoint | TypeParsableTransform>} [to] copy points to
 * a location or locations or transform a copy of the points
 * @property {'x' | 'y' | number | 'rotation' | 'moveOnly'} [along] copy points
 * along a linear path where `number` is a path at an angle in radians
 * @property {number} [num] the number of copies to make when copying `along` a
 * path
 * @property {number} [step] distance between copies if `along` is `'x'` or
 * `'y'` or a `number`, delta angle between copies if `along` is `'rotation'`
 * @property {TypeParsablePoint} [center] the center point about which to rotate
 * the copies when using `along` = `'rotation'`
 * @property {number | string} [start] copy step index or marker defining the
 * start of the points to copy
 * @property {number | string} [end] copy step index or marker defining the end
 * of the points to copy
 * @property {boolean} [original] `false` excludes all points before this step
 * in the final result (`true`)
 * @example
 * // Grid copy
 * figure.add({
 *   name: 'triGrid',
 *   method: 'polygon',
 *   options: {
 *     radius: 0.1,
 *     sides: 3,
 *     rotation: -Math.PI / 6,
 *     fill: 'tris',
 *     copy: [
 *       {
 *         along: 'x',
 *         num: 4,
 *         step: 0.3,
 *       },
 *       {
 *         along: 'y',
 *         num: 4,
 *         step: 0.3,
 *       },
 *     ],
 *   },
 * });
 *
 * @example
 * // Radial lines copy
 * figure.add({
 *   name: 'radialLines',
 *   method: 'generic',
 *   options: {
 *     points: [
 *       [-0.2, -0.1], [-0.2, 0.1], [0.2, 0.1],
 *       [-0.2, -0.1], [0.2, 0.1], [0.2, -0.1],
 *     ],
 *     copy: [
 *       {
 *         to: [[0.6, 0], [1.05, 0], [1.5, 0], [2.2, 0]],
 *       },
 *       {
 *         along: 'rotation',
 *         num: 5,
 *         step: Math.PI / 5,
 *         start: 1,              // only copy last step, not original points
 *       },
 *     ],
 *   },
 * });
 *
 * @example
 * // Ring copy (without original shape)
 * figure.add({
 *   name: 'halfRings',
 *   method: 'polygon',
 *   options: {
 *     radius: 0.1,
 *     sides: 20,
 *     fill: 'tris',
 *     copy: [
 *       'ring1',               // marker 1
 *       {
 *         to: [0.5, 0],
 *         original: false,     // don't include the original shape
 *       },
 *       {
 *         along: 'rotation',
 *         num: 7,
 *         step: Math.PI / 7,
 *         start: 'ring1',      // copy only from marker 1
 *       },
 *       'ring2',               // marker 2
 *       {
 *         to: [1, 0],
 *         start: 0,            // make a copy of the original shape only
 *         end: 1,
 *       },
 *       {
 *         along: 'rotation',
 *         num: 15,
 *         step: Math.PI / 15,
 *         start: 'ring2',      // copy points from Marker 2 only
 *       },
 *     ],
 *   },
 * });
 */

function getPointsToCopy(points, startIn, endIn, marks) {
  var out = [];
  var start = marks["".concat(startIn)];
  var end;

  if (endIn === 'end') {
    end = points.length;
  } else {
    end = marks["".concat(endIn)];
  }

  if (end == null) {
    end = points.length;
  }

  for (var i = start; i < end; i += 1) {
    out.push(points[i]._dup());
  }

  return out;
}

function copyOffset(pointsToCopy, // initialPoints: Array<Point>,
optionsIn) {
  var defaultOptions = {
    to: []
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
  options.to = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(options.to);
  var k = 0;
  var out = Array(options.to.length * pointsToCopy.length);

  for (var i = 0; i < options.to.length; i += 1) {
    for (var j = 0; j < pointsToCopy.length; j += 1) {
      out[k] = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](pointsToCopy[j].x + options.to[i].x, pointsToCopy[j].y + options.to[i].y);
      k += 1;
    }
  }

  return out;
} // TODO Speedup like copyOFfset


function copyTransform(pointsToCopy, // initialPoints: Array<Point>,
optionsIn) {
  var defaultOptions = {
    to: []
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);

  if (options.to instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
    options.to = [optionsIn.to];
  }

  var out = [];

  var _loop = function _loop(i) {
    // $FlowFixMe
    var matrix = options.to[i].matrix();
    out = [].concat(_toConsumableArray(out), _toConsumableArray(pointsToCopy.map(function (p) {
      return p.transformBy(matrix);
    })));
  };

  for (var i = 0; i < options.to.length; i += 1) {
    _loop(i);
  }

  return out;
} // TODO Speedup like copyOFfset


function copyLinear(pointsToCopy, // initialPoints: Array<Point>,
optionsIn) {
  if (optionsIn.along == null) {
    return [];
  }

  var defaultOptions = {
    num: 1
  };
  var angle = 0;
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);

  if (options.along === 'y') {
    angle = Math.PI / 2;
  } else if (options.along === 'x') {
    angle = 0;
  } else if (typeof options.along === 'number') {
    angle = options.along;
  }

  if (options.step == null) {
    var bounds = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getBoundingRect"])(pointsToCopy);
    options.step = Math.abs(bounds.height / Math.sin(angle));
  }

  var out = [];

  var _loop2 = function _loop2(i) {
    var step = options.step * i;
    out = [].concat(_toConsumableArray(out), _toConsumableArray(pointsToCopy.map(function (p) {
      return p.add(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["polarToRect"])(step, angle));
    })));
  };

  for (var i = 1; i < options.num + 1; i += 1) {
    _loop2(i);
  }

  return out;
} // TODO Speedup like copyOFfset


function copyAngle(pointsToCopy, // initialPoints: Array<Point>,
optionsIn) {
  var defaultOptions = {
    num: 1,
    step: Math.PI / 4,
    center: [0, 0]
  };
  var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
  options.center = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(options.center);
  var out = [];
  var center = options.center;

  var _loop3 = function _loop3(i) {
    var matrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().translate(-center.x, -center.y).rotate(i * options.step).translate(center.x, center.y).matrix();
    out = [].concat(_toConsumableArray(out), _toConsumableArray(pointsToCopy.map(function (p) {
      return p.transformBy(matrix);
    })));
  };

  for (var i = 1; i < options.num + 1; i += 1) {
    _loop3(i);
  }

  return out;
} // function copyArc(
//   pointsToCopy: Array<Point>,
//   initialPoints: Array<Point>,
//   optionsIn: CPY_Arc,
// ) {
//   const defaultOptions = {
//     num: 1,
//     step: 0.1,
//     angleStep: Math.PI / 4,
//     // arcStep: 0.1,
//     startAngle: 0,
//     stopAngle: Math.PI * 2,
//     center: [0, 0],
//   };
//   const options = joinObjects({}, defaultOptions, optionsIn);
//   options.center = getPoint(options.center);
//   let out = initialPoints;
//   const { center } = options;
//   for (let i = 1; i < options.num + 1; i += 1) {
//     const matrix = new Transform()
//       .translate(-center.x, -center.y)
//       .rotate(i * options.step)
//       .translate(center.x, center.y)
//       .matrix();
//     out = [...out, ...pointsToCopy.map(p => p.transformBy(matrix))];
//   }
//   return out;
// }


function copyStep(points, copyStyle, options) // marks: CPY_Marks,
{
  // const out = [];
  if (copyStyle === 'linear' || copyStyle === 'x' || copyStyle === 'y' || typeof copyStyle === 'number') {
    return copyLinear(points, options);
  }

  if (copyStyle === 'to') {
    if (options.to == null) {
      return points;
    }

    if (Array.isArray(options.to) && options.to.length === 0) {
      return points;
    }

    if (options.to instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
      return copyTransform(points, options);
    }

    if (Array.isArray(options.to) && options.to[0] instanceof _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]) {
      return copyTransform(points, options);
    }

    return copyOffset(points, options);
  }

  if (copyStyle === 'rotation') {
    return copyAngle(points, options);
  }

  return points;
}

function copyPoints(points, chain) {
  var marks = {}; // let out = [];

  var startIndex = 0; // let all = [];
  // $FlowFixMe

  var out = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(points);

  if (chain == null) {
    return out;
  }

  var chainToUse = [];

  if (!Array.isArray(chain)) {
    chainToUse = [chain];
  } else {
    chainToUse = chain;
  }

  marks['0'] = 0; // marks['1'] = points.length;

  chainToUse.forEach(function (c, index) {
    marks["".concat(index + 1)] = out.length;

    if (typeof c === 'string') {
      marks[c] = out.length;
    } else {
      var defaultOptions = {
        start: startIndex,
        end: 'end',
        original: true
      };
      var options = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, c);
      var copyStyle = 'to';

      if (options.along != null) {
        copyStyle = options.along;
      }

      var pointsToCopy = getPointsToCopy(out, options.start, options.end, marks);

      if (options.original === false) {
        startIndex = out.length;
      }

      out = [].concat(_toConsumableArray(out), _toConsumableArray(copyStep(pointsToCopy, copyStyle, options)));
    }
  });
  return _toConsumableArray(out.slice(startIndex));
}



/***/ }),

/***/ "./src/js/figure/geometries/ellipse.js":
/*!*********************************************!*\
  !*** ./src/js/figure/geometries/ellipse.js ***!
  \*********************************************/
/*! exports provided: getEllipseBorder, ellipseBorderToTris */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEllipseBorder", function() { return getEllipseBorder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipseBorderToTris", function() { return ellipseBorderToTris; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");


// import {
//   round,
// } from '../../../../tools/math';
function getEllipsePoints(width, height, sides, x, y) {
  var points = [];
  var deltaAngle = Math.PI * 2 / sides;

  for (var i = 0; i < sides; i += 1) {
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2 * Math.cos(deltaAngle * i) + x, height / 2 * Math.sin(deltaAngle * i) + y));
  }

  return points;
}

function getEllipseBorder(options) {
  var width = options.width,
      height = options.height,
      xAlign = options.xAlign,
      yAlign = options.yAlign,
      sides = options.sides;
  var x = 0;
  var y = 0;

  if (xAlign === 'left') {
    x = width / 2;
  } else if (xAlign === 'right') {
    x = -width / 2;
  } else if (typeof xAlign === 'number') {
    x = width / 2 - width * xAlign;
  }

  if (yAlign === 'bottom') {
    y = height / 2;
  } else if (yAlign === 'top') {
    y = -height / 2;
  } else if (typeof yAlign === 'number') {
    y = height / 2 - height * yAlign;
  }

  return getEllipsePoints(width, height, sides, x, y); // let lineDelta = 0;
  // if (line != null && line.widthIs === 'mid') {
  //   lineDelta = line.width / 2;
  // }
  // if (line != null && (line.widthIs === 'outside' || line.widthIs === 'negative')) {
  //   lineDelta = line.width;
  // }
  // let outline: Array<Point>;
  // if (lineDelta > 0) {
  //   outline = getEllipsePoints(
  //     width + lineDelta * 2,
  //     height + lineDelta * 2,
  //     sides, x, y,
  //   );
  // } else {  // $FlowFixMe
  //   outline = points.map(p => p._dup());
  // }
  // const border = [outline];
  // const { drawBorderBuffer } = options;
  // let borderBuffer = drawBorderBuffer;
  // if (typeof drawBorderBuffer === 'number') {
  //   borderBuffer = [getEllipsePoints(
  //     width + lineDelta * 2 + drawBorderBuffer * 2,
  //     height + lineDelta * 2 + drawBorderBuffer * 2,
  //     sides, x, y,
  //   )];
  // }
  // return [points;
}

function ellipseBorderToTris(border) {
  var points = [border[0]._dup(), border[1]._dup(), border[2]._dup()];

  for (var i = 2; i < border.length - 1; i += 1) {
    points.push(border[0]);
    points.push(border[i]);
    points.push(border[i + 1]);
  }

  return points;
}



/***/ }),

/***/ "./src/js/figure/geometries/line.js":
/*!******************************************!*\
  !*** ./src/js/figure/geometries/line.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");


// import {
//   round,
// } from '../../../../tools/math';
// function getLineBorder(options: {
//   p1: Point,
//   p2: Point,
//   width: number,
//   length: number | {
//     p1: number,
//     p2: number,
//   },
// }) {
//   const {
//     p1, p2, width, length,
//   } = options;
//   const line = new Line(p1, p2);
//   let p1Length = 0;
//   let p2Length = 0;
//   if (typeof length === 'number') {
//     const deltaLength = length - line.length();
//     p1Length = -deltaLength / 2;
//     p2Length = deltaLength / 2;
//   } else {
//     const p1L = length.p1;
//     const p2L = length.p2;
//     if (p1L != null) {
//       p1Length = p1L;
//     } else {
//       p1Length = 0;
//     }
//     if (p2L != null) {
//       p2Length = p2L;
//     } else {
//       p2Length = 0;
//     }
//   }
//   const horizontalBorder = [
//     new Point(p1Length, -width / 2),
//     new Point(p1Length, width / 2),
//     new Point(line.length() + p2Length, width / 2),
//     new Point(line.length() + p2Length, -width / 2),
//   ];
//   const matrix = new Transform().rotate(line.angle()).translate(p1).matrix();
//   return horizontalBorder.map(p => p.transformBy(matrix));
// }
function getLine(options) {
  var p1 = options.p1,
      p2 = options.p2,
      length = options.length,
      width = options.width,
      angle = options.angle,
      border = options.border,
      touchBorder = options.touchBorder,
      widthIs = options.widthIs;
  var points = [Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p1)];

  if (p2 == null) {
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](points[0].x + length * Math.cos(angle), points[0].y + length * Math.sin(angle)));
  } else {
    points.push(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoint"])(p2));
  }

  var borderToUse = border;
  var touchBorderToUse = touchBorder;

  if (border === 'outline') {
    borderToUse = 'line';
  }

  if (typeof touchBorderToUse === 'number') {
    var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](points[0], points[1]);
    var extendedLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](line.pointAtLength(-touchBorderToUse), line.pointAtLength(line.length() + touchBorderToUse));
    var negOffset;
    var posOffset;

    if (widthIs === 'positive') {
      negOffset = extendedLine.offset('negative', touchBorderToUse);
      posOffset = extendedLine.offset('positive', width + touchBorderToUse);
    } else if (widthIs === 'negative') {
      negOffset = extendedLine.offset('negative', width + touchBorderToUse);
      posOffset = extendedLine.offset('positive', touchBorderToUse);
    } else {
      negOffset = extendedLine.offset('negative', width / 2 + touchBorderToUse);
      posOffset = extendedLine.offset('positive', width / 2 + touchBorderToUse);
    }

    touchBorderToUse = [[negOffset.p1, negOffset.p2, posOffset.p2, posOffset.p1]];
  }

  return [points, borderToUse, touchBorderToUse];
}

/* harmony default export */ __webpack_exports__["default"] = (getLine);

/***/ }),

/***/ "./src/js/figure/geometries/lines/corners.js":
/*!***************************************************!*\
  !*** ./src/js/figure/geometries/lines/corners.js ***!
  \***************************************************/
/*! exports provided: circleCorner, cutCorner, cornerLine, makeCorner, lineToCorners */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleCorner", function() { return circleCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cutCorner", function() { return cutCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cornerLine", function() { return cornerLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeCorner", function() { return makeCorner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineToCorners", function() { return lineToCorners; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

 //
// Make a circular corner between points - P2 and p3 must be the same
// distance from p1
//
//               .....................................
//          p3  0                                     0 center
//              0                                  0  .
//              0                               0   b .
//              0                            0        .
//              0                         0           .
//              0                C     0              .
//              0                   0                 .
//              0                0                    .  A
//              0             0                       .
//              0          0                          .
//              0       0                             .
//              0    0                                .
//              0 0  a                              c .
//              000000000000000000000000000000000000000
//          p1                     B                    p2
//
//

function circleCorner(p2in, p1, p3in, sides) {
  // If sides is 0 or negative, then return the original points
  if (sides < 1) {
    return [p2in._dup(), p1._dup(), p3in._dup()];
  } // If sides is 1, then return the chamfer


  if (sides === 1) {
    return [p2in._dup(), p3in._dup()];
  }

  var p2 = p2in._dup();

  var p3 = p3in._dup();

  var points = [];

  var _2a = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngleMin"])(p2, p1, p3);

  if (_2a === Math.PI) {
    points.push(p2in._dup());

    for (var i = 0; i < sides - 2; i += 1) {
      points.push(p1._dup());
    }

    points.push(p3in._dup());
    return points;
  } // if equal to 0, that means the lines are going back on top of each other
  // in which case we still want a radius at the end, so make it small and
  // unnoticable


  var isZero = false; // let zeroMag = 0.0001;

  if (_2a === 0) {
    isZero = true;
    _2a = 0.00001;
  }

  var direction = _2a / Math.abs(_2a);

  var line12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var a = Math.abs(_2a / 2);
  var c = Math.PI / 2;
  var b = Math.PI - a - c;
  var B = line12.length();
  var C = Math.sin(c) / Math.sin(b) * B; // const C = B / Math.cos(a);

  var center = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p1.x + C * Math.cos(a * direction + line12.angle()), p1.y + C * Math.sin(a * direction + line12.angle()));

  var _2b = b * 2;

  var delta = _2b / sides * direction * -1;
  var lineC2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](center, p2);
  var angleC2 = lineC2.angle();
  var magC2 = lineC2.length();
  points.push(p2); // If the angle is zero, then we want to draw a pho (very small) polyline
  // that will simulate a radius at the end

  if (isZero) {
    var mag = 0.0001;
    var ang12 = line12.angle() + Math.PI / 2;
    var deltaZero = Math.PI / sides;

    for (var _i = 0; _i <= sides; _i += 1) {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](center.x + mag * Math.cos(ang12 + deltaZero * _i), center.y + mag * Math.sin(ang12 + deltaZero * _i)));
    }
  } else {
    for (var _i2 = 0; _i2 < sides - 1; _i2 += 1) {
      var angle = angleC2 + (_i2 + 1) * delta;
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](center.x + magC2 * Math.cos(angle), center.y + magC2 * Math.sin(angle)));
    }
  }

  points.push(p3); // if (reverse) {
  //   return points.reverse();
  // }

  return points;
}

function cutCorner(p2, p1, p3, sides, style, value) {
  var line12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var line13 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p3);
  var cut;

  if (style === 'fromVertex') {
    cut = value;
    cut = Math.min(cut, line12.length() / 2 * 0.99, line13.length() / 2 * 0.99);
  } else if (style === 'radius') {
    var angle = Math.abs(Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngleMin"])(p2, p1, p3)) / 2;
    cut = value / Math.tan(angle);
    cut = Math.min(cut, line12.length() / 2 * 0.99, line13.length() / 2 * 0.99);
  } else {
    // if (style === 'max')
    cut = Math.min(line12.length(), line13.length());
  } // cut = Math.min(cut, line12.length() / 2 * 0.99, line13.length() / 2 * 0.99);


  var p2Max = line12.pointAtPercent(cut / line12.length());
  var p3Max = line13.pointAtPercent(cut / line13.length());
  return circleCorner(p2Max, p1, p3Max, sides);
}

function cornerLine(pointsIn, close, type, sides, size) {
  var points = [];

  if (close) {
    points = cutCorner(pointsIn[pointsIn.length - 1], pointsIn[0], pointsIn[1], sides, type, size);
  } else {
    points.push(pointsIn[0]);
  }

  for (var i = 1; i < pointsIn.length - 1; i += 1) {
    var corner = cutCorner(pointsIn[i - 1], pointsIn[i], pointsIn[i + 1], sides, type, size);
    points = [].concat(_toConsumableArray(points), _toConsumableArray(corner));
  }

  if (close) {
    points = [].concat(_toConsumableArray(points), _toConsumableArray(cutCorner(pointsIn[pointsIn.length - 2], pointsIn[pointsIn.length - 1], pointsIn[0], sides, type, size)));
  } else {
    points.push(pointsIn[pointsIn.length - 1]._dup());
  }

  return points;
}

function makeCorner(p2, p1, p3, length) {
  var forceLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var line12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var line13 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p3);
  var newP2 = line12.pointAtPercent(length / line12.length());
  var newP3 = line13.pointAtPercent(length / line13.length());

  if (forceLength === false) {
    if (length > line12.length()) {
      newP2 = p2._dup();
    }

    if (length > line13.length()) {
      newP3 = p3._dup();
    }
  }

  return [newP2, p1._dup(), newP3];
}

function lineToCorners(pointsIn, close, length) {
  var forceLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var corners = [];

  for (var i = 1; i < pointsIn.length - 1; i += 1) {
    corners.push(makeCorner(pointsIn[i - 1], pointsIn[i], pointsIn[i + 1], length, forceLength));
  }

  if (close) {
    corners.push(makeCorner(pointsIn[pointsIn.length - 2], pointsIn[pointsIn.length - 1], pointsIn[0], length, forceLength));
    corners.push(makeCorner(pointsIn[pointsIn.length - 1], pointsIn[0], pointsIn[1], length, forceLength));
  }

  return corners;
}



/***/ }),

/***/ "./src/js/figure/geometries/lines/dashes.js":
/*!**************************************************!*\
  !*** ./src/js/figure/geometries/lines/dashes.js ***!
  \**************************************************/
/*! exports provided: getDashElementAndRemainder, makeDashDefinition, makeDashes, lineToDash */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDashElementAndRemainder", function() { return getDashElementAndRemainder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDashDefinition", function() { return makeDashDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeDashes", function() { return makeDashes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineToDash", function() { return lineToDash; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tools/math */ "./src/js/tools/math.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




function makeDashDefinition(dashes) {
  var cum = [];
  var cycleLength = dashes.reduce(function (p, sum) {
    cum.push(p + sum);
    return p + sum;
  }, 0);
  return {
    definition: dashes,
    sum: cycleLength,
    cum: cum
  };
}

function getDashElementAndRemainder(dash, offset) {
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
  var singleCycleOffset;

  if (offset > dash.sum) {
    singleCycleOffset = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(offset % dash.sum, precision);
  } else {
    singleCycleOffset = offset;
  }

  for (var i = 0; i < dash.definition.length; i += 1) {
    if (singleCycleOffset < dash.cum[i]) {
      return [i, Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(dash.cum[i] - singleCycleOffset, precision)];
    }

    if (singleCycleOffset === dash.cum[i]) {
      if (i + 1 < dash.definition.length) {
        return [i + 1, Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(dash.cum[i + 1] - singleCycleOffset, precision)];
      }

      return [0, Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(dash.cum[0], precision)];
    }
  }

  return [0, 0];
}

function makeDashes(dash, p1, p2, offset) {
  var precision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 8;
  var points = [];
  var cumDistance = 0; // eslint-disable-next-line prefer-const

  var _getDashElementAndRem = getDashElementAndRemainder(dash, offset, precision),
      _getDashElementAndRem2 = _slicedToArray(_getDashElementAndRem, 2),
      index = _getDashElementAndRem2[0],
      remainder = _getDashElementAndRem2[1];

  var onLine = true;
  var line12 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](p1, p2);
  var totLength = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(line12.length(), precision);
  var dashLength = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(remainder, precision);
  var lastIndex = index;

  while (cumDistance < totLength) {
    var isOnLine = index % 2 === 0;
    onLine = isOnLine;

    if (isOnLine) {
      var q1 = line12.pointAtPercent(cumDistance / totLength);
      var q2 = void 0;

      if (Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(cumDistance + dashLength, precision) <= totLength) {
        q2 = line12.pointAtPercent((cumDistance + dashLength) / totLength);
        cumDistance += dashLength;
      } else {
        q2 = p2._dup();
        cumDistance += dashLength;
      }

      points.push([q1, q2]);
    } else {
      cumDistance += dashLength;
    }

    cumDistance = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(cumDistance, precision);
    lastIndex = index;
    index = (index + 1) % dash.definition.length;
    dashLength = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(dash.definition[index], precision);
  }

  return {
    points: points,
    continues: cumDistance > totLength && lastIndex % 2 === 0,
    onLine: onLine
  };
}

function lineToDash(points, dash) {
  var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
  var dashToUse = dash;
  var offset = 0;

  if (dash.length % 2 === 1) {
    dashToUse = dash.slice(1);

    var _dash = _slicedToArray(dash, 1);

    offset = _dash[0];
  }

  var out = [];
  var dd = makeDashDefinition(dashToUse);
  var cumLength = offset;
  var lastContinue = false;
  var onLine = true;

  var processLine = function processLine(p1, p2) {
    var dashes = makeDashes(dd, p1, p2, cumLength, precision);
    onLine = dashes.onLine;
    var dashLines = dashes.points;
    var dashContinues = dashes.continues;

    if (lastContinue && dashLines[0] != null) {
      out[out.length - 1] = [].concat(_toConsumableArray(out[out.length - 1]), _toConsumableArray(dashLines[0].slice(1)));
      out = [].concat(_toConsumableArray(out), _toConsumableArray(dashLines.slice(1)));
    } else {
      out = [].concat(_toConsumableArray(out), _toConsumableArray(dashLines));
    }

    lastContinue = dashContinues;
    cumLength = Object(_tools_math__WEBPACK_IMPORTED_MODULE_1__["roundNum"])(cumLength + Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["distance"])(p1, p2), precision);
  };

  for (var i = 0; i < points.length - 1; i += 1) {
    var p1 = points[i];
    var p2 = points[i + 1];
    processLine(p1, p2);
  }

  if (close) {
    var _p = points[points.length - 1];
    var _p2 = points[0];
    processLine(_p, _p2);

    var _getDashElementAndRem3 = getDashElementAndRemainder(dd, offset),
        _getDashElementAndRem4 = _slicedToArray(_getDashElementAndRem3, 1),
        startIndex = _getDashElementAndRem4[0]; // const startIsOnLine = startIndex % 2 === 0;


    if (lastContinue && startIndex % 2 === 0 && out.length > 1) {
      out[0] = [].concat(_toConsumableArray(out[out.length - 1]), _toConsumableArray(out[0].slice(1)));
    }
  }

  return [out, onLine];
}



/***/ }),

/***/ "./src/js/figure/geometries/lines/lines.js":
/*!*************************************************!*\
  !*** ./src/js/figure/geometries/lines/lines.js ***!
  \*************************************************/
/*! exports provided: joinLinesInPoint, lineSegmentsToPoints, joinLinesInTangent, makePolyLine, makePolyLineCorners, addArrows, makeFastPolyLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinLinesInPoint", function() { return joinLinesInPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineSegmentsToPoints", function() { return lineSegmentsToPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinLinesInTangent", function() { return joinLinesInTangent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makePolyLine", function() { return makePolyLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makePolyLineCorners", function() { return makePolyLineCorners; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addArrows", function() { return addArrows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeFastPolyLine", function() { return makeFastPolyLine; });
/* harmony import */ var _corners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./corners */ "./src/js/figure/geometries/lines/corners.js");
/* harmony import */ var _dashes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dashes */ "./src/js/figure/geometries/lines/dashes.js");
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../tools/tools */ "./src/js/tools/tools.js");
/* harmony import */ var _arrow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../arrow */ "./src/js/figure/geometries/arrow.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







// import { getBufferBorder } from '../buffer';

/* eslint-disable yoda */
// A thick line is defined from:
//  * A reference line
//  * A width
//  * Where the reference line is relative to the width
//    ('mid', 'inside', 'outside')
//  * How to deal with the corners in the line
//
// Convert line segments that define the outer boundaries of a line into
// triangles for drawing in WebGL
//
//                        outside
// p1    ----------------------------------------------   p2
//       2, 4
//
//       1                                         3, 5
// p1    ----------------------------------------------   p2
//                        inside
//
function lineSegmentsToPoints(lineSegments, linePrimitives) {
  var borderIs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'line';
  var holeIs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [[]];
  var corner = arguments.length > 4 ? arguments[4] : undefined;
  var close = arguments.length > 5 ? arguments[5] : undefined;
  var tris = []; // let border = [];
  // console.log(lineSegments)

  var hole = [[]];
  var positiveBorder = [];
  var negativeBorder = [];
  lineSegments.forEach(function (lineSegment, index) {
    var negative = lineSegment[0];
    var positive = lineSegment.slice(-1)[0];

    if (linePrimitives) {
      for (var l = 0; l < lineSegment.length; l += 1) {
        tris.push(lineSegment[l].p1._dup());
        tris.push(lineSegment[l].p2._dup());
      }
    } else {
      tris.push(positive.p1._dup());
      tris.push(positive.p2._dup());
      tris.push(negative.p1._dup());
      tris.push(negative.p1._dup());
      tris.push(positive.p2._dup());
      tris.push(negative.p2._dup());
    }

    if (index === 0 || positiveBorder[positiveBorder.length - 1].isNotEqualTo(positive.p1)) {
      positiveBorder.push(positive.p1._dup());
    }

    if (close === false || index < lineSegments.length - 1 || index === lineSegments.length - 1 && positiveBorder[0].isNotEqualTo(positive.p2)) {
      positiveBorder.push(positive.p2._dup());
    }

    if (index === 0 || negativeBorder[negativeBorder.length - 1].isNotEqualTo(negative.p1)) {
      negativeBorder.push(negative.p1._dup());
    } // negative.p2._dup();


    if (close === false || index < lineSegments.length - 1 || index === lineSegments.length - 1 && negativeBorder[0].isNotEqualTo(negative.p2)) {
      negativeBorder.push(negative.p2._dup());
    } // positiveBorder.push(positive.p1._dup(), positive.p2._dup());
    // negativeBorder.push(negative.p1._dup(), negative.p2._dup());


    if (corner === 'fill' || corner === 'auto') {
      var nextLineSegment;

      if (index < lineSegments.length - 1) {
        nextLineSegment = lineSegments[index + 1];
      } else if (close) {
        var _lineSegments = _slicedToArray(lineSegments, 1);

        nextLineSegment = _lineSegments[0];
      }

      if (nextLineSegment != null) {
        var nextNegative = nextLineSegment[0];
        var nextPositive = nextLineSegment.slice(-1)[0];

        if (linePrimitives) {
          if (nextNegative.p1.isNotEqualTo(negative.p2, 10)) {
            tris.push(negative.p2._dup());
            tris.push(nextNegative.p1._dup());
          }

          if (nextPositive.p1.isNotEqualTo(positive.p2, 10)) {
            tris.push(positive.p2._dup());
            tris.push(nextPositive.p1._dup());
          }
        } else {
          if (nextNegative.p1.isNotEqualTo(negative.p2, 10)) {
            tris.push(negative.p2._dup());
            tris.push(positive.p2._dup());
            tris.push(nextNegative.p1._dup());
          }

          if (nextPositive.p1.isNotEqualTo(positive.p2, 10)) {
            tris.push(positive.p2._dup());
            tris.push(nextPositive.p1._dup());
            tris.push(negative.p2._dup());
          }
        }
      }
    } // if (borderIs === 'line') {
    //   border.push([
    //     negative.p1._dup(),
    //     negative.p2._dup(),
    //     positive.p2._dup(),
    //     positive.p1._dup(),
    //   ]);
    // } else if (borderIs === 'negative') {
    //   if (border.length === 0) {
    //     border.push([]);
    //   }
    //   border[0].push(
    //     negative.p1._dup(),
    //     negative.p2._dup(),
    //   );
    // } else if (borderIs === 'positive') {
    //   if (border.length === 0) {
    //     border.push([]);
    //   }
    //   border[0].push(
    //     positive.p1._dup(),
    //     positive.p2._dup(),
    //   );
    // }


    if (holeIs === 'positive') {
      hole[0].push(positive.p1._dup(), positive.p2._dup());
    } else if (holeIs === 'negative') {
      hole[0].push(negative.p1._dup(), negative.p2._dup());
    }
  });
  var border = [[]]; // console.log(borderIs)

  if (borderIs === 'positive') {
    border = [positiveBorder];
  } else if (borderIs === 'negative') {
    border = [negativeBorder];
  } else if (borderIs === 'line') {
    if (close === false) {
      border = [[].concat(negativeBorder, _toConsumableArray(positiveBorder.reverse()))];
    } else {
      border = [[].concat(negativeBorder, [negativeBorder[0], positiveBorder[0]], _toConsumableArray(positiveBorder.reverse()))];
    }
  } else if (Array.isArray(borderIs)) {
    border = borderIs;
  } // console.log(border)


  if (Array.isArray(holeIs)) {
    hole = holeIs;
  } // console.log(borderIs, border)


  return [tris, border, hole];
} // Extend two lines to their intersection point


function joinLinesInPoint(line1, lineNext, corner) {
  var intersect = line1.intersectsWith(lineNext);

  if (!intersect.withinLine && corner === 'fill') {
    return;
  }

  if (intersect.intersect != null) {
    line1.setP2(intersect.intersect._dup()); // $FlowFixMe

    lineNext.setP1(intersect.intersect._dup());
  }
} //                    2       2        2
//                    N     o N        N
//                       No      N        N
//                      o   N       N        N
//                    o        N       N        N
//                   o            N       N        N
//            angle o                N       N        N
//                 o                    N       N        N        / Tangent
//                 o                       N  1    N        N  1 /
//                o                           N       N        N/
//  in   000000000o000000000000000000000000000000        N  1  /
//       1        o                            2            N /
//  mid  0000000000000000000000000000000000000000000000000000/
//       1                                                2 /
//  out  00000000000000000000000000000000000000000000000000/
//       1                                              2 /
//                                                       /
//
// Note, for simplicity, both inside and outside can intercept with tangent
// and geometry is valid.


function joinLinesInTangent( // inside: Line,
// insideNext: Line,
mid, midNext, outside, outsideNext, corner) {
  var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngleMin"])(mid.p1, mid.p2, midNext.p2);
  var tangent = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](mid.p2, 1, mid.angle() + angle / 2 + Math.PI / 2);
  var intercept = outside.intersectsWith(tangent);
  var interceptNext = outsideNext.intersectsWith(tangent); // if (intercept.withinLine === false && interceptNext.withinLine === false) {
  //   const i = outside.intersectsWith(outsideNext);
  //   if (i.intersect != null) {
  //     outside.setP2(i.intersect);
  //     outsideNext.setP1(interceptNext.intersect);
  //     return;
  //   }
  // }

  if (corner === 'fill') {
    return;
  } // let intercept = tangent.intersectsWith(outside);


  if (intercept.intersect != null) {
    outside.setP2(intercept.intersect);
  } // intercept = tangent.intersectsWith(outsideNext);


  if (interceptNext.intersect != null) {
    outsideNext.setP1(interceptNext.intersect);
  }
}

function joinLinesAcuteInside(mid, midNext, inside, insideNext, linePrimitives) {
  var insideIntercept = inside.intersectsWith(insideNext);
  var withinLine = insideIntercept.withinLine,
      intersect = insideIntercept.intersect;

  if (withinLine && intersect != null) {
    inside.setP2(intersect);
    insideNext.setP1(intersect);
    return;
  }

  if (!linePrimitives) {
    var intercept = inside.intersectsWith(midNext);

    if (intercept.intersect != null && intercept.withinLine) {
      inside.setP2(intercept.intersect);
    }

    intercept = insideNext.intersectsWith(mid);

    if (intercept.intersect != null && intercept.withinLine) {
      insideNext.setP1(intercept.intersect);
    }
  }
}

function joinLinesObtuseInside(mid, midNext, inside, insideNext) {
  var insideIntercept = inside.intersectsWith(insideNext);
  var withinLine = insideIntercept.withinLine,
      intersect = insideIntercept.intersect;

  if (withinLine && intersect != null) {
    inside.setP2(intersect);
    insideNext.setP1(intersect);
    return;
  }

  var intercept = inside.intersectsWith(midNext);

  if (intercept.intersect != null && intercept.intersect.isWithinLine(midNext, 8)) {
    inside.setP2(intercept.intersect);
  }

  intercept = insideNext.intersectsWith(mid);

  if (intercept.intersect != null && intercept.intersect.isWithinLine(mid, 8)) {
    insideNext.setP1(intercept.intersect);
  }
}

function makeLineSegments(points, width, close, cornerStyle, widthIs, isInside) {
  var numLines = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 2;
  var idealLines = [];

  var makeLine = function makeLine(p1, p2) {
    return new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](p1, p2);
  };

  for (var i = 0; i < points.length - 1; i += 1) {
    idealLines.push(makeLine(points[i], points[i + 1]));
  }

  if (close) {
    idealLines.push(makeLine(points[points.length - 1], points[0]));
  }

  var segmentSides = [];
  var neg = 'negative';
  var pos = 'positive';
  var mid = 'mid'; // lineSegments should be more negative to more positive

  var lineSegments = [];

  var makeOffset = function makeOffset(prev, current, next, offset, index) {
    var minNegativeOffset = offset;
    var minPositiveOffset = offset;
    var prevAngle = Math.PI;

    if (prev != null) {
      prevAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(prev.p1, current.p1, current.p2);
      var minPrevAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngleMin"])(prev.p1, current.p1, current.p2);
      var minPrevOffset = current.distanceToPoint(prev.p1);
      var minOffset = Math.min(minPrevOffset, Math.tan(Math.abs(minPrevAngle)) * current.length()); // Negative side is inside angle

      if (prevAngle < Math.PI / 2) {
        minNegativeOffset = Math.min(minNegativeOffset, minOffset);
      } else if (prevAngle > Math.PI / 2 * 3) {
        minPositiveOffset = Math.min(minPositiveOffset, minOffset);
      }
    }

    var nextAngle = Math.PI;

    if (next != null) {
      nextAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(current.p1, current.p2, next.p2);
      var minNextAngle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngleMin"])(current.p1, current.p2, next.p2);
      var minNextOffset = current.distanceToPoint(next.p2);

      var _minOffset = Math.min(minNextOffset, Math.tan(Math.abs(minNextAngle)) * current.length());

      if (nextAngle < Math.PI / 2) {
        minNegativeOffset = Math.min(minNegativeOffset, _minOffset);
      } else if (nextAngle > Math.PI / 2 * 3) {
        minPositiveOffset = Math.min(minPositiveOffset, _minOffset);
      }
    } // let negativeLine;
    // let positiveLine;


    var offsetLine; // console.log(widthIs)
    // console.log(prevAngle, nextAngle)

    if (widthIs === 'negative') {
      if (cornerStyle === 'auto' && (isInside || prevAngle < Math.PI || nextAngle < Math.PI)) {
        offsetLine = current.offset('negative', minNegativeOffset);
      } else {
        offsetLine = current.offset('negative', offset);
      }
    } else if (widthIs === 'positive') {
      if (cornerStyle === 'auto' && (isInside || prevAngle > Math.PI || nextAngle > Math.PI)) {
        // console.log('min')
        offsetLine = current.offset('positive', minPositiveOffset);
      } else {
        offsetLine = current.offset('positive', offset);
      } // otherwise widthIs === 'mid'

    } else {
      offsetLine = current.offset('positive', offset);
    } // if (cornerStyle === 'auto' && widthIs !== 'mid') {
    //   negativeLine = current.offset('negative', minNegativeOffset);
    //   positiveLine = current.offset('positive', minPositiveOffset);
    // } else {
    //   negativeLine = current.offset('negative', offset);
    //   positiveLine = current.offset('positive', offset);
    // }


    lineSegments[index].push(offsetLine);
  };

  var step = width / (numLines - 1);

  for (var _i2 = 0; _i2 < idealLines.length; _i2 += 1) {
    var prev = _i2 > 0 ? idealLines[_i2 - 1] : null;
    var current = idealLines[_i2];
    var next = _i2 < idealLines.length - 1 ? idealLines[_i2 + 1] : null;

    if (close && _i2 === 0) {
      prev = idealLines[idealLines.length - 1];
    }

    if (close && _i2 === idealLines.length - 1) {
      // eslint-disable-next-line prefer-destructuring
      next = idealLines[0];
    }

    lineSegments.push([]);
    segmentSides.push([]);

    if (widthIs === 'negative' || widthIs === 'positive') {
      lineSegments[_i2].push(current._dup());

      segmentSides[_i2].push(mid);
    } else if (numLines === 1) {
      lineSegments[_i2].push(current._dup());

      segmentSides[_i2].push(mid);
    } else if (typeof widthIs === 'number') {
      var offsetLine = current.offset('negative', widthIs * width);

      lineSegments[_i2].push(offsetLine);

      segmentSides[_i2].push(neg);
    } else {
      var _offsetLine = current.offset('negative', width / 2);

      lineSegments[_i2].push(_offsetLine);

      segmentSides[_i2].push(neg);
    }

    for (var l = 1; l < numLines; l += 1) {
      if (widthIs === 'negative') {
        makeOffset(prev, current, next, l * step, _i2);

        segmentSides[_i2].push(neg);
      } else if (widthIs === 'positive') {
        makeOffset(prev, current, next, l * step, _i2);

        segmentSides[_i2].push(pos);
      } else if (typeof widthIs === 'number') {
        makeOffset(prev, current, next, -widthIs * width + l * step, _i2);

        segmentSides[_i2].push(-widthIs * width + l * step > 0 ? pos : neg);
      } else {
        makeOffset(prev, current, next, -width / 2 + l * step, _i2);

        segmentSides[_i2].push(-width / 2 + l * step > 0 ? pos : neg);
      }
    }

    if (widthIs === 'negative') {
      lineSegments[_i2].reverse();

      segmentSides[_i2].reverse();
    }
  } // console.log(idealLines, lineSegments, segmentSides)


  return [idealLines, lineSegments, segmentSides];
}

function getWidthIs(points, close, widthIs) {
  if (widthIs === 'mid' || widthIs === 'negative' || widthIs === 'positive' || typeof widthIs === 'number') {
    return widthIs;
  }

  var numInsideNegativeAngles = 0;
  var totAngles = close ? points.length : points.length - 2;

  var testAngle = function testAngle(p2, p1, p3) {
    var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(p2, p1, p3);

    if (angle < Math.PI) {
      numInsideNegativeAngles += 1;
    }

    if (angle === Math.PI) {
      totAngles -= 1;
    }
  };

  for (var i = 1; i < points.length - 1; i += 1) {
    testAngle(points[i - 1], points[i], points[i + 1]);
  }

  if (close) {
    testAngle(points[points.length - 1], points[0], points[1]);
    testAngle(points[points.length - 2], points[points.length - 1], points[0]);
  }

  if (numInsideNegativeAngles >= totAngles / 2) {
    if (widthIs === 'inside') {
      return 'negative';
    }

    return 'positive';
  }

  if (widthIs === 'inside') {
    return 'positive';
  }

  return 'negative';
}

function makeThickLine(points) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;
  var widthIsIn = arguments.length > 2 ? arguments[2] : undefined;
  var widthIsInside = arguments.length > 3 ? arguments[3] : undefined;
  var close = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var corner = arguments.length > 5 ? arguments[5] : undefined;
  var minAngleIn = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI / 7;
  var linePrimitives = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var lineNum = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 2;
  var borderIs = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 'line';
  var holeIs = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : [[]];
  var widthToUse = width; // if (widthIsIn === 'mid') {
  //   widthToUse = width / 2;
  // }
  // let widthIs = getWidthIs(points, close, widthIsIn);

  var _makeLineSegments = makeLineSegments(points, widthToUse, close, corner, widthIsIn, widthIsInside, lineNum),
      _makeLineSegments2 = _slicedToArray(_makeLineSegments, 3),
      idealLines = _makeLineSegments2[0],
      lineSegments = _makeLineSegments2[1],
      segmentSides = _makeLineSegments2[2];

  var widthIs = widthIsIn;

  if (typeof widthIs === 'number') {
    widthIs = 'mid';
  } // console.log(points, idealLines, lineSegments)
  // Join line segments based on the angle between them


  var minAngle = minAngleIn == null ? 0 : minAngleIn;

  var joinLineSegments = function joinLineSegments(currentIndex, nextIndex, lineIndex) {
    var mid = idealLines[currentIndex];
    var midNext = idealLines[nextIndex];
    var lineSegment = lineSegments[currentIndex][lineIndex];
    var lineSegmentNext = lineSegments[nextIndex][lineIndex]; // const [positive, mid, negative] = lineSegments[current];
    // const [positiveNext, midNext, negativeNext] = lineSegments[next];

    var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_2__["threePointAngle"])(mid.p1, mid.p2, midNext.p2); // If the angle is less than 180, then the 'negative' line segments are
    // on the outside of the angle.
    // console.log(currentIndex, lineIndex, angle)

    var segmentSide = segmentSides[currentIndex][lineIndex];

    if (0 < angle && angle < minAngle) {
      if (segmentSide === 'mid') {
        joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext, corner); // joinLinesInTangent(mid, midNext, positive, positiveNext);
      } else if (segmentSide === 'negative') {
        joinLinesAcuteInside(mid, midNext, lineSegment, lineSegmentNext, linePrimitives);
      } else if (segmentSide === 'positive') {
        joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext, corner);
      }
    } else if (minAngle <= angle && angle <= Math.PI / 2) {
      if (segmentSide === 'mid') {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner); // joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (segmentSide === 'negative') {
        joinLinesAcuteInside(mid, midNext, lineSegment, lineSegmentNext, linePrimitives);
      } else if (segmentSide === 'positive') {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner);
      } // If the angle is greater than the minAngle, then the line segments can
      // be connected directly

    } else if (Math.PI / 2 <= angle && angle < Math.PI) {
      if (segmentSide === 'mid' || typeof widthIs === 'number') {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner); // joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (segmentSide === 'negative') {
        joinLinesObtuseInside(mid, midNext, lineSegment, lineSegmentNext);
      } else if (segmentSide === 'positive') {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner);
      }
    } else if (angle === Math.PI) {
      if (segmentSide === 'negative') {
        // if (widthIsIn === 'inside') {
        //   joinLinesObtuseInside(mid, midNext, lineSegment, lineSegmentNext);
        // } else {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner); // }
      } else if (segmentSide === 'positive') {
        // if (widthIsIn === 'inside') {
        //   joinLinesObtuseInside(mid, midNext, lineSegment, lineSegmentNext);
        // } else {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner); // }
      } // If the angle is greater than 180, then the positive side is on the
      // inside of the angle

    } else if (Math.PI < angle && angle < Math.PI / 2 * 3) {
      if (segmentSide === 'mid') {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner);
        joinLinesInPoint(lineSegment, lineSegmentNext, corner);
      } else if (segmentSide === 'negative') {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner);
      } else if (segmentSide === 'positive') {
        joinLinesObtuseInside(mid, midNext, lineSegment, lineSegmentNext);
      } //

    } else if (Math.PI / 2 * 3 <= angle && angle <= Math.PI * 2 - minAngle) {
      if (segmentSide === 'mid') {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner); // joinLinesInPoint(lineSegment, lineSegmentNext);
      } else if (segmentSide === 'negative') {
        joinLinesInPoint(lineSegment, lineSegmentNext, corner);
      } else if (segmentSide === 'positive') {
        joinLinesAcuteInside(mid, midNext, lineSegment, lineSegmentNext, linePrimitives);
      } //

    } else if (Math.PI * 2 - minAngle < angle && angle < Math.PI * 2) {
      // console.log('asdf', segmentSide);
      // console.log(segmentSide)
      if (segmentSide === 'mid') {
        joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext, corner); // joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext);
      } else if (segmentSide === 'negative') {
        joinLinesInTangent(mid, midNext, lineSegment, lineSegmentNext, corner);
      } else if (segmentSide === 'positive') {
        joinLinesAcuteInside(mid, midNext, lineSegment, lineSegmentNext, linePrimitives);
      } // console.log(lineSegment)

    } else if (angle === Math.PI * 2 || angle === 0) {// do nothing
      // if (widthIs === 'mid') {
      //   joinLinesInPoint(lineSegment, lineSegmentNext);
      //   // joinLinesInPoint(lineSegment, lineSegmentNext);
      // } else if (widthIs === 'negative') {
      //   joinLinesInPoint(lineSegment, lineSegmentNext);
      // } else if (widthIs === 'positive') {
      //   joinLinesInPoint(lineSegment, lineSegmentNext);
      // }
    } // if (lineSegments.length >= 2) {
    //   console.log(currentIndex, lineIndex, lineSegments[2][0]._dup())
    // }

  }; // Create fill triangles between the positive & mid, and negative and mid lines


  var cornerFills = []; // const createFill = (currentIndex, nextIndex) => {
  //   const mid = idealLines[currentIndex];
  //   const midNext = idealLines[nextIndex];
  //   const positive = lineSegments[currentIndex].slice(-1)[0];
  //   const positiveNext = lineSegments[nextIndex].slice(-1)[0];
  //   const negative = lineSegments[currentIndex][0];
  //   const negativeNext = lineSegments[nextIndex][0];
  //   const angle = threePointAngle(mid.p1, mid.p2, midNext.p2);
  //   if (linePrimitives) {
  //     for (let i = 0; i < lineSegments[currentIndex].length; i += 1) {
  //       cornerFills.push(lineSegments[currentIndex][i].p2._dup());
  //       cornerFills.push(lineSegments[nextIndex][i].p1._dup());
  //     }
  //   } else if (angle < Math.PI) {
  //     if (widthIsIn !== 'inside') {
  //       cornerFills.push(positive.p2._dup());
  //       cornerFills.push(mid.p2._dup());
  //       cornerFills.push(positiveNext.p1._dup());
  //     }
  //   } else if (angle > Math.PI) {
  //     if (widthIsIn !== 'inside') {
  //       cornerFills.push(negative.p2._dup());
  //       cornerFills.push(mid.p2._dup());
  //       cornerFills.push(negativeNext.p1._dup());
  //     }
  //   }
  // };
  // NB: this all assumes the GL primitive is TRIANGLES. Thus the order the
  // triangles is drawn is not important, and so fills can happen in chunks.

  if (corner !== 'none') {
    for (var l = 0; l < lineNum; l += 1) {
      for (var i = 0; i < lineSegments.length - 1; i += 1) {
        // if (l === 0 && linePrimitives) {
        //   createFill(i, i + 1);
        // } else {
        joinLineSegments(i, i + 1, l); // }
        // if (corner === 'auto') {
        //   joinLineSegments(i, i + 1, l);
        // } else if (l === 0 && linePrimitives) {
        //   createFill(i, i + 1);
        // }
      }

      if (close) {
        // if (l === 0 && linePrimitives) {
        //   createFill(lineSegments.length - 1, 0);
        // } else {
        joinLineSegments(lineSegments.length - 1, 0, l); // }
        // if (corner === 'auto') {
        //   joinLineSegments(lineSegments.length - 1, 0, l);
        // } else if (l === 0 && linePrimitives) {
        //   createFill(lineSegments.length - 1, 0);
        // }
      }
    }
  }

  var _lineSegmentsToPoints = lineSegmentsToPoints(lineSegments, linePrimitives, borderIs, holeIs, corner, close),
      _lineSegmentsToPoints2 = _slicedToArray(_lineSegmentsToPoints, 3),
      tris = _lineSegmentsToPoints2[0],
      border = _lineSegmentsToPoints2[1],
      hole = _lineSegmentsToPoints2[2]; // if (close === false) {
  //   return [[...tris, ...cornerFills], [[...border[0]], [...hole]];
  // }


  return [[].concat(_toConsumableArray(tris), cornerFills), border, hole];
} // from https://mathworld.wolfram.com/Circle-LineIntersection.html


function circleLineIntersection(center, radius, lineIn) {
  var offsetToZero = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](-center.x, -center.y);
  var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](lineIn.p1.add(offsetToZero), lineIn.p2.add(offsetToZero));
  var x1 = line.p1.x;
  var y1 = line.p1.y;
  var x2 = line.p2.x;
  var y2 = line.p2.y;
  var dx = x2 - x1;
  var dy = y2 - y1;
  var dr = Math.sqrt(dx * dx + dy * dy);
  var D = x1 * y2 - x2 * y1;
  var r = radius;

  var sgn = function sgn(value) {
    return value < 0 ? -1 : 1;
  };

  var i1x = (D * dy + sgn(dy) * dx * Math.sqrt(r * r * dr * dr - D * D)) / (dr * dr);
  var i2x = (D * dy - sgn(dy) * dx * Math.sqrt(r * r * dr * dr - D * D)) / (dr * dr);
  var i1y = (-D * dx + Math.abs(dy) * Math.sqrt(r * r * dr * dr - D * D)) / (dr * dr);
  var i2y = (-D * dx - Math.abs(dy) * Math.sqrt(r * r * dr * dr - D * D)) / (dr * dr);
  var intersections = []; // eslint-disable-next-line no-restricted-globals

  if (!isNaN(i1x) && !isNaN(i1y)) {
    var i = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](i1x, i1y).sub(offsetToZero);

    if (lineIn.hasPointOn(i)) {
      intersections.push(i);
    }
  } // eslint-disable-next-line no-restricted-globals


  if (!isNaN(i2x) && !isNaN(i2y)) {
    var _i3 = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](i2x, i2y).sub(offsetToZero);

    if (lineIn.hasPointOn(_i3)) {
      intersections.push(_i3);
    }
  }

  return intersections;
} // From end of line
// Go back lines until distance to p1 is > arrow length
// Find intersection between circle (arrow length) and line
// That is the end of the line, and defines the arrow start


function shortenLineForArrows(points, arrow) {
  var start = arrow.start,
      end = arrow.end;
  var shortenedPoints = []; // let addStartArrow = false;

  if (start != null) {
    var startPoint = points[0];
    var index = 0;

    var _getArrowLength = Object(_arrow__WEBPACK_IMPORTED_MODULE_4__["getArrowLength"])(start),
        _getArrowLength2 = _slicedToArray(_getArrowLength, 2),
        arrowLength = _getArrowLength2[1];

    var pointFound = false;

    while (index < points.length - 1 && pointFound === false) {
      index += 1;
      var distanceToEnd = startPoint.distance(points[index]);

      if (arrowLength < distanceToEnd) {
        pointFound = true;
      }
    }

    if (pointFound) {
      var line = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](points[index - 1], points[index]);

      var _circleLineIntersecti = circleLineIntersection(startPoint, arrowLength, line),
          _circleLineIntersecti2 = _slicedToArray(_circleLineIntersecti, 1),
          intersect = _circleLineIntersecti2[0];

      if (intersect != null) {
        shortenedPoints = [intersect].concat(_toConsumableArray(points.slice(index))); // addStartArrow = true;
      }
    }
  } else {
    shortenedPoints = points;
  } // let addEndArrow = false;


  if (end != null) {
    var endPoint = points[points.length - 1];

    var _index = points.length - 1;

    var _getArrowLength3 = Object(_arrow__WEBPACK_IMPORTED_MODULE_4__["getArrowLength"])(end),
        _getArrowLength4 = _slicedToArray(_getArrowLength3, 2),
        _arrowLength = _getArrowLength4[1];

    var _pointFound = false;

    while (_index > 0 && _pointFound === false) {
      _index -= 1;

      var _distanceToEnd = endPoint.distance(points[_index]);

      if (_arrowLength < _distanceToEnd) {
        _pointFound = true;
      }
    }

    if (_pointFound) {
      var _line = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](points[_index + 1], points[_index]);

      var _circleLineIntersecti3 = circleLineIntersection(endPoint, _arrowLength, _line),
          _circleLineIntersecti4 = _slicedToArray(_circleLineIntersecti3, 1),
          _intersect = _circleLineIntersecti4[0];

      if (_intersect != null) {
        shortenedPoints = [].concat(_toConsumableArray(shortenedPoints.slice(0, _index + 1)), [_intersect]); // addEndArrow = true;
      }
    }
  }

  return shortenedPoints;
}

function makePolyLine(pointsIn) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;
  var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var widthIsIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'mid';
  var cornerStyle = arguments.length > 4 ? arguments[4] : undefined;
  var cornerSize = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.1;
  var cornerSides = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 10;
  var minAutoCornerAngle = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI / 7;
  var dash = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
  var linePrimitives = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var lineNum = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 2;
  var borderIs = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 'line';
  var touchBorderBuffer = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
  var holeIs = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : [[]];
  var arrowIn = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : null;
  var precision = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 8;
  var points = [];
  var cornerStyleToUse;
  var orderedPoints = pointsIn;
  var arrow = Object(_arrow__WEBPACK_IMPORTED_MODULE_4__["simplifyArrowOptions"])(arrowIn, width, true);

  if (close === false && arrowIn != null) {
    // $FlowFixMe
    orderedPoints = shortenLineForArrows(pointsIn, arrow);
  } // console.log(orderedPoints)
  // Convert line to line with corners


  if (cornerStyle === 'auto') {
    points = orderedPoints.map(function (p) {
      return p._dup();
    });
    cornerStyleToUse = 'auto';
  } else if (cornerStyle === 'radius') {
    points = Object(_corners__WEBPACK_IMPORTED_MODULE_0__["cornerLine"])(orderedPoints, close, 'fromVertex', cornerSides, cornerSize);
    cornerStyleToUse = 'fill';
  } else {
    cornerStyleToUse = cornerStyle;
    points = orderedPoints.map(function (p) {
      return p._dup();
    });
  }

  var widthIs = getWidthIs(points, close, widthIsIn); // Convert line to dashed line

  var dashedTris = [];
  var onLine = true;

  if (dash.length > 1) {
    var _lineToDash = Object(_dashes__WEBPACK_IMPORTED_MODULE_1__["lineToDash"])(points, dash, close, precision),
        _lineToDash2 = _slicedToArray(_lineToDash, 2),
        dashes = _lineToDash2[0],
        onDash = _lineToDash2[1];

    onLine = onDash;
    var closeDashes = false;

    if (dashes.length === 1) {
      closeDashes = close;
    }

    dashes.forEach(function (d) {
      var _makeThickLine = makeThickLine(d, width, widthIs, widthIsIn === 'inside', closeDashes, cornerStyleToUse, minAutoCornerAngle, linePrimitives, lineNum, borderIs, holeIs),
          _makeThickLine2 = _slicedToArray(_makeThickLine, 1),
          tris = _makeThickLine2[0];

      dashedTris = [].concat(_toConsumableArray(dashedTris), _toConsumableArray(tris));
    });
  } // Get tris and border of solid line


  var _makeThickLine3 = makeThickLine(points, width, widthIs, widthIsIn === 'inside', close, cornerStyleToUse, minAutoCornerAngle, linePrimitives, lineNum, borderIs, holeIs),
      _makeThickLine4 = _slicedToArray(_makeThickLine3, 3),
      tris = _makeThickLine4[0],
      border = _makeThickLine4[1],
      hole = _makeThickLine4[2]; // Get touch border if there is a buffer


  var touchBorder = border;

  if (typeof touchBorderBuffer === 'number' && touchBorderBuffer !== 0) {
    // console.log(touchBorderBuffer)
    touchBorder = []; // for (let i = 0; i < border.length; i += 1) {
    //   touchBorder.push(getBufferBorder(border[i], touchBorderBuffer));
    // }
    // touchBorder = getBufferBorder(border[0], touchBorderBuffer);

    var widthIsBuffer = 0.5;
    var widthBuffer = width + touchBorderBuffer * 2;

    if (widthIs === 'positive') {
      widthIsBuffer = touchBorderBuffer / widthBuffer;
    } else if (widthIs === 'negative') {
      widthIsBuffer = (touchBorderBuffer + width) / widthBuffer;
    } else if (widthIs === 'mid') {
      widthIsBuffer = 0.5;
    } else {
      widthIsBuffer = (touchBorderBuffer + widthIs * width) / widthBuffer;
    }

    var pointsToUse = points;

    if (close === false) {
      var firstLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](points[0], points[1]);
      var firstPoint = firstLine.pointAtLength(-touchBorderBuffer);
      var lastLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](points[points.length - 2], points[points.length - 1]);
      var lastPoint = lastLine.pointAtLength(lastLine.length() + touchBorderBuffer);
      pointsToUse = [firstPoint].concat(_toConsumableArray(points.slice(1, -1)), [lastPoint]);
    }

    var borderIsToUse = borderIs;

    if (Array.isArray(borderIs)) {
      borderIsToUse = 'line';
    }

    var _makeThickLine5 = makeThickLine(pointsToUse, widthBuffer, widthIsBuffer, widthIsIn === 'inside', close, cornerStyleToUse, minAutoCornerAngle, linePrimitives, lineNum, borderIsToUse, holeIs);

    var _makeThickLine6 = _slicedToArray(_makeThickLine5, 2);

    touchBorder = _makeThickLine6[1];
  }

  var trisToUse = dash.length > 1 ? dashedTris : tris; // if (dash.length > 1) {
  //   if (arrow != null && close === false) {
  //     return addArrows(arrow, dashedTris, border, touchBorder, hole);
  //   }
  //   return [dashedTris, border, touchBorder, hole];
  // }

  if (arrowIn != null && close === false) {
    // eslint-disable-next-line no-use-before-define
    return addArrows(arrow, [orderedPoints[0], pointsIn[0]], [orderedPoints[orderedPoints.length - 1], pointsIn[pointsIn.length - 1]], trisToUse, border, touchBorder, hole, touchBorderBuffer, width, onLine);
  } // if (close === false) {
  // }


  return [trisToUse, border, touchBorder, hole];
}

function makePolyLineCorners(pointsIn) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.01;
  var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var cornerLength = arguments.length > 3 ? arguments[3] : undefined;
  var widthIs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'mid';
  var cornerStyle = arguments.length > 5 ? arguments[5] : undefined;
  var cornerSize = arguments.length > 6 ? arguments[6] : undefined;
  var cornerSides = arguments.length > 7 ? arguments[7] : undefined;
  var minAutoCornerAngle = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Math.PI / 7;
  var linePrimitives = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var lineNum = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
  var drawBorderBuffer = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
  // split line into corners
  var corners = Object(_corners__WEBPACK_IMPORTED_MODULE_0__["lineToCorners"])(pointsIn, close, cornerLength, false);
  var tris = [];
  var borders = [];
  var holes = [];
  var borderBuffers = [];
  var drawBorderBufferToUse = 0;

  if (typeof drawBorderBuffer === 'number') {
    drawBorderBufferToUse = drawBorderBuffer;
  }

  corners.forEach(function (corner) {
    var _makePolyLine = makePolyLine(corner, width, false, widthIs, cornerStyle, cornerSize, cornerSides, minAutoCornerAngle, [], linePrimitives, lineNum, 'line', drawBorderBufferToUse, [[]]),
        _makePolyLine2 = _slicedToArray(_makePolyLine, 4),
        t = _makePolyLine2[0],
        b = _makePolyLine2[1],
        dbb = _makePolyLine2[2],
        h = _makePolyLine2[3];

    tris = [].concat(_toConsumableArray(tris), _toConsumableArray(t));
    borders = [].concat(_toConsumableArray(borders), _toConsumableArray(b));
    borderBuffers = [].concat(_toConsumableArray(borderBuffers), _toConsumableArray(dbb));
    holes = [].concat(_toConsumableArray(holes), _toConsumableArray(h));
  });
  return [tris, borders, borderBuffers, holes];
}

function addArrows(arrowIn, startArrowIn, endArrowIn, existingTriangles, existingBorder, existingTouchBorder, holeBorder, drawBorderBuffer, lineWidth, onLine) {
  var arrow = {};

  if (arrowIn != null) {
    arrow = arrowIn;
  }

  var updatedTriangles = existingTriangles;
  var updatedBorder = existingBorder;
  var updatedTouchBorder = existingTouchBorder;
  var count = updatedTriangles.length;
  var _arrow = arrow,
      start = _arrow.start;

  if (start != null) {
    var startArrowLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](startArrowIn[0], startArrowIn[1]);
    var startLineMid = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](updatedTriangles[0], updatedTriangles[2]).midPoint();
    startArrowLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](startLineMid, startArrowLine.length(), startArrowLine.angle());
    var startArrow = [startArrowLine.p1, startArrowLine.p2];

    var _getArrow = Object(_arrow__WEBPACK_IMPORTED_MODULE_4__["getArrow"])(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, start, {
      // start: startArrow[0],
      // end: startArrow[1],
      align: 'tail',
      drawPosition: startArrow[0],
      angle: new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](startArrow[0], startArrow[1]).angle(),
      drawBorderBuffer: drawBorderBuffer,
      tailWidth: lineWidth
    })),
        _getArrow2 = _slicedToArray(_getArrow, 3),
        border = _getArrow2[0],
        touchBorder = _getArrow2[1],
        tail = _getArrow2[2];

    var points = Object(_arrow__WEBPACK_IMPORTED_MODULE_4__["getArrowTris"])(border, start);
    updatedTriangles = [].concat(_toConsumableArray(updatedTriangles), _toConsumableArray(points), [updatedTriangles[0]._dup(), updatedTriangles[2]._dup(), tail[0]._dup(), tail[0]._dup(), updatedTriangles[2]._dup(), tail[1]._dup()]);
    updatedBorder = [].concat(_toConsumableArray(updatedBorder), [border]);
    updatedTouchBorder = [].concat(_toConsumableArray(updatedTouchBorder), [touchBorder[0]]);
  }

  var _arrow2 = arrow,
      end = _arrow2.end;

  if (end != null) {
    var l = count;
    var endArrowLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](endArrowIn[0], endArrowIn[1]);
    var endLineMid = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](updatedTriangles[l - 2], updatedTriangles[l - 1]).midPoint();
    endArrowLine = new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](endLineMid, endArrowLine.length(), endArrowLine.angle());
    var endArrow = [endArrowLine.p1, endArrowLine.p2];

    var _getArrow3 = Object(_arrow__WEBPACK_IMPORTED_MODULE_4__["getArrow"])(Object(_tools_tools__WEBPACK_IMPORTED_MODULE_3__["joinObjects"])({}, end, {
      // start: endArrow[0],
      // end: endArrow[1],
      align: 'tail',
      drawPosition: endArrow[0],
      angle: new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Line"](endArrow[0], endArrow[1]).angle(),
      drawBorderBuffer: drawBorderBuffer,
      tailWidth: lineWidth
    })),
        _getArrow4 = _slicedToArray(_getArrow3, 3),
        _border = _getArrow4[0],
        _touchBorder = _getArrow4[1],
        _tail = _getArrow4[2];

    var _points = Object(_arrow__WEBPACK_IMPORTED_MODULE_4__["getArrowTris"])(_border, end);

    var connection = [];

    if (onLine) {
      connection = [updatedTriangles[l - 2]._dup(), updatedTriangles[l - 1]._dup(), _tail[0]._dup(), _tail[0]._dup(), updatedTriangles[l - 1]._dup(), _tail[1]._dup()];
    }

    updatedTriangles = [].concat(_toConsumableArray(updatedTriangles), _toConsumableArray(_points), _toConsumableArray(connection));
    updatedBorder = [].concat(_toConsumableArray(updatedBorder), [_border]);
    updatedTouchBorder = [].concat(_toConsumableArray(updatedTouchBorder), [_touchBorder[0]]);
  }

  return [updatedTriangles, updatedBorder, updatedTouchBorder, holeBorder];
}

function makeFastPolyLine(pointsIn, width, close) {
  var len = close ? pointsIn.length * 4 + 2 : (pointsIn.length - 1) * 4;
  var points = Array(len);
  var half = width / 2;
  var orth = Math.PI / 2;

  var getPoints = function getPoints(index1, index2) {
    var p1 = pointsIn[index1];
    var p2 = pointsIn[index2];
    var angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
    var dx1 = half * Math.cos(angle - orth);
    var dx2 = half * Math.cos(angle + orth);
    var dy1 = half * Math.sin(angle - orth);
    var dy2 = half * Math.sin(angle + orth);
    return [new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](p1.x + dx1, p1.y + dy1), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](p1.x + dx2, p1.y + dy2), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](p2.x + dx1, p2.y + dy1), new _tools_g2__WEBPACK_IMPORTED_MODULE_2__["Point"](p2.x + dx2, p2.y + dy2)];
  };

  for (var i = 0; i < pointsIn.length - 1; i += 1) {
    var _getPoints = getPoints(i, i + 1),
        _getPoints2 = _slicedToArray(_getPoints, 4),
        p11 = _getPoints2[0],
        p12 = _getPoints2[1],
        p21 = _getPoints2[2],
        p22 = _getPoints2[3];

    points[i * 4] = p11;
    points[i * 4 + 1] = p12;
    points[i * 4 + 2] = p21;
    points[i * 4 + 3] = p22;
  }

  if (close) {
    var _getPoints3 = getPoints(pointsIn.length - 1, 0),
        _getPoints4 = _slicedToArray(_getPoints3, 4),
        _p = _getPoints4[0],
        _p2 = _getPoints4[1],
        _p3 = _getPoints4[2],
        _p4 = _getPoints4[3];

    points[len - 6] = _p;
    points[len - 5] = _p2;
    points[len - 4] = _p3;
    points[len - 3] = _p4;
    points[len - 2] = points[0]._dup();
    points[len - 1] = points[1]._dup();
  }

  return [points, [[]], [[]], [[]]];
}

 // TODO
// inside and dash
// inside and radius
// Inside and radius
// const figure = new Fig.Figure();
// const { Point } = Fig;
// const line = [
//     new Point(0.5, 0),
//     new Point(0, 0.024286),
//     new Point(-0.5, 0),
//     // new Point(0, 1),
// ];
// figure.add([
//   {
//     name: 'pad',
//     method: 'polygon',
//     options: {
//       radius: 0.2,
//       color: [0.5, 0.5, 0.5, 0.5],
//       sides: 100,
//     },
//   },
//   {
//     name: 'r',
//     method: 'polyline',
//     options: {
//       points: line,
//       width: 0.03,
//       close: true,
//       pointsAt: 'inside',
//       cornerStyle: 'radius',
//       cornerSize: 0.05,
//       cornerSides: 10,
//     },
//   },
//   {
//     name: 'x2',
//     method: 'line',
//     options: {
//       p1: [-1, 0],
//       p2: [1, 0],
//       width: 0.005,
//       color: [0.5, 0.5, 0.5, 0.5],
//     }
//   },
// ]);
// const pad = figure.getElement('pad');
// pad.setMovable();
// pad.setTransformCallback = () => {
//   line[1] = pad.getPosition();
//   const r = figure.getElement('r');
//   r.updatePoints(line);
//   figure.animateNextFrame();
// }
// figure.initialize();
// pad.setPosition(0, 0.1);
// Inside and dash
// {
//   name: 'r',
//   method: 'polyline',
//   options: {
//     points: line,
//     width: 0.03,
//     close: true,
//     pointsAt: 'inside',
//     dash: [0.1, 0.03],
//   },
// },

/***/ }),

/***/ "./src/js/figure/geometries/polygon/polygon.js":
/*!*****************************************************!*\
  !*** ./src/js/figure/geometries/polygon/polygon.js ***!
  \*****************************************************/
/*! exports provided: getPolygonPoints, getTrisFillPolygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPolygonPoints", function() { return getPolygonPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTrisFillPolygon", function() { return getTrisFillPolygon; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tools/g2 */ "./src/js/tools/g2.js");
 // import {
//   round,
// } from '../../../../tools/math';

function getPolygonPoints(options) {
  var radius = options.radius,
      rotation = options.rotation,
      offset = options.offset,
      sides = options.sides,
      sidesToDraw = options.sidesToDraw,
      direction = options.direction,
      innerRadius = options.innerRadius;
  var deltaAngle = Math.PI * 2 / sides;
  var sidesMultiplier = 1;

  if (innerRadius != null) {
    deltaAngle /= 2;
    sidesMultiplier = 2;
  }

  var points = [];

  if (sidesToDraw === 0) {
    return [];
  }

  for (var i = 0; i < sidesToDraw * sidesMultiplier; i += sidesMultiplier) {
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](radius * Math.cos(deltaAngle * i * direction + rotation) + offset.x, radius * Math.sin(deltaAngle * i * direction + rotation) + offset.y));

    if (innerRadius != null) {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](innerRadius * Math.cos(deltaAngle * (i + 1) * direction + rotation) + offset.x, innerRadius * Math.sin(deltaAngle * (i + 1) * direction + rotation) + offset.y));
    }
  }

  if (sidesToDraw < sides) {
    points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](radius * Math.cos(deltaAngle * sidesToDraw * sidesMultiplier * direction + rotation) + offset.x, radius * Math.sin(deltaAngle * sidesToDraw * sidesMultiplier * direction + rotation) + offset.y));
  }

  return points;
} // function getFanTrisPolygon(
//   radius: number,
//   rotation: number,
//   offset: Point,
//   sides: number,
//   sidesToDraw: number,
//   direction: -1 | 1,
// ): Array<Point> {
//   const fan = [offset._dup(), ...getPolygonPoints(
//     radius, rotation, offset, sides, sidesToDraw, direction,
//   )];
//   if (sides === sidesToDraw) {
//     fan.push(fan[1]._dup());
//   }
//   return fan;
// }


function getTrisFillPolygon(center, border, sides, sidesToDraw) {
  var points = []; // const center = border.slice(-1)[0];

  for (var i = 1; i < border.length; i += 1) {
    points.push(center._dup());
    points.push(border[i]._dup());
    points.push(border[i - 1]._dup());
  }

  if (sides === sidesToDraw) {
    points.push(center._dup());
    points.push(border[0]._dup());
    points.push(border[border.length - 1]._dup());
  }

  return points;
}



/***/ }),

/***/ "./src/js/figure/geometries/rectangle.js":
/*!***********************************************!*\
  !*** ./src/js/figure/geometries/rectangle.js ***!
  \***********************************************/
/*! exports provided: getRectangleBorder, rectangleBorderToTris */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRectangleBorder", function() { return getRectangleBorder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rectangleBorderToTris", function() { return rectangleBorderToTris; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

 // import {
//   round,
// } from '../../../../tools/math';

function getRectPoints(width, height, sides, radius, x, y) {
  var offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0);

  if (radius < 0.000000001) {
    return [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x + offset.x, y + offset.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x + width + offset.x, y + offset.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x + width + offset.x, y + height + offset.y), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](x + offset.x, y + height + offset.y)];
  }

  var points = [];
  var deltaAngle = Math.PI / 2 / sides;
  var r = Math.min(width / 2, height / 2, radius);
  var corners = [[x + r, y + r, Math.PI], [x - r + width, y + r, Math.PI / 2 * 3], [x - r + width, y - r + height, 0], [x + r, y - r + height, Math.PI / 2]];
  corners.forEach(function (corner) {
    var _corner = _slicedToArray(corner, 3),
        cx = _corner[0],
        cy = _corner[1],
        angle = _corner[2];

    for (var i = 0; i < sides + 1; i += 1) {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](cx + r * Math.cos(i * deltaAngle + angle), cy + r * Math.sin(i * deltaAngle + angle)).add(offset));
    }
  });
  return points;
}

function getRectangleBorder(options) {
  var width = options.width,
      height = options.height,
      xAlign = options.xAlign,
      yAlign = options.yAlign; // const { drawBorderBuffer } = options;

  var x = 0;
  var y = 0;

  if (xAlign === 'center') {
    x = -width / 2;
  } else if (xAlign === 'right') {
    x = -width;
  } else if (typeof xAlign === 'number') {
    x = -width * xAlign;
  }

  if (yAlign === 'middle') {
    y = -height / 2;
  } else if (yAlign === 'top') {
    y = -height;
  } else if (typeof yAlign === 'number') {
    y = -height * yAlign;
  }

  var _options$corner = options.corner,
      radius = _options$corner.radius,
      sides = _options$corner.sides;
  var points = getRectPoints(width, height, sides, radius, x, y, options.offset); // let lineDelta = 0;
  // if (line != null && line.widthIs === 'mid') {
  //   lineDelta = line.width / 2;
  // }
  // if (line != null && (line.widthIs === 'outside' || line.widthIs === 'negative')) {
  //   lineDelta = line.width;
  // }
  // let outline: Array<Point>;
  // if (lineDelta > 0) {
  //   outline = getRectPoints(
  //     width + lineDelta * 2,
  //     height + lineDelta * 2,
  //     sides, radius, x - lineDelta, y - lineDelta, options.offset,
  //   );
  // } else {  // $FlowFixMe
  //   outline = points.map(p => p._dup());
  // }
  // const border = [outline];
  // let bufferBorder = border;
  // if (typeof drawBorderBuffer === 'number') {
  //   bufferBorder = [getRectPoints(
  //     width + lineDelta * 2 + drawBorderBuffer * 2,
  //     height + lineDelta * 2 + drawBorderBuffer * 2,
  //     sides, radius, x - lineDelta - drawBorderBuffer, y - lineDelta - drawBorderBuffer,
  //     options.offset,
  //   )];
  // } else {
  //   bufferBorder = drawBorderBuffer;
  // }
  // console.log(points)

  return points;
}

function rectangleBorderToTris(border) {
  var points = [border[0]._dup(), border[1]._dup(), border[2]._dup()];

  for (var i = 2; i < border.length - 1; i += 1) {
    points.push(border[0]);
    points.push(border[i]);
    points.push(border[i + 1]);
  }

  return points;
}



/***/ }),

/***/ "./src/js/figure/geometries/triangle.js":
/*!**********************************************!*\
  !*** ./src/js/figure/geometries/triangle.js ***!
  \**********************************************/
/*! exports provided: getTriangleBorder, getTriangleDirection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTriangleBorder", function() { return getTriangleBorder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTriangleDirection", function() { return getTriangleDirection; });
/* harmony import */ var _tools_g2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tools/g2 */ "./src/js/tools/g2.js");
/* harmony import */ var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tools/tools */ "./src/js/tools/tools.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


 // import {
//   makePolyLine,
// } from './lines/lines';

function getTriangleDirection(points) {
  var _points = _slicedToArray(points, 3),
      p1 = _points[0],
      p2 = _points[1],
      p3 = _points[2];

  var angle = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["threePointAngle"])(p1, p2, p3);

  if (angle > Math.PI) {
    return 1;
  }

  return -1;
} // function increaseTriangleByOffset(points: Array<Point>, delta) {
//   const direction = getTriangleDirection(points);
//   const [, , outline] = makePolyLine(
//     points, delta, true, direction === -1 ? 'negative' : 'positive', 'auto', 0.1,
//     10, Math.PI / 7, [], false,
//     2, direction === -1 ? 'negative' : 'positive', 0, [],
//   );
//   return [outline[0][0], outline[0][1], outline[0][3]];
// }


function alignTriangle(pointsIn, xAlign, yAlign, rotation) {
  var rotationMatrix;

  if (typeof rotation === 'number') {
    rotationMatrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(rotation).matrix();
  } else {
    var side = 's1';
    var angle = 0;

    if (typeof rotation === 'string') {
      side = rotation;
    } else {
      var _joinObjects = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, {
        side: 's1',
        angle: 0
      }, rotation);

      side = _joinObjects.side;
      angle = _joinObjects.angle;
    }

    var r = 0;

    if (side === 's1') {
      var sideRot = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](pointsIn[0], pointsIn[1]).angle();
      r = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["minAngleDiff"])(angle, sideRot);
    } else if (side === 's2') {
      var _sideRot = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](pointsIn[1], pointsIn[2]).angle();

      r = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["minAngleDiff"])(angle, _sideRot);
    } else if (side === 's3') {
      var _sideRot2 = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](pointsIn[2], pointsIn[0]).angle();

      r = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["minAngleDiff"])(angle, _sideRot2);
    }

    rotationMatrix = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Transform"]().rotate(r).matrix();
  }

  var points = pointsIn.map(function (p) {
    return p.transformBy(rotationMatrix);
  });
  var minX = Math.min(points[0].x, points[1].x, points[2].x);
  var minY = Math.min(points[0].y, points[1].y, points[2].y);
  var maxX = Math.max(points[0].x, points[1].x, points[2].x);
  var maxY = Math.max(points[0].y, points[1].y, points[2].y);
  var width = maxX - minX;
  var height = maxY - minY;
  var center = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getTriangleCenter"])(points[0], points[1], points[2]);
  var s1Center = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](points[0], points[1]).midPoint();
  var s2Center = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](points[1], points[2]).midPoint();
  var s3Center = new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Line"](points[2], points[0]).midPoint();
  var x = 0;
  var y = 0;

  if (xAlign === 'left') {
    x = -minX;
  } else if (xAlign === 'center') {
    x = -maxX + width / 2;
  } else if (xAlign === 'right') {
    x = -maxX;
  } else if (xAlign === 'centroid') {
    x = -center.x;
  } else if (xAlign === 'a2') {
    x = -points[1].x;
  } else if (xAlign === 'a3') {
    x = -points[2].x;
  } else if (xAlign === 's1') {
    x = -s1Center.x;
  } else if (xAlign === 's2') {
    x = -s2Center.x;
  } else if (xAlign === 's3') {
    x = -s3Center.x;
  } else if (typeof xAlign === 'number') {
    x = -minX - width * xAlign;
  }

  if (yAlign === 'bottom') {
    y = -minY;
  } else if (yAlign === 'middle') {
    y = -maxY + height / 2;
  } else if (yAlign === 'top') {
    y = -maxY;
  } else if (yAlign === 'centroid') {
    y = -center.y;
  } else if (yAlign === 'a2') {
    y = -points[1].y;
  } else if (yAlign === 'a3') {
    y = -points[2].y;
  } else if (yAlign === 's1') {
    y = -s1Center.y;
  } else if (yAlign === 's2') {
    y = -s2Center.y;
  } else if (yAlign === 's3') {
    y = -s3Center.y;
  } else if (typeof yAlign === 'number') {
    y = -minY - height * yAlign;
  }

  return points.map(function (p) {
    return new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](p.x + x, p.y + y);
  });
} //                             c3
//                              .
//                            .   .
//                         .   a3   .
//                       .            .
//                s3   .                .   s2
//                   .                    .
//                 .                        .
//               /                           \
//             /  a1                       a2  \
//         c1  ---------------------------------   c2
//                           s1
//
//


function getASAPoints(ASA, direction) {
  var _ASA = _slicedToArray(ASA, 3),
      a1 = _ASA[0],
      s1 = _ASA[1],
      a2 = _ASA[2];

  var points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](s1, 0)];
  var a3 = Math.PI - a1 - a2;
  var s2 = s1 / Math.sin(a3) * Math.sin(a1);
  points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](s1 + s2 * Math.cos((Math.PI - a2) * direction), 0 + s2 * Math.sin((Math.PI - a2) * direction)));
  return points;
} //                             c3
//                              .
//                            .   \
//                         .   a3   \
//                       .            \
//                s3   .                \   s2
//                   .                    \
//                 .                       \
//               .                           \
//             .  a1                       a2  \
//         c1  ---------------------------------   c2
//                           s1
//
//


function getSASPoints(SAS, direction) {
  var _SAS = _slicedToArray(SAS, 3),
      s1 = _SAS[0],
      a2 = _SAS[1],
      s2 = _SAS[2];

  var points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](s1, 0)];
  points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](s1 + s2 * Math.cos((Math.PI - a2) * direction), 0 + s2 * Math.sin((Math.PI - a2) * direction)));
  return points;
} //                             c3
//                              .
//                            .   \
//                         .   a3   \
//                       .            \
//                s3   .                \   s2
//                   .                    \
//                 .                       \
//               .                           \
//             .  a1                       a2  \
//         c1  . . . . . . . . . . . . . . . . . .  c2
//                           s1
//
//


function getAASPoints(AAS, direction) {
  var _AAS = _slicedToArray(AAS, 3),
      a1 = _AAS[0],
      a2 = _AAS[1],
      s2 = _AAS[2];

  var a3 = Math.PI - a1 - a2;
  var s1 = s2 / Math.sin(a1) * Math.sin(a3);
  var points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](s1, 0)];
  points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](s1 + s2 * Math.cos((Math.PI - a2) * direction), 0 + s2 * Math.sin((Math.PI - a2) * direction)));
  return points;
} //                             c3
//                              .
//                            /   \
//                         /   a3   \
//                       /            \
//                s3   /                \   s2
//                   /                    \
//                 /                       \
//               /                           \
//             /  a1                       a2  \
//         c1  ----------------------------------   c2
//                           s1
//
//


function getSSSPoints(SSS, direction) {
  var _SSS = _slicedToArray(SSS, 3),
      s1 = _SSS[0],
      s2 = _SSS[1],
      s3 = _SSS[2];

  var a2 = Math.acos((s1 * s1 + s2 * s2 - s3 * s3) / (2 * s1 * s2));
  var points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](s1, 0)];
  points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](s1 + s2 * Math.cos((Math.PI - a2) * direction), 0 + s2 * Math.sin((Math.PI - a2) * direction)));
  return points;
}

function getTriangleBorder(options) {
  var points;
  var direction = options.direction;

  if (options.points != null) {
    points = Object(_tools_g2__WEBPACK_IMPORTED_MODULE_0__["getPoints"])(options.points);
  } else if (options.ASA != null) {
    points = getASAPoints(options.ASA, direction);
  } else if (options.SAS != null) {
    points = getSASPoints(options.SAS, direction);
  } else if (options.AAS != null) {
    points = getAASPoints(options.AAS, direction);
  } else if (options.SSS != null) {
    points = getSSSPoints(options.SSS, direction);
  } else {
    var width = options.width,
        height = options.height,
        top = options.top;
    points = [new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, 0), new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, 0)];

    if (top === 'left') {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](0, height * direction));
    } else if (top === 'center') {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width / 2, height * direction));
    } else if (top === 'right') {
      points.push(new _tools_g2__WEBPACK_IMPORTED_MODULE_0__["Point"](width, height * direction));
    }
  }

  return alignTriangle(points, options.xAlign, options.yAlign, options.rotation);
}



/***/ }),

/***/ "./src/js/figure/webgl/GlobalAnimation.js":
/*!************************************************!*\
  !*** ./src/js/figure/webgl/GlobalAnimation.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * `'nextFrame'` | `'prevFrame'` | `'syncNow'` | `'now'`
 *
 *
 * `'syncNow'` is a synchronized 'now' time. The
 * first time 'syncNow' is used, the current time will be stored and used
 * for all subsequent calls to 'syncNow'. 'syncNow' is reset every
 * time a new animation frame is drawn, or 100ms after a first syncNow call
 * has been made after a reset.
 *
 * 'now' is the instantaneous time
 *
 * `'nextFrame'` will be the time of the next animation frame
 *
 * `'prevFrame'` is the time of the last animation frame
 * @typedef {'now' | 'nextFrame' | 'prevFrame' | 'syncNow'} TypeWhen
 */
// Singleton class that contains projects global variables
var GlobalAnimation = /*#__PURE__*/function () {
  // Method for requesting the next animation frame
  // used to cancel animation frames
  // syncNow: () => number;
  function GlobalAnimation() {
    _classCallCheck(this, GlobalAnimation);

    // If the instance alread exists, then don't create a new instance.
    // If it doesn't, then setup some default values.
    if (!GlobalAnimation.instance) {
      this.requestNextAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
      GlobalAnimation.instance = this;
      this.reset();
    }

    return GlobalAnimation.instance;
  }

  _createClass(GlobalAnimation, [{
    key: "reset",
    value: function reset() {
      this.drawQueue = [];
      this.nextDrawQueue = [];
      this.lastFrame = null;
      this.debug = false;
      this.simulatedFPS = 60;
      this.debugFrameTime = 0.5;

      if (this.timers != null && this.timers.length > 0) {
        this.timers.forEach(function (id) {
          return clearTimeout(id);
        });
      }

      this.timers = [];

      if (this.timeoutId != null) {
        clearTimeout(this.timeoutId);
      }

      this.timeoutId = null;

      this.now = function () {
        return performance.now();
      };

      this.updateSyncNow = true;
      this.manual = false;
    }
  }, {
    key: "getWhen",
    value: function getWhen(when) {
      if (when === 'now') {
        return this.now();
      }

      if (when === 'prevFrame') {
        return this.lastFrame;
      }

      if (when === 'syncNow') {
        return this.syncNow();
      }

      return null;
    }
  }, {
    key: "syncNow",
    value: function syncNow() {
      var _this = this;

      if (this.updateSyncNow) {
        this.updateSyncNow = false;
        this.synchronizedNow = this.now();
        this.syncNowTimer = setTimeout(function () {
          _this.updateSyncNow = true;
        }, 100);
      }

      return this.synchronizedNow;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "now",
    value: function now() {
      return performance.now();
    }
  }, {
    key: "setDebugFrameRate",
    value: function setDebugFrameRate() {
      var _this2 = this;

      var simulatedFPS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60;
      var frameTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      if (this.timeoutId != null) {
        clearTimeout(this.timeoutId);
      }

      cancelAnimationFrame(this.animationId);
      this.simulatedFPS = simulatedFPS;
      this.debugFrameTime = frameTime;
      this.debug = true;
      this.nowTime = performance.now();

      this.now = function () {
        return _this2.nowTime;
      };

      this.queueNextDebugFrame();
    }
  }, {
    key: "setManualFrames",
    value: function setManualFrames() {
      var _this3 = this;

      this.manual = true;
      this.nowTime = performance.now();

      this.now = function () {
        return _this3.nowTime;
      };
    }
  }, {
    key: "endManualFrames",
    value: function endManualFrames() {
      this.manual = false;

      this.now = function () {
        return performance.now;
      };
    }
  }, {
    key: "frame",
    value: function frame(duration) {
      this.nowTime += duration * 1000;
      this.draw(this.nowTime);
    }
  }, {
    key: "queueNextDebugFrame",
    value: function queueNextDebugFrame() {
      var _this4 = this;

      if (this.debugFrameTime != null) {
        this.timeoutId = setTimeout(function () {
          _this4.nowTime += 1 / _this4.simulatedFPS * 1000;

          if (_this4.nextDrawQueue.length > 0) {
            _this4.draw(_this4.now());
          }

          _this4.queueNextDebugFrame();
        }, this.debugFrameTime * 1000);
      } else {
        this.nowTime += 1 / this.simulatedFPS * 1000;

        if (this.nextDrawQueue.length > 0) {
          this.draw(this.now());
        }
      }
    }
  }, {
    key: "setTimeout",
    value: function (_setTimeout) {
      function setTimeout(_x, _x2) {
        return _setTimeout.apply(this, arguments);
      }

      setTimeout.toString = function () {
        return _setTimeout.toString();
      };

      return setTimeout;
    }(function (f, time) {
      if (this.debug) {
        var timeScale = 0;

        if (this.debugFrameTime != null) {
          timeScale = (this.debugFrameTime || 0) / (1 / this.simulatedFPS);
        } // console.log('setTimeout', time, timeScale)


        if (timeScale > 0) {
          var _id2 = setTimeout(f, time * timeScale);

          this.timers.push(_id2);
          return _id2;
        }

        var _id = setTimeout(f, 0);

        this.timers.push(_id);
        return _id;
      }

      var id = setTimeout(f, time);
      this.timers.push(id);
      return id;
    })
  }, {
    key: "clearTimeout",
    value: function (_clearTimeout) {
      function clearTimeout(_x3) {
        return _clearTimeout.apply(this, arguments);
      }

      clearTimeout.toString = function () {
        return _clearTimeout.toString();
      };

      return clearTimeout;
    }(function (id) {
      if (id == null) {
        return;
      }

      clearTimeout(id);
      var index = this.timers.indexOf(id);

      if (index > -1) {
        this.timers.splice(index, 1);
      }
    })
  }, {
    key: "disableDebugFrameRate",
    value: function disableDebugFrameRate() {
      if (this.timeoutId != null) {
        clearTimeout(this.timeoutId);
      }

      this.timeoutId = null;
      this.debug = false;

      if (this.nextDrawQueue.length > 0) {
        this.animateNextFrame();
      }
    }
  }, {
    key: "draw",
    value: function draw(now) {
      clearTimeout(this.syncNowTimer);
      this.updateSyncNow = true;
      this.drawQueue = this.nextDrawQueue;
      this.nextDrawQueue = [];
      var nowSeconds = now * 0.001;

      if (this.manual) {
        nowSeconds = this.now() * 0.001;
      }

      for (var i = 0; i < this.drawQueue.length; i += 1) {
        this.drawQueue[i](nowSeconds);
      }

      this.drawQueue = [];
      this.lastFrame = now;
    }
  }, {
    key: "queueNextFrame",
    value: function queueNextFrame(func) {
      // if (!(func in this.nextDrawQueue)) {
      this.nextDrawQueue.push(func); // }
      // if (triggerFrameRequest) {
      //   this.animateNextFrame();
      // }

      if (this.nextDrawQueue.length === 1) {
        if (!this.debug) {
          this.animateNextFrame();
        }
      }
    } // simulateNextFrame() {
    //   if (this.timeoutId == null) {
    //     this.queueNextDebugFrame();
    //   }
    // }
    // Queue up an animation frame

  }, {
    key: "animateNextFrame",
    value: function animateNextFrame() {
      cancelAnimationFrame(this.animationId); // $FlowFixMe

      var nextFrame = this.requestNextAnimationFrame.call(window, this.draw.bind(this));
      this.animationId = nextFrame;
    }
  }]);

  return GlobalAnimation;
}(); // Do not automatically create and instance and return it otherwise can't
// mock elements in jest
// // const globalvars: Object = new GlobalVariables();
// // Object.freeze(globalvars);


/* harmony default export */ __webpack_exports__["default"] = (GlobalAnimation);

/***/ }),

/***/ "./src/js/figure/webgl/shaders.js":
/*!****************************************!*\
  !*** ./src/js/figure/webgl/shaders.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var vertex = {
  simple: {
    source: 'attribute vec2 a_position;' + 'uniform mat3 u_matrix;' + 'uniform float u_z;' + 'void main() {' + 'gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, u_z, 1);' + '}',
    varNames: ['a_position', 'u_matrix', 'u_z']
  },
  withTexture: {
    source: 'attribute vec2 a_position;' + 'attribute vec2 a_texcoord;' + 'uniform mat3 u_matrix;' + 'uniform float u_z;' + 'varying vec2 v_texcoord;' + 'void main() {' + 'gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, u_z, 1);' + 'v_texcoord = a_texcoord;' + '}',
    varNames: ['a_position', 'a_texcoord', 'u_matrix', 'u_z']
  }
};
var fragment = {
  simple: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'void main() {' + 'gl_FragColor = u_color;' + '}',
    varNames: ['u_color']
  },
  withTexture: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'uniform int u_use_texture;' + 'uniform sampler2D u_texture;' + 'varying vec2 v_texcoord;' + 'void main() {' + 'if ( u_use_texture == 1) {' + 'gl_FragColor = texture2D(u_texture, v_texcoord);' + '} else {' + 'gl_FragColor = u_color;' + '}' + '}',
    varNames: ['u_color', 'u_use_texture', 'u_texture']
  },
  text: {
    source: 'precision mediump float;' + 'uniform vec4 u_color;' + 'uniform sampler2D u_texture;' + 'varying vec2 v_texcoord;' + 'void main() {' // + 'float a = texture2D(u_texture, v_texcoord).a;'
    // + 'if ( a < 0.2 ) {'
    //   + 'a = a / 1.2;'
    // + '}'
    // + 'gl_FragColor = vec4(u_color.rgb, min(a * 1.2, 1.0) * u_color.a);'
    // + '}'
    // + 'gl_FragColor = a * u_color;'
    + 'vec4 c = texture2D(u_texture, v_texcoord);' + 'gl_FragColor = vec4(c.a * u_color.rgb, c.a * u_color.a);' + '}',
    varNames: ['u_color', 'u_texture']
  }
};

var getShaders = function getShaders() {
  var vName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'simple';
  var fName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'simple';

  if (Object.hasOwnProperty.call(vertex, vName) && Object.hasOwnProperty.call(fragment, fName)) {
    return {
      vertexSource: vertex[vName].source,
      fragmentSource: fragment[fName].source,
      varNames: vertex[vName].varNames.concat(fragment[fName].varNames)
    };
  }

  return {
    vertexSource: '',
    fragmentSource: '',
    varNames: []
  };
};

/* harmony default export */ __webpack_exports__["default"] = (getShaders);

/***/ }),

/***/ "./src/js/figure/webgl/webgl.js":
/*!**************************************!*\
  !*** ./src/js/figure/webgl/webgl.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders */ "./src/js/figure/webgl/shaders.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var glMock = {
  TRIANGLES: 1,
  TRIANGLE_STRIP: 2,
  TRIANGLE_FAN: 3,
  LINES: 4,
  LINK_STATUS: 1,
  VERTEX_SHADER: 1,
  COMPILE_STATUS: 1,
  FRAGMENT_SHADER: 1,
  SRC_ALPHA: 1,
  ONE_MINUS_SRC_ALPHA: 1,
  BLEND: 1,
  COLOR_BUFFER_BIT: 1,
  TEXTURE_2D: 1,
  RGBA: 1,
  UNSIGNED_BYTE: 1,
  TEXTURE_WRAP_S: 1,
  CLAMP_TO_EDGE: 1,
  TEXTURE_WRAP_T: 1,
  TEXTURE_MIN_FILTER: 1,
  LINEAR: 1,
  ARRAY_BUFFER: 1,
  STATIC_DRAW: 1,
  FLOAT: 1,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 1,
  createBuffer: function createBuffer() {},
  bindBuffer: function bindBuffer() {},
  bufferData: function bufferData() {},
  enableVertexAttribArray: function enableVertexAttribArray() {},
  vertexAttribPointer: function vertexAttribPointer() {},
  disableVertexAttribArray: function disableVertexAttribArray() {},
  uniformMatrix3fv: function uniformMatrix3fv() {},
  uniform4f: function uniform4f() {},
  uniform1f: function uniform1f() {},
  uniform1i: function uniform1i() {},
  texParameteri: function texParameteri() {},
  drawArrays: function drawArrays() {},
  clearColor: function clearColor() {},
  clear: function clear() {},
  createTexture: function createTexture() {},
  activeTexture: function activeTexture() {},
  bindTexture: function bindTexture() {},
  pixelStorei: function pixelStorei() {},
  texImage2D: function texImage2D() {},
  blendFunc: function blendFunc() {},
  attachShader: function attachShader() {},
  linkProgram: function linkProgram() {},
  getProgramParameter: function getProgramParameter() {},
  createProgram: function createProgram() {},
  deleteProgram: function deleteProgram() {},
  createShader: function createShader() {},
  shaderSource: function shaderSource() {},
  compileShader: function compileShader() {},
  getShaderParameter: function getShaderParameter() {},
  getAttribLocation: function getAttribLocation() {},
  getUniformLocation: function getUniformLocation() {},
  enable: function enable() {},
  map: function map() {},
  getExtension: function getExtension() {
    return {
      loseContext: function loseContext() {}
    };
  },
  disable: function disable() {},
  deleteShader: function deleteShader() {},
  useProgram: function useProgram() {},
  viewport: function viewport() {},
  canvas: {
    toDataURL: function toDataURL() {
      return '';
    },
    width: 100,
    clientHeight: 100,
    height: 100,
    style: {
      top: 0,
      visibility: 'visible'
    }
  }
};

function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (success) {
    return program;
  }

  gl.deleteProgram(program);
  return null;
}

function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (success) {
    return shader;
  }

  gl.deleteShader(shader);
  return null;
}

function createProgramFromScripts(gl, vertexShaderSource, fragmentShaderSource) {
  // Get the strings for our GLSL shaders
  // const vertexShaderSource = document.getElementById(vertexScript).text;
  // const fragmentShaderSource = document.getElementById(fragScript).text;
  // create GLSL shaders, upload the GLSL source, compile the shaders
  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource); // Link the two shaders into a program

  if (vertexShader && fragmentShader) {
    return createProgram(gl, vertexShader, fragmentShader);
  }

  return null;
}

function getGLLocations(gl, program, locationsList) {
  var i;
  var newLocations = {};
  var loc;

  for (i = 0; i < locationsList.length; i += 1) {
    loc = locationsList[i];

    if (loc[0] === 'a') {
      newLocations[loc] = gl.getAttribLocation(program, loc);
    }

    if (loc[0] === 'u') {
      newLocations[loc] = gl.getUniformLocation(program, loc);
    }
  }

  return newLocations;
} // function resizeCanvasToDisplaySize(canvas) {
//   // const mul = multiplier || 1;
//   const mul = window.devicePixelRatio || 1;
//   const width = canvas.clientWidth * mul || 0;
//   const height = canvas.clientHeight * mul || 0;
//   if (canvas.width !== width || canvas.height !== height) {
//     canvas.width = width;     // eslint-disable-line no-param-reassign
//     canvas.height = height;   // eslint-disable-line no-param-reassign
//     return true;
//   }
//   return false;
// }

/* eslint-disable */


function autoResize(event) {// let contRect = document.getElementById('container').getBoundingClientRect();
  // let diagRect = document.getElementById('figure').getBoundingClientRect();
  // let textRect = document.getElementById('learning_text_container').getBoundingClientRect();
  // let canvRect = this.gl.canvas.getBoundingClientRect();
  // // console.log(contRect)
  // console.log(this.gl.canvas.getBoundingClientRect());
  // // this.gl.canvas.height = 500;
  // // this.gl.canvas.width = 500;
  // // this.gl.canvas.width=500;
  // // this.gl.viewport(diagRect.left, canvRect.height+canvRect.top, textRect.width, textRect.height); 
  // // this.gl.viewport(0,0,100,100);
  // // console.log(document.getElementById('Figure').left);
}

var WebGLInstance = /*#__PURE__*/function () {
  _createClass(WebGLInstance, [{
    key: "addTexture",
    // locations: Object;
    value: function addTexture(id, glTexture, type) {
      if (this.textures[id] && this.textures[id].glTexture != null) {
        return this.textures[id].index;
      }

      var index = 0;

      if (this.textures[id]) {
        index = this.textures[id].index;
      } else {
        index = Object.keys(this.textures).length;
      }

      this.textures[id] = {
        glTexture: glTexture,
        index: index,
        type: type,
        state: 'loaded',
        onLoad: []
      };
      return index;
    }
  }, {
    key: "onLoad",
    value: function onLoad(textureId) {
      this.textures[textureId].onLoad.forEach(function (f) {
        return f();
      });
      this.textures[textureId].onLoad = [];
    }
  }, {
    key: "getProgram",
    value: function getProgram(vertexShader, fragmentShader) {
      for (var i = 0; i < this.programs.length; i += 1) {
        var program = this.programs[i];

        if (program.vertexShader === vertexShader && program.fragmentShader === fragmentShader) {
          return i;
        }
      }

      var shaders = Object(_shaders__WEBPACK_IMPORTED_MODULE_0__["default"])(vertexShader, fragmentShader);
      var newProgram = createProgramFromScripts(this.gl, shaders.vertexSource, shaders.fragmentSource);
      var programDetails = {
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        program: newProgram,
        locations: getGLLocations(this.gl, newProgram, shaders.varNames)
      };
      this.programs.push(programDetails);
      return this.programs.length - 1;
    }
  }, {
    key: "useProgram",
    value: function useProgram(programIndex) {
      var program = this.programs[programIndex];

      if (this.lastUsedProgram !== program) {
        this.gl.useProgram(program.program);
        this.lastUsedProgram = program.program;
      }

      return program.locations;
    }
  }]);

  function WebGLInstance(canvas, // vertexSource: string,
  // fragmentSource: string,
  // shaderLocations: Array<string>,
  backgroundColor) {
    _classCallCheck(this, WebGLInstance);

    var gl = canvas.getContext('webgl', {
      antialias: true
    });

    if (gl == null) {
      // $FlowFixMe
      gl = glMock;
    }

    this.programs = [];
    this.lastUsedProgram = null;
    this.textures = {};

    if (gl != null) {
      // $FlowFixMe
      this.gl = gl; // this.program = createProgramFromScripts(
      //   this.gl,
      //   vertexSource,
      //   fragmentSource,
      // );
      // this.locations = getGLLocations(this.gl, this.program, shaderLocations);
      // Prep canvas
      // resizeCanvasToDisplaySize(this.gl.canvas);

      this.resize(); // Tell WebGL how to convert from clip space to pixels
      // this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
      // gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      // this.gl.viewport(0, 500, 500, 500);   // Tell WebGL how to convert from clip space to pixels
      // Clear the canvas
      // const bc = backgroundColor;
      // this.gl.clearColor(bc[0], bc[1], bc[2], bc[3]);

      this.gl.clearColor(0, 0, 0, 0);
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.gl.disable(this.gl.DEPTH_TEST);
      this.gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      this.gl.enable(gl.BLEND); // this.gl.useProgram(this.program);
      // window.addEventListener('resize', autoResize.bind(this, event));
    }
  }

  _createClass(WebGLInstance, [{
    key: "resize",
    value: function resize() {
      var realToCSSPixels = window.devicePixelRatio; // console.log("asdf");
      // Lookup the size the browser is displaying the canvas in CSS pixels
      // and compute a size needed to make our drawingbuffer match it in
      // device pixels.

      var displayWidth = Math.floor(this.gl.canvas.clientWidth * realToCSSPixels);
      var displayHeight = Math.floor(this.gl.canvas.clientHeight * realToCSSPixels); // console.log('in webgl', displayWidth)
      // Check if the canvas is not the same size.

      if (this.gl.canvas.width !== displayWidth || this.gl.canvas.height !== displayHeight) {
        // Make the canvas the same size
        this.gl.canvas.width = displayWidth;
        this.gl.canvas.height = displayHeight;
      }

      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    } // resize() {
    //   var width = this.gl.canvas.clientWidth;
    //   var height = this.gl.canvas.clientHeight;
    //   if (this.gl.canvas.width != width ||
    //       this.gl.canvas.height != height) {
    //      this.gl.canvas.width = width;
    //      this.gl.canvas.height = height;
    //      return true;
    //   }
    //   return false;
    // }
    // var needToRender = true;  // draw at least once
    // function checkRender() {
    //    if (resize() || needToRender) {
    //      needToRender = false;
    //      drawStuff();
    //    }
    //    requestAnimationFrame(checkRender);
    // }
    // checkRender();

  }]);

  return WebGLInstance;
}();

/* harmony default export */ __webpack_exports__["default"] = (WebGLInstance);

/***/ }),

/***/ "./src/js/tools/FunctionMap.js":
/*!*************************************!*\
  !*** ./src/js/tools/FunctionMap.js ***!
  \*************************************/
/*! exports provided: FunctionMap, GlobalFunctionMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FunctionMap", function() { return FunctionMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlobalFunctionMap", function() { return GlobalFunctionMap; });
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import type { Transform } from '../tools/g2';
// import { Point, getTransform, Transform } from '../tools/g2';
// import { round } from '../tools/math';
// import type { FigureElement } from './Element';
// import GlobalAnimation from './webgl/GlobalAnimation';
// Singleton class that contains projects global functions
var GeneralFunctionMap = /*#__PURE__*/function () {
  function GeneralFunctionMap() {
    _classCallCheck(this, GeneralFunctionMap);

    this.map = {};
  }

  _createClass(GeneralFunctionMap, [{
    key: "add",
    value: function add(id, fn) {
      if (this.map == null) {
        this.map = {};
      }

      this.map[id] = {
        fn: fn
      };
    }
  }, {
    key: "exec",
    value: function exec(idOrFn) {
      if (idOrFn == null) {
        return null;
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (typeof idOrFn === 'string') {
        // return this.fnMap.exec(fn, ...args);
        if (this.map[idOrFn] != null) {
          var _this$map$idOrFn;

          if (args.length === 0) {
            return this.map[idOrFn].fn();
          }

          return (_this$map$idOrFn = this.map[idOrFn]).fn.apply(_this$map$idOrFn, args);
        }
      }

      if (typeof idOrFn === 'function') {
        return idOrFn.apply(void 0, args);
      }

      return null;
    }
  }, {
    key: "execOnMaps",
    value: function execOnMaps(idOrFn, mapsIn) {
      if (idOrFn == null) {
        return null;
      }

      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      if (typeof idOrFn === 'string') {
        var maps = [this.map].concat(_toConsumableArray(mapsIn));

        for (var i = 0; i < maps.length; i += 1) {
          var map = maps[i];

          if (map[idOrFn] != null) {
            var _map$idOrFn;

            if (args.length === 0) {
              return map[idOrFn].fn();
            }

            return (_map$idOrFn = map[idOrFn]).fn.apply(_map$idOrFn, args);
          }
        }
      }

      if (typeof idOrFn === 'function') {
        return idOrFn.apply(void 0, args);
      }

      return null;
    }
  }]);

  return GeneralFunctionMap;
}();

var GlobalFunctionMap = /*#__PURE__*/function (_GeneralFunctionMap) {
  _inherits(GlobalFunctionMap, _GeneralFunctionMap);

  var _super = _createSuper(GlobalFunctionMap);

  function GlobalFunctionMap() {
    var _this;

    _classCallCheck(this, GlobalFunctionMap);

    // If the instance alread exists, then don't create a new instance.
    // If it doesn't, then setup some default values.
    if (!GlobalFunctionMap.instance) {
      _this = _super.call(this);
      GlobalFunctionMap.instance = _assertThisInitialized(_this);
      _this.map = {};
    }

    return _possibleConstructorReturn(_this, GlobalFunctionMap.instance);
  }

  return GlobalFunctionMap;
}(GeneralFunctionMap);

var FunctionMap = /*#__PURE__*/function (_GeneralFunctionMap2) {
  _inherits(FunctionMap, _GeneralFunctionMap2);

  var _super2 = _createSuper(FunctionMap);

  function FunctionMap() {
    var _this2;

    _classCallCheck(this, FunctionMap);

    _this2 = _super2.call(this);
    _this2.global = new GlobalFunctionMap();
    return _this2;
  }

  _createClass(FunctionMap, [{
    key: "exec",
    value: function exec(idOrFn) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      // const result = super.exec(idOrFn, ...args);
      // if (result === null) {
      //   return this.global.exec(idOrFn, ...args);
      // }
      // return result;
      return this.execOnMaps.apply(this, [idOrFn, [this.global.map]].concat(args));
    }
  }, {
    key: "execOnMaps",
    value: function execOnMaps(idOrFn, mapsIn) {
      var _get2;

      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      return (_get2 = _get(_getPrototypeOf(FunctionMap.prototype), "execOnMaps", this)).call.apply(_get2, [this, idOrFn, [].concat(_toConsumableArray(mapsIn), [this.global.map])].concat(args));
    }
  }]);

  return FunctionMap;
}(GeneralFunctionMap);



/***/ }),

/***/ "./src/js/tools/color.js":
/*!*******************************!*\
  !*** ./src/js/tools/color.js ***!
  \*******************************/
/*! exports provided: RGBToArray, HexToArray, cssColorToArray, colorArrayToRGB, colorArrayToRGBA, getCSSColors, areColorsSame, areColorsWithinDelta */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBToArray", function() { return RGBToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HexToArray", function() { return HexToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssColorToArray", function() { return cssColorToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorArrayToRGB", function() { return colorArrayToRGB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorArrayToRGBA", function() { return colorArrayToRGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areColorsSame", function() { return areColorsSame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areColorsWithinDelta", function() { return areColorsWithinDelta; });
/* harmony import */ var _colorNames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorNames */ "./src/js/tools/colorNames.js");
/* harmony import */ var _getCssColors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssColors */ "./src/js/tools/getCssColors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSColors", function() { return _getCssColors__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./src/js/tools/math.js");
 // official css color names
// eslint-disable-next-line import/no-cycle




// Function that converts any rgb or rgba string to an array of rgba numbers
// between 0 and 1
function RGBToArray(color) {
  // Reduce the rgb(a) string to just numbers
  var colString = color;
  colString = colString.replace(/.*\(/i, '');
  colString = colString.replace(/\)/i, '');
  var strArray = colString.split(','); // Go through each rgb(a) value and normalize to 1.0

  var value = strArray.map(function (x, index) {
    if (index < 3) {
      return parseInt(x, 10) / 255.0;
    }

    return parseFloat(x);
  }); // If an alpha value isn't included, then include it with default value 1.0

  if (value.length === 3) {
    value.push(1);
  }

  return value;
} // Function that converts any hex color string to an array of rgba numbers
// between 0 and 1 (where alpha is always 1)


function HexToArray(color) {
  var colHex = color.slice(1);

  if (colHex.length < 6) {
    colHex = "".concat(colHex[0]).concat(colHex[0]).concat(colHex[1]).concat(colHex[1]).concat(colHex[2]).concat(colHex[2]);
  }

  var col = [parseInt(colHex.slice(0, 2), 16) / 255.0, parseInt(colHex.slice(2, 4), 16) / 255.0, parseInt(colHex.slice(4, 6), 16) / 255.0, 1];
  return col;
}

function cssColorToArray(cssColorString) {
  var oNames = Object(_colorNames__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Official css color names

  var color = cssColorString.slice(0); // If the color is an official name, then replace it with the hex rgb
  // equivalent

  if (color in oNames) {
    color = oNames[color];
  } // colorValue is the rgba array of colors between 0 and 1


  var colorValue = []; // If color string starts with 'rgb' (and therefore also 'rgba')

  if (color.toLowerCase().startsWith('rgb')) {
    colorValue = RGBToArray(color); // If color string starts with '#' it is hex
  } else if (color.startsWith('#')) {
    colorValue = HexToArray(color);
  } // If the color value array is defined, then add it to the final
  // dictionary


  if (colorValue.length > 0) {
    return colorValue;
  }

  return null;
}

function colorArrayToRGBA(color) {
  return "rgba(".concat(Math.floor(color[0] * 255), ",").concat(Math.floor(color[1] * 255), ",").concat(Math.floor(color[2] * 255), ",").concat(color[3], ")");
}

function colorArrayToRGB(color) {
  return "rgb(".concat(Math.floor(color[0] * 255), ",").concat(Math.floor(color[1] * 255), ",").concat(Math.floor(color[2] * 255), ")");
}

function areColorsSame(color1, color2) {
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;

  if (color1.length !== color2.length) {
    return false;
  }

  for (var i = 0; i < color1.length; i += 1) {
    if (Object(_math__WEBPACK_IMPORTED_MODULE_2__["round"])(color1[i], precision) !== Object(_math__WEBPACK_IMPORTED_MODULE_2__["round"])(color2[i], precision)) {
      return false;
    }
  }

  return true;
}

function areColorsWithinDelta(color1, color2) {
  var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.001;

  if (color1.length !== color2.length) {
    return false;
  }

  for (var i = 0; i < color1.length; i += 1) {
    var dC = Math.abs(color1[i] - color2[i]);

    if (dC > delta) {
      return false;
    }
  }

  return true;
}



/***/ }),

/***/ "./src/js/tools/colorNames.js":
/*!************************************!*\
  !*** ./src/js/tools/colorNames.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// @ flow
function colorNames() {
  return {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgrey: '#a9a9a9',
    darkgreen: '#006400',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    gold: '#ffd700',
    goldenrod: '#daa520',
    gray: '#808080',
    grey: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavender: '#e6e6fa',
    lavenderblush: '#fff0f5',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgrey: '#d3d3d3',
    lightgreen: '#90ee90',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32'
  };
} // function a(input) {
//   console.log(input);
// }


/* harmony default export */ __webpack_exports__["default"] = (colorNames);

/***/ }),

/***/ "./src/js/tools/g2.js":
/*!****************************!*\
  !*** ./src/js/tools/g2.js ***!
  \****************************/
/*! exports provided: Point, line, Line, distance, minAngleDiff, deg, normAngle, Transform, Rect, Translation, Scale, Rotation, spaceToSpaceTransform, getBoundingRect, linearPath, curvedPath, quadraticBezier, translationPath, polarToRect, rectToPolar, getDeltaAngle, normAngleTo90, threePointAngle, threePointAngleMin, randomPoint, getMaxTimeFromVelocity, getMoveTime, parsePoint, clipAngle, spaceToSpaceScale, getPoint, getScale, getPoints, quadBezierPoints, getRect, getTransform, getLine, deceleratePoint, decelerateValue, decelerateTransform, RectBounds, LineBounds, RangeBounds, TransformBounds, Vector, transformValueToArray, getBounds, Bounds, getTriangleCenter, getBoundingBorder, getBorder, comparePoints, isBuffer, getPositionInRect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return Point; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "line", function() { return line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minAngleDiff", function() { return minAngleDiff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg", function() { return deg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normAngle", function() { return normAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rect", function() { return Rect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Translation", function() { return Translation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scale", function() { return Scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rotation", function() { return Rotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToSpaceTransform", function() { return spaceToSpaceTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoundingRect", function() { return getBoundingRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearPath", function() { return linearPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curvedPath", function() { return curvedPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadraticBezier", function() { return _quadraticBezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translationPath", function() { return translationPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polarToRect", function() { return polarToRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rectToPolar", function() { return rectToPolar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDeltaAngle", function() { return getDeltaAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normAngleTo90", function() { return normAngleTo90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "threePointAngle", function() { return threePointAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "threePointAngleMin", function() { return threePointAngleMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomPoint", function() { return randomPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMaxTimeFromVelocity", function() { return getMaxTimeFromVelocity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMoveTime", function() { return getMoveTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePoint", function() { return parsePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipAngle", function() { return clipAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spaceToSpaceScale", function() { return spaceToSpaceScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPoint", function() { return getPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScale", function() { return getScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPoints", function() { return getPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadBezierPoints", function() { return quadBezierPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRect", function() { return getRect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransform", function() { return getTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLine", function() { return getLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deceleratePoint", function() { return deceleratePoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decelerateValue", function() { return decelerateValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decelerateTransform", function() { return decelerateTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectBounds", function() { return RectBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBounds", function() { return LineBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RangeBounds", function() { return RangeBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransformBounds", function() { return TransformBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformValueToArray", function() { return transformValueToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBounds", function() { return getBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bounds", function() { return Bounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTriangleCenter", function() { return getTriangleCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBoundingBorder", function() { return getBoundingBorder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBorder", function() { return getBorder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "comparePoints", function() { return comparePoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return isBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPositionInRect", function() { return getPositionInRect; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./src/js/tools/math.js");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools */ "./src/js/tools/tools.js");
/* harmony import */ var _m2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./m2 */ "./src/js/tools/m2.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-disable no-use-before-define */


 // import { joinObjects } from './tools';

function _quadraticBezier(P0, P1, P2, t) {
  return (1 - t) * ((1 - t) * P0 + t * P1) + t * ((1 - t) * P1 + t * P2);
}
/**
 * Clip and angle between 0 and 2π (`'0to360'`) or -π to π (`'-180to180'`).
 * `null` will return the angle between -2π to 2π.
 * @example
 * const clipAngle = Fig.clipAngle
 *
 * const a1 = clipAngle(Math.PI / 2 * 5, '0to360');
 * console.log(a1);
 * // 1.5707963267948966
 *
 * const a2 = clipAngle(Math.PI / 4 * 5, '-180to180');
 * console.log(a2);
 * // -2.356194490192345
 *
 * const a3 = clipAngle(-Math.PI / 4 * 10, null);
 * console.log(a3);
 * // -1.5707963267948966
 */


function clipAngle(angleToClip, clipTo) {
  if (clipTo === null) {
    return angleToClip;
  } // Modular 2π gives -360to360


  var angle = angleToClip % (Math.PI * 2);

  if (clipTo === '0to360') {
    if (angle < 0) {
      angle += Math.PI * 2;
    }

    if (angle >= Math.PI * 2) {
      angle -= Math.PI * 2;
    }
  }

  if (clipTo === '-180to180') {
    if (angle < -Math.PI) {
      angle += Math.PI * 2;
    }

    if (angle >= Math.PI) {
      angle -= Math.PI * 2;
    }
  }

  if (clipTo === '-360to0') {
    if (angle > 0) {
      angle -= Math.PI * 2;
    }

    if (angle <= -Math.PI * 2) {
      angle += Math.PI * 2;
    }
  }

  return angle;
}

function getPrecision(options) {
  var defaultPrecision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var precision;

  if (options) {
    precision = options.precision;
  }

  var precisionToUse = defaultPrecision;

  if (precision != null) {
    precisionToUse = precision;
  }

  return precisionToUse;
}

// point can be defined as:
//    - Point instance
//    - [1, 1]
//    - { f1Type: 'p', def: [1, 1]}
function parsePoint(pIn, onFail) {
  if (pIn instanceof Point) {
    return pIn;
  }

  var onFailToUse = onFail;

  if (onFailToUse == null) {
    onFailToUse = null;
  }

  if (pIn == null) {
    return onFailToUse;
  }

  var p = pIn;

  if (typeof p === 'string') {
    try {
      p = JSON.parse(p);
    } catch (_unused) {
      return onFailToUse;
    }
  }

  if (Array.isArray(p)) {
    if (p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number') {
      return new Point(p[0], p[1]);
    }

    return onFailToUse;
  }

  if (p.f1Type != null) {
    if (p.f1Type === 'p' && p.state != null && Array.isArray([p.state]) && p.state.length === 2) {
      var _p$state = _slicedToArray(p.state, 2),
          x = _p$state[0],
          y = _p$state[1];

      return new Point(x, y);
    }

    return onFailToUse;
  }

  if (typeof p === 'number') {
    return new Point(p, p);
  } // if (typeof (p) === 'object') {
  //   const keys = Object.keys(p);
  //   if (keys.indexOf('x') > -1 && keys.indexOf('y') > -1) {
  //     return new Point(p.x, p.y);
  //   }
  // }


  return onFailToUse;
}
/**
 * Parse a {@link TypeParsablePoint} and return a {@link Point}.
 * @return {Point}
 */


function getPoint(p) {
  var parsedPoint = parsePoint(p);

  if (parsedPoint == null) {
    parsedPoint = new Point(0, 0);
  }

  return parsedPoint;
}
/**
 * Parse an array of parsable point definitions ({@link TypeParsablePoint})
 * returning an array of points.
 * @return {Array<Point>}
 */


function getPoints(points) {
  if (Array.isArray(points)) {
    if (points.length === 2 && typeof points[0] === 'number') {
      // $FlowFixMe
      return [getPoint(points)];
    } // $FlowFixMe


    return points.map(function (p) {
      return getPoint(p);
    });
  }

  return [getPoint(points)];
}
/**
 * Parse a scale definition and return a {@link Point} representing the scale
 * in x and y.
 * Scale can either be defined as a {@link TypeParsablePoint} or a `number` if
 * the x and y scale is equal.
 * @return {Point} x and y scale
 */


function getScale(s) {
  var parsedPoint;

  if (typeof s === 'number') {
    parsedPoint = new Point(s, s);
  } else {
    parsedPoint = getPoint(s);
  }

  return parsedPoint;
}
/**
 * An object representing a rectangle.
 *
 * @example
 * // get Rect from Fig
 * const { Rect } = Fig;
 *
 * // define a rect centered at origin with width 4 and height 2
 * const r = new Rect(-2, -1, 4, 2);
 */


var Rect = /*#__PURE__*/function () {
  /**
   * Constructor
   * @constructor
   * @param {number} left - left location
   * @param {number} bottom - bottom location
   * @param {number} width - rectangle width
   * @param {number} height - rectangle height
   */
  function Rect(left, bottom, width, height) {
    _classCallCheck(this, Rect);

    /**
      Left side x coordinate
     */
    this.left = left;
    /**
      Rectange width
     */

    this.width = width;
    /**
      Rectangle height
     */

    this.height = height;
    /**
      Bottom side y coordinate
     */

    this.bottom = bottom;
    /**
      Top side y coordinate
     */

    this.top = bottom + height;
    /**
      Right side x coordinate
     */

    this.right = left + width;
  }
  /**
   * Return a duplicate rectangle object
   */


  _createClass(Rect, [{
    key: "_dup",
    value: function _dup() {
      return new Rect(this.left, this.bottom, this.width, this.height);
    }
  }, {
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      return {
        f1Type: 'rect',
        state: [Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.left, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.bottom, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.width, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.height, precision)]
      };
    }
    /**
     * Returns `true` if `point` is within on on the border of the rectangle
     * @param {TypeParsablePoint} point point to test
     * @param {number} precision precision to test
     * @example
     * const r = new Rect(-2, -1, 4, 2);
     *
     * // check if point is within the rectangle (will return `true`)
     * const result = r.isPointInside([0, 1]);
     */

  }, {
    key: "isPointInside",
    value: function isPointInside(point) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var p = getPoint(point).round(precision);
      var top = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.top, precision);
      var bottom = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.bottom, precision);
      var left = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.left, precision);
      var right = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.right, precision);

      if (p.x < left || p.x > right || p.y < bottom || p.y > top) {
        return false;
      }

      return true;
    }
    /**
     * Returns a rectangle with coordinates rounded to `precision`
     * @param {number} precision precision to test
     */

  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var newRect = new Rect(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.left, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.bottom, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.width, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.height, precision));
      newRect.width = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(newRect.width, precision);
      newRect.height = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(newRect.height, precision);
      newRect.top = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(newRect.top, precision);
      newRect.right = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(newRect.right, precision);
      return newRect;
    }
  }]);

  return Rect;
}(); // /**
//  JSON definition of a rect.
//  @property {'rect'} f1Type rect identifier
//  @property {[number, number, number, number]} state left, bottom, width
//  * and height definition
//  */


function parseRect(rIn, onFail) {
  if (rIn instanceof Rect) {
    return rIn;
  }

  var onFailToUse = onFail;

  if (onFailToUse == null) {
    onFailToUse = null;
  }

  if (rIn == null) {
    return onFailToUse;
  }

  var r = rIn;

  if (typeof r === 'string') {
    try {
      r = JSON.parse(r);
    } catch (_unused2) {
      return onFailToUse;
    }
  }

  if (Array.isArray(r) && r.length === 4) {
    return new Rect(r[0], r[1], r[2], r[3]);
  }

  var _r = r,
      f1Type = _r.f1Type,
      state = _r.state;

  if (f1Type != null && f1Type === 'rect' && state != null && Array.isArray([state]) && state.length === 4) {
    var _state2 = _slicedToArray(state, 4),
        l = _state2[0],
        b = _state2[1],
        w = _state2[2],
        h = _state2[3];

    return new Rect(l, b, w, h);
  }

  return onFailToUse;
}
/**
 * Convert a parsable rectangle definition to a {@link Rect}.
 * @param {TypeParsableRect} r parsable rectangle definition
 * @return {Rect} rectangle object
 */


function getRect(r) {
  var parsedRect = parseRect(r);

  if (parsedRect == null) {
    parsedRect = new Rect(0, 0, 1, 1);
  }

  return parsedRect;
}
/* eslint-disable comma-dangle */

/**
 * Object representing a point.
 *
 * Contains methods that makes it conventient to add, subtract and
 * transform points.
 *
 * @example
 * // get Point from Fig
 * const { Point } = Fig;
 *
 * // define a point at (0, 2)
 * const p = new Point(0, 2);
 *
 * // find the distance to another point (0, 1) which will be 1
 * const d = p.distance([0, 1]);
 *
 * // add to another point (3, 1) which will result in (3, 3)
 * const q = p.add(3, 1);
 */


var Point = /*#__PURE__*/function () {
  _createClass(Point, null, [{
    key: "zero",

    /**
     * x value of point
    */

    /** y value of point */

    /**
     * Return a point at (0, 0)
     */
    value: function zero() {
      return new Point(0, 0);
    }
    /**
     * Return a point at (1, 1)
     */

  }, {
    key: "Unity",
    value: function Unity() {
      return new Point(1, 1);
    }
    /**
     * Constructor
     * @constructor
     * @param x x coordinate of point
     * @param y y coordinate of point
     */

  }]);

  function Point(x, y) {
    _classCallCheck(this, Point);

    this.x = x;
    this.y = y;
    this._type = 'point';
  }

  _createClass(Point, [{
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      return {
        f1Type: 'p',
        state: [Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision)]
      };
    }
    /**
     * Return a duplicate of the {@link Point} object
     */

  }, {
    key: "_dup",
    value: function _dup() {
      return new Point(this.x, this.y);
    }
    /**
     * Scale x and y values of point by scalar
     * @example
     * p = new Point(1, 1);
     * s = p.scale(3);
     * // s = Point{x: 3, y: 3};
     */

  }, {
    key: "scale",
    value: function scale(scalar) {
      return new Point(this.x * scalar, this.y * scalar);
    }
    /**
     * Subtract (x, y) values or a {@link Point} and return the difference as a new {@link Point}
     * @example
     * p = new Point(3, 3);
     * d = p.sub(1, 1)
     * // d = Point{x: 2, y: 2}
     *
     * p = new Point(3, 3);
     * q = new Point(1, 1);
     * d = p.sub(q)
     * // d = Point{x: 2, y: 2}
     */

  }, {
    key: "sub",
    value: function sub(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (pointOrX instanceof Point) {
        return new Point(this.x - pointOrX.x, this.y - pointOrX.y);
      }

      return new Point(this.x - pointOrX, this.y - y);
    }
    /**
     * Add (x, y) values or a {@link Point} and return the sum as a new {@link Point}
     * @example
     * p = new Point(3, 3);
     * d = p.add(1, 1)
     * // d = Point{x: 4, y: 4}
     *
     * p = new Point(3, 3);
     * q = new Point(1, 1);
     * d = p.add(q)
     * // d = Point{x: 4, y: 4}
     */

  }, {
    key: "add",
    value: function add(pointOrX) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (pointOrX instanceof Point) {
        return new Point(this.x + pointOrX.x, this.y + pointOrX.y);
      }

      return new Point(this.x + pointOrX, this.y + y);
    }
    /**
     * Return the distance between the point and the origin
     * @example
     * p = new Point(1, 1);
     * d = p.distance();
     * // d = 1.4142135623730951
     */

  }, {
    key: "distance",
    value: function distance() {
      var toPointIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (toPointIn == null) {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }

      var toPoint = getPoint(toPointIn);

      if (toPoint == null) {
        return this.distance();
      }

      return this.sub(toPoint).distance();
    }
    /**
     * Return a new point with (x, y) values rounded to some precision
     * @example
     * p = new Point(1.234, 1.234);
     * q = p.round(2);
     * // q = Point{x: 1.23, y: 1.23}
     */

  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Point(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision));
    }
    /**
     * Return a new point that is clipped to min and max values from the origin.
     *
     * Use a point as a parameter to define different (x, y) min/max values,
     * a number to define the same (x, y) min/max values, or null to have no
     * min/max values.
     * @example
     * p = new Point(2, 2);
     * q = p.clip(1, 1);
     * // q = Point{x: 1, y: 1}
     *
     * p = new Point(2, 2);
     * q = p.clip(1, null);
     * // q = Point{x: 1, y: 2}
     *
     * p = new Point(-2, -2);
     * minClip = new Point(-1, -1.5);
     * q = p.clip(minClip, null);
     * // q = Point{x: -1, y: -1.5}
     */

  }, {
    key: "clip",
    value: function clip(min, max) {
      var minX;
      var minY;
      var maxX;
      var maxY;

      if (min instanceof Point) {
        minX = min.x;
        minY = min.y;
      } else {
        minX = min;
        minY = min;
      }

      if (max instanceof Point) {
        maxX = max.x;
        maxY = max.y;
      } else {
        maxX = max;
        maxY = max;
      }

      var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(this.x, minX, maxX);
      var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(this.y, minY, maxY);
      return new Point(x, y);
    }
    /**
     * Transform the point with a 3x3 matrix (2 dimensional transform)
     * @example
     * // Transform a point with a (2, 2) translation then 90º rotation
     * p = new Point(1, 1);
     * m = new Transform().translate(2, 2).rotate(Math.PI / 2).matrix();
     * // m = [0, -1, -2, 1, 0, 2, 0, 0, 1]
     * q = p.transformBy(m)
     * // q = Point{x: -3, y: 3}
     */

  }, {
    key: "transformBy",
    value: function transformBy(matrix) {
      var transformedPoint = _m2__WEBPACK_IMPORTED_MODULE_2__["transform"](matrix, this.x, this.y);
      return new Point(transformedPoint[0], transformedPoint[1]);
    }
  }, {
    key: "quadraticBezier",
    value: function quadraticBezier(p1, p2, t) {
      var bx = _quadraticBezier(this.x, p1.x, p2.x, t);

      var by = _quadraticBezier(this.y, p1.y, p2.y, t);

      return new Point(bx, by);
    }
    /**
     * Rotate a point some angle around a center point
     * @param angle - in radians
     * @example
     * // Rotate a point around the origin
     * p = new Point(1, 0);
     * q = p.rotate(Math.PI)
     * // q = Point{x: -1, y: 0}
     *
     * // Rotate a point around (1, 1)
     * p = new Point(2, 1);
     * q = p.rotate(Math.PI, new Point(1, 1))
     * // q = Point{x: 0, y: 1}
     */

  }, {
    key: "rotate",
    value: function rotate(angle) {
      var center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Point(0, 0);
      var c = Math.cos(angle);
      var s = Math.sin(angle);
      var matrix = [c, -s, s, c]; // eslint-disable-line indent

      var centerPoint = center;
      var pt = this.sub(centerPoint);
      return new Point(matrix[0] * pt.x + matrix[1] * pt.y + centerPoint.x, matrix[2] * pt.x + matrix[3] * pt.y + centerPoint.y);
    }
    /* eslint-enable comma-dangle */

    /**
     * Compare two points for equality to some precision
     * @example
     * p = new Point(1.123, 1.123);
     * q = new Point(1.124, 1.124);
     * p.isEqualTo(q)
     * // false
     *
     * p.isEqualTo(q, 2)
     * // true
     */

  }, {
    key: "isEqualTo",
    value: function isEqualTo(p) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var pr = this;
      var qr = p;

      if (typeof precision === 'number') {
        pr = this.round(precision);
        qr = qr.round(precision);
      }

      if (pr.x === qr.x && pr.y === qr.y) {
        return true;
      }

      return false;
    }
  }, {
    key: "isWithinDelta",
    value: function isWithinDelta(p) {
      var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0000001;
      var dX = Math.abs(this.x - p.x);
      var dY = Math.abs(this.y - p.y);

      if (dX > delta || dY > delta) {
        return false;
      }

      return true;
    }
    /**
     * Compare two points for unequality to some precision
     * @example
     * p = new Point(1.123, 1.123);
     * q = new Point(1.124, 1.124);
     * p.isNotEqualTo(q)
     * // true
     *
     * p.isNotEqualTo(q, 2)
     * // false
     */

  }, {
    key: "isNotEqualTo",
    value: function isNotEqualTo(p, precision) {
      return !this.isEqualTo(p, precision);
    }
  }, {
    key: "isNotWithinDelta",
    value: function isNotWithinDelta(p) {
      var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0000001;
      return !this.isWithinDelta(p, delta);
    }
  }, {
    key: "isWithinLine",
    value: function isWithinLine(l, precision) {
      return l.hasPointOn(this, precision);
    }
  }, {
    key: "getShaddowOnLine",
    value: function getShaddowOnLine(l) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var shaddow = new Line(this, 1, l.angle() + Math.PI / 2);

      var _shaddow$intersectsWi = shaddow.intersectsWith(l),
          intersect = _shaddow$intersectsWi.intersect; // console.log(intersect, inLine, alongLine, )


      if (intersect != null && intersect.isWithinLine(l, precision)) {
        return intersect;
      }

      return null;
    }
  }, {
    key: "shaddowIsOnLine",
    value: function shaddowIsOnLine(l) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var intersect = this.getShaddowOnLine(l, precision);

      if (intersect != null) {
        return true;
      }

      return false;
    }
  }, {
    key: "clipToLine",
    value: function clipToLine(l) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;

      if (l.hasPointOn(this, precision)) {
        return this._dup();
      }

      var shaddow = this.getShaddowOnLine(l, precision);

      if (shaddow != null) {
        return shaddow;
      }

      var d1 = this.distance(l.p1);
      var d2 = this.distance(l.p2);

      if (d1 <= d2) {
        return l.p1._dup();
      }

      return l.p2._dup();
    }
  }, {
    key: "isOnUnboundLine",
    value: function isOnUnboundLine(l, precision) {
      return l.hasPointAlong(this, precision);
    }
  }, {
    key: "isInPolygon",
    value: function isInPolygon(polygonVertices) {
      var windingNumber = 0;
      var n = polygonVertices.length - 1;
      var v = polygonVertices.slice();
      var p = this;
      var popLastPoint = false; // polygonVertices needs to have the last vertex the same as the first vertex

      if (v[0].isNotEqualTo(v[n])) {
        v.push(v[0]);
        popLastPoint = true;
        n += 1;
      }

      for (var i = 0; i < n; i += 1) {
        if (v[i].y <= p.y) {
          if (v[i + 1].y > p.y) {
            // an upward crossing
            if (Point.isLeft(v[i], v[i + 1], p) > 0) {
              // P left of  edge
              windingNumber += 1; // have  a valid up intersect
            }
          }
        } else if (v[i + 1].y <= p.y) {
          // start y > P.y (no test needed)
          // a downward crossing
          if (Point.isLeft(v[i], v[i + 1], p) < 0) {
            // P right of  edge
            windingNumber -= 1; // have  a valid down intersect
          }
        }
      }

      if (popLastPoint) {
        v.pop();
      }

      if (windingNumber === 0) {
        return false;
      }

      return true;
    }
  }, {
    key: "isOnPolygon",
    value: function isOnPolygon(polygonVertices) {
      var popLastPoint = false;
      var p = this;
      var n = polygonVertices.length - 1; // Number of sides

      var v = polygonVertices.slice(); // polygonVertices needs to have the last vertex the same as the first vertex

      if (v[0].isNotEqualTo(v[n])) {
        v.push(v[0]);
        popLastPoint = true;
        n += 1;
      }

      for (var i = 0; i < n; i += 1) {
        // if(p.isEqualTo(v[i])) {
        //   return true;
        // }
        var l = line(v[i], v[i + 1]);

        if (p.isWithinLine(l)) {
          if (popLastPoint) {
            v.pop();
          }

          return true;
        }
      }

      if (p.isInPolygon(polygonVertices)) {
        if (popLastPoint) {
          v.pop();
        }

        return true;
      }

      if (popLastPoint) {
        v.pop();
      }

      return false;
    }
  }, {
    key: "toPolar",
    value: function toPolar() {
      return {
        mag: Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)),
        angle: Math.atan2(this.y, this.x)
      };
    }
  }, {
    key: "toDelta",
    value: function toDelta(delta, percent) {
      var translationStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'linear';
      var translationOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        magnitude: 0.5,
        offset: 0.5,
        controlPoint: null
      };
      var pathPoint = translationPath(translationStyle, this._dup(), delta, percent, translationOptions);
      return pathPoint;
    }
  }], [{
    key: "isLeft",
    value: function isLeft(p0, p1, p2) {
      return (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y);
    }
  }]);

  return Point;
}();

function linearPath(start, delta, percent) {
  return start.add(delta.x * percent, delta.y * percent);
} // type linearPathOptionsType = {
// };

/**
 * Curved translation path options, that defineds the control
 * point of a quadratic bezier curve.
 *
 * Use `controlPoint` to define the control point directly. This
 * will override all other properties.
 *
 * Otherwise `direction`, `magnitude` and `offset` can be used
 * to calculate the control point based on the start and end
 * points of the curve.
 *
 * The control point is calculated by:
 * - Define a line from start to target - it will have length `d`
 * - Define a point `P` on the line
 * - Define a control line from point `P` with length `d` and some
 *   angle delta from the original line.
 *
 * The properties then customize this calculation:
 * - `magnitude` will scale the distance d
 * - `offset` will define where on the line point `P` is where `0.5` is
 *   the midpoint and `0.1` is 10% along the line from the start location
 * - `direction` will define which side of the line the control line should be
 *   drawn
 * - `angle` defines the angle delta between the line and the control line - by
 *    default this a right angle (Math.PI / 2)
 *
 * The directions `'up'`, `'down'`, `'left'`, `'right'` all reference the side
 * of the line. The `'positive'`
 * direction is the side of the line that the line would move toward when
 * rotated in the positive direction around the start point. The
 * '`negative`' side of the line is then the opposite side.
 *
 * These directions only work when the `angle` is between `0` and `Math.PI`.
 *
 * @property {TypeParsablePoint | null} controlPoint
 * @property {number} magnitude
 * @property {number} offset
 * @property {number} angle (`Math.PI / 2`)
 * @property {'positive' | 'negative' | 'up' | 'left' | 'down' | 'right'} direction
 */


// export type pathOptionsType = OBJ_QuadraticBezier & linearPathOptionsType;
function curvedPath(start, delta, percent, options) {
  var o = options; // const angle = Math.atan2(delta.y, delta.x);
  // const midPoint = start.add(new Point(delta.x * o.offset, delta.y * o.offset));
  // const dist = delta.toPolar().mag * o.magnitude;

  var controlPoint = options.controlPoint; // const o = options;
  // const dist = delta.toPolar().mag * o.magnitude;

  if (controlPoint == null) {
    // let angleDelta = Math.PI / 2;
    // if (o.angle != null) {
    //   angleDelta = o.angle;
    // }
    // const { direction } = options;
    // let xDelta = Math.cos(angle + angleDelta);
    // let yDelta = Math.sin(angle + angleDelta);
    // if (direction === 'up') {
    //   if (yDelta < 0) {
    //     yDelta = Math.sin(angle + angleDelta + Math.PI);
    //   }
    //   if (xDelta < 0) {
    //     xDelta = Math.cos(angle + angleDelta + Math.PI);
    //   }
    // } else if (direction === 'down') {
    //   if (yDelta > 0) {
    //     yDelta = Math.sin(angle + angleDelta + Math.PI);
    //   }
    //   if (xDelta > 0) {
    //     xDelta = Math.cos(angle + angleDelta + Math.PI);
    //   }
    // } else if (direction === 'left') {
    //   if (yDelta > 0) {
    //     yDelta = Math.sin(angle + angleDelta + Math.PI);
    //   }
    //   if (xDelta > 0) {
    //     xDelta = Math.cos(angle + angleDelta + Math.PI);
    //   }
    // } else if (direction === 'right') {
    //   if (yDelta < 0) {
    //     yDelta = Math.sin(angle + angleDelta + Math.PI);
    //   }
    //   if (xDelta < 0) {
    //     xDelta = Math.cos(angle + angleDelta + Math.PI);
    //   }
    // }
    var angleDelta = Math.PI / 2;

    if (o.angle != null) {
      angleDelta = o.angle;
    }

    var offsetToUse = 0;

    if (o.offset != null) {
      offsetToUse = o.offset;
    }

    if (o.direction == null) {
      o.direction = 'positive';
    }

    var magToUse = 1;

    if (o.magnitude != null) {
      magToUse = o.magnitude;
    }

    var displacementLine = new Line(start, start.add(delta));
    var lineAngle = clipAngle(displacementLine.angle(), '0to360');
    var linePoint = start.add(new Point(delta.x * offsetToUse, delta.y * offsetToUse)); // norm line angle is between 0 and 180

    var normLineAngle = lineAngle; // clipAngle(lineAngle, '0to360');

    if (normLineAngle >= Math.PI) {
      normLineAngle -= Math.PI;
    } // if (lineAngle < 0) {
    //   lineAngle += Math.PI;
    // }


    var controlAngle = lineAngle + angleDelta;
    var direction = o.direction;

    if (direction === 'positive') {
      controlAngle = lineAngle + angleDelta;
    } else if (direction === 'negative') {
      controlAngle = lineAngle - angleDelta;
    } else if (direction === 'up') {
      if (lineAngle <= Math.PI / 2 || lineAngle >= Math.PI / 2 * 3) {
        controlAngle = lineAngle + angleDelta;
      } else {
        controlAngle = lineAngle - angleDelta;
      }
    } else if (direction === 'down') {
      if (lineAngle <= Math.PI / 2 || lineAngle >= Math.PI / 2 * 3) {
        controlAngle = lineAngle - angleDelta;
      } else {
        controlAngle = lineAngle + angleDelta;
      }
    } else if (direction === 'left') {
      if (lineAngle <= Math.PI) {
        controlAngle = lineAngle + angleDelta;
      } else {
        controlAngle = lineAngle - angleDelta;
      }
    } else if (direction === 'right') {
      if (lineAngle <= Math.PI) {
        controlAngle = lineAngle - angleDelta;
      } else {
        controlAngle = lineAngle + angleDelta;
      }
    }

    var dist = magToUse * displacementLine.length();
    controlPoint = new Point(linePoint.x + dist * Math.cos(controlAngle), linePoint.y + dist * Math.sin(controlAngle));
  }

  var p0 = start;
  var p1 = getPoint(controlPoint);
  var p2 = start.add(delta);
  var t = percent;

  var bx = _quadraticBezier(p0.x, p1.x, p2.x, t);

  var by = _quadraticBezier(p0.y, p1.y, p2.y, t);

  return new Point(bx, by);
}

function translationPath() {
  var pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'linear';
  var start = arguments.length > 1 ? arguments[1] : undefined;
  var delta = arguments.length > 2 ? arguments[2] : undefined;
  var percent = arguments.length > 3 ? arguments[3] : undefined;
  var options = arguments.length > 4 ? arguments[4] : undefined;

  if (pathType === 'linear') {
    return linearPath(start, delta, percent);
  }

  if (pathType === 'curved' || pathType === 'curve') {
    return curvedPath(start, delta, percent, options);
  }

  return new Point(0, 0);
} // function point(x: number, y: number) {
//   return new Point(x, y);
// }


function pointinRect(q, p1, p2, precision) {
  if (precision === undefined || precision === null) {
    if (q.x >= Math.min(p1.x, p2.x) && q.x <= Math.max(p1.x, p2.x) && q.y >= Math.min(p1.y, p2.y) && q.y <= Math.max(p1.y, p2.y)) {
      return true;
    }
  } else if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.x, precision) >= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.min(p1.x, p2.x), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.x, precision) <= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.max(p1.x, p2.x), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.y, precision) >= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.min(p1.y, p2.y), precision) && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(q.y, precision) <= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.max(p1.y, p2.y), precision)) {
    return true;
  }

  return false;
}

function distance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function deg(angle) {
  return angle * 180 / Math.PI;
}
/**
 * Get the minimum absolute angle difference between two angles
 *
 * @example
 * const minAngleDiff = Fig.minAngleDiff;
 * const d1 = minAngleDiff(0.1, 0.2);
 * console.log(d1);
 * // -0.1
 *
 * const d2 = minAngleDiff(0.2, 0.1);
 * console.log(d2);
 * // 0.1
 *
 * const d3 = minAngleDiff(0.1, -0.1);
 * console.log(d3);
 * // 0.2
 */


function minAngleDiff(angle1, angle2) {
  if (angle1 === angle2) {
    return 0;
  }

  return Math.atan2(Math.sin(angle1 - angle2), Math.cos(angle1 - angle2));
}

function normAngle(angle) {
  var newAngle = angle;

  while (newAngle >= Math.PI * 2.0) {
    newAngle -= Math.PI * 2.0;
  }

  while (newAngle < 0) {
    newAngle += Math.PI * 2.0;
  }

  return newAngle;
}

function normAngleTo90(angle) {
  var newAngle = normAngle(angle);

  if (newAngle > Math.PI / 2 && newAngle < Math.PI) {
    newAngle += Math.PI;
  }

  if (newAngle === Math.PI) {
    newAngle = 0;
  }

  if (newAngle > Math.PI && newAngle < Math.PI * 3 / 2) {
    newAngle -= Math.PI;
  }

  return newAngle;
}

// 0 is quickest direction
// 1 is positive direction CCW
// -1 is negative direction CW
// 2 is not through 0
// 3 is numerical
function getDeltaAngle(startAngle, targetAngle) {
  var rotDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var start = normAngle(startAngle);
  var target = normAngle(targetAngle);
  var dir = rotDirection;

  if (start === target) {
    return 0;
  }

  if (dir === 2) {
    if (start > target) {
      dir = -1;
    } else {
      dir = 1;
    }
  }

  if (dir === 0) {
    return minAngleDiff(target, start);
  }

  if (dir === 1) {
    if (start > target) {
      return Math.PI * 2 - start + target;
    }
  }

  if (dir === -1) {
    if (target > start) {
      return -start - (Math.PI * 2 - target);
    }
  }

  return target - start; // if (rotDirection === 2) {
  //   if (target > start) {
  //     return target - start;
  //   }
  // }
  // if (rotDirection === 2) {
  //   if (start + rotDiff < 0) {
  //     rotDiff = Math.PI * 2 + rotDiff;
  //   } else if (start + rotDiff > Math.PI * 2) {
  //     rotDiff = -(Math.PI * 2 - rotDiff);
  //   }
  // } else if (rotDiff * rotDirection < 0) {
  //   rotDiff = rotDirection * Math.PI * 2.0 + rotDiff;
  // }
  // return rotDiff;
} // Line definition: Ax + By = C
//
// So if we have two points: (x1, y1) and (x2, y2) on the same line, they must
// both satisfy the same equation:
//
//    Ax1 + By1 = C   - 1
//    Ax2 + By2 = C   - 2
//
// Both 1 and 2 equal C, so can equate left hand sides:
//    Ax1 + By1 = Ax2 + By2
//    A(x1 - x2) = B(y2 - y1)
//    A / B = (y2 - y1) / (x1 - x2)
//
//    So A = (y2 - y1) and B = x1 - x2
//
//  Then C from 1 is:
//    C = (y2 - y1)x1 + (x1 - x2)y1
//
//  So calculating y from x:
//    y = (C - Ax) / B   for B != 0
//      If B == 0, then x1 == x2, and so we have a vertical line at x1
//      and so y is not dependent on x
//  And calculating x from y:
//    x = (C - By) / A    for A != 0
//      If A == 0, then y1 == y2, and so we have a horizontal line at y1
//      and so x is not dependent on y
//
//  To find the y intercept:
//    if B != 0: y intercept = Ax + By = C => y = C / B
//    if B == 0, there is no single y intercept
//      - is either no intercept, or along the y axis
//
//  To find the x intercept:
//    if A != 0: x intercept = Ax + By = C => x = C / A
//    if A == 0, there is no single x intercept
//      - is either no intercept, or along the x axis
//
//  Another form of the line equation is y = mx + c where:
//   - c is the y intercept (or C / B)
//   - m = y2 - y1 / x2 - x1 = A / (-B) = - A / B
//

/**
 * Line intersection result object with keys:
 * @property {undefined | Point} intersect will be `undefined` if there is
 * no intersect
 * @property {boolean} alongLine `true` if `intersect` is along line calling
 * `intersectsWith`
 * @property {boolean} withinLine `true` if `intersect` is within line calling
 * `intersectsWith`
 */


/**
 * Object representing a line.
 *
 * A line is defined by two points, or a point and the distance and
 * angle to another point.
 *
 * A finite line exists only between these two points.
 *
 * An infinite line can extend beyond either or both of the points to infinity.
 *
 * A line can also be defined as an infinite line by saying it extends beyond one
 * @example
 * // get Line from Fig
 * const { Line } = Fig;
 *
 * // define a finite line from [0, 0] to [1, 0] with a point, magnitude and
 * // angle
 * const l1 = new Line([0, 0], 1, 0)
 *
 * // define a finite line from [0, 0] to [1, 0] with two points
 * const l2 = new Line([0, 0], [1, 0])
 *
 * // define an infinite line from [0, 0], through [1, 0] and to infinity
 * const l3 = new Line([0, 0], [1, 0], 1)
 *
 * // define an infinite line trough [0, 0] and [1, 0]
 * const l4 = new Line([0, 0], [1, 0], 0)
 */
var Line = /*#__PURE__*/function () {
  /**
   * @param {0 | 1 | 2} ends number of ends the line has. `2` ends is a finite
   * line. `1` end is an infinite line that terminates at the first point, and
   * goes through the second point to infinity. `0` ends is an infinite line
   * that goes through both first and second points to infinity.
   */
  function Line(p1, p2OrMag) {
    var angle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var ends = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;

    _classCallCheck(this, Line);

    this.p1 = getPoint(p1);

    if (p2OrMag == null) {
      this.ang = angle;
      this.p2 = this.p1.add(1 * Math.cos(this.ang), 1 * Math.sin(this.ang));
    } else if (typeof p2OrMag === 'number') {
      this.p2 = this.p1.add(p2OrMag * Math.cos(angle), p2OrMag * Math.sin(angle));
      this.ang = angle;
    } else {
      this.p2 = getPoint(p2OrMag);
      this.ang = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
    }

    this.ends = ends;
    this.setupLine();
  }

  _createClass(Line, [{
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      return {
        f1Type: 'l',
        state: [[Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.p1.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.p1.y, precision)], [Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.p2.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.p2.y, precision)], this.ends]
      };
    }
  }, {
    key: "setupLine",
    value: function setupLine() {
      this.A = this.p2.y - this.p1.y;
      this.B = this.p1.x - this.p2.x;
      this.C = this.A * this.p1.x + this.B * this.p1.y;
      this.distance = distance(this.p1, this.p2);
    }
  }, {
    key: "_dup",
    value: function _dup() {
      return new Line(this.p1, this.p2, 0, this.ends);
    }
    /**
     * Change p1 of the line
     */

  }, {
    key: "setP1",
    value: function setP1(p1) {
      this.p1 = getPoint(p1);
      this.ang = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
      this.setupLine();
    }
    /**
     * Change p2 of the line
     */

  }, {
    key: "setP2",
    value: function setP2(p2) {
      this.p2 = getPoint(p2);
      this.ang = Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
      this.setupLine();
    }
    /**
     * Get p1 or p2
     * @return {Point}
     */

  }, {
    key: "getPoint",
    value: function getPoint() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (index === 2) {
        return this.p2;
      }

      return this.p1;
    }
  }, {
    key: "reverse",
    value: function reverse() {
      return new Line(this.p2, this.p1, 0, this.ends);
    }
    /**
     * Get the y coordinate of a point on the line with a given x coordinate
     * @return {number | null} where `null` is returned if the line is vertical
     */

  }, {
    key: "getYFromX",
    value: function getYFromX(x) {
      if (this.B !== 0) {
        return (this.C - this.A * x) / this.B;
      }

      return null;
    }
    /**
     * Get the x coordinate of a point on the line with a given y coordinate
     * @return {number | null} where `null` is returned if the line is horiztonal
     */

  }, {
    key: "getXFromY",
    value: function getXFromY(y) {
      if (this.A !== 0) {
        return (this.C - this.B * y) / this.A;
      }

      return null;
    }
    /**
     * Get the y intercept (at x = 0) of line
     * @return {number | null} where `null` is returned if the line is vertical
     */

  }, {
    key: "getYIntercept",
    value: function getYIntercept() {
      return this.getYFromX(0);
    }
    /**
     * Get the x intercept (at y = 0) of line
     * @return {number | null} where `null` is returned if the line is horizontal
     */

  }, {
    key: "getXIntercept",
    value: function getXIntercept() {
      return this.getXFromY(0);
    }
    /**
     * Get the gradient of the line
     * @return {number}
     */

  }, {
    key: "getGradient",
    value: function getGradient() {
      if (this.B === 0) {
        return null;
      }

      return -this.A / this.B;
    }
    /**
     * Get the angle of the line from p1 to p2
     * @return {number}
     */

  }, {
    key: "angle",
    value: function angle() {
      return this.ang;
    }
    /**
     * Return a duplicate line with values rounded to `precision`
     * @return {Line}
     */

  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var lineRounded = new Line(this.p1, this.p2, 0, this.ends);
      lineRounded.A = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.A, precision);
      lineRounded.B = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.B, precision);
      lineRounded.C = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.C, precision);
      lineRounded.ang = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.ang, precision);
      lineRounded.distance = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(lineRounded.distance, precision);
      return lineRounded;
    }
    /**
     * Return the distance between p1 and p2. Note, for infinite lines
     * this will still return the distance between p1 and p2 that defines
     * the line.
     * @return {number}
     */

  }, {
    key: "length",
    value: function length() {
      // return this.p1.sub(this.p2).distance();
      return this.distance;
    }
    /* eslint-disable comma-dangle */

    /**
     * Return the midpoint between p1 and p2.
     * @return {Point}
     */

  }, {
    key: "midPoint",
    value: function midPoint() {
      // const length = this.length();
      // const direction = this.p2.sub(this.p1);
      // const angle = Math.atan2(direction.y, direction.x);
      // const midPoint = point(
      //   this.p1.x + length / 2 * Math.cos(angle),
      //   this.p1.y + length / 2 * Math.sin(angle)
      // );
      // return midPoint;
      return this.pointAtPercent(0.5);
    }
    /**
     * Return the point along some percent of the distance between p1 and p2.
     * @return {Point}
     */

  }, {
    key: "pointAtPercent",
    value: function pointAtPercent(percent) {
      var length = this.length();
      var direction = this.p2.sub(this.p1);
      var angle = Math.atan2(direction.y, direction.x);
      var p = new Point(this.p1.x + length * percent * Math.cos(angle), this.p1.y + length * percent * Math.sin(angle));
      return p;
    }
    /**
     * Return the point along the line at some length from p1
     * @return {Point}
     */

  }, {
    key: "pointAtLength",
    value: function pointAtLength(length) {
      var totalLength = this.p2.sub(this.p1).distance();
      return this.pointAtPercent(length / totalLength); // const angle = Math.atan2(direction.y, direction.x);
      // const p = new Point(
      //   this.p1.x + length * Math.cos(angle),
      //   this.p1.y + length * Math.sin(angle)
      // );
      // return p;
    }
    /* eslint-enable comma-dangle */

    /**
     * `true` if `point` is along the line extended to infinity on both ends
     * @return {boolean}
     */

  }, {
    key: "hasPointAlong",
    value: function hasPointAlong(point) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var p = getPoint(point);

      if (precision === undefined || precision === null) {
        if (this.C === this.A * p.x + this.B * p.y) {
          return true;
        }
      } else if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.C, precision) === Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.A * p.x + this.B * p.y, precision)) {
        return true;
      }

      return false;
    }
    /**
     * Perpendicular distance from `point` to line
     * @return {number}
     */

  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var p = getPoint(point);
      return Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.abs(this.A * p.x + this.B * p.y - this.C) / Math.sqrt(Math.pow(this.A, 2) + Math.pow(this.B, 2)), precision);
    }
    /**
     * `true` if `point` is on the line.
     *
     * If the line has 2 or 1 finite ends, point must be on or between the
     * defined ends.
     * @return {boolean}
     */

  }, {
    key: "hasPointOn",
    value: function hasPointOn(point) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var p = getPoint(point);

      if (this.hasPointAlong(p, precision)) {
        if (this.ends === 2) {
          if (pointinRect(p, this.p1, this.p2, precision)) {
            return true;
          }

          return false;
        }

        if (this.ends === 1) {
          if (this.p1.isEqualTo(p, precision)) {
            return true;
          }

          var p1ToP = new Line(this.p1, p);

          if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(clipAngle(p1ToP.ang, '0to360'), precision) === Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(clipAngle(this.ang, '0to360'), precision)) {
            return true;
          }

          return false;
        }

        return true; // if this.ends === 0 and point is along, then it is on.
      }

      return false;
    }
    /**
     * `true` if two lines are equal to within some rounding `precision`.
     * @return {boolean}
     */

  }, {
    key: "isEqualTo",
    value: function isEqualTo(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l1 = this;
      var l2 = line2;

      if (l1.ends !== l2.ends) {
        return false;
      }

      if (l1.ends === 2) {
        if (l1.p1.isNotEqualTo(l2.p1, precision) && l1.p1.isNotEqualTo(l2.p2, precision)) {
          return false;
        }

        if (l1.p2.isNotEqualTo(l2.p1, precision) && l1.p2.isNotEqualTo(l2.p2, precision)) {
          return false;
        }

        return true;
      }

      if (l1.ends === 1) {
        if (l1.p1.isNotEqualTo(l2.p1, precision)) {
          return false;
        }

        if (!l1.hasPointOn(l2.p2, precision)) {
          return false;
        }

        return true;
      } // otherwise ends === 0


      if (!l1.hasPointOn(l2.p1)) {
        return false;
      }

      return true;
    }
    /**
     * `true` if two lines are within a delta of each other.
     *
     * This is distinct from a rounding precision as it is an absolute
     * delta.
     *
     * @return {boolean}
     */

  }, {
    key: "isWithinDelta",
    value: function isWithinDelta(line2) {
      var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00000001;
      var l1 = this;
      var l2 = line2;

      if (l1.ends !== l2.ends) {
        return false;
      }

      if (l1.ends === 2) {
        if (l1.p1.isNotWithinDelta(l2.p1, delta) && l1.p1.isNotWithinDelta(l2.p2, delta)) {
          return false;
        }

        if (l1.p2.isNotWithinDelta(l2.p1, delta) && l1.p2.isNotWithinDelta(l2.p2, delta)) {
          return false;
        }

        return true;
      }

      if (l1.ends === 1) {
        if (l1.p1.isNotWithinDelta(l2.p1, delta)) {
          return false;
        }

        if (!l1.hasPointOn(l2.p2, delta)) {
          return false;
        }

        return true;
      } // otherwise ends === 0


      if (!l1.hasPointOn(l2.p1)) {
        return false;
      }

      return true;
    } // isWithinLine
    // hasLineWithin
    // isAlongLine
    // isParrallelToLine
    // isPerpendicularToLine
    // hasLineOn(line2: Line, precision: number = 8) {
    //   return line2.isOn(this, precision);
    // }

    /**
     * `true` if this line is within `line2`
     * @return {boolean}
     */

  }, {
    key: "hasLineWithin",
    value: function hasLineWithin(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      return line2.isWithinLine(this, precision);
    }
    /**
     * `true` if this line is along the infinite length of `line2`
     * @return {boolean}
     */

  }, {
    key: "isAlongLine",
    value: function isAlongLine(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l1 = this.round(precision);
      var l2 = line2.round(precision); // If A and B are zero, then this is not a line

      if (l1.A === 0 && l1.B === 0 || l2.A === 0 && l2.B === 0) {
        return false;
      } // If A is 0, then it must be 0 on the other line. Similar with B


      if (l1.A !== 0) {
        var scale = l2.A / l1.A;

        if (l1.B * scale !== l2.B) {
          return false;
        }

        if (l1.C * scale !== l2.C) {
          return false;
        }

        return true;
      }

      if (l2.A !== 0) {
        var _scale = l1.A / l2.A;

        if (l2.B * _scale !== l1.B) {
          return false;
        }

        if (l2.C * _scale !== l1.C) {
          return false;
        }

        return true;
      }

      if (l1.B !== 0) {
        var _scale2 = l2.B / l1.B;

        if (l1.A * _scale2 !== l2.A) {
          return false;
        }

        if (l1.C * _scale2 !== l2.C) {
          return false;
        }

        return true;
      }

      if (l2.B !== 0) {
        var _scale3 = l1.B / l2.B;

        if (l2.A * _scale3 !== l1.A) {
          return false;
        }

        if (l2.C * _scale3 !== l1.C) {
          return false;
        }

        return true;
      }

      return true;
    }
    /**
     * `true` if this line is contained within `line2`
     * @return {boolean}
     */

  }, {
    key: "isWithinLine",
    value: function isWithinLine(line2) {
      var _this = this;

      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l1 = this.round(precision);
      var l2 = line2.round(precision);

      if (!l1.isAlongLine(l2, precision)) {
        return false;
      }

      if (line2.ends === 0) {
        return true;
      }

      var withinEnds = function withinEnds() {
        return l2.hasPointOn(_this.p1, precision) && l2.hasPointOn(_this.p2, precision);
      };

      if (this.ends < line2.ends) {
        return false;
      }

      if (this.ends === 2) {
        return withinEnds();
      }

      return withinEnds();
    } // left, right, top, bottom is relative to cartesian coordinates
    // 'outside' is the outside of a polygon defined in the positive direction
    // (CCW).

    /**
     * Create a line that is offset by some distance from this line.
     *
     * `'left'`, `'right'`, `'top'` and `'bottom'` are relative to cartesian
     * coordinates.
     *
     * `'positive'` to the right of a vertical line defined from bottom to top and
     * above a horizontal line defined from right to left. Another way to think of
     * it is if lines are used to create a polygon in the positive rotation
     * direction (CCW), the the `'positive'` side will be on the outside of the
     * polygon.
     *
     * `'negative'` is then the inside of the same polygon.
     * @return  {Line}
     */

  }, {
    key: "offset",
    value: function offset(direction, dist) {
      var normalizedAngle = this.ang;

      if (normalizedAngle >= Math.PI) {
        normalizedAngle -= Math.PI;
      }

      if (normalizedAngle < 0) {
        normalizedAngle += Math.PI;
      }

      var offsetAngle = normalizedAngle - Math.PI / 2;

      if (direction === 'positive') {
        offsetAngle = clipAngle(this.ang, '0to360') + Math.PI / 2;
      } else if (direction === 'negative') {
        offsetAngle = clipAngle(this.ang, '0to360') - Math.PI / 2;
      } else if (normalizedAngle < Math.PI / 2) {
        if (direction === 'left' || direction === 'top') {
          offsetAngle = normalizedAngle + Math.PI / 2;
        }
      } else if (direction === 'left' || direction === 'bottom') {
        offsetAngle = normalizedAngle + Math.PI / 2;
      }

      var p1 = new Point(this.p1.x + dist * Math.cos(offsetAngle), this.p1.y + dist * Math.sin(offsetAngle));
      var p2 = new Point(this.p2.x + dist * Math.cos(offsetAngle), this.p2.y + dist * Math.sin(offsetAngle));
      return new Line(p1, p2, 0, this.ends);
    } // If two lines are parallel, their determinant is 0

    /**
     * `true` if this line is parralel with `line2`
     * @return {boolean}
     */

  }, {
    key: "isParallelWith",
    value: function isParallelWith(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l2 = line2; // line2.round(precision);

      var l1 = this; // this.round(precision);

      var det = l1.A * l2.B - l2.A * l1.B;

      if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(det, precision) === 0) {
        return true;
      }

      return false;
    } // This needs to be tested somewhere as p1ToShaddow = line was updated

  }, {
    key: "shaddowOn",
    value: function shaddowOn(l) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;

      var _this$intersectsWith = this.intersectsWith(l, precision),
          intersect = _this$intersectsWith.intersect;

      if (intersect == null) {
        return null;
      }

      var perpendicular = new Line(intersect, 1, l.ang + Math.PI / 2);
      var shaddow = this.p1.getShaddowOnLine(perpendicular, precision);
      var p1ToShaddow = new Line(this.p1, shaddow);
      var dist = p1ToShaddow.distance; // const distance = shaddow.distance(this.p1);

      var projection = new Point(this.p1.x + dist * 2 * Math.cos(p1ToShaddow.ang), this.p1.y + dist * 2 * Math.sin(p1ToShaddow.ang));
      return new Line(intersect, projection);
    } // At two lines intersection, the x and y values must be equal
    //   A1x + B1y = C1 => y = -A1/B1x + C1/B1      - Eq 1
    //   A2x + B2y = C2 => y = -A2/B2x + C2/B2      - Eq 2
    // Right hand sides are equal:
    //   -A1/B1x + C1/B1 = -A2/B2x + C2/B2
    //   x(-A1/B1 + A2/B2) = C2/B2 - C1/B1
    //   x(-A1B2 + A2B1)/B1B2 = (C2B1 - C1B2)/B1B2
    //   x = (C2B1 - C1B2) / (-A1B2 + A2B1)
    //   y = -A1/B1x + C1/B1
    // If however B1 is 0, then y can be found from eqn 2
    //   y = -A2/B2x + C2/B2

    /**
     * The intersection between this line and `line2`.
     *
     * The returned result is an {@link Intersect} object with keys `intersect`,
     * `alongLine` and `withinLine`. The `intersect` is found by extending both
     * lines to infinity and recording where they cross. If the two lines never
     * cross, and are not collinear, then the result will be `undefined`.
     * `alongLine` and `withinLine` can then be used as metadata to defermine if
     * the intersection is within finite lines or not.
     *
     * The properties of the two lines, such as whether they have zero, finite,
     * or infinite length, and are parallel or collinear will define the result.
     *
     * If the lines are not parallel and/or collinear then the returned intercept
     * will be the point where the two lines, extended to infinity, cross. The
     * `withinLine` returned property can then be used to determine if the
     * intercept point is within this line.
     *
     * If one of the lines has zero length, then `intersect` will only be
     * defined if p1 of the zero length line lies along the other line.
     *
     * If both of the lines have zero length, then `intersect` will only be
     * defined if p1 of both lines is the same.
     *
     * If the lines are parallel and not collinear, then `intercept` will be
     * undefined.
     *
     * If lines are collinear then the `intercept` point will be defined by how
     * many finite ends the lines have and wheter the lines are overlapping or
     * not
     *
     * Lines are equal:
     *    - 0 ends: take the yIntercept (or xIntercept if vertical)
     *    - 1 ends: take the p1 point
     *    - 2 ends: take the midPoint
     *
     * One line within the other: take mid point between mid points
     *    - 2 ends around 2 ends: take the midPoint of the two midPoints
     *    - 0 ends around 2 ends: take the midPoint of the 2 ends
     *    - 0 ends around 1 ends: take the p1 of the 1 ends
     *    - 1 end around 1 end: take the midPoint between the p1s
     *    - 1 end around 2 ends: take the midPoint of the two ends
     *
     * Lines are not overlapping:
     *    - Both 2 ends - take midPoint between 2 closest ends
     *    - Both 1 ends - take midPoint between 2 p1s
     *    - One 1 end and 2 end - take midPoint between p1 and closest point
     *
     * Lines are partially overlapping:
     *    - Both 2 ends - take midPoint between 2 overlapping ends
     *    - Both 1 ends - take midPoint between both p1s
     *    - One 1 end and 2 end - take midPoint between overlapping end and p1
     * @return {Intersect}
     */

  }, {
    key: "intersectsWith",
    value: function intersectsWith(line2) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      var l2 = line2; // line2.round(precision);

      var l1 = this; // this.round(precision);

      var d1 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.distance, precision);
      var d2 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(l2.distance, precision);

      if (d1 === 0 || d2 === 0) {
        var _i2;

        var alongLine = false;
        var _withinLine = false;

        if (d1 === 0 && d2 === 0) {
          if (l1.p1.isEqualTo(l2.p1, precision)) {
            _i2 = l1.p1._dup();
            alongLine = true;
            _withinLine = true;
          }
        }

        if (d1 > 0) {
          if (l1.hasPointOn(l2.p1, precision)) {
            _i2 = l2.p1._dup();
            _withinLine = true;
            alongLine = true;
          } else if (l1.hasPointAlong(l2.p1, precision)) {
            _i2 = l2.p1._dup();
            alongLine = true;
          }
        }

        if (d2 > 0) {
          if (l2.hasPointOn(l1.p1, precision)) {
            _i2 = l1.p1._dup();
            _withinLine = true;
            alongLine = true;
          } else if (l2.hasPointAlong(l1.p1, precision)) {
            _i2 = l1.p1._dup();
            alongLine = true;
          }
        }

        return {
          intersect: _i2,
          alongLine: alongLine,
          withinLine: _withinLine
        };
      }

      if (!l1.isParallelWith(l2)) {
        var _i3;

        if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(l1.A, precision) === 0 && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(l2.B, precision) === 0) {
          _i3 = new Point(l2.p1.x, l1.p1.y);
        } else if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(l1.B, precision) === 0 && Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(l2.A, precision) === 0) {
          _i3 = new Point(l1.p1.x, l2.p1.y); // if l1.B is 0, then l1 has constant x
        } else if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(l1.B, precision) === 0) {
          var x = (l2.C * l1.B - l1.C * l2.B) / (-l1.A * l2.B + l2.A * l1.B);
          var y = -l2.A / l2.B * x + l2.C / l2.B;
          _i3 = new Point(x, y);
        } else {
          var _x = (l2.C * l1.B - l1.C * l2.B) / (-l1.A * l2.B + l2.A * l1.B);

          var _y = -l1.A / l1.B * _x + l1.C / l1.B;

          _i3 = new Point(_x, _y);
        }

        if (l1.hasPointOn(_i3, precision) && l2.hasPointOn(_i3, precision)) {
          return {
            alongLine: true,
            withinLine: true,
            intersect: _i3
          };
        }

        return {
          alongLine: true,
          withinLine: false,
          intersect: _i3
        };
      }

      if (!l1.isAlongLine(l2, precision)) {
        return {
          alongLine: false,
          withinLine: false,
          intersect: undefined
        };
      } // If lines are collinear they could be either:
      //   - equal:
      //      - 0 ends: take the yIntercept (or xIntercept if vertical)
      //      - 1 ends: take the p1 point
      //      - 2 ends: take the midPoint
      //   - one within the other: take mid point between mid points
      //      - 2 ends around 2 ends: take the midPoint of the two midPoints
      //      - 0 ends around 2 ends: take the midPoint of the 2 ends
      //      - 0 ends around 1 ends: take the p1 of the 1 ends
      //      - 1 end around 1 end: take the midPoint between the p1s
      //      - 1 end around 2 ends: take the midPoint of the two ends
      //   - not overlapping:
      //      - Both 2 ends - take midPoint between 2 closest ends
      //      - Both 1 ends - take midPoint between 2 p1s
      //      - One 1 end and 2 end - take midPoint between p1 and closest point
      //   - partially overlapping:
      //      - Both 2 ends - take midPoint between 2 overlapping ends
      //      - Both 1 ends - take midPoint between both p1s
      //      - One 1 end and 2 end - take midPoint between overlapping end and p1
      // If Equal


      var xIntercept = this.getXIntercept();
      var yIntercept = this.getYIntercept();
      var defaultIntercept;

      if (yIntercept != null) {
        defaultIntercept = new Point(0, yIntercept);
      } else if (xIntercept != null) {
        defaultIntercept = new Point(xIntercept, 0);
      } else {
        defaultIntercept = new Point(0, 0);
      } // const defaultIntercept = yIntercept == null ? new Point(
      // xIntercept == null ? 0 : xIntercept, 0) : new Point(0, yIntercept);


      if (l1.isEqualTo(l2, precision)) {
        var _i4;

        if (l1.ends === 2) {
          _i4 = l1.midPoint();
        } else if (l1.ends === 1) {
          _i4 = l1.p1._dup();
        } else {
          _i4 = defaultIntercept;
        }

        return {
          alongLine: true,
          withinLine: true,
          intersect: _i4
        };
      } // If one line is fully within the other


      var i;

      var lineIsWithin = function lineIsWithin(li1, li2) {
        // If fully overlapping
        if (li1.hasLineWithin(li2, precision)) {
          if (li1.ends === 2) {
            i = new Line(li1.midPoint(), li2.midPoint()).midPoint();
          }

          if (li1.ends === 1 && li2.ends === 1) {
            i = new Line(li1.p1, li2.p1);
          }

          if (li1.ends === 1 && li2.ends === 2) {
            i = li2.midPoint();
          }

          if (li1.ends === 0 && li2.ends === 2) {
            i = li2.midPoint();
          }

          if (li1.ends === 0 && li2.ends === 1) {
            i = li2.p1._dup();
          }

          if (li1.ends > li2.ends) {
            if (li1.ends === 2) {
              i = li1.midPoint();
            } else {
              i = li1.p1;
            }
          }

          if (li1.ends === 1 && li2.ends === 1) {
            i = new Line(li1.p1, li2.p1).midPoint();
          }

          return true;
        }

        return false;
      };

      if (lineIsWithin(l1, l2)) {
        return {
          alongLine: true,
          withinLine: true,
          intersect: i
        };
      }

      if (lineIsWithin(l2, l1)) {
        return {
          alongLine: true,
          withinLine: true,
          intersect: i
        };
      } // Two finite lines


      if (l1.ends === 2 && l2.ends === 2) {
        // Not overlapping
        if (!l1.p1.isWithinLine(l2, precision) && !l1.p2.isWithinLine(l2, precision) && !l2.p1.isWithinLine(l1, precision) && !l2.p2.isWithinLine(l1, precision)) {
          var line11 = new Line(l1.p1, l2.p1);
          var line12 = new Line(l1.p1, l2.p2);
          var line21 = new Line(l1.p2, l2.p1);
          var line22 = new Line(l1.p2, l2.p2);
          i = line11.midPoint();
          var len = line11.length();

          if (line12.length() < len) {
            i = line12.midPoint();
            len = line12.length();
          }

          if (line21.length() < len) {
            i = line21.midPoint();
            len = line21.length();
          }

          if (line22.length() < len) {
            i = line22.midPoint();
            len = line22.length();
          }

          return {
            alongLine: true,
            withinLine: false,
            intersect: i
          };
        } // Partial overlap


        if (l1.p1.isWithinLine(l2, precision)) {
          if (l2.p1.isWithinLine(l1, precision)) {
            i = new Line(l1.p1, l2.p1).midPoint();
          } else {
            i = new Line(l1.p1, l2.p2).midPoint();
          }
        } else if (l2.p1.isWithinLine(l1, precision)) {
          i = new Line(l1.p2, l2.p1).midPoint();
        } else {
          i = new Line(l1.p2, l2.p2).midPoint();
        }

        return {
          alongLine: true,
          withinLine: true,
          intersect: i
        };
      } // Two 1 end lines


      if (l1.ends === 1 && l2.ends === 1) {
        // Both not overlapping and partial overlap will have an intersect as
        // the midPoint between the p1s
        return {
          alongLine: true,
          withinLine: false,
          intersect: new Line(l1.p1, l2.p1).midPoint()
        };
      } // One 1 end, one 2 end is the only remaining possibility


      var withinLine = false;

      var checkOverlap = function checkOverlap(li1, li2) {
        // partial overlap
        if (li1.p1.isWithinLine(li2)) {
          withinLine = true;

          if (li2.p1.isWithinLine(li1)) {
            i = new Line(li1.p1, li2.p1).midPoint();
          } else {
            i = new Line(li1.p1, li2.p2).midPoint();
          } // No Overlap

        } else {
          withinLine = false;
          var l11 = new Line(li1.p1, li2.p1);
          var l12 = new Line(li1.p1, li2.p2);

          if (l11.length() < l12.length()) {
            i = l11.midPoint();
          } else {
            i = l12.midPoint();
          }
        }
      };

      if (l1.ends === 1 && l2.ends === 2) {
        checkOverlap(l1, l2);
      } else {
        checkOverlap(l2, l1);
      }

      return {
        alongLine: true,
        withinLine: withinLine,
        intersect: i
      };
    }
  }]);

  return Line;
}();

var Vector = /*#__PURE__*/function (_Line) {
  _inherits(Vector, _Line);

  var _super = _createSuper(Vector);

  function Vector(p1OrLine, p2OrMag) {
    var _this2;

    var angle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, Vector);

    if (p1OrLine instanceof Line) {
      _this2 = _super.call(this, p1OrLine.p1, p1OrLine.distance, p1OrLine.ang);
    } else {
      _this2 = _super.call(this, p1OrLine, p2OrMag, angle);
    }

    _this2.i = _this2.distance * Math.cos(_this2.ang);
    _this2.j = _this2.distance * Math.sin(_this2.ang);
    return _possibleConstructorReturn(_this2);
  }

  _createClass(Vector, [{
    key: "unit",
    value: function unit() {
      return new Vector(this.p1, 1, this.ang);
    }
  }, {
    key: "dotProduct",
    value: function dotProduct(v) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
      return Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.i * v.i + this.j * v.j, precision);
    }
  }]);

  return Vector;
}(Line);

function line(p1, p2) {
  return new Line(p1, p2);
}

// line can be defined as:
//    - [[0, 0], [1, 0]]
//    - [[0, 0], 1, 0]
function parseLine(lIn, onFail) {
  if (lIn instanceof Line) {
    return lIn;
  }

  var onFailToUse = onFail;

  if (onFailToUse == null) {
    onFailToUse = null;
  }

  if (lIn == null) {
    return onFailToUse;
  }

  var l = lIn;

  if (typeof l === 'string') {
    try {
      l = JSON.parse(l);
    } catch (_unused3) {
      return onFailToUse;
    }
  }

  if (Array.isArray(l)) {
    if (l.length === 4) {
      return new Line(getPoint(l[0]), l[1], l[2], l[3]);
    }

    if (l.length === 3) {
      if (typeof l[1] === 'number') {
        return new Line(getPoint(l[0]), l[1], l[2]);
      } // $FlowFixMe


      return new Line(getPoint(l[0]), getPoint(l[1]), 0, l[2]);
    }

    if (l.length === 2) {
      return new Line(getPoint(l[0]), getPoint(l[1]));
    }

    return onFailToUse;
  }

  if (l.f1Type != null) {
    if (l.f1Type === 'l' && l.state != null && Array.isArray([l.state]) && l.state.length === 3) {
      var _l$state = _slicedToArray(l.state, 3),
          p1 = _l$state[0],
          p2 = _l$state[1],
          ends = _l$state[2];

      return new Line(getPoint(p1), getPoint(p2), 0, ends);
    }

    return onFailToUse;
  }

  return onFailToUse;
}
/**
 * Convert a parsable line definition to a {@link Line}.
 * @param {TypeParsableLine} l parsable line definition
 * @return {Line} `Line` object
 */


function getLine(l) {
  var parsedLine = parseLine(l);

  if (parsedLine == null) {
    parsedLine = new Line(new Point(0, 0), new Point(1, 0));
  }

  return parsedLine;
}

/**
 * Rotation transform element
 */
var Rotation = /*#__PURE__*/function () {
  /**
   * @param {number | string} rotationAngle
   * @param {string} name name to give to rotation to identify it in a more
   * complex {@link Transform}
   */
  function Rotation(rotationAngle) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, Rotation);

    var nameToUse = name;
    var angle = rotationAngle;

    if (typeof angle === 'string') {
      try {
        angle = JSON.parse(angle);
      } catch (_unused4) {
        angle = 0;
      }
    }

    if (typeof angle === 'number') {
      this.r = angle;
    } else if (angle.f1Type != null && angle.f1Type === 'r' && angle.state != null && Array.isArray(angle.state) && angle.state.length === 2) {
      var _angle$state = _slicedToArray(angle.state, 2),
          n = _angle$state[0],
          r = _angle$state[1];

      nameToUse = n;
      this.r = r;
    } else {
      this.r = 0;
    }

    this.name = nameToUse;
  }

  _createClass(Rotation, [{
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      return {
        f1Type: 'r',
        state: [this.name, Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.r, precision)]
      };
    }
    /**
     * Return a rotation matrix representing the rotation
     * @return {Array<number>}
     */

  }, {
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_2__["rotationMatrix"](this.r);
    }
    /**
     * Subtract `rotToSub` from this rotation
     * @return {Rotation}
     */

  }, {
    key: "sub",
    value: function sub() {
      var rotToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(0, this.name);
      return new Rotation(this.r - rotToSub.r, this.name);
    }
    /**
     * Round this rotation to some `precision`
     * @return {Rotation}
     */

  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Rotation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.r, precision), this.name);
    }
    /**
     * Add `rotToAdd` to this rotation
     * @return {Rotation}
     */

  }, {
    key: "add",
    value: function add() {
      var rotToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(0, this.name);
      return new Rotation(this.r + rotToAdd.r, this.name);
    }
    /**
     * Multiply `rotToMul` to this rotation
     * @return {Rotation}
     */

  }, {
    key: "mul",
    value: function mul() {
      var rotToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Rotation(1, this.name);
      return new Rotation(this.r * rotToMul.r, this.name);
    }
    /**
     * Return a duplicate rotation
     * @return {Rotation}
     */

  }, {
    key: "_dup",
    value: function _dup() {
      return new Rotation(this.r, this.name);
    }
  }]);

  return Rotation;
}();

/**
 * Translation transform element
 */
var Translation = /*#__PURE__*/function (_Point) {
  _inherits(Translation, _Point);

  var _super2 = _createSuper(Translation);

  /**
   * @param {Point | number} txOrTranslation translation or x value of
   * translation
   * @param {number} ty y value of translation (only used if `txOrTranslation`
   * is a `number`)
   * @param {string} name name to identify translation when included in a more
   * complex {@link Transform}
   */
  function Translation(txOrTranslation) {
    var _this3;

    var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    _classCallCheck(this, Translation);

    var nameToUse = name;
    var tx = txOrTranslation;
    var tyToUse = ty;

    if (typeof tx === 'string') {
      try {
        tx = JSON.parse(tx);
      } catch (_unused5) {
        tx = 0;
      }

      if (Array.isArray(tx) && tx.length === 2) {
        var _tx = tx;

        var _tx2 = _slicedToArray(_tx, 2);

        tx = _tx2[0];
        tyToUse = _tx2[1];
      }
    }

    if (tx instanceof Point) {
      _this3 = _super2.call(this, tx.x, tx.y);
    } else if (typeof tx === 'number') {
      _this3 = _super2.call(this, tx, tyToUse);
    } else if (tx.f1Type != null && tx.f1Type === 't' && tx.state != null && Array.isArray(tx.state) && tx.state.length === 3) {
      var _tx$state = _slicedToArray(tx.state, 3),
          n = _tx$state[0],
          x = _tx$state[1],
          y = _tx$state[2];

      nameToUse = n;
      _this3 = _super2.call(this, x, y);
    } else {
      _this3 = _super2.call(this, 0, 0);
    }

    _this3.name = nameToUse;
    return _possibleConstructorReturn(_this3);
  }

  _createClass(Translation, [{
    key: "_state",
    value: function _state(options) {
      var precision = getPrecision(options);
      return {
        f1Type: 't',
        state: [this.name, Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision)]
      };
    }
    /**
     * Returns a translation matrix
     * @return {Array<number>}
     */

  }, {
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_2__["translationMatrix"](this.x, this.y);
    }
    /**
     * Subtract `translationToSub` from this translation
     * @return {Translation}
     */

  }, {
    key: "sub",
    value: function sub() {
      var translationToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var t = new Point(0, 0);

      if (typeof translationToSub === 'number') {
        t = new Translation(translationToSub, y);
      } else {
        t = translationToSub;
      }

      return new Translation(this.x - t.x, this.y - t.y, this.name);
    }
    /**
     * Add `translationToAdd` to this translation
     * @return {Translation}
     */

  }, {
    key: "add",
    value: function add() {
      var translationToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var t = new Point(0, 0);

      if (typeof translationToAdd === 'number') {
        t = new Translation(translationToAdd, y);
      } else {
        t = translationToAdd;
      }

      return new Translation(this.x + t.x, this.y + t.y, this.name);
    }
    /**
     * Multiply `translationToMul` to this translation
     * @return {Translation}
     */

  }, {
    key: "mul",
    value: function mul() {
      var translationToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Translation(1, 1);
      return new Translation(this.x * translationToMul.x, this.y * translationToMul.y, this.name);
    }
    /**
     * Round this translation to some `precision`
     * @return {Translation}
     */

  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Translation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision), this.name);
    }
    /**
     * Return a duplicate translation
     */

  }, {
    key: "_dup",
    value: function _dup() {
      return new Translation(this.x, this.y, this.name);
    }
  }]);

  return Translation;
}(Point);

/**
 * Scale transform element
 */
var Scale = /*#__PURE__*/function (_Point2) {
  _inherits(Scale, _Point2);

  var _super3 = _createSuper(Scale);

  /**
   * @param {Point | number} sxOrScale scale or x value of
   * scale
   * @param {number} ty y value of scale (only used if `sxOrScale`
   * is a `number`)
   * @param {string} name name to identify scale when included in a more
   * complex {@link Transform}
   */
  function Scale(sxOrScale, sy) {
    var _this4;

    var nameIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    _classCallCheck(this, Scale);

    var name = nameIn;
    var sx = sxOrScale;
    var syToUse = sy;

    if (typeof sx === 'string') {
      try {
        sx = JSON.parse(sx);
      } catch (_unused6) {
        sx = 0;
      }

      if (Array.isArray(sx) && sx.length === 2) {
        var _sx = sx;

        var _sx2 = _slicedToArray(_sx, 2);

        sx = _sx2[0];
        syToUse = _sx2[1];
      }
    }

    if (sx instanceof Point) {
      _this4 = _super3.call(this, sx.x, sx.y);
    } else if (typeof sx === 'number') {
      if (syToUse != null) {
        _this4 = _super3.call(this, sx, syToUse);
      } else {
        _this4 = _super3.call(this, sx, sx);
      }
    } else if (sx.f1Type != null && sx.f1Type === 's' && sx.state != null && Array.isArray(sx.state) && sx.state.length === 3) {
      var _sx$state = _slicedToArray(sx.state, 3),
          n = _sx$state[0],
          x = _sx$state[1],
          y = _sx$state[2];

      name = n;
      _this4 = _super3.call(this, x, y);
    } else {
      _this4 = _super3.call(this, 1, 1);
    }

    _this4.name = name;
    return _possibleConstructorReturn(_this4);
  }

  _createClass(Scale, [{
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      return {
        f1Type: 's',
        state: [this.name, Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision)]
      };
    }
    /**
     * Returns a scale matrix
     * @return {Array<number>}
     */

  }, {
    key: "matrix",
    value: function matrix() {
      return _m2__WEBPACK_IMPORTED_MODULE_2__["scaleMatrix"](this.x, this.y);
    }
    /**
     * Subtract `scaleToSub` from this scale
     * @return {Scale}
     */

  }, {
    key: "sub",
    value: function sub() {
      var scaleToSub = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s = new Point(0, 0);

      if (typeof scaleToSub === 'number') {
        s = new Scale(scaleToSub, y);
      } else {
        s = scaleToSub;
      }

      return new Scale(this.x - s.x, this.y - s.y, this.name);
    }
    /**
     * Round this scale to some `precision`
     * @return {Scale}
     */

  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      return new Scale(Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.y, precision), this.name);
    }
    /**
     * Add `scaleToAdd` to this scale
     * @return {Scale}
     */

  }, {
    key: "add",
    value: function add() {
      var scaleToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(0, 0);
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s = new Point(0, 0);

      if (typeof scaleToAdd === 'number') {
        s = new Scale(scaleToAdd, y);
      } else {
        s = scaleToAdd;
      }

      return new Scale(this.x + s.x, this.y + s.y, this.name);
    }
    /**
     * Multiply `scaleToMul` to this scale
     * @return {Scale}
     */

  }, {
    key: "mul",
    value: function mul() {
      var scaleToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scale(1, 1);

      if (scaleToMul instanceof Scale || scaleToMul instanceof Point) {
        return new Scale(this.x * scaleToMul.x, this.y * scaleToMul.y);
      }

      return new Scale(this.x * scaleToMul, this.y * scaleToMul, this.name);
    }
    /**
     * Return a duplicate of this scale
     * @return {Scale}
     */

  }, {
    key: "_dup",
    value: function _dup() {
      return new Scale(this.x, this.y, this.name);
    }
  }]);

  return Scale;
}(Point);

/**
 * Object that represents a chain of {@link Rotation}, {@link Translation} and
 * {@link Scale} transforms
 *
 * Use `translate`, `scale` and `rotate` methods to create chains (see example).
 *
 * @example
 * // Create a tranform that first scales, then rotates then translates
 * const t1 = new Transform().scale(2, 2).rotate(Math.PI).translate(1, 1)
 */
var Transform = /*#__PURE__*/function () {
  /**
   * @param {Array<Translation | Rotation | Scale> | string} chainOrName chain
   * of transforms to initialize this Transform with, or name of transform if
   * not initializing with transforms.
   * @param {string} name transform name if `chainOrName` defines initializing
   * transforms
   */
  function Transform() {
    var chainOrName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    _classCallCheck(this, Transform);

    if (typeof chainOrName === 'string') {
      this.order = [];
      this.name = chainOrName;
    } else {
      // for (let i = 0; i < orderOrName.length; i += 1 ) {
      //   const t = orderOrName[i];
      //   if (
      //     !(t instanceof Translation)
      //     && !(t instanceof Scale)
      //     && !(t instanceof Rotation)
      //   ) {
      //     debugger;
      //   }
      // }
      // debugger;
      this.order = chainOrName.map(function (t) {
        return t._dup();
      });
      this.name = name;
    } // this.order = order.slice();


    this.index = this.order.length;
    this._type = 'transform';
    this.calcAndSetMatrix();
  }

  _createClass(Transform, [{
    key: "_state",
    value: function _state() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        precision: 8
      };
      // const { precision } = options;
      var out = [];
      this.order.forEach(function (transformElement) {
        out.push(transformElement._state(options));
      }); // if (this.name !== '') {
      //   // return [this.name, ...out];
      //   out = [this.name, ...out];
      // }

      return {
        f1Type: 'tf',
        state: [this.name].concat(out)
      };
    }
    /**
     * Return a standard unity transform chain that includes scale, rotation and
     * translation blocks
     * @return {Transform}
     */

  }, {
    key: "standard",
    value: function standard() {
      return this.scale(1, 1).rotate(0).translate(0, 0);
    }
    /**
     * Return a duplicate transform with an added {@link Translation} transform
     * @param {number | Point} xOrTranslation
     * @return {Transform}
     */

  }, {
    key: "translate",
    value: function translate(xOrTranslation) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.name;
      var translation = new Translation(xOrTranslation, y, name);
      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(translation);
      } else {
        this.order[this.index] = translation;
        this.index += 1;
        this.calcAndSetMatrix();
        return this;
      }

      return new Transform(order, name);
    }
    /**
     * Return a duplicate transform with an added {@link Rotation} transform
     * @param {number} r
     * @return {Transform}
     */

  }, {
    key: "rotate",
    value: function rotate(r) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.name;
      var rotation = new Rotation(r, name); // rotation.name = name;

      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(rotation);
      } else {
        this.order[this.index] = rotation;
        this.index += 1;
        this.calcAndSetMatrix();
        return this;
      } // this.order.push(new Rotation(r));
      // this.calcMatrix();


      return new Transform(order, name);
    }
    /**
     * Return a duplicate transform with an added {@link Scale} transform
     * @param {number | Point} xOrScale
     * @return {Transform}
     */

  }, {
    key: "scale",
    value: function scale(xOrScale) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.name;
      var scale = new Scale(xOrScale, y, name);
      var order = this.order.slice();

      if (this.index === this.order.length) {
        order.push(scale);
      } else {
        this.order[this.index] = scale;
        this.index += 1;
        this.calcAndSetMatrix();
        return this;
      }

      return new Transform(order, name);
    }
    /**
     * Remove some transforms from this transform chain
     * @return {Transform}
     */

  }, {
    key: "remove",
    value: function remove(transformNames) {
      var newOrder = [];
      var names;

      if (typeof transformNames === 'string') {
        names = [transformNames];
      } else {
        names = transformNames;
      }

      this.order.forEach(function (transformElement) {
        if (names.indexOf(transformElement.name) === -1) {
          newOrder.push(transformElement._dup());
        }
      });
      return new Transform(newOrder, this.name);
    }
    /**
     * Transform matrix of the transform chain
     * @return {Array<number>}
     */

  }, {
    key: "calcMatrix",
    value: function calcMatrix() {
      var orderStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var orderEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.order.length - 1;
      var orderEndToUse = orderEnd;

      if (orderEnd < 0) {
        orderEndToUse = this.order.length + orderEnd;
      }

      var m = _m2__WEBPACK_IMPORTED_MODULE_2__["identity"]();

      for (var i = orderEndToUse; i >= orderStart; i -= 1) {
        m = _m2__WEBPACK_IMPORTED_MODULE_2__["mul"](m, this.order[i].matrix());
      }

      return m; // this.mat = m2.copy(m);
      // return m;
      // this.mat = m;
    }
  }, {
    key: "calcAndSetMatrix",
    value: function calcAndSetMatrix() {
      this.mat = this.calcMatrix();
    } // /**
    //  * Transform matrix of the transform chain
    //  * @return {Array<number>}
    //  */
    // calcMatrix(
    //   orderStart: number = 0,
    //   orderEnd: number = this.order.length - 1,
    // ) {
    //   let orderEndToUse = orderEnd;
    //   if (orderEnd < 0) {
    //     orderEndToUse = this.order.length + orderEnd;
    //   }
    //   let m = m2.identity();
    //   for (let i = orderEndToUse; i >= orderStart; i -= 1) {
    //     m = m2.mul(m, this.order[i].matrix());
    //   }
    //   // this.mat = m2.copy(m);
    //   // return m;
    //   this.mat = m;
    // }

  }, {
    key: "update",
    value: function update(index) {
      if (index < this.order.length) {
        this.index = index;
      }

      return this;
    }
    /**
     * Retrieve the nth {@link Translation} transform value from this transform
     * chain where n = `translationIndex`. If `translationIndex` is invalid
     * (like if it is larger than the number of `Translation` transforms available)
     * then `null` will be returned.
     * @return {Point | null}
     */

  }, {
    key: "t",
    value: function t() {
      var translationIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (count === translationIndex) {
            return new Point(t.x, t.y);
          }

          count += 1;
        }
      }

      return null;
    }
    /**
     * Clip all {@link Rotation} transforms within this transform chain to
     * angles between 0º-360º, -180º-180º, or not at all (`null`)
     */

  }, {
    key: "clipRotation",
    value: function clipRotation(clipTo) {
      for (var i = 0; i < this.order.length; i += 1) {
        var transformStep = this.order[i];

        if (transformStep instanceof Rotation) {
          transformStep.r = clipAngle(transformStep.r, clipTo);
        }
      }
    }
    /**
     * Return a duplicate transform chain with an updated the nth
     * {@link Translation} transform where n = `index`
     * @return {Transform}
     */

  }, {
    key: "updateTranslation",
    value: function updateTranslation(x) {
      var yOrIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var count = 0;
      var actualIndex = index;

      if (x instanceof Point) {
        actualIndex = yOrIndex;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (count === actualIndex) {
            this.order[i] = new Translation(x, yOrIndex, this.name);
            this.calcAndSetMatrix();
            return this;
          }

          count += 1;
        }
      }

      return this;
    }
    /**
     * Retrieve the nth {@link Scale} transform value from this transform
     * chain where n = `scaleIndex`. If `scaleIndex` is invalid
     * (like if it is larger than the number of `Scale` transforms available)
     * then `null` will be returned.
     * @return {Point | null}
     */

  }, {
    key: "s",
    value: function s() {
      var scaleIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Scale) {
          if (count === scaleIndex) {
            return new Point(t.x, t.y);
          }

          count += 1;
        }
      }

      return null;
    }
    /**
     * Return an interpolated transform between this transform and `delta` at
     * some `percent` between the two.
     *
     * Interpolation can either be `'linear'` or '`curved'`.
     * @return {Transform}
     */

  }, {
    key: "toDelta",
    value: function toDelta(delta, percent, translationStyle, translationOptions) // translationPath: (Point, Point, number, ?number, ?number) => Point,
    // direction: number = 1,
    // mag: number = 0.5,
    // offset: number = 0.5,
    {
      var calcTransform = this._dup();

      for (var i = 0; i < this.order.length; i += 1) {
        var stepStart = this.order[i];
        var stepDelta = delta.order[i];

        if (stepStart instanceof Scale && stepDelta instanceof Scale) {
          calcTransform.order[i] = stepStart.add(stepDelta.mul(percent));
        }

        if (stepStart instanceof Rotation && stepDelta instanceof Rotation) {
          calcTransform.order[i] = new Rotation(stepStart.r + stepDelta.r * percent, stepStart.name);
        }

        if (stepStart instanceof Translation && stepDelta instanceof Translation) {
          calcTransform.order[i] = new Translation(translationPath(translationStyle, stepStart, stepDelta, percent, translationOptions), 0, stepStart.name);
        }
      }

      return calcTransform;
    }
    /**
     * Return a duplicate transform chain with an updated the nth
     * {@link Scale} transform where n = `index`
     * @return {Transform}
     */

  }, {
    key: "updateScale",
    value: function updateScale(x) {
      var yOrIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var count = 0;
      var actualIndex = index;
      var scale = new Point(1, 1);

      if (x instanceof Point) {
        if (yOrIndex == null) {
          actualIndex = 0;
        } else {
          actualIndex = yOrIndex;
        }

        scale = x;
      } else if (yOrIndex == null) {
        scale.x = x;
        scale.y = x;
      } else {
        scale.x = x;
        scale.y = yOrIndex;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Scale) {
          if (count === actualIndex) {
            this.order[i] = new Scale(scale.x, scale.y, this.name);
            this.calcAndSetMatrix();
            return this;
          }

          count += 1;
        }
      }

      return this;
    }
    /**
     * Retrieve the nth {@link Rotation} transform value from this transform
     * chain where n = `rotationIndex`. If `scaleIndex` is invalid
     * (like if it is larger than the number of `Rotation` transforms available)
     * then `null` will be returned.
     * @return {Point | null}
     */

  }, {
    key: "r",
    value: function r() {
      var rotationIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Rotation) {
          if (count === rotationIndex) {
            return t.r;
          }

          count += 1;
        }
      }

      return null;
    }
    /**
     * Return a duplicate transform chain with an updated the nth
     * {@link Rotation} transform where n = `index`
     * @return {Transform}
     */

  }, {
    key: "updateRotation",
    value: function updateRotation(r) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var count = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Rotation) {
          if (count === index) {
            this.order[i] = new Rotation(r, this.name);
            this.calcAndSetMatrix();
            return this;
          }

          count += 1;
        }
      }

      return this;
    }
    /**
     * Return the matrix that respresents the cascaded transform chain
     * @return {Array<number>}
     */

  }, {
    key: "m",
    value: function m() {
      return this.mat;
    }
    /**
     * Return the matrix that respresents the cascaded transform chain
     * @return {Array<number>}
     */

  }, {
    key: "matrix",
    value: function matrix() {
      return this.mat;
    }
    /**
     * `true` if `transformToCompare` has the same order of {@link Rotation},
     * {@link Scale} and {@link Translation} transform elements in the transform
     * chain.
     * @return {boolean}
     */

  }, {
    key: "isSimilarTo",
    value: function isSimilarTo(transformToCompare) {
      if (transformToCompare.order.length !== this.order.length) {
        return false;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        if (this.order[i].constructor.name !== transformToCompare.order[i].constructor.name) {
          return false;
        }
      }

      return true;
    }
    /**
     * `true` if `transformToCompare` is equal to this transform within some
     * `precision`.
     * @return {boolean}
     */

  }, {
    key: "isEqualTo",
    value: function isEqualTo(transformToCompare) {
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;

      // if (transformToCompare.order.length !== this.order.length) {
      //   return false;
      // }
      if (!this.isSimilarTo(transformToCompare)) {
        return false;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var compare = transformToCompare.order[i];
        var thisTrans = this.order[i];

        if (thisTrans.constructor.name !== compare.constructor.name) {
          return false;
        }

        if (thisTrans instanceof Translation && compare instanceof Translation || thisTrans instanceof Scale && compare instanceof Scale) {
          if (compare.isNotEqualTo(thisTrans, precision)) {
            return false;
          }
        }

        if (thisTrans instanceof Rotation) {
          // $FlowFixMe
          if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(compare.r, precision) !== Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(thisTrans.r, precision)) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * `true` if `transformToCompare` is wihtin some `delta` of this transform.
     * `isEqualTo` rounds the values to some precision to compare values. In
     * comparison this will directly compare the delta between values. This may
     * be more useful than rounding when values are close to rounding thresholds.
     * @return {boolean}
     */

  }, {
    key: "isWithinDelta",
    value: function isWithinDelta(transformToCompare) {
      var delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00000001;

      if (!this.isSimilarTo(transformToCompare)) {
        return false;
      }

      for (var i = 0; i < this.order.length; i += 1) {
        var compare = transformToCompare.order[i];
        var thisTrans = this.order[i];

        if (thisTrans.constructor.name !== compare.constructor.name) {
          return false;
        }

        if (thisTrans instanceof Translation && compare instanceof Translation || thisTrans instanceof Scale && compare instanceof Scale) {
          if (compare.isNotWithinDelta(thisTrans, delta)) {
            return false;
          }
        }

        if (thisTrans instanceof Rotation) {
          // $FlowFixMe
          var dR = Math.abs(compare.r - thisTrans.r);

          if (dR > delta) {
            return false;
          }
        }
      }

      return true;
    } // Subtract a transform from the current one.
    // If the two transforms have different order types, then just return
    // the current transform.

    /**
     * Subtract each chain element in `transformToSubtract` from each chain
     * element in this transform chain. Both transform
     * chains must be similar and have the same order of {@link Rotation},
     * {@link Scale} and {@link Translation} transform elements
     * @see <a href="#transformissimilarto">Transform.isSimilarTo</a>
     */

  }, {
    key: "sub",
    value: function sub() {
      var transformToSubtract = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToSubtract)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].sub(transformToSubtract.order[i]));
      }

      return new Transform(order, this.name);
    } // Add a transform to the current one.
    // If the two transforms have different order types, then just return
    // the current transform.

    /**
     * Add each chain element in `transformToSubtract` to each chain
     * element in this transform chain. Both transform
     * chains must be similar and have the same order of {@link Rotation},
     * {@link Scale} and {@link Translation} transform elements
     * @see <a href="#transformissimilarto">Transform.isSimilarTo</a>
     */

  }, {
    key: "add",
    value: function add() {
      var transformToAdd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToAdd)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].add(transformToAdd.order[i]));
      }

      return new Transform(order, this.name);
    } // transform step wise multiplication

    /**
     * Multiply each chain element in `transformToSubtract` with each chain
     * element in this transform chain. Both transform
     * chains must be similar and have the same order of {@link Rotation},
     * {@link Scale} and {@link Translation} transform elements
     * @see <a href="#transformissimilarto">Transform.isSimilarTo</a>
     */

  }, {
    key: "mul",
    value: function mul() {
      var transformToMul = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Transform();

      if (!this.isSimilarTo(transformToMul)) {
        return new Transform(this.order, this.name);
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        // $FlowFixMe (this is already fixed in isSimilarTo check above)
        order.push(this.order[i].mul(transformToMul.order[i]));
      }

      return new Transform(order, this.name);
    }
    /**
     * Return a transform chain whose order is `initialTransform` and then this
     * transform chain
     * @return {Transform}
     * @example
     * // rotate and then translate
     * const rotation = new Transform().rotate(Math.PI / 2);
     * const translation = new Transform().translate(0.5, 0);
     * const t = translation.transform(rotation)
     */

  }, {
    key: "transform",
    value: function transform(initialTransform) {
      var t = new Transform([], this.name);
      t.order = initialTransform.order.concat(this.order);
      t.mat = _m2__WEBPACK_IMPORTED_MODULE_2__["mul"](this.matrix(), initialTransform.matrix());
      return t;
    }
    /**
     * Return a transform chain whose order is this transform chain, then the
     * `t` chain.
     * @return {Transform}
     * @example
     * // rotate and then translate
     * const rotation = new Transform().rotate(Math.PI / 2);
     * const translation = new Transform().translate(0.5, 0);
     * const t = rotation.transformBy(translation)
     */

  }, {
    key: "transformBy",
    value: function transformBy(t) {
      var t1 = new Transform([], this.name);
      t1.order = this.order.concat(t.order);
      t1.mat = _m2__WEBPACK_IMPORTED_MODULE_2__["mul"](t.matrix(), this.matrix());
      return t1;
    }
    /**
     * Return a duplicate transform with all values rounded
     */

  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        order.push(this.order[i].round(precision));
      }

      return new Transform(order, this.name);
    }
    /**
     * Return a duplicate transform that is clipped to `minTransform` and
     * `maxTransform`. Both `minTransform` and `maxTransform` must be similar
     * to this transform meaning they must all share the same order of
     * {@link Rotation}, {@link Scale} and {@link Translation} transform elements.
     *
     * Use `limitLine` to clip the first {@link Translation} transform in the
     * chain to within a {@link Line}.
     * @see <a href="#transformissimilarto">Transform.isSimilarTo</a>
     */

  }, {
    key: "clip",
    value: function clip(minTransform, maxTransform, limitLine) {
      if (!this.isSimilarTo(minTransform) || !this.isSimilarTo(maxTransform)) {
        return this._dup();
      }

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];
        var min = minTransform.order[i];
        var max = maxTransform.order[i];

        if (t instanceof Translation && min instanceof Translation && max instanceof Translation) {
          var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.x, min.x, max.x);
          var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.y, min.y, max.y);
          order.push(new Translation(x, y, this.name));
        } else if (t instanceof Rotation && min instanceof Rotation && max instanceof Rotation) {
          order.push(new Rotation(Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.r, min.r, max.r), this.name));
        } else if (t instanceof Scale && min instanceof Scale && max instanceof Scale) {
          var _x2 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.x, min.x, max.x);

          var _y2 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(t.y, min.y, max.y);

          order.push(new Scale(_x2, _y2, this.name));
        }
      }

      var clippedTransform = new Transform(order, this.name);

      if (limitLine != null) {
        var _t = clippedTransform.t();

        if (_t != null) {
          var perpLine = new Line(_t, 1, limitLine.angle() + Math.PI / 2);

          var _perpLine$intersectsW = perpLine.intersectsWith(limitLine),
              intersect = _perpLine$intersectsW.intersect;

          if (intersect) {
            if (intersect.isWithinLine(limitLine, 4)) {
              clippedTransform.updateTranslation(intersect);
            } else {
              var p1Dist = distance(intersect, limitLine.p1);
              var p2Dist = distance(intersect, limitLine.p2);

              if (p1Dist < p2Dist) {
                clippedTransform.updateTranslation(limitLine.p1);
              } else {
                clippedTransform.updateTranslation(limitLine.p2);
              }
            }
          }
        }
      }

      return clippedTransform;
    }
  }, {
    key: "clipMag",
    value: function clipMag(zeroThresholdTransform, maxTransform) {
      var vector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      // const min = 0.00001;
      // const max = 1 / min;
      // const zeroS = zeroThresholdTransform.s() || new Point(min, min);
      // const zeroR = zeroThresholdTransform.r() || min;
      // const zeroT = zeroThresholdTransform.t() || new Point(min, min);
      // const maxS = maxTransform.s() || new Point(max, max);
      // const maxR = maxTransform.r() || max;
      // const maxT = maxTransform.t() || new Point(max, max);
      // if (!this.isSimilarTo(zeroThresholdTransform) ||
      //     !this.isSimilarTo(maxTransform)) {
      //   return new Transform(this.order);
      // }
      var order = [];
      var z = transformValueToArray(zeroThresholdTransform, this); // const max = maxTransform;

      var max = transformValueToArray(maxTransform, this);

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          if (vector) {
            var _t$toPolar = t.toPolar(),
                mag = _t$toPolar.mag,
                angle = _t$toPolar.angle;

            var clipM = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(mag, z[i], max[i]);

            order.push(new Translation(clipM * Math.cos(angle), clipM * Math.sin(angle), this.name));
          } else {
            var x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.x, z[i], max[i]);

            var y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.y, z[i], max[i]);

            order.push(new Translation(x, y, this.name));
          }
        } else if (t instanceof Rotation) {
          var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.r, z[i], max[i]);

          order.push(new Rotation(r, this.name));
        } else if (t instanceof Scale) {
          var _x3 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.x, z[i], max[i]);

          var _y3 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipMag"])(t.y, z[i], max[i]);

          order.push(new Scale(_x3, _y3, this.name));
        }
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "constant",
    value: function constant() {
      var _constant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          order.push(new Translation(_constant, _constant, this.name));
        } else if (t instanceof Rotation) {
          order.push(new Rotation(_constant, this.name));
        } else if (t instanceof Scale) {
          order.push(new Scale(_constant, _constant, this.name));
        }
      }

      return new Transform(order, this.name);
    }
  }, {
    key: "zero",
    value: function zero() {
      return this.constant(0);
    }
    /**
     * `true` if all transforms within the transform chain are below the
     * `zeroThreshold`
     */

  }, {
    key: "isZero",
    value: function isZero() {
      var zeroThreshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation || t instanceof Scale) {
          if (Math.abs(t.x) > zeroThreshold || Math.abs(t.y) > zeroThreshold) {
            return false;
          }
        } else if (t instanceof Rotation) {
          if (clipAngle(t.r, '0to360') > zeroThreshold) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * Return a duplicate transform.
     */

  }, {
    key: "_dup",
    value: function _dup() {
      var t = new Transform(this.order, this.name);
      t.index = this.index;
      return t;
    }
  }, {
    key: "decelerate",
    value: function decelerate(velocity, decelerationIn, deltaTime, boundsIn, bounceLossIn, zeroVelocityThresholdIn) {
      var precision = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 8;
      var deceleration = transformValueToArray(decelerationIn, this);
      var bounceLoss = transformValueToArray(bounceLossIn, this);
      var zeroVelocityThreshold = transformValueToArray(zeroVelocityThresholdIn, this);
      var bounds;

      if (boundsIn instanceof TransformBounds) {
        bounds = boundsIn;
      } else if (boundsIn === 'none') {
        bounds = new TransformBounds(this);
      } else {
        bounds = new TransformBounds(this, boundsIn);
      } // const bounds = getTransformBoundsLimit(boundsIn, this);


      var result = decelerateTransform(this, velocity, deceleration, deltaTime, bounds, bounceLoss, zeroVelocityThreshold, precision);
      return {
        velocity: result.velocity,
        transform: result.transform,
        duration: result.duration
      };
    }
  }, {
    key: "timeToZeroV",
    value: function timeToZeroV(velocity, deceleration, bounds, bounceLoss, zeroVelocityThreshold) {
      var precision = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 8;
      return this.decelerate(velocity, deceleration, null, bounds, bounceLoss, zeroVelocityThreshold, precision);
    } // Return the velocity of each element in the transform
    // If the current and previous transforms are inconsistent in type order,
    // then a transform of value 0, but with the same type order as "this" will
    // be returned.

  }, {
    key: "velocity",
    value: function velocity(previousTransform, deltaTime, zeroThreshold, maxTransform) {
      var order = [];

      if (!this.isSimilarTo(previousTransform)) {
        return this.zero();
      }

      var deltaTransform = this.sub(previousTransform);

      for (var i = 0; i < deltaTransform.order.length; i += 1) {
        var t = deltaTransform.order[i];

        if (t instanceof Translation) {
          order.push(new Translation(t.x / deltaTime, t.y / deltaTime));
        } else if (t instanceof Rotation) {
          order.push(new Rotation(t.r / deltaTime));
        } else if (t instanceof Scale) {
          order.push(new Scale(t.x / deltaTime, t.y / deltaTime));
        }
      }

      var v = new Transform(order);
      return v.clipMag(zeroThreshold, maxTransform);
    }
    /**
     * Return a duplicate transform chain where all transforms are
     * identity transforms.
     */

  }, {
    key: "identity",
    value: function identity() {
      var order = [];

      for (var i = 0; i < this.order.length; i += 1) {
        var t = this.order[i];

        if (t instanceof Translation) {
          order.push(new Translation(0, 0, this.name));
        } else if (t instanceof Rotation) {
          order.push(new Rotation(0, this.name));
        } else if (t instanceof Scale) {
          order.push(new Scale(1, 1, this.name));
        }
      }

      return new Transform(order, this.name);
    }
  }]);

  return Transform;
}();

function parseTransform(inTransform, onFail) {
  if (inTransform instanceof Transform) {
    return inTransform;
  }

  var onFailToUse = onFail;

  if (onFailToUse == null) {
    onFailToUse = null;
  }

  if (inTransform == null) {
    return onFailToUse;
  }

  var tToUse = inTransform;

  if (typeof tToUse === 'string') {
    try {
      tToUse = JSON.parse(tToUse);
    } catch (_unused7) {
      return onFailToUse;
    }
  }

  if (Array.isArray(tToUse)) {
    var t = new Transform();
    tToUse.forEach(function (transformElement) {
      if (typeof transformElement === 'string') {
        t.name = transformElement;
        return;
      }

      if (transformElement.length === 3) {
        var _transformElement = _slicedToArray(transformElement, 3),
            _type = _transformElement[0],
            x = _transformElement[1],
            y = _transformElement[2];

        if (_type === 's') {
          t = t.scale(x, y);
        } else {
          t = t.translate(x, y);
        }

        return;
      }

      var _transformElement2 = _slicedToArray(transformElement, 2),
          type = _transformElement2[0],
          value = _transformElement2[1];

      if (type === 's') {
        t = t.scale(value, value);
      } else if (type === 't') {
        t = t.translate(value, value);
      } else {
        t = t.rotate(value);
      }
    });
    return t;
  }

  var _tToUse = tToUse,
      f1Type = _tToUse.f1Type,
      state = _tToUse.state;

  if (f1Type != null && f1Type === 'tf' && state != null && Array.isArray(state)) {
    var _t2 = new Transform();

    tToUse.state.forEach(function (transformElement) {
      if (typeof transformElement === 'string') {
        _t2.name = transformElement;
        return;
      }

      var teF1Type = transformElement.f1Type;

      if (teF1Type != null) {
        if (teF1Type === 's') {
          // $FlowFixMe
          _t2 = _t2.scale(transformElement);
        } else if (teF1Type === 't') {
          // $FlowFixMe
          _t2 = _t2.translate(transformElement);
        } else if (teF1Type === 'r') {
          // $FlowFixMe
          _t2 = _t2.rotate(transformElement);
        }
      }
    });
    return _t2;
  }

  return onFailToUse;
}
/**
 * Convert a parsable transform definition to a {@link Transform}.
 * @param {TypeParsableTransform} t parsable transform definition
 * @return {Transform} transform object
 */


function getTransform(t) {
  var parsedTransform = parseTransform(t);

  if (parsedTransform == null) {
    parsedTransform = new Transform();
  }

  return parsedTransform;
}

function spaceToSpaceTransform(s1, s2) {
  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var xScale = s2.x.width / s1.x.width;
  var yScale = s2.y.height / s1.y.height;
  var t = new Transform(name).scale(xScale, yScale).translate(s2.x.bottomLeft - s1.x.bottomLeft * xScale, s2.y.bottomLeft - s1.y.bottomLeft * yScale);
  return t;
}

function spaceToSpaceScale(s1, s2) {
  var xScale = s2.x.width / s1.x.width;
  var yScale = s2.y.height / s1.y.height;
  return new Point(xScale, yScale);
}

function comparePoints(p, currentMin, currentMax, firstPoint) {
  var min = new Point(0, 0);
  var max = new Point(0, 0);

  if (firstPoint) {
    min.x = p.x;
    min.y = p.y;
    max.x = p.x;
    max.y = p.y;
  } else {
    min.x = p.x < currentMin.x ? p.x : currentMin.x;
    min.y = p.y < currentMin.y ? p.y : currentMin.y;
    max.x = p.x > currentMax.x ? p.x : currentMax.x;
    max.y = p.y > currentMax.y ? p.y : currentMax.y;
  }

  return {
    min: min,
    max: max
  };
}
/**
 * Polar coordinates to cartesian coordinates conversion
 *
 * @example
 * const polarToRect = Fig.polarToRect;
 * const p = polarToRect(Math.sqrt(2), Math.PI / 4);
 * console.log(p);
 * // Point {x: 1, y: 1)
 */


function polarToRect(mag, angle) {
  return new Point(mag * Math.cos(angle), mag * Math.sin(angle));
}
/**
 * Cartesian coordinates to polar coordinates conversion
 *
 * @example
* const rectToPolar = Fig.rectToPolar;
* const p = rectToPolar(0, 1);
* console.log(p);
* // {mag: 1, angle: 1.5707963267948966}
 */


function rectToPolar(x) {
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var rect;

  if (typeof x === 'number') {
    rect = new Point(x, y);
  } else {
    rect = x;
  }

  var mag = rect.distance();
  var angle = Math.atan2(rect.y, rect.x);

  if (angle < 0) {
    angle += Math.PI * 2;
  }

  return {
    mag: mag,
    angle: angle
  };
}
/**
 * Buffer for rectangle, where `left`, `bottom`, `right` and `top` are
 * the buffer values for a rectangle's left, bottom, right and top sides
 * respectively.
 */


/**
 * Convert a parsable buffer into a buffer.
 * @return {OBJ_Buffer}
 */
function getBuffer(buffer) {
  var left;
  var right;
  var top;
  var bottom;

  if (typeof buffer === 'number') {
    left = buffer;
    right = buffer;
    top = buffer;
    bottom = buffer;
  } else if (Array.isArray(buffer)) {
    if (buffer.length === 2) {
      var _buffer = _slicedToArray(buffer, 2);

      left = _buffer[0];
      top = _buffer[1];
      right = left;
      bottom = top;
    } else {
      var _buffer2 = _slicedToArray(buffer, 4);

      left = _buffer2[0];
      bottom = _buffer2[1];
      right = _buffer2[2];
      top = _buffer2[3];
    }
  } else {
    var o = Object(_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, buffer);
    left = o.left;
    right = o.right;
    top = o.top;
    bottom = o.bottom;
  }

  return {
    left: left,
    right: right,
    top: top,
    bottom: bottom
  };
}

function isBuffer(input) {
  if (typeof input === 'number') {
    return true;
  }

  if (Array.isArray(input)) {
    if ((input.length === 4 || input.length === 2) && typeof input[0] === 'number') {
      return true;
    }
  } else {
    return false;
  }

  if (_typeof(input) === 'object') {
    var keys = Object.keys(input);

    if (keys.length > 4) {
      return false;
    }

    for (var i = 0; i < keys.length; i += 1) {
      var key = keys[i];

      if (key !== 'left' && key !== 'right' && key !== 'top' && key !== 'bottom') {
        return false;
      }
    }

    return true;
  }

  return false;
}

function getBoundingRect(pointArrays) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var firstPoint = true;
  var result = {
    min: new Point(0, 0),
    max: new Point(0, 0)
  };
  pointArrays.forEach(function (pointOrArray) {
    if (Array.isArray(pointOrArray)) {
      pointOrArray.forEach(function (p) {
        result = comparePoints(p, result.min, result.max, firstPoint);
        firstPoint = false;
      });
    } else {
      result = comparePoints(pointOrArray, result.min, result.max, firstPoint);
    }

    firstPoint = false;
  });

  var _getBuffer = getBuffer(buffer),
      left = _getBuffer.left,
      right = _getBuffer.right,
      top = _getBuffer.top,
      bottom = _getBuffer.bottom;

  return new Rect(result.min.x - left, result.min.y - bottom, result.max.x - result.min.x + right + left, result.max.y - result.min.y + top + bottom);
}

function getBoundingBorder(pointArrays) {
  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var r = getBoundingRect(pointArrays, buffer);
  return [new Point(r.left, r.bottom), new Point(r.right, r.bottom), new Point(r.right, r.top), new Point(r.left, r.top)];
} // // Finds the min angle between three points
// function threePointAngleMin(p2: Point, p1: Point, p3: Point) {
//   const p12 = distance(p1, p2);
//   const p13 = distance(p1, p3);
//   const p23 = distance(p2, p3);
//   return Math.acos((p12 ** 2 + p13 ** 2 - p23 ** 2) / (2 * p12 * p13));
// }
// Finds the angle between three points for p12 to p13 in the positive
// angle direction

/**
 * Returns the angle from the line (p1, p2) to the line (p1, p3) in the positive
 * rotation direction and normalized from 0 to Math.PI * 2.
 *
 * @example
 * const threePointAngle = Fig.threePointAngle;
 * const getPoint = Fig.getPoint;
 *
 * const p1 = threePointAngle(getPoint([1, 0]), getPoint([0, 0]), getPoint([0, 1]));
 * console.log(p1);
 * // 1.5707963267948966
 *
 * const p2 = threePointAngle(getPoint([0, 1]), getPoint([0, 0]), getPoint([1, 0]));
 * console.log(p2);
 * // 4.71238898038469
 */


function threePointAngle(p2, p1, p3) {
  var r12 = p2.sub(p1);
  var r13 = p3.sub(p1); // const p12 = distance(p1, p2);
  // const p13 = distance(p1, p3);
  // const p23 = distance(p2, p3);
  // const minAngle = Math.acos((p12 ** 2 + p13 ** 2 - p23 ** 2) / (2 * p12 * p13));

  var angle12 = r12.toPolar().angle;
  var angle13 = r13.toPolar().angle;
  angle13 -= angle12;
  angle12 = 0;
  return clipAngle(angle13, '0to360');
}
/**
 * Returns the minimum angle from the line (p1, p2) to the line (p1, p3).
 *
 * @example
 * const threePointAngleMin = Fig.threePointAngleMin;
 * const getPoint = Fig.getPoint;
 *
 * const p1 = threePointAngleMin(getPoint([1, 0]), getPoint([0, 0]), getPoint([0, 1]));
 * console.log(p1);
// 1.5707963267948966
 *
 * const p2 = threePointAngleMin(getPoint([0, 1]), getPoint([0, 0]), getPoint([1, 0]));
 * console.log(p2);
 * // -1.5707963267948966
 */


function threePointAngleMin(p2, p1, p3) {
  var a12 = clipAngle(Math.atan2(p2.y - p1.y, p2.x - p1.x), '0to360');
  var a13 = clipAngle(Math.atan2(p3.y - p1.y, p3.x - p1.x), '0to360');
  var delta = a13 - a12;

  if (delta > Math.PI) {
    delta = -(Math.PI * 2 - delta);
  } else if (delta < -Math.PI) {
    delta = Math.PI * 2 + delta;
  }

  return delta;
}

function randomPoint(withinRect) {
  var randPoint = Object(_math__WEBPACK_IMPORTED_MODULE_0__["rand2D"])(withinRect.left, withinRect.bottom, withinRect.right, withinRect.top);
  return new Point(randPoint.x, randPoint.y);
}

function getMaxTimeFromVelocity(startTransform, stopTransform, velocityTransform) {
  var rotDirection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var deltaTransform = stopTransform.sub(startTransform);
  var time = 0;
  var velocityTransformToUse;

  if (typeof velocityTransform === 'number') {
    velocityTransformToUse = startTransform._dup().constant(velocityTransform);
  } else {
    velocityTransformToUse = velocityTransform;
  }

  deltaTransform.order.forEach(function (delta, index) {
    if (delta instanceof Translation || delta instanceof Scale) {
      var v = velocityTransformToUse.order[index];

      if ((v instanceof Translation || v instanceof Scale) && v.x !== 0 && v.y !== 0) {
        var xTime = Math.abs(delta.x / v.x);
        var yTime = Math.abs(delta.y / v.y);
        time = xTime > time ? xTime : time;
        time = yTime > time ? yTime : time;
      }
    }

    var start = startTransform.order[index];
    var target = stopTransform.order[index];

    if (delta instanceof Rotation && start instanceof Rotation && target instanceof Rotation) {
      var rotDiff = getDeltaAngle(start.r, target.r, rotDirection); // eslint-disable-next-line no-param-reassign

      delta.r = rotDiff;
      var _v = velocityTransformToUse.order[index];

      if (_v instanceof Rotation && _v !== 0) {
        var rTime = Math.abs(delta.r / _v.r);
        time = rTime > time ? rTime : time;
      }
    }
  });
  return time;
}

function getMoveTime(startTransform, stopTransform) // 100%/s
{
  var rotDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var translationVelocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Point(0.25, 0.25);
  var rotationVelocity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2 * Math.PI / 6;
  var scaleVelocity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Point(1, 1);
  var startTransforms;

  if (startTransform instanceof Transform) {
    startTransforms = [startTransform];
  } else {
    startTransforms = startTransform;
  }

  var stopTransforms;

  if (stopTransform instanceof Transform) {
    stopTransforms = [stopTransform];
  } else {
    stopTransforms = stopTransform;
  }

  if (stopTransforms.length !== startTransforms.length) {
    return 0;
  }

  var maxDuration = 0;
  startTransforms.forEach(function (startT, index) {
    var stopT = stopTransforms[index];

    var velocity = startT._dup();

    for (var i = 0; i < velocity.order.length; i += 1) {
      var v = velocity.order[i];

      if (v instanceof Translation) {
        v.x = translationVelocity.x;
        v.y = translationVelocity.y;
      } else if (v instanceof Rotation) {
        v.r = rotationVelocity;
      } else {
        v.x = scaleVelocity.x;
        v.y = scaleVelocity.y;
      }
    }

    var time = getMaxTimeFromVelocity(startT, stopT, velocity, rotDirection);

    if (time > maxDuration) {
      maxDuration = time;
    }
  });
  return maxDuration;
}

function quadBezierPoints(p0, p1, p2, sides) {
  var step = 1 / sides;

  if (sides === 0 || sides === 1 || sides === 2) {
    return [p0, p1, p2];
  }

  var points = [];

  for (var i = 0; i < sides + 1; i += 1) {
    var t = 0 + i * step;
    points.push(new Point(Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x, Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y));
  }

  return points;
}

var Bounds = /*#__PURE__*/function () {
  function Bounds(boundary) {
    var bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'inside';
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;

    _classCallCheck(this, Bounds);

    this.boundary = boundary;
    this.bounds = bounds;
    this.precision = precision;
  } // eslint-disable-next-line class-methods-use-this


  _createClass(Bounds, [{
    key: "_dup",
    value: function _dup() {
      return new Bounds();
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "_state",
    value: function _state(options) {
      return {
        f1Type: 'bounds',
        state: []
      };
    } // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: "contains",
    value: function contains(position) {
      return true;
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "intersect",
    value: function intersect(position) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (typeof position === 'number') {
        return {
          intersect: position,
          distance: 0,
          reflection: direction + Math.PI
        };
      }

      return {
        intersect: getPoint(position),
        distance: 0,
        reflection: direction + Math.PI
      };
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "clip",
    value: function clip(position) {
      if (typeof position === 'number') {
        return position;
      }

      return getPoint(position);
    } // eslint-disable-next-line class-methods-use-this
    // clipVelocity(velocity: TypeParsablePoint | number) {
    //   if (typeof velocity === 'number') {
    //     return velocity;
    //   }
    //   return getPoint(velocity);
    // }

  }]);

  return Bounds;
}(); // class ValueBounds extends Bounds {
//   boundary: ?number;
// }


var RangeBounds = /*#__PURE__*/function (_Bounds) {
  _inherits(RangeBounds, _Bounds);

  var _super4 = _createSuper(RangeBounds);

  function RangeBounds(optionsIn) {
    _classCallCheck(this, RangeBounds);

    var defaultOptions = {
      bounds: 'inside',
      precision: 8,
      min: null,
      max: null
    };
    var options = Object(_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);
    var boundary = {
      min: options.min,
      max: options.max
    };
    return _super4.call(this, boundary, options.bounds, options.precision);
  }

  _createClass(RangeBounds, [{
    key: "_dup",
    value: function _dup() {
      return new RangeBounds({
        bounds: this.bounds,
        precision: this.precision,
        min: this.boundary.min,
        max: this.boundary.max
      });
    }
  }, {
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      return {
        f1Type: 'rangeBounds',
        state: [this.bounds, this.precision, this.boundary.min != null ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.min, precision) : null, this.boundary.max != null ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.max, precision) : null]
      };
    }
  }, {
    key: "contains",
    value: function contains(position) {
      if (typeof position === 'number') {
        var _p = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(position, this.precision);

        if ((this.boundary.min == null || _p >= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.min, this.precision)) && (this.boundary.max == null || _p <= Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.max, this.precision))) {
          return true;
        }

        return false;
      }

      var p = getPoint(position);

      if (this.contains(p.x) && this.contains(p.y)) {
        return true;
      }

      return false; // const p = getPoint(position);
      // if (
      //   (this.boundary.min == null
      //     || (p.x >= this.boundary.min && p.y >= this.boundary.min))
      //   && (this.boundary.max == null
      //     || (p.x <= this.boundary.max && p.y <= this.boundary.max))
      // ) {
      //   return true;
      // }
      // return false;
    }
  }, {
    key: "intersect",
    value: function intersect(position) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var reflection = direction * -1;
      var _this$boundary = this.boundary,
          min = _this$boundary.min,
          max = _this$boundary.max;

      if (!(typeof position === 'number')) {
        return {
          intersect: null,
          distance: 0,
          reflection: direction
        };
      }

      if (this.contains(position)) {
        if (max != null && Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(position, this.precision) === Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(max, this.precision) && this.bounds === 'outside') {
          if (direction === -1) {
            return {
              intersect: max,
              distance: 0,
              reflection: 1
            };
          }

          return {
            intersect: null,
            distance: 0,
            reflection: 1
          };
        }

        if (min != null && Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(position, this.precision) === Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(min, this.precision) && this.bounds === 'outside') {
          if (direction === 1) {
            return {
              intersect: min,
              distance: 0,
              reflection: -1
            };
          }

          return {
            intersect: null,
            distance: 0,
            reflection: -1
          };
        }

        if (direction === 1) {
          if (max == null) {
            return {
              intersect: null,
              distance: 0,
              reflection: direction
            };
          }

          return {
            intersect: max,
            distance: Math.abs(position - max),
            reflection: -1
          };
        }

        if (min == null) {
          return {
            intersect: null,
            distance: 0,
            reflection: direction
          };
        }

        return {
          intersect: min,
          distance: Math.abs(position - min),
          reflection: 1
        };
      }

      if (min != null && position < min && direction === 1) {
        return {
          intersect: min,
          distance: Math.abs(position - min),
          reflection: reflection
        };
      }

      if (max != null && position > max && direction === -1) {
        return {
          intersect: max,
          distance: Math.abs(position - max),
          reflection: reflection
        };
      }

      return {
        intersect: null,
        distance: 0,
        reflection: direction
      };
    }
  }, {
    key: "clip",
    value: function clip(position) {
      if (typeof position === 'number') {
        return Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(position, this.boundary.min, this.boundary.max);
      }

      var p = getPoint(position);

      var clipped = p._dup();

      clipped.x = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(p.x, this.boundary.min, this.boundary.max);
      clipped.y = Object(_math__WEBPACK_IMPORTED_MODULE_0__["clipValue"])(p.y, this.boundary.min, this.boundary.max);
      return clipped;
    }
  }]);

  return RangeBounds;
}(Bounds);

var RectBounds = /*#__PURE__*/function (_Bounds2) {
  _inherits(RectBounds, _Bounds2);

  var _super5 = _createSuper(RectBounds);

  function RectBounds(optionsOrRect) {
    _classCallCheck(this, RectBounds);

    var defaultOptions = {
      left: null,
      right: null,
      top: null,
      bottom: null,
      bounds: 'inside',
      precision: 8
    };
    var options = Object(_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsOrRect);
    var boundary = {
      left: options.left,
      right: options.right,
      top: options.top,
      bottom: options.bottom
    };
    return _super5.call(this, boundary, options.bounds, options.precision);
  }

  _createClass(RectBounds, [{
    key: "_dup",
    value: function _dup() {
      return new RectBounds({
        bounds: this.bounds,
        precision: this.precision,
        left: this.boundary.left,
        right: this.boundary.right,
        top: this.boundary.top,
        bottom: this.boundary.bottom
      });
    }
  }, {
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      return {
        f1Type: 'rectBounds',
        state: [this.bounds, this.precision, this.boundary.left != null ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.left, precision) : null, this.boundary.bottom != null ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.bottom, precision) : null, this.boundary.right != null ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.right, precision) : null, this.boundary.top != null ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.top, precision) : null]
      };
    }
  }, {
    key: "contains",
    value: function contains(position) {
      if (typeof position === 'number') {
        return false;
      }

      var p = getPoint(position).round(this.precision);

      if (this.boundary.left != null && p.x < Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.left, this.precision)) {
        return false;
      }

      if (this.boundary.right != null && p.x > Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.right, this.precision)) {
        return false;
      }

      if (this.boundary.bottom != null && p.y < Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.bottom, this.precision)) {
        return false;
      }

      if (this.boundary.top != null && p.y > Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.top, this.precision)) {
        return false;
      }

      return true;
    }
  }, {
    key: "clip",
    value: function clip(position) {
      if (typeof position === 'number') {
        return position;
      }

      var clipped = getPoint(position);

      if (this.boundary.left != null && clipped.x < this.boundary.left) {
        clipped.x = this.boundary.left;
      }

      if (this.boundary.right != null && clipped.x > this.boundary.right) {
        clipped.x = this.boundary.right;
      }

      if (this.boundary.bottom != null && clipped.y < this.boundary.bottom) {
        clipped.y = this.boundary.bottom;
      }

      if (this.boundary.top != null && clipped.y > this.boundary.top) {
        clipped.y = this.boundary.top;
      }

      return clipped;
    }
  }, {
    key: "intersect",
    value: function intersect(position) {
      var _this5 = this;

      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (typeof position === 'number') {
        return {
          intersect: null,
          distance: 0,
          reflection: direction
        };
      }

      var a = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(clipAngle(direction, '0to360'), this.precision);
      var pi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.PI, this.precision);
      var threePiOnTwo = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(3 * Math.PI / 2, this.precision);
      var piOnTwo = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(Math.PI / 2, this.precision);
      var p = getPoint(position);
      var _this$boundary2 = this.boundary,
          top = _this$boundary2.top,
          bottom = _this$boundary2.bottom,
          left = _this$boundary2.left,
          right = _this$boundary2.right; // let zeroHeight = false;
      // if (
      //   top != null && bottom != null
      //   && roundNum(top, this.precision) === roundNum(bottom, this.precision)
      // ) {
      //   zeroHeight = true;
      // }
      // let zeroWdith = false;
      // if (
      //   left != null && right != null
      //   && roundNum(left, this.precision) === roundNum(right, this.precision)
      // ) {
      //   zeroWdith = true;
      // }

      var calcHBound = function calcHBound(h) {
        if (h != null) {
          if (bottom != null && top != null) {
            return new Line([h, bottom], [h, top]);
          }

          if (bottom == null && top != null) {
            return new Line([h, top], null, -Math.PI / 2, 1);
          }

          if (bottom != null && top == null) {
            return new Line([h, bottom], null, Math.PI / 2, 1);
          }

          if (bottom == null && top == null) {
            return new Line([h, 0], null, Math.PI / 2, 0);
          }
        }

        return null;
      };

      var calcVBound = function calcVBound(v) {
        if (v != null) {
          if (left != null && right != null) {
            return new Line([left, v], [right, v]);
          }

          if (left == null && right != null) {
            return new Line([right, v], null, -Math.PI, 1);
          }

          if (left != null && right == null) {
            return new Line([left, v], null, 0, 1);
          }

          if (left == null && right == null) {
            return new Line([0, v], null, Math.PI, 0);
          }
        }

        return null;
      }; // Get the lines for each bound


      var boundBottom = calcVBound(bottom);
      var boundTop = calcVBound(top);
      var boundLeft = calcHBound(left);
      var boundRight = calcHBound(right); // Get the closest boundary intersect

      var trajectory = new Line(p, null, direction, 1);

      var getIntersect = function getIntersect(boundLine, id) {
        if (boundLine == null) {
          return null;
        }

        if (boundLine.hasPointOn(p, _this5.precision)) {
          return {
            intersect: p._dup(),
            distance: 0,
            id: id
          };
        }

        var result = trajectory.intersectsWith(boundLine, _this5.precision);

        if (result.withinLine && result.intersect != null) {
          return {
            intersect: result.intersect,
            distance: Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(p.distance(result.intersect), _this5.precision),
            id: id
          };
        }

        return null;
      };

      var bottomIntersect = getIntersect(boundBottom, 'bottom');
      var topIntersect = getIntersect(boundTop, 'top');
      var leftIntersect = getIntersect(boundLeft, 'left');
      var rightIntersect = getIntersect(boundRight, 'right');

      var getClosestIntersect = function getClosestIntersect(intersect1, intersect2) {
        var closestIntersect = null;

        if (intersect1 != null && intersect2 != null) {
          if (intersect1.distance === 0 && _this5.bounds === 'inside') {
            closestIntersect = intersect2;
          } else if (intersect2.distance === 0 && _this5.bounds === 'inside') {
            closestIntersect = intersect1;
          } else if (intersect1.distance < intersect2.distance) {
            closestIntersect = intersect1;
          } else {
            closestIntersect = intersect2;
          }
        } else if (intersect1 != null) {
          closestIntersect = intersect1;
        } else if (intersect2 != null) {
          closestIntersect = intersect2;
        }

        return closestIntersect;
      };

      var vIntersect = getClosestIntersect(bottomIntersect, topIntersect);
      var hIntersect = getClosestIntersect(leftIntersect, rightIntersect);
      var intersects = [];

      if (vIntersect != null && hIntersect != null && vIntersect.distance === hIntersect.distance) {
        intersects = [vIntersect, hIntersect];
      } else {
        var result = getClosestIntersect(vIntersect, hIntersect);

        if (result != null) {
          intersects = [result];
        }
      }

      if (intersects.length === 0) {
        return {
          intersect: null,
          distance: 0,
          reflection: direction
        };
      }

      var i;
      var d = 0;
      var xMirror = 1;
      var yMirror = 1;
      intersects.forEach(function (intersect) {
        if (intersect.id === 'left' || intersect.id === 'right') {
          xMirror = -1;
        } else {
          yMirror = -1;
        }

        i = intersect.intersect;
        d = intersect.distance;
      });
      var reflection = polarToRect(1, direction);

      if (xMirror === -1) {
        reflection.x *= -1;
      }

      if (yMirror === -1) {
        reflection.y *= -1;
      }

      if (d === 0) {
        i = p;
      }

      var r = rectToPolar(reflection).angle;
      var noIntersect = false; // Test for if the point is on the border, trajectory is along the border
      // and the cross bound is null

      if (d === 0 && this.bounds === 'inside' && intersects.length === 1) {
        if ((intersects[0].id === 'bottom' || intersects[0].id === 'top') && (this.boundary.left == null || this.boundary.right == null) && (a === 0 || a === pi)) {
          noIntersect = true;
        }

        if ((intersects[0].id === 'right' || intersects[0].id === 'left') && (this.boundary.top == null || this.boundary.bottom == null) && (a === piOnTwo || a === threePiOnTwo)) {
          noIntersect = true;
        }

        if (intersects[0].id === 'right' && this.boundary.left == null && a === pi) {
          noIntersect = true;
        }

        if (intersects[0].id === 'left' && this.boundary.right == null && a === 0) {
          noIntersect = true;
        }

        if (intersects[0].id === 'top' && this.boundary.bottom == null && a === threePiOnTwo) {
          noIntersect = true;
        }

        if (intersects[0].id === 'bottom' && this.boundary.top == null && a === piOnTwo) {
          noIntersect = true;
        }
      }

      if (d === 0 && this.bounds === 'inside' && intersects.length === 2) {
        if (intersects[0].id === 'bottom' && intersects[1].id === 'left' && this.boundary.right == null && a === 0) {
          noIntersect = true;
        }

        if (intersects[0].id === 'bottom' && intersects[1].id === 'left' && this.boundary.top == null && a === piOnTwo) {
          noIntersect = true;
        }

        if (intersects[0].id === 'top' && intersects[1].id === 'left' && this.boundary.right == null && a === 0) {
          noIntersect = true;
        }

        if (intersects[0].id === 'top' && intersects[1].id === 'left' && this.boundary.bottom == null && a === threePiOnTwo) {
          noIntersect = true;
        }

        if (intersects[0].id === 'top' && intersects[1].id === 'right' && this.boundary.left == null && a === pi) {
          noIntersect = true;
        }

        if (intersects[0].id === 'top' && intersects[1].id === 'right' && this.boundary.bottom == null && a === threePiOnTwo) {
          noIntersect = true;
        }

        if (intersects[0].id === 'bottom' && intersects[1].id === 'right' && this.boundary.left == null && a === pi) {
          noIntersect = true;
        }

        if (intersects[0].id === 'bottom' && intersects[1].id === 'right' && this.boundary.top == null && a === piOnTwo) {
          noIntersect = true;
        }
      } // Test for if the point is on the border, bounds is outside, and the
      // trajectory is away from the border


      if (d === 0 && this.bounds === 'outside' && intersects.length === 2) {
        if (intersects[0].id === 'bottom' && intersects[1].id === 'left' && (a >= piOnTwo || a === 0)) {
          noIntersect = true;
        }

        if (intersects[0].id === 'top' && intersects[1].id === 'left' && a >= 0 && a <= threePiOnTwo) {
          noIntersect = true;
        }

        if (intersects[0].id === 'top' && intersects[1].id === 'right' && (a <= pi || a >= threePiOnTwo)) {
          noIntersect = true;
        }

        if (intersects[0].id === 'bottom' && intersects[1].id === 'right' && (a <= piOnTwo || a >= pi)) {
          noIntersect = true;
        }
      }

      if (d === 0 && this.bounds === 'outside' && intersects.length === 1) {
        var _intersects = intersects,
            _intersects2 = _slicedToArray(_intersects, 1),
            intersect = _intersects2[0];

        if (intersect.id === 'left' && a >= piOnTwo && a <= threePiOnTwo) {
          noIntersect = true;
        }

        if (intersect.id === 'right' && (a <= piOnTwo || a >= threePiOnTwo)) {
          noIntersect = true;
        }

        if (intersect.id === 'bottom' && (a >= pi || a === 0)) {
          noIntersect = true;
        }

        if (intersect.id === 'top' && a <= pi) {
          noIntersect = true;
        }
      }

      if (noIntersect) {
        i = null;
        r = direction;
      }

      return {
        intersect: i,
        distance: d,
        reflection: r
      };
    }
  }]);

  return RectBounds;
}(Bounds);

var LineBounds = /*#__PURE__*/function (_Bounds3) {
  _inherits(LineBounds, _Bounds3);

  var _super6 = _createSuper(LineBounds);

  function LineBounds(optionsIn) {
    _classCallCheck(this, LineBounds);

    var boundary;
    var defaultOptions = {
      angle: 0,
      mag: 1,
      bounds: 'inside',
      precision: 8,
      ends: 2
    };
    var options = Object(_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])({}, defaultOptions, optionsIn);

    if (options.line != null) {
      boundary = getLine(options.line);
    } else if (options.p1 != null && options.p2 != null) {
      boundary = new Line(options.p1, options.p2, 0, options.ends);
    } else if (options.p1 != null) {
      boundary = new Line(options.p1, options.mag, options.angle, options.ends);
    }

    return _super6.call(this, boundary, options.bounds, options.precision);
  }

  _createClass(LineBounds, [{
    key: "_dup",
    value: function _dup() {
      return new LineBounds({
        bounds: this.bounds,
        precision: this.precision,
        p1: this.boundary.p1._dup(),
        p2: this.boundary.p2._dup(),
        mag: this.boundary.distance,
        angle: this.boundary.ang,
        ends: this.boundary.ends
      });
    }
  }, {
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      return {
        f1Type: 'lineBounds',
        state: [this.bounds, this.precision, Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.p1.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.p1.y, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.p2.x, precision), Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(this.boundary.p2.y, precision), this.boundary.ends]
      };
    }
  }, {
    key: "contains",
    value: function contains(position) {
      if (typeof position === 'number') {
        return false;
      }

      var p = getPoint(position);
      return p.isWithinLine(this.boundary, this.precision);
    }
  }, {
    key: "clip",
    value: function clip(position) {
      if (typeof position === 'number') {
        return position;
      }

      var p = getPoint(position); // if (window.asdf) {
      //   console.log(position, p)
      // }

      return p.clipToLine(this.boundary, this.precision);
    } // The intersect of a Line Boundary can be its finite end points
    //  - p1 only if 1 ended
    //  - p1 or p2 if 2 ended

  }, {
    key: "intersect",
    value: function intersect(position) {
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (typeof position === 'number' || this.boundary.ends === 0 // Unbounded line will have no intersect
      ) {
          return {
            intersect: null,
            distance: 0,
            reflection: direction
          };
        } // If the point is not along the line, then it is invalid


      var p = getPoint(position);

      if (!this.boundary.hasPointAlong(p, this.precision)) {
        return {
          intersect: null,
          distance: 0,
          reflection: direction
        };
      }

      var onLine = false;

      if (this.boundary.hasPointOn(p, this.precision)) {
        onLine = true;
      }

      var b = this.boundary;

      var p1 = this.boundary.p1._dup();

      var p2 = this.boundary.p2._dup();

      var angleDelta = Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(Math.abs(clipAngle(direction, '0to360') - clipAngle(b.ang, '0to360')), this.precision);
      var d1 = p.distance(p1);
      var d2 = p.distance(p2); // If the point is on p1, unless it is inside and going towards p2 the
      // result can be given immediately

      if (p.isEqualTo(p1, this.precision)) {
        if (this.bounds === 'inside' && angleDelta !== 0) {
          return {
            intersect: p1,
            distance: 0,
            reflection: b.ang
          };
        }

        if (this.bounds === 'outside' && angleDelta !== 0) {
          return {
            intersect: null,
            distance: 0,
            reflection: direction
          };
        }

        if (this.bounds === 'outside' && angleDelta === 0) {
          return {
            intersect: p1,
            distance: 0,
            reflection: b.ang + Math.PI
          };
        }
      } // If it is a one ended line, then only p1 is an intersect


      if (b.ends === 1) {
        if (onLine === true && angleDelta === 0 || onLine === false && angleDelta !== 0) {
          return {
            intersect: null,
            distance: 0,
            reflection: direction
          };
        }

        return {
          intersect: p1,
          distance: d1,
          reflection: direction + Math.PI
        };
      } // We are now left with a two ended line
      // So if the point is on p2, then unless it is inside and going toward
      // p1, the answer can be given now


      if (p.isEqualTo(p2, this.precision)) {
        if (this.bounds === 'inside' && angleDelta === 0) {
          return {
            intersect: p2,
            distance: 0,
            reflection: b.ang + Math.PI
          };
        }

        if (this.bounds === 'outside' && angleDelta === 0) {
          return {
            intersect: null,
            distance: 0,
            reflection: direction
          };
        }

        if (this.bounds === 'outside' && angleDelta !== 0) {
          return {
            intersect: p2,
            distance: 0,
            reflection: b.ang
          };
        } // return { intersect: p2, distance: 0, reflection };

      }

      if (onLine && angleDelta === 0) {
        return {
          intersect: p2,
          distance: d2,
          reflection: direction + Math.PI
        };
      }

      if (onLine) {
        return {
          intersect: p1,
          distance: d1,
          reflection: direction + Math.PI
        };
      } // We now know the point is off a 2 ended line


      var i;
      var d;

      if (d1 < d2 && angleDelta === 0) {
        i = p1;
        d = d1;
      } else if (d2 < d1 && angleDelta !== 0) {
        i = p2;
        d = d2;
      } else {
        return {
          intersect: null,
          distance: 0,
          reflection: direction
        };
      }

      return {
        intersect: i,
        distance: d,
        reflection: direction + Math.PI
      };
    }
  }, {
    key: "clipVelocity",
    value: function clipVelocity(velocity) {
      if (typeof velocity === 'number') {
        return velocity;
      }

      if (this.boundary == null) {
        return velocity;
      }

      var v = getPoint(velocity); // $FlowFixMe

      var unitVector = new Vector(this.boundary).unit();
      var projection = unitVector.dotProduct(new Vector([0, 0], v));
      var ang = this.boundary.ang;

      if (projection < -1) {
        ang += Math.PI;
        projection = -projection;
      }

      return polarToRect(projection, ang);
    }
  }]);

  return LineBounds;
}(Bounds);

function getBounds(bounds) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var transform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Transform();

  if (bounds == null) {
    return new Bounds();
  }

  if (bounds instanceof Bounds) {
    return bounds;
  }

  if (bounds.type != null) {
    // $FlowFixMe
    return getBounds(bounds.bounds, bounds.type);
  }

  if (type === 'rect') {
    // $FlowFixMe
    return new RectBounds(bounds);
  }

  if (type === 'range') {
    // $FlowFixMe
    return new RangeBounds(bounds);
  }

  if (type === 'line') {
    // $FlowFixMe
    return new LineBounds(bounds);
  }

  if (type === 'transform') {
    // $FlowFixMe
    return new TransformBounds(transform, bounds);
  }

  if (bounds.min !== undefined || bounds.max !== undefined) {
    return getBounds(bounds, 'range');
  }

  if (bounds instanceof Rect) {
    return new RectBounds(bounds);
  }

  if (bounds instanceof Line) {
    return new LineBounds({
      line: bounds
    });
  }

  if (bounds.left !== undefined || bounds.right !== undefined || bounds.top !== undefined || bounds.bottom !== undefined) {
    return getBounds(bounds, 'rect');
  }

  if (bounds.line !== undefined || bounds.p1 !== undefined || bounds.p2 !== undefined || bounds.angle !== undefined || bounds.mag !== undefined || bounds.ends !== undefined) {
    return getBounds(bounds, 'line');
  }

  if (bounds.translation !== undefined || bounds.scale !== undefined || bounds.rotation !== undefined) {
    return getBounds(bounds, 'transform', transform);
  }

  if (bounds.f1Type !== undefined && bounds.state != null) {
    var f1Type = bounds.f1Type,
        state = bounds.state;

    if (f1Type != null && f1Type === 'rangeBounds' && state != null && Array.isArray([state]) && state.length === 4) {
      // $FlowFixMe
      var _state3 = _slicedToArray(state, 4),
          b = _state3[0],
          precision = _state3[1],
          min = _state3[2],
          max = _state3[3];

      return new RangeBounds({
        bounds: b,
        precision: precision,
        min: min,
        max: max
      });
    }

    if (f1Type != null && f1Type === 'rectBounds' && state != null && Array.isArray([state]) && state.length === 6) {
      // $FlowFixMe
      var _state4 = _slicedToArray(state, 6),
          _b = _state4[0],
          _precision = _state4[1],
          left = _state4[2],
          bottom = _state4[3],
          right = _state4[4],
          top = _state4[5];

      return new RectBounds({
        bounds: _b,
        precision: _precision,
        left: left,
        bottom: bottom,
        right: right,
        top: top
      });
    }

    if (f1Type != null && f1Type === 'lineBounds' && state != null && Array.isArray([state]) && state.length === 7) {
      // $FlowFixMe
      var _state5 = _slicedToArray(state, 7),
          _b2 = _state5[0],
          _precision2 = _state5[1],
          x = _state5[2],
          y = _state5[3],
          x2 = _state5[4],
          y2 = _state5[5],
          ends = _state5[6];

      return new LineBounds({
        bounds: _b2,
        precision: _precision2,
        p1: new Point(x, y),
        p2: new Point(x2, y2),
        ends: ends
      });
    }

    if (f1Type != null && f1Type === 'transformBounds' && state != null && Array.isArray([state]) && state.length === 3) {
      // $FlowFixMe
      var _state6 = _slicedToArray(state, 3),
          _precision3 = _state6[0],
          order = _state6[1],
          boundsArray = _state6[2];

      var t = new TransformBounds(new Transform(), {}, _precision3);
      t.order = order.slice();
      var boundary = [];
      boundsArray.forEach(function (b) {
        if (b == null) {
          boundary.push(null);
        } else {
          boundary.push(getBounds(b));
        }
      });
      t.boundary = boundary;
      return t;
    }
  }

  return null;
}

function transformValueToArray(transformValue, transform) {
  if (Array.isArray(transformValue)) {
    return transformValue;
  }

  var order = []; // debugger;

  if (typeof transformValue === 'number') {
    for (var i = 0; i < transform.order.length; i += 1) {
      order.push(transformValue);
    }

    return order;
  }

  for (var _i5 = 0; _i5 < transform.order.length; _i5 += 1) {
    var transformation = transform.order[_i5];

    if (transformation instanceof Translation) {
      var value = 0;

      if (transformValue.position != null) {
        value = transformValue.position;
      }

      if (transformValue.translation != null) {
        value = transformValue.translation;
      }

      order.push(value);
    } else if (transformation instanceof Scale) {
      var _value = 0;

      if (transformValue.scale != null) {
        _value = transformValue.scale;
      }

      order.push(_value);
    } else if (transformation instanceof Rotation) {
      var _value2 = 0;

      if (transformValue.rotation != null) {
        _value2 = transformValue.rotation;
      }

      order.push(_value2);
    }
  }

  return order;
} // bounds: null
// bounds: { translation: [-1, -1, 2, 2], scale: [-1, 1], rotation: [-1, 1] }
// bounds: 'figure',
// bounds: new TransformBounds(transform, [null, null] | { translation: null })
// bounds: [null, [-1, -1, 2, 2], null]
// bounds: [null, [null, -1, null, 2], null]
// bounds: TransformBounds | Rect | Array<number> | 'figure',
// type TypeBoundsDefinition = null | ;


var TransformBounds = /*#__PURE__*/function (_Bounds4) {
  _inherits(TransformBounds, _Bounds4);

  var _super7 = _createSuper(TransformBounds);

  function TransformBounds(transform) {
    var _this6;

    var bounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;

    _classCallCheck(this, TransformBounds);

    // let boundary = [];
    var order = [];

    for (var i = 0; i < transform.order.length; i += 1) {
      var transformation = transform.order[i];

      if (transformation instanceof Translation) {
        order.push('t');
      } else if (transformation instanceof Scale) {
        order.push('s');
      } else {
        order.push('r');
      }
    }

    _this6 = _super7.call(this, [], 'inside', precision);
    _this6.order = order;

    _this6.createBounds(bounds);

    return _this6;
  }

  _createClass(TransformBounds, [{
    key: "isUnbounded",
    value: function isUnbounded() {
      for (var i = 0; i < this.boundary.length; i += 1) {
        if (this.boundary[i] !== null) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_dup",
    value: function _dup() {
      var t = new TransformBounds(new Transform(), {}, this.precision);
      t.order = this.order.slice();
      t.boundary = [];
      this.boundary.forEach(function (b) {
        if (b == null) {
          t.boundary.push(null);
        } else {
          t.boundary.push(b._dup());
        }
      });
      return t;
    }
  }, {
    key: "_state",
    value: function _state(options) {
      // const { precision } = options;
      var precision = getPrecision(options);
      var bounds = [];
      this.boundary.forEach(function (b) {
        if (b == null) {
          bounds.push(null);
        } else {
          bounds.push(b._state({
            precision: precision
          }));
        }
      });
      return {
        f1Type: 'transformBounds',
        state: [this.precision, this.order.slice(), bounds]
      };
    }
  }, {
    key: "createBounds",
    value: function createBounds(bounds) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (bounds == null || bounds instanceof Bounds) {
        this.boundary[index] = bounds;
        return;
      }

      if (Array.isArray(bounds)) {
        this.boundary = bounds;
        return;
      }

      var boundary = [];
      this.order.forEach(function (o) {
        var bound = null;

        if (o === 't' && bounds.position != null) {
          bound = getBounds(bounds.position);
        }

        if (o === 't' && bounds.translation != null) {
          bound = getBounds(bounds.translation);
        }

        if (o === 'r' && bounds.rotation != null) {
          bound = getBounds(bounds.rotation);
        }

        if (o === 's' && bounds.scale != null) {
          bound = getBounds(bounds.scale);
        }

        boundary.push(bound);
      });
      this.boundary = boundary;
    }
  }, {
    key: "update",
    value: function update(type, bound) {
      var typeIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var index = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var o = this.order[i];

        if (o === type) {
          if (typeIndex == null || typeIndex === index) {
            this.boundary[i] = getBounds(bound);
          }

          index += 1;
        } // if (o === type && (typeIndex == null || typeIndex === index)) {
        //   this.boundary[i] = getBounds(bound);
        //   index += 1;
        // }

      }
    }
  }, {
    key: "updateTranslation",
    value: function updateTranslation(bound) {
      var translationIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var b = getBounds(bound);

      if (b instanceof RangeBounds) {
        b = new RectBounds({
          left: b.boundary.min,
          bottom: b.boundary.min,
          top: b.boundary.max,
          right: b.boundary.max
        });
      }

      this.update('t', b, translationIndex);
    }
  }, {
    key: "updateRotation",
    value: function updateRotation(bound) {
      var translationIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.update('r', bound, translationIndex);
    }
  }, {
    key: "updateScale",
    value: function updateScale(bound) {
      var translationIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.update('s', bound, translationIndex);
    }
  }, {
    key: "getBound",
    value: function getBound(type) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var typeIndex = 0;

      for (var i = 0; i < this.order.length; i += 1) {
        var o = this.order[i];

        if (o === type) {
          if (typeIndex === index) {
            return this.boundary[i];
          }

          typeIndex += 1;
        }
      }

      return null;
    }
  }, {
    key: "getTranslation",
    value: function getTranslation() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.getBound('t', index);
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.getBound('s', index);
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.getBound('r', index);
    } // $FlowFixMe

  }, {
    key: "contains",
    value: function contains(t) {
      for (var i = 0; i < t.order.length; i += 1) {
        var transformElement = t.order[i];
        var b = this.boundary[i]; // $FlowFixMe

        if (transformElement instanceof Rotation) {
          if (b != null && !b.contains(transformElement.r)) {
            return false;
          }
        } else if (b != null && !b.contains(new Point(transformElement.x, transformElement.y))) {
          return false;
        }
      }

      return true;
    } // $FlowFixMe

  }, {
    key: "clip",
    value: function clip(t) {
      var order = [];

      for (var i = 0; i < t.order.length; i += 1) {
        var transformElement = t.order[i];
        var b = this.boundary[i];

        if (b != null) {
          var clipped = void 0;

          if (transformElement instanceof Rotation) {
            clipped = b.clip(transformElement.r);
          } else {
            clipped = b.clip(new Point(transformElement.x, transformElement.y));
          }

          var newElement = void 0;

          if (transformElement instanceof Translation) {
            newElement = new Translation(clipped.x, clipped.y, transformElement.name);
          } else if (transformElement instanceof Scale) {
            newElement = new Scale(clipped.x, clipped.y, transformElement.name);
          } else {
            newElement = new Rotation(clipped, transformElement.name);
          } // clipped.name = transformElement.name;


          order.push(newElement);
        } else {
          order.push(transformElement._dup());
        }
      }

      return new Transform(order, t.name);
    }
  }]);

  return TransformBounds;
}(Bounds);

function deceleratePoint(positionIn, velocityIn, deceleration) {
  var deltaTimeIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var boundsIn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var bounceLossIn = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var zeroVelocityThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var precision = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 8;
  var bounds;

  if (boundsIn instanceof RangeBounds) {
    bounds = new RectBounds({
      left: boundsIn.boundary.min,
      right: boundsIn.boundary.max,
      bottom: boundsIn.boundary.min,
      top: boundsIn.boundary.max
    });
  } else {
    bounds = boundsIn;
  } // clip velocity to the dimension of interest


  var velocity = velocityIn; // $FlowFixMe

  if (bounds != null && bounds.clipVelocity != null) {
    // $FlowFixMe
    velocity = bounds.clipVelocity(velocityIn);
  } // const velocity = velocityIn;


  var stopFlag = false;

  if (deltaTimeIn == null) {
    stopFlag = true;
  } // Get the mag and angle of the velocity and check if under the zero threshold


  var _velocity$toPolar = velocity.toPolar(),
      mag = _velocity$toPolar.mag,
      angle = _velocity$toPolar.angle;

  if (mag <= zeroVelocityThreshold) {
    return {
      velocity: new Point(0, 0),
      position: positionIn,
      duration: 0
    };
  } // Clip position in the bounds


  var position = positionIn._dup();

  if (bounds != null) {
    position = bounds.clip(positionIn); // try {
    //   position = bounds.clip(positionIn);
    // } catch(error) {
    //   console.log('error', error)
    //   console.log('error - data', positionIn)
    //   console.log('error - data', bounds)
    //   debugger;
    // }
  } // Initial Velocity


  var v0 = mag; // Total change in velocity to go to zero threshold

  var deltaV = Math.abs(v0) - zeroVelocityThreshold;
  var deltaTime = deltaTimeIn;

  if (deltaTime == null || deltaTime > Math.abs(deltaV / deceleration)) {
    deltaTime = Math.abs(deltaV / deceleration);
  } // Calculate distance traveeled over time and so find the new Position


  var distanceTravelled = v0 * deltaTime - 0.5 * deceleration * Math.pow(deltaTime, 2);
  var newPosition = polarToRect(distanceTravelled, angle).add(position); // If the new position is within the bounds, then can return the result.

  if (bounds == null || bounds.contains(newPosition)) {
    if (stopFlag) {
      return {
        duration: deltaTime,
        position: newPosition,
        velocity: new Point(0, 0)
      };
    }

    var v1 = v0 - deceleration * deltaTime;

    if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(v1, precision) <= Object(_math__WEBPACK_IMPORTED_MODULE_0__["round"])(zeroVelocityThreshold, precision)) {
      v1 = 0;
    }

    return {
      position: newPosition,
      velocity: polarToRect(v1, angle),
      duration: deltaTime
    };
  } // if we got here, the new position is out of bounds


  var bounceScaler = 1 - bounceLossIn; // let result;
  // try {
  //   result = bounds.intersect(position, clipAngle(angle, '0to360'));
  // } catch(error) {
  //   console.log(error)
  //   debugger;
  // }

  var result = bounds.intersect(position, clipAngle(angle, '0to360')); // if newPosition is not contained within bounds, but the intersect distance
  // is larger than the distance travelled in deltaTime, then there is likely a
  // rounding error...

  if (result.distance != null && result.distance > distanceTravelled) {
    throw new Error('Error in calculating intersect');
  }

  var intersectPoint;

  if (typeof result.intersect === 'number') {
    intersectPoint = new Point(result.intersect, 0);
  } else if (result.intersect == null) {
    return {
      position: newPosition,
      velocity: new Point(0, 0),
      duration: deltaTime
    };
  } else {
    intersectPoint = result.intersect;
  } // const intersectPoint = result.position;


  var distanceToBound = result.distance;
  var reflectionAngle = result.reflection; // if (intersectPoint == null) {
  //   return {
  //     duration: timeToZeroV,
  //     position: newPosition,
  //   };
  // }
  // Calculate the time to the intersect point

  var acc = -v0 / Math.abs(v0) * deceleration;
  var s = distanceToBound;
  var b = v0;
  var a = 0.5 * acc;
  var c = -s;
  var t = (-b + Math.sqrt(Math.pow(b, 2) - 4 * a * c)) / (2 * a); // If there is no bounce (all energy is lost) then return the result

  if (bounceLossIn === 1) {
    return {
      velocity: new Point(0, 0),
      position: intersectPoint,
      duration: t
    };
  }

  var velocityAtIntersect = v0 + acc * t; // (s - 0.5 * a * (t ** 2)) / t;

  var bounceVelocity = velocityAtIntersect * bounceScaler;
  var rectBounceVelocity = new Point(bounceVelocity * Math.cos(reflectionAngle), bounceVelocity * Math.sin(reflectionAngle));

  if (stopFlag) {
    var newStop = deceleratePoint(intersectPoint, rectBounceVelocity, deceleration, deltaTimeIn, bounds, bounceLossIn, zeroVelocityThreshold, precision);
    return {
      duration: t + newStop.duration,
      position: newStop.position,
      velocity: new Point(0, 0)
    };
  }

  return deceleratePoint(intersectPoint, rectBounceVelocity, deceleration, deltaTime - t, bounds, bounceLossIn, zeroVelocityThreshold, precision);
}

function decelerateValue(value, velocity, deceleration) {
  var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var boundsIn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var bounceLoss = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var zeroVelocityThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var precision = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 8;
  var bounds = boundsIn;

  if (boundsIn != null) {
    // let { min, max } = boundsIn.boundary;
    // if (min == null) {
    // }
    bounds = new LineBounds({
      p1: [boundsIn.boundary.min != null ? boundsIn.boundary.min : 0, 0],
      p2: [boundsIn.boundary.max != null ? boundsIn.boundary.max : 0, 0]
    });
  }

  var result = deceleratePoint(new Point(value, 0), new Point(velocity, 0), deceleration, deltaTime, bounds, bounceLoss, zeroVelocityThreshold, precision);
  return {
    duration: result.duration,
    value: result.position.x,
    velocity: result.velocity.x
  };
}

function decelerateIndependantPoint(value, velocity, deceleration) {
  var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var boundsIn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var bounceLoss = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var zeroVelocityThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var precision = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 8;
  var xBounds = null;
  var yBounds = null;

  if (boundsIn != null) {
    xBounds = new RangeBounds({
      min: boundsIn.boundary.left,
      max: boundsIn.boundary.right
    });
    yBounds = new RangeBounds({
      min: boundsIn.boundary.bottom,
      max: boundsIn.boundary.top
    });
  }

  var xResult = decelerateValue(value.x, velocity.x, deceleration, deltaTime, xBounds, bounceLoss, zeroVelocityThreshold, precision);
  var yResult = decelerateValue(value.y, velocity.y, deceleration, deltaTime, yBounds, bounceLoss, zeroVelocityThreshold, precision);
  return {
    duration: Math.max(xResult.duration, yResult.duration),
    point: new Point(xResult.value, yResult.value),
    velocity: new Point(xResult.velocity, yResult.velocity)
  };
}

// function getTransformBoundsLimit(
//   boundsDefinition: TypeTransformLinkBoundsDefinition | TypeTransformBounds,
//   transform: Transform,
// ): TypeTransformBounds {
//   if (Array.isArray(boundsDefinition)) {
//     return boundsDefinition;
//   }
//   const order = [];
//   for (let i = 0; i < transform.order.length; i += 1) {
//     const transformation = transform.order[i];
//     if (transformation instanceof Translation) {
//       let position = null;
//       if (boundsDefinition.position != null) {
//         ({ position } = boundsDefinition);
//       }
//       if (boundsDefinition.translation != null) {
//         position = boundsDefinition.translation;
//       }
//       order.push(position);
//     } else if (transformation instanceof Scale) {
//       let scale = null;
//       if (boundsDefinition.scale != null) {
//         ({ scale } = boundsDefinition);
//       }
//       order.push(scale);
//     } else if (transformation instanceof Rotation) {
//       let rotation = null;
//       if (boundsDefinition.rotation != null) {
//         ({ rotation } = boundsDefinition);
//       }
//       order.push(rotation);
//     }
//   }
//   return order;
// }
function decelerateTransform(transform, velocity, deceleration, deltaTime, boundsIn, bounceLoss, zeroVelocityThreshold) {
  var precision = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 8;
  var duration = 0;
  var newOrder = [];
  var newVOrder = [];
  var bounds;

  if (boundsIn instanceof TransformBounds) {
    bounds = boundsIn;
  } else {
    bounds = new TransformBounds(transform, boundsIn);
  }

  for (var i = 0; i < transform.order.length; i += 1) {
    var transformation = transform.order[i];
    var result = void 0;
    var newTransformation = void 0;
    var newVTransformation = void 0;

    if (transformation instanceof Translation) {
      result = deceleratePoint( // $FlowFixMe
      transformation, velocity.order[i], deceleration[i], deltaTime, bounds.boundary[i], bounceLoss[i], zeroVelocityThreshold[i], precision);
      newTransformation = new Translation(result.position.x, result.position.y);
      newVTransformation = new Translation(result.velocity.x, result.velocity.y);
    } else if (transformation instanceof Scale) {
      result = decelerateIndependantPoint( // $FlowFixMe
      transformation, velocity.order[i], deceleration[i], deltaTime, // $FlowFixMe
      bounds.boundary[i], bounceLoss[i], zeroVelocityThreshold[i], precision);
      newTransformation = new Scale(result.point.x, result.point.y);
      newVTransformation = new Scale(result.velocity.x, result.velocity.y);
    } else {
      result = decelerateValue( // $FlowFixMe
      transformation.r, velocity.order[i].r, deceleration[i], deltaTime, // $FlowFixMe
      bounds.boundary[i], bounceLoss[i], zeroVelocityThreshold[i], precision);
      newTransformation = new Rotation(result.value);
      newVTransformation = new Rotation(result.velocity);
    }

    if (deltaTime === null) {
      if (result.duration > duration) {
        var _result = result;
        duration = _result.duration;
      }
    }

    newVOrder.push(newVTransformation);
    newOrder.push(newTransformation);
  }

  if (deltaTime != null) {
    duration = deltaTime;
  }

  return {
    transform: new Transform(newOrder),
    velocity: new Transform(newVOrder),
    duration: duration
  };
}
/**
 * Get center of a triangle
 *
 * @example
 * const getTriangleCenter = Fig.getTriangleCenter;
 *
 * const center = getTriangleCenter([0, 0], [1, 0], [0, 1]);
 * console.log(center);
 * // Point {x: 0.3333333333333333, y: 0.3333333333333333}
 */


function getTriangleCenter(p1, p2, p3) {
  var A = getPoint(p1);
  var B = getPoint(p2);
  var C = getPoint(p3);
  var Ox = (A.x + B.x + C.x) / 3;
  var Oy = (A.y + B.y + C.y) / 3;
  return new Point(Ox, Oy);
}

function isParsablePoint(value) {
  if (Array.isArray(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number') {
    return true;
  }

  if (value instanceof Point) {
    return true;
  }

  if (value.f1Type != null && value.f1Type === 'p') {
    return true;
  }

  if (typeof value === 'string' && value.charAt(0) === '[') {
    var newValue;

    try {
      newValue = JSON.parse(value);
    } catch (_unused8) {
      return false;
    }

    return isParsablePoint(newValue);
  }

  return false;
}
/**
 * A border is an array of points defining a contigous, closed border.
 *
 * `Array<TypeParsablePoint> | Array<Array<TypeParsablePoint>>`
 *
 * If a border is not contigous, but rather is several "islands" of contigous,
 * closed borders, then an array of point arrays can be used, where each point
 * array is one island.
 */


function getBorder(border) {
  if (typeof border === 'string' || typeof border === 'number') {
    return border;
  } // $FlowFixMe


  if (isParsablePoint(border[0])) {
    // $FlowFixMe
    return [border.map(function (p) {
      return getPoint(p);
    })];
  } // $FlowFixMe


  return border.map(function (b) {
    return b.map(function (p) {
      return getPoint(p);
    });
  });
}

function getPositionInRect(r) // offset: TypeParsablePoint = new Point(0, 0),
{
  var xAlign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var yAlign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var rect = getRect(r);
  var position = new Point(rect.left, rect.bottom);

  if (xAlign === 'center') {
    position.x += rect.width / 2;
  } else if (xAlign === 'right') {
    position.x = rect.right;
  } else if (typeof xAlign === 'number') {
    position.x += rect.width * xAlign;
  } else if (xAlign.startsWith('o')) {
    position.x += parseFloat(xAlign.slice(1));
  }

  if (yAlign === 'middle') {
    position.y += rect.height / 2;
  } else if (yAlign === 'top') {
    position.y = rect.top;
  } else if (typeof yAlign === 'number') {
    position.y += rect.height * yAlign;
  } else if (yAlign.startsWith('o')) {
    position.y += parseFloat(yAlign.slice(1));
  }

  return position;
} // function getBorder(borders: Array<Array<TypeParsablePoint>>) {
//   if (!Array.isArray(borders)) {
//     return borders;
//   }
//   const borderOut: Array<Array<Point>> = [];
//   borders.forEach((b) => {
//     borderOut.push(b.map((bElement: TypeParsablePoint) => getPoint(bElement)));
//   });
//   return borderOut;
// }




/***/ }),

/***/ "./src/js/tools/getCssColors.js":
/*!**************************************!*\
  !*** ./src/js/tools/getCssColors.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getCSSColors; });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ "./src/js/tools/color.js");
/* harmony import */ var _getCssVariables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssVariables */ "./src/js/tools/getCssVariables.js");
// eslint-disable-next-line import/no-cycle


var baseColors = ['blue', 'red', 'yellow', 'green', 'cyan', 'brown', 'orange', 'violet', 'grey', 'black', 'white'];
var shades = ['base', 'lighter', 'light', 'dark', 'darker', 'higher', 'high', 'low', 'lower'];
var paletteColorNames = [];
baseColors.forEach(function (color) {
  shades.forEach(function (shade) {
    paletteColorNames.push("--palette-".concat(color, "-").concat(shade));
  });
});
var figureColorNames = ['--figure-background', '--figure-primary', '--figure-warning', '--figure-safe', '--figure-passive', '--figure-construction1', '--figure-construction2', '--figure-construction3', '--figure-construction4', '--figure-construction5', '--figure-construction6', '--figure-construction7', '--figure-construction8', '--figure-construction9', '--figure-disabled', '--figure-disabledDark', '--figure-disabledDarker', '--figure-disabledDarkest', '--figure-push', '--figure-action', '--figure-text-base', '--figure-text-warning', '--figure-text-plot', '--figure-text-keyword', '--figure-text-keyword2', '--figure-text-latin', '--figure-text-greek', '--figure-text-english', '--figure-text-note', '--figure-qr-background'];
function getCSSColors() {
  var customColorNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var colors = {};
  var paletteColors = {};
  var figureColors = {};
  var colorNames = customColorNames.map(function (name) {
    return "--colors-".concat(name);
  });
  var _document = document,
      body = _document.body;

  if (body) {
    colors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, colorNames, '--colors-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
    paletteColors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, paletteColorNames, '--palette-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
    figureColors = Object(_getCssVariables__WEBPACK_IMPORTED_MODULE_1__["getDefinedCSSVariables"])(body, figureColorNames, '--figure-', false, // $FlowFixMe
    _color__WEBPACK_IMPORTED_MODULE_0__["cssColorToArray"]);
  }

  colors.palette = paletteColors;
  colors.figure = figureColors;
  return colors;
}

/***/ }),

/***/ "./src/js/tools/getCssVariables.js":
/*!*****************************************!*\
  !*** ./src/js/tools/getCssVariables.js ***!
  \*****************************************/
/*! exports provided: getCSSVariables, getDefinedCSSVariables, searchObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCSSVariables", function() { return getCSSVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefinedCSSVariables", function() { return getDefinedCSSVariables; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "searchObject", function() { return searchObject; });
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools */ "./src/js/tools/tools.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



function searchObject(obj, path, text) {
  var results = [];
  Object.keys(obj).forEach(function (key) {
    var newPath = "".concat(path, ".").concat(key);

    if (key.includes(text)) {
      results.push(newPath);
    } else if (_typeof(obj[key]) === 'object') {
      var newResult = searchObject(obj[key], newPath, text);

      if (newResult) {
        results = results.concat(newResult);
      }
    } else if (typeof obj[key] === 'string') {
      if (obj[key].includes(text)) {
        results.push(newPath);
      }
    }
  });
  return results;
}

function toCamelCase(input, prefix) {
  var rePrefix = new RegExp(prefix, 'g');
  var reCamelCase1 = /-[a-z]/g;
  var reCamelCase2 = /_[a-z]/g;

  var repl = function repl(str) {
    return str[1].toUpperCase();
  };

  var noPrefix = input.replace(rePrefix, '');
  var camelCase1 = noPrefix.replace(reCamelCase1, repl);
  var camelCase2 = camelCase1.replace(reCamelCase2, repl);
  var noDash = camelCase2.replace(/-/g, '');
  return noDash;
}

function getDefinedCSSVariables(idOrElement, propertyNames) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var makeFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var modifier = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (a) {
    return a;
  };
  var variables = {};
  var elem = idOrElement;

  if (typeof idOrElement === 'string') {
    elem = document.getElementById(idOrElement);
  }

  if (elem instanceof HTMLElement) {
    var style = window.getComputedStyle(elem);

    if (style) {
      propertyNames.forEach(function (propertyName) {
        var value = style.getPropertyValue(propertyName);

        if (value == null) {
          return;
        }

        value = value.trim();
        var fValue = parseFloat(value);
        var valueToAdd = value;

        if (!Number.isNaN(fValue)) {
          valueToAdd = fValue;
        }

        valueToAdd = modifier(valueToAdd);

        if (makeFlat) {
          var shortName = toCamelCase(propertyName, prefix);
          variables[shortName] = valueToAdd;
        } else {
          var rePrefix = new RegExp(prefix, 'g');
          var noPrefix = propertyName.replace(rePrefix, '');
          Object(_tools__WEBPACK_IMPORTED_MODULE_0__["addToObject"])(variables, noPrefix, valueToAdd, '-');
        }
      });
    }
  }

  return variables;
}

function getCSSVariables(idOrElement) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var makeFlat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var variables = {};
  var elem = idOrElement;

  if (typeof idOrElement === 'string') {
    elem = document.getElementById(idOrElement);
  }

  if (elem instanceof HTMLElement) {
    var style = window.getComputedStyle(elem);

    if (style) {
      var numProperties = style.length;

      for (var i = 0; i < numProperties; i += 1) {
        var propertyName = style[i];

        if (prefix === '' || propertyName.startsWith(prefix)) {
          var value = style.getPropertyValue(propertyName);

          if (value != null) {
            value = value.trim();
            var fValue = parseFloat(value);
            var valueToAdd = value;

            if (!Number.isNaN(fValue)) {
              valueToAdd = fValue;
            }

            if (makeFlat) {
              var shortName = toCamelCase(propertyName, prefix);
              variables[shortName] = valueToAdd;
            } else {
              var rePrefix = new RegExp(prefix, 'g');
              var noPrefix = propertyName.replace(rePrefix, '');
              Object(_tools__WEBPACK_IMPORTED_MODULE_0__["addToObject"])(variables, noPrefix, valueToAdd, '-');
            }
          }
        }
      }
    }
  }

  return variables;
}



/***/ }),

/***/ "./src/js/tools/htmlGenerator.js":
/*!***************************************!*\
  !*** ./src/js/tools/htmlGenerator.js ***!
  \***************************************/
/*! exports provided: actionWord, click, highlight, addClass, addId, onClickId, highlightWord, centerV, centerH, centerVH, toHTML, itemSelector, unit, applyModifiers, setOnClicks, setHTML, withClass, style, clickW, link */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "actionWord", function() { return actionWord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "click", function() { return click; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "highlight", function() { return highlight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addClass", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addId", function() { return addId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onClickId", function() { return onClickId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "highlightWord", function() { return highlightWord; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerV", function() { return centerV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerH", function() { return centerH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "centerVH", function() { return centerVH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHTML", function() { return toHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "itemSelector", function() { return itemSelector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unit", function() { return unit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyModifiers", function() { return applyModifiers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOnClicks", function() { return setOnClicks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setHTML", function() { return setHTML; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withClass", function() { return withClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "style", function() { return style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clickW", function() { return clickW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "link", function() { return link; });
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ "./src/js/tools/color.js");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools */ "./src/js/tools/tools.js");
/* harmony import */ var _figure_Recorder_Recorder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../figure/Recorder/Recorder */ "./src/js/figure/Recorder/Recorder.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





function convertTextArrayToParagraphs(text) {
  var firstParagraphMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var textToUse = '';
  var firstPStyle = '';

  if (firstParagraphMargin != null) {
    firstPStyle = " style=\"margin-top:".concat(firstParagraphMargin, "%\"");
  }

  if (Array.isArray(text)) {
    text.forEach(function (t, index) {
      if (t.startsWith('<')) {
        textToUse += t;
      } else if (index === 0) {
        textToUse += "<p style=\"margin-top:".concat(firstPStyle, "\">").concat(t, "</p>");
      } else {
        textToUse += "<p>".concat(t, "</p>");
      }
    }); // textToUse = `<p${style}>${text.join('</p><p>')}</p>`;
  } else {
    textToUse = text;
  }

  return textToUse;
}

function withClass() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var classText = arguments.length > 1 ? arguments[1] : undefined;
  var textToUse = convertTextArrayToParagraphs(text);
  return "<div class=\"".concat(classText, "\">").concat(textToUse, "</div>");
}

function centerV() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text, 0);
  return "<div style=\"display: table; height: 100%; width: 100%;\">\n        <div style=\"display: table-cell; vertical-align: middle; height: 100%; width: 100%;\">\n        ".concat(textToUse, "</div></div>");
}

function centerVH() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text, 0);
  return "<div style=\"display: table; height: 100%; text-align:center; width:100%;\">\n        <div style=\"display: table-cell; vertical-align: middle; height: 100%; width: 100%;\">\n        ".concat(textToUse, "</div></div>");
}

function centerH() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var textToUse = convertTextArrayToParagraphs(text);
  return "<div style=\"text-align:center;\">\n        ".concat(textToUse, "</div>");
}

function style() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var text = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var marginLeft = '';
  var marginRight = '';
  var marginTop = '';
  var marginLine = '';
  var size = '';
  var className = '';
  var color = '';
  var listStyleType = '';
  var id = '';

  if (typeof options === 'number') {
    marginTop = "margin-top:".concat(options, "%");
  } else {
    if (options.left != null) {
      marginLeft = "margin-left:".concat(options.left, "%;");
    }

    if (options.right != null) {
      marginRight = "margin-right:".concat(options.right, "%;");
    }

    if (options.centerV) {
      marginTop = 'margin-top:0;';
    }

    if (options.top != null) {
      marginTop = "margin-top:".concat(options.top, "%;");
    }

    if (options.line != null) {
      marginLine = "margin-top:".concat(options.line, "%;");
    }

    if (options.size != null) {
      size = "font-size:".concat(options.size, "em;");
    }

    if (options.className) {
      className = "class=\"".concat(options.className, "\"");
    }

    if (options.color) {
      color = "color:".concat(Object(_color__WEBPACK_IMPORTED_MODULE_0__["colorArrayToRGBA"])(options.color), ";");
    }

    if (options.listStyleType) {
      listStyleType = "list-style-type:".concat(options.listStyleType, ";");
    }

    if (options.id) {
      id = "id=\"".concat(options.id, "\"");
    }
  }

  var p = "<p style=\"".concat(marginLeft).concat(marginRight).concat(marginLine).concat(size).concat(color, "\"").concat(className, ">");
  var pFirst = "<p style=\"".concat(marginLeft).concat(marginRight).concat(marginTop).concat(size).concat(color, "\"").concat(className).concat(id, ">");
  var li = "<li style=\"".concat(marginLeft).concat(marginRight).concat(marginLine).concat(size).concat(color).concat(listStyleType, "\"").concat(className, ">");
  var ul = "<ul style=\"".concat(marginLeft).concat(marginRight).concat(marginTop).concat(size).concat(color, "\"").concat(className).concat(id, ">");
  var ol = "<ol style=\"".concat(marginLeft).concat(marginRight).concat(marginTop).concat(size).concat(color, "\"").concat(className).concat(id, ">");
  var textToUse;

  if (options.list != null) {
    if (Array.isArray(text)) {
      textToUse = text.join("</li>".concat(li));
    } else {
      textToUse = text;
    }

    if (options.list === 'unordered') {
      textToUse = "".concat(ul).concat(li).concat(textToUse, "</ul>");
    } else {
      textToUse = "".concat(ol).concat(li).concat(textToUse, "</ol>");
    }
  } else {
    if (Array.isArray(text)) {
      textToUse = text.join("</p>".concat(p));
    } else {
      textToUse = text;
    }

    textToUse = "".concat(pFirst).concat(textToUse, "</p>");
  }

  if (options.centerH) {
    textToUse = centerH(textToUse);
  }

  if (options.centerV) {
    textToUse = centerV(textToUse);
  }

  return textToUse;
}

function itemSelector() {
  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [''];
  var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var selectorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var outStr = "<ul id=\"id__figureone_item_selector_".concat(selectorIndex, "\" \n                    class=").concat(classes, ">");
  items.forEach(function (item, index) {
    outStr += "<li id=\"id__figureone_item_selector_".concat(index, "\">").concat(item, "</li>");
  });
  outStr += '</ul>';
  return outStr;
}

var unit = function unit(deg, rad) {
  return "<span class=\"figureone__unit_deg\">".concat(deg, "</span><span class=\"figureone__unit_rad\">").concat(rad, "</span>\n  ");
};

function toHTML() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var classes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var idStr = '';

  if (id) {
    idStr = " id=\"".concat(id, "\"");
  }

  var classStr = '';

  if (classes) {
    classStr = " class=\"".concat(classes, "\"");
  }

  var colorStr = '';

  if (color) {
    colorStr = " style=\"color:".concat(Object(_color__WEBPACK_IMPORTED_MODULE_0__["colorArrayToRGBA"])(color), ";\"");
  }

  return {
    replacementText: "<span".concat(idStr).concat(classStr, "\"").concat(colorStr, ">").concat(text.replace(RegExp(/_/, 'gi'), ' ').trim(), "</span>")
  };
}

function highlight() {
  var classesOrColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var classStr = 'highlight_word';

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: function replacementText(text) {
      return toHTML(text, '', classStr, color);
    }
  };
}

function link(linkStr) {
  var colorOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var classStr = 'action_word interactive_word';
  var colorToUse = null;
  var defaultOptions = {
    color: null,
    id: "figureone__id_".concat(Object(_tools__WEBPACK_IMPORTED_MODULE_1__["generateUniqueId"])()),
    interactive: true,
    classes: '',
    text: null,
    newTab: true
  };
  var options = defaultOptions;

  if (Array.isArray(colorOrOptions)) {
    colorToUse = colorOrOptions;
  } else if (colorOrOptions != null) {
    options = Object(_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, colorOrOptions);
  }

  var _options = options,
      color = _options.color,
      id = _options.id,
      classes = _options.classes,
      text = _options.text;

  if (color != null) {
    colorToUse = color;
  }

  if (classes !== '') {
    classStr = "".concat(classStr, " ").concat(classes);
  }

  var target = options.newTab ? ' target="_blank"' : '';

  var idToUse = function idToUse() {
    return id;
  };

  return {
    replacementText: function replacementText(textIn) {
      var idStr = id ? " id=\"".concat(id, "\"") : '';
      var colorStr = colorToUse ? " style=\"color:".concat(Object(_color__WEBPACK_IMPORTED_MODULE_0__["colorArrayToRGBA"])(colorToUse), ";\"") : '';
      return {
        replacementText: "<a href=".concat(linkStr).concat(idStr, "class=\"").concat(classStr, "\"").concat(colorStr, " rel=\"noreferrer noopener\"").concat(target, ">").concat((text || textIn).trim(), "</a>")
      };
    },
    id: idToUse
  };
}

function highlightWord(text) {
  var classesOrColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var classStr = 'highlight_word';

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: toHTML(text, '', classStr, color).replacementText
  };
}

function addClass() {
  var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    replacementText: function replacementText(text) {
      return toHTML(text, '', classes);
    } // id: '',

  };
}

function addId() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    replacementText: function replacementText(text) {
      return toHTML(text, id);
    } // id: '',

  };
}

function click(actionMethod, bind) {
  var colorOrOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var classStr = 'action_word';
  var colorToUse = null;
  var defaultOptions = {
    color: null,
    id: "figureone__id_".concat(Object(_tools__WEBPACK_IMPORTED_MODULE_1__["generateUniqueId"])()),
    interactive: true,
    classes: '',
    text: null
  };
  var options = defaultOptions;

  if (Array.isArray(colorOrOptions)) {
    colorToUse = colorOrOptions;
  } else if (colorOrOptions != null) {
    options = Object(_tools__WEBPACK_IMPORTED_MODULE_1__["joinObjects"])(defaultOptions, colorOrOptions);
  }

  var _options2 = options,
      interactive = _options2.interactive,
      color = _options2.color,
      id = _options2.id,
      classes = _options2.classes,
      text = _options2.text;

  if (color != null) {
    colorToUse = color;
  }

  if (interactive) {
    classStr = "".concat(classStr, " interactive_word");
  }

  if (classes !== '') {
    classStr = "".concat(classStr, " ").concat(classes);
  }

  var idToUse = function idToUse() {
    return id;
  };

  return {
    replacementText: function replacementText(textIn) {
      return toHTML(text || textIn, idToUse(), classStr, colorToUse);
    },
    id: idToUse,
    actionMethod: actionMethod,
    bind: bind
  };
}

function clickW(textToUse, actionMethod, bind) {
  var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return click(actionMethod, bind, {
    color: color,
    text: textToUse
  });
}

function actionWord(text) {
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Object(_tools__WEBPACK_IMPORTED_MODULE_1__["generateUniqueId"])();
  var classesOrColor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var interactive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var classStr = 'action_word';

  if (interactive) {
    classStr = "".concat(classStr, " interactive_word");
  }

  if (typeof classesOrColor === 'string') {
    classStr = "".concat(classesOrColor, " ").concat(classStr);
  }

  var color = null;

  if (Array.isArray(classesOrColor)) {
    color = classesOrColor;
  }

  return {
    replacementText: toHTML(text, id, classStr, color).replacementText,
    id: id
  };
}

function modifyText(text, key, mod) {
  var outText = '';
  var expression = new RegExp("\\|".concat(key, "\\|"), 'gi');
  var replacement = '';

  if (typeof mod === 'string') {
    replacement = mod;
  } else if (typeof mod.replacementText === 'string') {
    replacement = mod.replacementText;
  } else {
    replacement = mod.replacementText(key).replacementText;
  }

  outText = text.replace(expression, replacement);
  return outText;
}

function onClickId(id, actionMethod, bind) {
  var additionalClassesToAdd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  var recorder = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new _figure_Recorder_Recorder__WEBPACK_IMPORTED_MODULE_2__["Recorder"]();
  var element = document.getElementById(id);

  if (element) {
    element.classList.add('action_word_enabled');
    additionalClassesToAdd.split(' ').forEach(function (classString) {
      if (classString) {
        element.classList.add(classString);
      }
    });

    var onClickFn = function onClickFn() {
      // const recorder = new Recorder();
      if (recorder.state === 'recording') {
        recorder.recordEvent('click', [id]);
      }

      actionMethod.bind.apply(actionMethod, _toConsumableArray(bind))();
    };

    element.onclick = onClickFn;
  }
}

function applyModifiers(text, modifiers) {
  var highlightClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'highlight_word';
  var monochrome = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var outText = text;
  Object.keys(modifiers).forEach(function (key) {
    var mod = modifiers[key]; // if (mod.replacementText != null) {

    outText = modifyText(outText, key, mod); // }
  });
  var r = RegExp(/\|([^|]*)\|/gi);
  outText = outText.replace(r, "<span class=\"".concat(highlightClass, "\">$1</span>"));

  if (monochrome) {
    var c = RegExp(/style="color:rgba\([^)]*\);"/gi);
    outText = outText.replace(c, '');
    var h = RegExp(/highlight_word/gi);
    outText = outText.replace(h, '');
    var i = RegExp(/interactive_word/gi);
    outText = outText.replace(i, '');
    var id = RegExp(/id="[^"]*"/gi);
    outText = outText.replace(id, '');
  }

  return outText;
}

function setOnClicks(modifiers) {
  var additionalClassesToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var recorder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _figure_Recorder_Recorder__WEBPACK_IMPORTED_MODULE_2__["Recorder"]();
  Object.keys(modifiers).forEach(function (key) {
    var mod = modifiers[key];

    if (typeof mod !== 'string' && 'actionMethod' in mod) {
      onClickId(typeof mod.id === 'string' ? mod.id : mod.id(key), mod.actionMethod, mod.bind, additionalClassesToAdd, recorder);
    }
  });
}

function setHTML(element, text) {
  var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var classesToAdd = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  var modifiedText = applyModifiers(text, modifiers); // eslint-disable-next-line no-param-reassign

  element.innerHTML = modifiedText;
  setOnClicks(modifiers, classesToAdd);
}



/***/ }),

/***/ "./src/js/tools/m2.js":
/*!****************************!*\
  !*** ./src/js/tools/m2.js ***!
  \****************************/
/*! exports provided: mul, identity, t, copy, translate, rotate, transform, scale, inverse, rotationMatrix, translationMatrix, scaleMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return t; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationMatrix", function() { return rotationMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translationMatrix", function() { return translationMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleMatrix", function() { return scaleMatrix; });
// 2D Matrix functions
function mul(a, b) {
  return [a[0] * b[0] + a[1] * b[3] + a[2] * b[6], a[0] * b[1] + a[1] * b[4] + a[2] * b[7], a[0] * b[2] + a[1] * b[5] + a[2] * b[8], a[3] * b[0] + a[4] * b[3] + a[5] * b[6], a[3] * b[1] + a[4] * b[4] + a[5] * b[7], a[3] * b[2] + a[4] * b[5] + a[5] * b[8], a[6] * b[0] + a[7] * b[3] + a[8] * b[6], a[6] * b[1] + a[7] * b[4] + a[8] * b[7], a[6] * b[2] + a[7] * b[5] + a[8] * b[8]];
}

function t(a) {
  return [a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]];
}

function identity() {
  return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}

function copy(a) {
  return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]];
}

function translationMatrix(tx, ty) {
  return [1, 0, tx, 0, 1, ty, 0, 0, 1];
}

function translate(m, tx, ty) {
  return mul(m, translationMatrix(tx, ty));
}

function rotationMatrix(angle) {
  var c = Math.cos(angle);
  var s = Math.sin(angle);
  return [c, -s, 0, s, c, 0, 0, 0, 1];
}

function rotate(m, angle) {
  return mul(m, rotationMatrix(angle));
}

function scaleMatrix(sx, sy) {
  return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
}

function scale(m, sx, sy) {
  return mul(m, scaleMatrix(sx, sy));
}

function transform(m, px, py) {
  return [m[0] * px + m[1] * py + m[2], m[3] * px + m[4] * py + m[5]];
}

function inverse(m) {
  var det = m[0] * (m[4] * m[8] - m[7] * m[5]) - // eslint-disable-line
  m[1] * (m[3] * m[8] - m[5] * m[6]) + // eslint-disable-line
  m[2] * (m[3] * m[7] - m[4] * m[6]);
  var invdet = 1 / det;
  var minv00 = (m[4] * m[8] - m[7] * m[5]) * invdet;
  var minv01 = (m[2] * m[7] - m[1] * m[8]) * invdet;
  var minv02 = (m[1] * m[5] - m[2] * m[4]) * invdet;
  var minv10 = (m[5] * m[6] - m[3] * m[8]) * invdet;
  var minv11 = (m[0] * m[8] - m[2] * m[6]) * invdet;
  var minv12 = (m[3] * m[2] - m[0] * m[5]) * invdet;
  var minv20 = (m[3] * m[7] - m[6] * m[4]) * invdet;
  var minv21 = (m[6] * m[1] - m[0] * m[7]) * invdet;
  var minv22 = (m[0] * m[4] - m[3] * m[1]) * invdet;
  return [minv00, minv01, minv02, minv10, minv11, minv12, minv20, minv21, minv22];
}



/***/ }),

/***/ "./src/js/tools/math.js":
/*!******************************!*\
  !*** ./src/js/tools/math.js ***!
  \******************************/
/*! exports provided: round, roundNum, decelerate, easeinout, easeout, easein, sinusoid, sinusoidAbs, linear, triangle, clipMag, clipValue, range, randInt, rand, randElement, removeRandElement, randElements, rand2D, randSign */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundNum", function() { return roundNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decelerate", function() { return decelerate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeinout", function() { return easeinout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeout", function() { return easeout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easein", function() { return easein; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinusoid", function() { return sinusoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinusoidAbs", function() { return sinusoidAbs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "triangle", function() { return triangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipMag", function() { return clipMag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipValue", function() { return clipValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randInt", function() { return randInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return rand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randElement", function() { return randElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeRandElement", function() { return removeRandElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randElements", function() { return randElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand2D", function() { return rand2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randSign", function() { return randSign; });
var roundNum = function roundNum(value) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  var multiplier = Math.pow(10, precision);
  var result = Math.round(value * multiplier) / multiplier; // if (Object.is(result, -0)) {
  // if (result === -0) {
  //   result = 0;
  // }

  var objectIsPolyfill = function objectIsPolyfill(x, y) {
    if (x === y) {
      // 0 === -0, but they are not identical
      return x !== 0 || 1 / x === 1 / y;
    } // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN("foo") => true
    // eslint-disable-next-line no-self-compare


    return x !== x && y !== y;
  };

  if (objectIsPolyfill(result, -0)) {
    result = 0;
  } // if (result === -0) {
  //   // 0 === -0, but they are not identical
  //   return result !== 0 || 1 / x === 1 / y;
  // }


  return result;
};

/**
 * Rounds a number or numbers in an array
 * @method
 * @param {number | Array<number>} arrayOrValue - Value or array of values to be rounded
 * @param {number} precision - Number of decimal places to round to
 * @returns {number | Array<number>} Rounded value or array of values
 */
function round(arrayOrValue) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  var result = 0;

  if (Array.isArray(arrayOrValue)) {
    return arrayOrValue.map(function (elem) {
      return round(elem, precision);
    });
  }

  if (typeof arrayOrValue === 'number') {
    result = roundNum(arrayOrValue, precision);
  } else if (arrayOrValue != null && arrayOrValue.round != null) {
    result = arrayOrValue.round(precision);
  } // $FlowFixMe


  return result;
} // // clipValue clips a value to either 0 if it's small enough, or to a max value
// // Value, and maxValue are sign independent. e.g.
// //    * value, maxValue = 2, 1 => clips to 1
// //    * value, maxValue = -2, -1 => clips to -1
// //    * value, maxValue = -2, 1 => clips to -1
// //    * value, maxValue = 2, -1 => clips to 1
// function clipValue(
//   value: number,
//   zeroThreshold: number,
//   maxValue: number = 0,
// ) {
//   let result = value;
//   let zero = zeroThreshold;
//   if (zero < 0) {
//     zero = -zero;
//   }
//   if (value > -zero && value < zero) {
//     return 0;
//   }
//   let max = maxValue;
//   if (max < 0) {
//     max = -max;
//   }
//   if (value > max) {
//     result = max;
//   }
//   if (value < -max) {
//     result = -max;
//   }
//   return result;
// }
// Clip a value to either max velocity, or 0 once under the minimum
// threashold.
//  * velocity: can be positive or negative
//  * maxVelocity will clip velocity to:
//      * |maxVelocity| if velocity > 0
//      * -|maxVelocity| if velcity < 0
//  * zeroThreshold will clip velocity to:
//       * 0 if velocity is larger than -|zeroThreshold| and smaller than
//         |zeroThreshold|.


function clipMag(value, zeroThreshold, maxValue) {
  var result = value;
  var zeroT = zeroThreshold;
  var maxV = maxValue;

  if (zeroT === null) {
    zeroT = 0;
  }

  if (zeroT < 0) {
    zeroT = -zeroT;
  }

  if (maxV === null) {
    return result;
  }

  if (maxV < 0) {
    maxV = -maxV;
  }

  if (value >= -zeroT && value <= zeroT) {
    result = 0;
  }

  if (value > maxV) {
    result = maxV;
  }

  if (value < -maxV) {
    result = -maxV;
  }

  return result;
}

function clipValue(value, minValue, maxValue) {
  var clipped = value;

  if (minValue !== null) {
    if (value < minValue) {
      clipped = minValue;
    }
  }

  if (maxValue !== null) {
    if (value > maxValue) {
      clipped = maxValue;
    }
  }

  return clipped;
}

var decelerate = function getPositionVelocityFromDecAndTime(position, velocity, magDeceleration, time, zeroThreshold) {
  var zeroT = 0;

  if (zeroThreshold !== null) {
    zeroT = zeroThreshold;
  }

  var decel = 0;

  if (magDeceleration !== null) {
    decel = magDeceleration;
  } // If the velocity is currently 0, then no further deceleration can occur, so
  // return the current velocity and position


  var v = clipMag(velocity, zeroT, velocity);

  if (v === 0) {
    return {
      p: position,
      v: 0
    };
  }

  var d = decel;

  if (decel < 0) {
    d = -d;
  } // If there is some initial velocity, then calc its sign and


  var sign = velocity / Math.abs(velocity);
  var newVelocity = velocity - sign * d * time; // if the new velocity changes sign, then it should go to 0. If it doesn't
  // change sign, then clip incase it should go to 0 because it is below
  // the zero velocity threshold.

  var newSign = newVelocity / Math.abs(newVelocity);

  if (newSign !== sign) {
    newVelocity = 0;
  } else {
    newVelocity = clipMag(newVelocity, zeroT, newVelocity);
  } // If the new velocity is clipped, then we need to use the time to where the
  // velocity crosses the clipping point.
  // v_new = v_init + a*t
  // Therefore, if v_new = zeroT: t = (zeroT - vi)/a


  var t = time;

  if (newVelocity === 0) {
    var z = zeroT;
    var zSign = z / Math.abs(z);

    if (zSign !== sign) {
      z = -z;
    }

    t = Math.abs((z - velocity) / d);
  } // Now can calculate the new position


  var newPosition = position + velocity * t - sign * 0.5 * d * t * t;
  return {
    p: newPosition,
    v: newVelocity
  };
};

var linear = function linear(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    return percentTime;
  }

  return percentTime;
};

function triangle() {
  var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var frequency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var mag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var phaseOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return bias + 2 * mag / Math.PI * Math.asin(Math.sin(2 * Math.PI * frequency * deltaTime + phaseOffset)); // return bias + mag * Math.sin(deltaTime * frequency * 2.0 * Math.PI + phaseOffset);
}

var easeinout = function easeinout(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    if (percentTime === 0.5) {
      return 0.5;
    }

    var a = percentTime;
    return (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2);
  }

  var x = percentTime;
  var percentDistance = Math.pow(x, 2) / (Math.pow(x, 2) + Math.pow(1 - x, 2));
  return percentDistance;
};

function easeout(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    if (percentTime === 0) {
      return 0;
    }

    var a = percentTime / 2 + 0.5;
    var b = (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2);
    return (b - 0.5) * 2;
  }

  var x = 0.5 + percentTime / 2;
  var power = 2;
  var percentDistance = Math.pow(x, power) / (Math.pow(x, power) + Math.pow(1 - x, power));
  return (percentDistance - 0.5) * 2;
}

function easein(percentTime) {
  var invert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (invert) {
    if (percentTime === 1) {
      return 1;
    }

    var a = percentTime / 2;
    var b = (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2);
    return b * 2;
  }

  var x = percentTime / 2;
  var power = 2;
  var percentDistance = Math.pow(x, power) / (Math.pow(x, power) + Math.pow(1 - x, power));
  return percentDistance * 2;
}

function sinusoid() {
  var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var frequency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var mag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var phaseOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return bias + mag * Math.sin(deltaTime * frequency * 2.0 * Math.PI + phaseOffset);
}

function sinusoidAbs() {
  var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  var frequency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var mag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var phaseOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return bias + Math.abs(mag * Math.sin(deltaTime * frequency * 2.0 * Math.PI + phaseOffset));
} // const animationPhase = (transform, time, rotDirection = 0, animationStyle = easeinout) => {
//     return {
//         transform: transform._dup(),
//         time: time,
//         rotDirection: rotDirection,
//         animationStyle: animationStyle,
//     }
// }

/**
 * Creates an array with a range of numbers
 * @param start - Range start
 * @param stop - Range stop
 * @param step - Range step
 * @returns {Array<number>} Range of numbers in an array
 */


function range(start, stop) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
  var out = [];

  if (stop > start) {
    for (var i = start; i <= stop; i = round(i + step, precision)) {
      out.push(i);
    }
  } else {
    for (var _i = start; _i >= stop; _i = round(_i + step, precision)) {
      out.push(_i);
    }
  }

  return out;
}
/**
 * Return a -1 or 1 randomly
 * @return {number} -1 or 1
 */


function randSign() {
  return Math.random() > 0.5 ? 1 : -1;
}
/**
 * Return a random int.
 *
 * If a `max = null`, then the returned integer will be in the range of 0 to
 * `minOrMax`.
 *
 * Otherwise the returned value is in the range of `minOrMax` to `max`.
 *
 * Use `sign` to also return a random sign (negative or positive);
 *
 * @return {number} random integer
 */


function randInt(minOrMax) {
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var r = 0;

  if (max != null) {
    var min = minOrMax;
    r = Math.floor(Math.random() * Math.floor(max - min) + Math.floor(min));
  } else {
    r = Math.floor(Math.random() * Math.floor(minOrMax));
  }

  if (sign) {
    r *= randSign();
  }

  return r;
}
/**
 * Return a random number.
 *
 * If a `max = null`, then the returned number will be in the range of 0 to
 * `minOrMax`.
 *
 * Otherwise the returned value is in the range of `minOrMax` to `max`.
 *
 * Use `sign` to also return a random sign (negative or positive);
 *
 * @return {number} random number
 */


function rand(minOrMax) {
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var plusOrMinus = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var r = 0;

  if (max != null) {
    var min = minOrMax;
    r = Math.random() * (max - min) + min;
  } else {
    r = Math.random() * minOrMax;
  }

  if (plusOrMinus) {
    r *= randSign();
  }

  return r;
}
/**
 * Get a random element from an array.
 */


function randElement(inputArray) {
  var index = randInt(inputArray.length);
  return inputArray[index];
}
/**
 * Remove and return random element from an array.
 */


function removeRandElement(inputArray) {
  var index = rand(inputArray.length);
  return inputArray.splice(index, 1)[0];
}
/**
 * Get a number of random elements from an array.
 */


function randElements(num, inputArray) {
  var possibleIndeces = range(0, inputArray.length - 1, 1);
  var elements = [];

  for (var i = 0; i < num; i += 1) {
    var index = removeRandElement(possibleIndeces);
    elements.push(inputArray[index]);
  }

  return elements;
}

function rand2D(minX, minY, maxX, maxY) {
  return {
    x: rand(minX, maxX),
    y: rand(minY, maxY)
  };
}



/***/ }),

/***/ "./src/js/tools/styleSheets.js":
/*!*************************************!*\
  !*** ./src/js/tools/styleSheets.js ***!
  \*************************************/
/*! exports provided: getCSSVariables, getDefinedCSSVariables, searchObject, getCSSColors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getCssVariables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCssVariables */ "./src/js/tools/getCssVariables.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSVariables", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["getCSSVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefinedCSSVariables", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["getDefinedCSSVariables"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "searchObject", function() { return _getCssVariables__WEBPACK_IMPORTED_MODULE_0__["searchObject"]; });

/* harmony import */ var _getCssColors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getCssColors */ "./src/js/tools/getCssColors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCSSColors", function() { return _getCssColors__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "./src/js/tools/tools.js":
/*!*******************************!*\
  !*** ./src/js/tools/tools.js ***!
  \*******************************/
/*! exports provided: diffPathsToObj, diffObjToPaths, Console, classify, extractFrom, ObjectKeyPointer, getElement, addToObject, duplicateFromTo, isTouchDevice, generateUniqueId, joinObjects, cleanUIDs, loadRemote, loadRemoteCSS, deleteKeys, copyKeysFromTo, generateRandomString, duplicate, assignObjectFromTo, joinObjectsWithOptions, objectToPaths, getObjectDiff, updateObjFromPath, pathsToObj, UniqueMap, compressObject, refAndDiffToObject, uncompressObject, unminify, minify, ObjectTracker, download, Subscriber, SubscriptionManager, getFromObject, splitString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "diffPathsToObj", function() { return diffPathsToObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "diffObjToPaths", function() { return diffObjToPaths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Console", function() { return Console; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classify", function() { return classify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFrom", function() { return extractFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectKeyPointer", function() { return ObjectKeyPointer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getElement", function() { return getElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToObject", function() { return addToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "duplicateFromTo", function() { return duplicateFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTouchDevice", function() { return isTouchDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateUniqueId", function() { return generateUniqueId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinObjects", function() { return joinObjects; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanUIDs", function() { return cleanUIDs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRemote", function() { return loadRemote; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadRemoteCSS", function() { return loadRemoteCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteKeys", function() { return deleteKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyKeysFromTo", function() { return copyKeysFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateRandomString", function() { return generateRandomString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "duplicate", function() { return duplicate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignObjectFromTo", function() { return assignObjectFromTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinObjectsWithOptions", function() { return joinObjectsWithOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectToPaths", function() { return objectToPaths; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getObjectDiff", function() { return getObjectDiff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateObjFromPath", function() { return updateObjFromPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathsToObj", function() { return pathsToObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniqueMap", function() { return UniqueMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compressObject", function() { return compressObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "refAndDiffToObject", function() { return refAndDiffToObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uncompressObject", function() { return uncompressObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unminify", function() { return unminify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "minify", function() { return minify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectTracker", function() { return ObjectTracker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "download", function() { return download; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Subscriber", function() { return Subscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubscriptionManager", function() { return SubscriptionManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFromObject", function() { return getFromObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitString", function() { return splitString; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./src/js/tools/math.js");
/* harmony import */ var _FunctionMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FunctionMap */ "./src/js/tools/FunctionMap.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


 // import Worker from '../figure/recorder.worker.js';

var Console = function Console(text) {
  console.log(text); // eslint-disable-line no-console
}; // function add(a: number, b: number): number {
//   return a + b;
// }
// function mulToString(a: number, b: number): string {
//   return (a * b).toString();
// }
// const divide = (a: number, b: number): number => a / b;


var classify = function classify(key, value) {
  var nonEmpty = value || key;
  var withKey = nonEmpty[0] === '-' || nonEmpty.startsWith("".concat(key, "-")) ? "".concat(key, " ").concat(nonEmpty) : nonEmpty;
  var joinStr = " ".concat(key, "-");
  return "".concat(withKey.split(' -').join(joinStr));
};

var ObjectKeyPointer = /*#__PURE__*/function () {
  function ObjectKeyPointer(object, key) {
    _classCallCheck(this, ObjectKeyPointer);

    this.object = object;
    this.key = '';

    if (key in object) {
      this.key = key;
    }
  }

  _createClass(ObjectKeyPointer, [{
    key: "setValue",
    value: function setValue(value) {
      if (this.key) {
        this.object[this.key] = value;
      }
    }
  }, {
    key: "execute",
    value: function execute() {
      if (this.key) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return this.object[this.key].apply(null, args);
      }

      return undefined;
    }
  }, {
    key: "value",
    value: function value() {
      if (this.key) {
        return this.object[this.key];
      }

      return undefined;
    }
  }]);

  return ObjectKeyPointer;
}(); //


function extractFrom(objectToExtractFrom, keyValues) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '_';
  var out = [];

  if (typeof keyValues === 'string') {
    if (keyPrefix + keyValues in objectToExtractFrom) {
      return new ObjectKeyPointer(objectToExtractFrom, keyPrefix + keyValues);
    }

    var keyHeirarchy = keyValues.split(keySeparator);
    var keys = keyHeirarchy.filter(function (k) {
      return k.length > 0;
    });
    var prefixAndKey = "".concat(keyPrefix).concat(keys[0]);

    if (keys.length > 1) {
      if (prefixAndKey in objectToExtractFrom) {
        return extractFrom(objectToExtractFrom[prefixAndKey], keys.slice(1).join(keySeparator), keyPrefix, keySeparator);
      }
    } else if (keys.length === 1) {
      if (prefixAndKey in objectToExtractFrom) {
        return new ObjectKeyPointer(objectToExtractFrom, prefixAndKey);
      }
    }

    return undefined;
  }

  if (Array.isArray(keyValues)) {
    keyValues.forEach(function (kv) {
      var result = extractFrom(objectToExtractFrom, kv, keyPrefix, keySeparator);

      if (result !== undefined) {
        out.push(result);
      }
    });
  } else {
    Object.keys(keyValues).forEach(function (key) {
      if (keyPrefix + key in objectToExtractFrom) {
        out.push({
          obj: new ObjectKeyPointer(objectToExtractFrom, keyPrefix + key),
          // $FlowFixMe
          value: keyValues[key]
        });
      }
    });
  }

  return out;
}

function getFromObject(objectToGetFrom, keyPath) {
  var levelSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';

  if (keyPath.length === 0 || keyPath === levelSeparator) {
    return objectToGetFrom;
  }

  var result = extractFrom(objectToGetFrom, keyPath, '', levelSeparator);

  if (result === undefined) {
    return undefined;
  } // $FlowFixMe


  return result.value();
} // function getObjectValueFromPath(
//   objectToExtractFrom: Object,
//   path: string,
//   pathSeparator: string = '.',
// ) {
//   const result = extractFrom(objectToExtractFrom, path, '', pathSeparator);
//   if (result === undefined) {
//     return undefined;
//   }
//   if (Array.isArray(result)) {
//     return result[0].value();
//   }
//   return result.value();
// }


function getElement(collection, keyValues) {
  return extractFrom(collection, keyValues, '_', '_');
}

function addToObject(obj, keyPath, valueToAdd) {
  var levelSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
  var levels = keyPath.split(levelSeparator).filter(function (a) {
    return a.length > 0;
  });
  var currentLevel = obj;
  levels.forEach(function (level, index) {
    if (index === levels.length - 1) {
      currentLevel[level] = valueToAdd;
      return;
    }

    if (!Object.prototype.hasOwnProperty.call(currentLevel, level)) {
      currentLevel[level] = {};
    }

    currentLevel = currentLevel[level];
  });
} // function duplicateFromTo(
//   fromObject: Object,
//   toObject: Object,
//   exceptKeys: Array<string> = [],
// ) {
//   const copyValue = (value) => {
//     if (typeof value === 'number'
//         || typeof value === 'boolean'
//         || typeof value === 'string'
//         || value == null
//         || typeof value === 'function') {
//       return value;
//     }
//     if (typeof value._dup === 'function') {
//       return value._dup();
//     }
//     if (Array.isArray(value)) {
//       const arrayCopy = [];
//       value.forEach(arrayElement => arrayCopy.push(copyValue(arrayElement)));
//       return arrayCopy;
//     }
//     if (typeof value === 'object') {
//       const objectCopy = {};
//       Object.keys(value).forEach((key) => {
//         const v = copyValue(value[key]);
//         objectCopy[key] = v;
//       });
//       return objectCopy;
//     }
//     return value;
//   };
//   Object.keys(fromObject).forEach((key) => {
//     if (exceptKeys.indexOf(key) === -1) {
//       // eslint-disable-next-line no-param-reassign
//       toObject[key] = copyValue(fromObject[key]);
//     }
//   });
// }


function duplicate(value) {
  if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string' || value == null || value === NaN // eslint-disable-line
  || typeof value === 'function') {
    return value;
  }

  if (typeof value._dup === 'function') {
    return value._dup();
  }

  if (Array.isArray(value)) {
    var arrayDup = [];
    value.forEach(function (arrayElement) {
      return arrayDup.push(duplicate(arrayElement));
    });
    return arrayDup;
  } // if (typeof value === 'object') {


  var objectDup = {};
  Object.keys(value).forEach(function (key) {
    var v = duplicate(value[key]);
    objectDup[key] = v;
  });
  return objectDup; // }
  // return value;
}

function assignObjectFromTo(fromObject, toObject) {
  var exceptIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var duplicateValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var parentPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
  var except = typeof exceptIn === 'string' ? [exceptIn] : exceptIn;
  Object.keys(fromObject).forEach(function (key) {
    // debugger;
    var keyPath = parentPath !== '' ? "".concat(parentPath, ".").concat(key) : key;

    if (except.indexOf(keyPath) !== -1) {
      return;
    }

    var value = fromObject[key];

    if (_typeof(value) === 'object' && value != null && value._assignAsLinkOnly) {
      // eslint-disable-next-line no-param-reassign
      toObject[key] = fromObject[key];
      return;
    }

    if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string' || value == null || typeof value === 'function' || typeof value._dup === 'function' || Array.isArray(value)) {
      // Only assign the value if:
      //    * Value is not undefined OR
      //    * Value is undefined and toObject[key] is undefined
      if (value !== undefined || toObject[key] === undefined) {
        if (duplicateValues) {
          // eslint-disable-next-line no-param-reassign
          toObject[key] = duplicate(value);
        } else {
          // eslint-disable-next-line no-param-reassign
          toObject[key] = value;
        }
      }
    } else {
      // If the fromObject[key] value is an object, but the toObject[key] value
      // is not an object, but then make toObject[key] an empty object
      var toValue = toObject[key];

      if (typeof toValue === 'number' || typeof toValue === 'boolean' || typeof toValue === 'string' || toValue == null || typeof toValue === 'function' || Array.isArray(toValue)) {
        // eslint-disable-next-line no-param-reassign
        toObject[key] = {};
      }

      assignObjectFromTo(value, toObject[key], except, duplicateValues, keyPath);
    }
  });
}

function joinObjectsWithOptions(options) {
  var except = options.except;
  var dup = options.duplicate;

  if (except == null) {
    except = [];
  }

  if (dup == null) {
    dup = false;
  }

  var num = arguments.length <= 1 ? 0 : arguments.length - 1;
  var out = arguments.length <= 1 ? undefined : arguments[1];

  for (var i = 1; i < num; i += 1) {
    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];

    if (o != null) {
      assignObjectFromTo(o, out, except, dup, '');
    }
  }

  return out;
} // joins objects like object.assign but goes as many levels deep as the object
// is. Objects later in the arrawy overwrite objects earlier.


function joinObjects() {
  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    objects[_key2] = arguments[_key2];
  }

  return joinObjectsWithOptions.apply(void 0, [{}].concat(objects));
}

function duplicateFromTo(fromObject, toObject) {
  var exceptKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  joinObjectsWithOptions({
    except: exceptKeys,
    duplicate: true
  }, toObject, fromObject);
}

function generateUniqueId() {
  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

  var randomString = function randomString(s) {
    return "".concat(s).concat(Math.floor(Math.random() * 1000000));
  };

  var seedToUse = seed;

  if (seedToUse.length === 0) {
    seedToUse = 'id_random_';
  }

  var idExists = true;
  var newId = randomString(seedToUse);

  while (idExists) {
    newId = randomString(seedToUse);
    var element = document.getElementById(newId);

    if (element == null) {
      idExists = false;
    }
  }

  return newId;
}

function isTouchDevice() {
  var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');

  var mq = function mq(query) {
    return window.matchMedia(query).matches;
  };
  /* eslint-disable no-undef, no-mixed-operators */
  // $FlowFixMe


  if ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch) {
    return true;
  }
  /* eslint-enable no-undef, no-mixed-operators */
  // include the 'heartz' as a way to have a non matching MQ to help terminate the join
  // https://git.io/vznFH


  var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');
  return mq(query);
}

function loadRemote(scriptId, url) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var existingScript = document.getElementById(scriptId);

  if (!existingScript) {
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    script.id = scriptId; // e.g., googleMaps or stripe

    if (document.body) {
      document.body.appendChild(script);
    }

    script.onload = function () {
      if (callback != null) {
        callback(scriptId, url);
      }
    };
  } else if (callback != null) {
    callback(scriptId, url);
  }
}

function loadRemoteCSS(id, url) {
  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var existingScript = document.getElementById(id);

  if (!existingScript) {
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = url;
    link.id = id; // e.g., googleMaps or stripe

    if (document.body) {
      document.body.appendChild(link);
    }

    link.onload = function () {
      if (callback != null) {
        callback(id, url);
      }
    };
  } else if (callback != null) {
    callback(id, url);
  }
} // function remoteLoadToObject(
//   scriptId: string,
//   url: string,
//   toObject: {},
//   callback: null | (string, string) => void = null,
// ) {
//   loadRemote(scriptId, url, callback);
// }


var cleanUIDs = function cleanUIDs(objectToClean) {
  var genericUID = '0000000000';

  if (objectToClean == null) {
    return;
  }

  if ('uid' in objectToClean) {
    if (objectToClean.uid === genericUID) {
      return;
    } // eslint-disable-next-line no-param-reassign


    objectToClean.uid = genericUID;
  }

  var keys = Object.keys(objectToClean);

  for (var i = 0; i < keys.length; i += 1) {
    var key = keys[i];
    var value = objectToClean[key];

    if (_typeof(value) === 'object' && !Array.isArray(value) && value != null && typeof value !== 'function' && typeof value !== 'number' && typeof value !== 'boolean' && typeof value !== 'string') {
      cleanUIDs(value);
    }
  }
};

function deleteKeys(obj, keys) {
  keys.forEach(function (key) {
    if (obj[key] !== undefined) {
      // eslint-disable-next-line no-param-reassign
      delete obj[key];
    }
  });
}

function copyKeysFromTo(source, destination, keys) {
  keys.forEach(function (key) {
    if (source[key] !== undefined) {
      // eslint-disable-next-line no-param-reassign
      destination[key] = source[key];
    }
  });
}

function generateRandomString() {
  return (Math.random() * 1e18).toString(36);
}

var UniqueMap = /*#__PURE__*/function () {
  function UniqueMap() {
    _classCallCheck(this, UniqueMap);

    this.map = {};
    this.index = 1;
    this.inverseMap = {};
    this.letters = '0abcdefghijklmnopqrstuvwxz';
    this.undefinedCode = '.a';
  }

  _createClass(UniqueMap, [{
    key: "reset",
    value: function reset() {
      this.index = 1;
      this.map = {};
    }
  }, {
    key: "add",
    value: function add(pathStr) {
      if (this.map[pathStr] != null) {
        return this.map[pathStr];
      }

      var unique = this.getNextUniqueString();
      this.map[pathStr] = unique;
      return unique;
    }
  }, {
    key: "getNextUniqueString",
    value: function getNextUniqueString() {
      if (this.index === 0) {
        return 'a';
      }

      var order = Math.floor(Math.log(this.index) / Math.log(this.letters.length));
      var remainder = this.index;
      var out = '';

      for (var i = order; i >= 0; i -= 1) {
        var factor = Math.floor(remainder / Math.pow(this.letters.length, i));
        remainder -= factor * Math.pow(this.letters.length, i);
        out = "".concat(out).concat(this.letters[factor]);
      }

      this.index += 1;
      return out;
    }
  }, {
    key: "makeInverseMap",
    value: function makeInverseMap() {
      var _this = this;

      this.inverseMap = {};
      Object.keys(this.map).forEach(function (key) {
        var uniqueStr = _this.map[key];
        _this.inverseMap[uniqueStr] = key;
      });
    }
  }, {
    key: "get",
    value: function get(uniqueStr) {
      if (uniqueStr === this.undefinedCode) {
        return undefined;
      }

      if (this.inverseMap[uniqueStr] != null) {
        return this.inverseMap[uniqueStr];
      }

      return uniqueStr;
    }
  }]);

  return UniqueMap;
}();

function compressObject(obj, map) {
  var keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var strValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var precision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var uncompress = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  if (typeof obj === 'string') {
    // if (obj === 'do') {
    //   console.log(obj, strValues, uncompress, map.get(obj))
    // }
    if (strValues && uncompress) {
      return map.get(obj);
    }

    if (strValues) {
      return map.add(obj);
    }

    return obj;
  }

  if (typeof obj === 'number') {
    if (precision === null || uncompress) {
      return obj;
    }

    return Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(obj, precision);
  }

  if (typeof obj === 'boolean' || typeof obj === 'function' || obj === null) {
    return obj;
  }

  if (obj === undefined) {
    return map.undefinedCode;
  }

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i += 1) {
      // eslint-disable-next-line no-param-reassign
      obj[i] = compressObject(obj[i], map, keys, strValues, precision, uncompress);
    }

    return obj;
  }

  if (_typeof(obj) === 'object') {
    var objKeys = Object.keys(obj);
    var obj2 = {};

    for (var _i = 0; _i < objKeys.length; _i += 1) {
      var k = objKeys[_i]; // eslint-disable-next-line no-param-reassign

      obj[k] = compressObject(obj[k], map, keys, strValues, precision, uncompress);

      if (keys && uncompress) {
        var value = map.get(k);

        if (value != null) {
          obj2[value] = obj[k];
        }
      } else if (keys) {
        obj2[map.add(k)] = obj[k];
      } else {
        obj2[k] = obj[k];
      }
    }

    if (keys) {
      return obj2;
    }

    return obj2;
  }

  return obj;
}

function uncompressObject(obj, map) {
  var keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var strValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return compressObject(obj, map, keys, strValues, null, true);
}

function minify(objectOrArray) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  var map = new UniqueMap();
  return {
    minified: compressObject(objectOrArray, map, true, true, precision),
    map: map
  };
}

function unminify(minObjectOrArray) {
  var map = minObjectOrArray.map;

  if (!(map instanceof UniqueMap)) {
    var uMap = new UniqueMap();
    uMap.map = map.map;
    uMap.index = map.index;
    uMap.letters = map.letters;
    map = uMap;
  }

  map.makeInverseMap();
  return uncompressObject(minObjectOrArray.minified, map, true, true);
}

function objectToPaths(obj) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var pathObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  if (typeof obj === 'string' // || typeof obj === 'number'
  || typeof obj === 'boolean' || typeof obj === 'function') {
    pathObj["".concat(path)] = obj; // eslint-disable-line no-param-reassign

    return pathObj;
  }

  if (typeof obj === 'number') {
    if (precision != null) {
      pathObj["".concat(path)] = Object(_math__WEBPACK_IMPORTED_MODULE_0__["roundNum"])(obj, precision); // eslint-disable-line no-param-reassign
    } else {
      pathObj["".concat(path)] = obj; // eslint-disable-line no-param-reassign
    }

    return pathObj;
  }

  if (obj === null) {
    pathObj["".concat(path)] = null; // eslint-disable-line no-param-reassign

    return pathObj;
  }

  if (obj === undefined) {
    // pathObj[`${path}`] = undefined; // eslint-disable-line no-param-reassign
    return pathObj;
  }

  if (Array.isArray(obj)) {
    obj.forEach(function (o, index) {
      objectToPaths(o, "".concat(path, "[").concat(index, "]"), pathObj, precision);
    });
    return pathObj;
  }

  Object.keys(obj).forEach(function (key) {
    objectToPaths(obj[key], "".concat(path, ".").concat(key), pathObj, precision);
  });
  return pathObj;
}

function getObjectDiff(obj1In, diffs, obj2) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  // const pathMap = {};
  var obj1 = obj1In;

  if (diffs.length > 0) {
    // eslint-disable-next-line no-use-before-define
    obj1 = refAndDiffToObject.apply(void 0, [obj1In].concat(_toConsumableArray(diffs)));
  }

  var paths1 = objectToPaths(obj1, '', {}, precision);
  var paths2 = objectToPaths(obj2, '', {}, precision);
  var added = {};
  var diff = {};
  var removed = {};
  Object.keys(paths1).forEach(function (key1) {
    if (paths2[key1] === undefined) {
      removed[key1] = paths1[key1];
      return;
    }

    if (paths1[key1] !== paths2[key1]) {
      if (debug) {
        diff[key1] = [paths1[key1], paths2[key1]];
      } else {
        diff[key1] = paths2[key1];
      }
    }
  });
  Object.keys(paths2).forEach(function (key2) {
    if (paths1[key2] === undefined) {
      added[key2] = paths2[key2];
    }
  });
  var out = {};

  if (Object.keys(diff).length > 0) {
    out.diff = diff;
  }

  if (Object.keys(added).length > 0) {
    out.added = added;
  }

  if (Object.keys(removed).length > 0) {
    out.removed = removed;
  }

  return out;
}

function updateObjFromPath(remainingPath, obj, value) {
  var remove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // console.log(remainingPath)
  var fullP = remainingPath[0];

  if (fullP.length === 0) {
    return;
  }

  var arrayStringIndeces = fullP.match(/\[[^\]]*\]/g);
  var p = fullP.replace(/\[.*/, '');

  if (remainingPath.length === 1 && remove && !arrayStringIndeces) {
    // eslint-disable-next-line no-param-reassign
    delete obj[p];
    return;
  }

  if (arrayStringIndeces) {
    var arrayIndeces = arrayStringIndeces.map(function (e) {
      return parseInt(e.replace(/\[|\]/g, ''), 10);
    }); // console.log(arrayIndeces)
    // return;

    if (obj[p] == null || !Array.isArray(obj[p])) {
      obj[p] = []; // eslint-disable-line no-param-reassign
    } // console.log(obj)
    // return


    var currentArray = obj[p];
    var index = 0;

    for (var i = 0; i < arrayIndeces.length; i += 1) {
      index = arrayIndeces[i];

      if (currentArray.length <= index) {
        for (var j = currentArray.length; j < index - currentArray.length + 1; j += 1) {
          currentArray.push(undefined);
        }
      }

      if (i < arrayIndeces.length - 1) {
        // currentArray[index] = currentArray[index][i];
        if (!Array.isArray(currentArray[index])) {
          currentArray[index] = [];
        }

        currentArray = currentArray[index];
      }
    }

    if (remainingPath.length === 1 && remove) {
      currentArray[index] = undefined;
      return;
    }

    if (remainingPath.length === 1) {
      currentArray[index] = value;
      return;
    }

    if (currentArray[index] == null || _typeof(currentArray[index]) !== 'object') {
      currentArray[index] = {};
    }

    updateObjFromPath(remainingPath.slice(1), currentArray[index], value, remove);
    return;
  } // if (remainingPath.length === 1 && remove) {
  //   console.log('asdf')
  //   obj[p] = undefined;
  // }


  if (remainingPath.length === 1) {
    obj[p] = value; // eslint-disable-line no-param-reassign

    return;
  }

  if (obj[p] == null) {
    obj[p] = {}; // eslint-disable-line no-param-reassign
  }

  updateObjFromPath(remainingPath.slice(1), obj[p], value, remove);
}

function pathsToObj(paths) {
  var obj = {};
  Object.keys(paths).forEach(function (key) {
    var path = key.split('.').filter(function (p) {
      return p.length > 0;
    });
    var value = paths[key];

    if (Array.isArray(value)) {
      updateObjFromPath(path, obj, value.slice(-1)[0]);
    } else {
      updateObjFromPath(path, obj, value);
    }
  });
  return obj;
}

function refAndDiffToObject(referenceIn) {
  var ref = duplicate(referenceIn);

  var processPaths = function processPaths(paths) {
    var remove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    // console.log(paths)
    Object.keys(paths).forEach(function (pathStr) {
      // console.log(pathStr)
      var path = pathStr.split('.').filter(function (p) {
        return p.length > 0;
      });
      var value = paths[pathStr];

      if (Array.isArray(value)) {
        updateObjFromPath(path, ref, value.slice(-1)[0], remove);
      } else {
        updateObjFromPath(path, ref, value, remove);
      }
    });
  }; // console.log(diffsIn)


  for (var _len3 = arguments.length, diffsIn = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    diffsIn[_key3 - 1] = arguments[_key3];
  }

  diffsIn.forEach(function (diffIn) {
    // console.log(diffIn)
    var added = diffIn.added,
        removed = diffIn.removed,
        diff = diffIn.diff; // console.log(1, removed)

    if (removed != null) {
      processPaths(removed, true);
    } // console.log(2)


    if (added != null) {
      processPaths(added);
    } // console.log(3)


    if (diff != null) {
      processPaths(diff);
    }
  });
  return ref;
}

function diffPathsToObj(diff) {
  var out = {};

  if (diff.diff && Object.keys(diff.diff).length > 0) {
    out.diff = pathsToObj(diff.diff);
  }

  if (diff.added && Object.keys(diff.added).length > 0) {
    out.added = pathsToObj(diff.added);
  }

  if (diff.removed && Object.keys(diff.removed).length > 0) {
    out.removed = pathsToObj(diff.removed);
  }

  return out;
}

function diffObjToPaths(diff) {
  var out = {};

  if (diff.diff && Object.keys(diff.diff).length > 0) {
    out.diff = objectToPaths(diff.diff);
  }

  if (diff.added && Object.keys(diff.added).length > 0) {
    out.added = objectToPaths(diff.added);
  }

  if (diff.removed && Object.keys(diff.removed).length > 0) {
    out.removed = objectToPaths(diff.removed);
  }

  return out;
} // Class that can track an object's differences over time


var ObjectTracker = /*#__PURE__*/function () {
  //             time   refName  diff
  function ObjectTracker() {
    var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;

    _classCallCheck(this, ObjectTracker);

    this.precision = precision;
    this.reset();
  }

  _createClass(ObjectTracker, [{
    key: "toObj",
    value: function toObj() {
      var _this2 = this;

      var references = {};
      Object.keys(this.references).forEach(function (refName) {
        references[refName] = {
          basedOn: _this2.references[refName].basedOn,
          diff: diffPathsToObj(_this2.references[refName].diff)
        };
      }); // $FlowFixMe

      var diffs = this.diffs.map(function (d) {
        return [d[0], d[1], diffPathsToObj(d[2]), d[3]];
      });
      return {
        baseReference: duplicate(this.baseReference),
        diffs: diffs,
        references: references,
        precision: this.precision,
        lastReferenceName: this.lastReferenceName
      };
    }
  }, {
    key: "setFromObj",
    value: function setFromObj(obj) {
      var references = {};
      Object.keys(obj.references).forEach(function (refName) {
        references[refName] = {
          basedOn: obj.references[refName].basedOn,
          diff: diffObjToPaths(obj.references[refName].diff)
        };
      });
      this.references = references;
      this.baseReference = duplicate(obj.baseReference);
      this.precision = obj.precision;
      this.diffs = obj.diffs.map(function (d) {
        return [d[0], d[1], diffObjToPaths(d[2]), d[3]];
      });
      this.lastReferenceName = obj.lastReferenceName;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.baseReference = null;
      this.references = {};
      this.diffs = [];
      this.lastReferenceName = '__base';
    }
  }, {
    key: "setBaseReference",
    value: function setBaseReference(obj) {
      this.baseReference = duplicate(obj);
      this.lastReferenceName = '__base';
    }
  }, {
    key: "addReference",
    value: function addReference(obj, refName) {
      var basedOn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '__base';

      if (this.baseReference == null || refName === '__base') {
        this.setBaseReference(obj);
      }

      if (refName !== '__base') {
        this.references[refName] = {
          diff: this.getDiffToReference(obj, basedOn),
          basedOn: basedOn
        };
        this.lastReferenceName = refName;
      }
    }
  }, {
    key: "getReferenceChain",
    value: function getReferenceChain(name, chain) {
      if (name === '__base') {
        return chain;
      }

      if (this.references[name] == null) {
        return chain;
      }

      return this.getReferenceChain(this.references[name].basedOn, [this.references[name].diff].concat(_toConsumableArray(chain)));
    }
  }, {
    key: "getReference",
    value: function getReference(refName) {
      var referenceChain = this.getReferenceChain(refName, []);
      return refAndDiffToObject.apply(void 0, [this.baseReference].concat(_toConsumableArray(referenceChain)));
    }
  }, {
    key: "getDiffToReference",
    value: function getDiffToReference(obj, refName) {
      // const s1 = performance.now()
      var referenceChain = this.getReferenceChain(refName, []); // console.log('ref Chain', performance.now() - s1);
      // const s2 = performance.now()

      var diff = getObjectDiff(this.baseReference, referenceChain, obj, this.precision); // console.log('s2', performance.now() - s2);

      return diff;
    }
  }, {
    key: "getObjFromDiffAndReference",
    value: function getObjFromDiffAndReference(diff, refName) {
      var referenceChain = this.getReferenceChain(refName, []);
      var diffs = [].concat(_toConsumableArray(referenceChain), [diff]);
      return refAndDiffToObject.apply(void 0, [this.baseReference].concat(_toConsumableArray(diffs)));
    }
  }, {
    key: "add",
    value: function add(time, obj) {
      var refName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.lastReferenceName;
      var timeCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (this.baseReference == null) {
        this.setBaseReference(obj);
      }

      var diff = this.getDiffToReference(obj, refName);
      this.diffs.push([time, refName, diff, timeCount]);
    }
  }, {
    key: "addWithWorker",
    value: function addWithWorker(time, obj) {
      var refName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.lastReferenceName;
      var timeCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      if (this.baseReference == null) {
        this.setBaseReference(obj);
      }

      this.startWorker();

      if (this.worker != null) {
        // $FlowFixMe
        this.worker.postMessage([time, refName, obj, timeCount]);
      }
    }
  }, {
    key: "startWorker",
    value: function startWorker() {
      if (this.worker != null) {
        return;
      } // $FlowFixMe


      this.worker = new Worker(); // // $FlowFixMe
      // this.worker.addEventListener('message', function (event) {
      //   console.log(event.data)
      // });
    }
  }, {
    key: "getFromIndex",
    value: function getFromIndex(index) {
      if (index > this.diffs.length) {
        return null;
      }

      var _this$diffs$index = _slicedToArray(this.diffs[index], 3),
          basedOn = _this$diffs$index[1],
          diff = _this$diffs$index[2];

      return this.getObjFromDiffAndReference(diff, basedOn);
    }
  }]);

  return ObjectTracker;
}();

var Subscriber = /*#__PURE__*/function () {
  function Subscriber() {
    var fnMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _FunctionMap__WEBPACK_IMPORTED_MODULE_1__["FunctionMap"]();

    _classCallCheck(this, Subscriber);

    this.fnMap = fnMap;
    this.subscribers = {};
    this.nextId = 0;
    this.order = [];
  }

  _createClass(Subscriber, [{
    key: "add",
    value: function add(callback) {
      var numberOfSubscriptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      this.subscribers["".concat(this.nextId)] = {
        callback: callback,
        num: numberOfSubscriptions
      };
      this.order.push("".concat(this.nextId));
      this.nextId += 1;
      return this.nextId - 1;
    }
  }, {
    key: "publish",
    value: function publish(payload) {
      var _this3 = this;

      var subscribersToRemove = [];

      for (var i = 0; i < this.order.length; i += 1) {
        var _id = this.order[i];
        var _this$subscribers$_id = this.subscribers[_id],
            callback = _this$subscribers$_id.callback,
            num = _this$subscribers$_id.num; // if (callback != null) {
        //   callback(payload);
        // }

        if (num === 1) {
          subscribersToRemove.push(_id);
        }

        var publishOk = false;

        if (num !== 0) {
          publishOk = true; // subscribersToRemove.push(id);
        }

        if (num > 0) {
          this.subscribers["".concat(_id)].num = num - 1;
        } // if (num > 0) {
        // }
        // else if (num > 1) {
        //   publishOk = true;
        //   this.subscribers[`${id}`].num = num - 1;
        // }
        // if (this.subscribers[`${id}`].num > 0) {


        if (publishOk) {
          this.fnMap.exec(callback, payload);
        }
      }

      subscribersToRemove.forEach(function (id) {
        _this3.remove(id);
      });
    }
  }, {
    key: "remove",
    value: function remove(idIn) {
      var id = "".concat(idIn);

      if (this.subscribers[id] != null) {
        delete this.subscribers[id];
      }

      var index = this.order.indexOf(id);

      if (index > -1) {
        this.order.splice(index, 1);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "_excludeStateKeys",
    value: function _excludeStateKeys() {
      return ['fnMap'];
    }
  }]);

  return Subscriber;
}();

var SubscriptionManager = /*#__PURE__*/function () {
  function SubscriptionManager() {
    var fnMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _FunctionMap__WEBPACK_IMPORTED_MODULE_1__["FunctionMap"]();

    _classCallCheck(this, SubscriptionManager);

    this.subscriptions = {};
    this.fnMap = fnMap;
  }

  _createClass(SubscriptionManager, [{
    key: "add",
    value: function add(subscriptionName, callback) {
      var numberOfSubscriptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

      if (this.subscriptions[subscriptionName] == null) {
        this.subscriptions[subscriptionName] = new Subscriber(this.fnMap);
      }

      return this.subscriptions[subscriptionName].add(callback, numberOfSubscriptions);
    }
  }, {
    key: "publish",
    value: function publish(subscriptionName, payload) {
      if (this.subscriptions[subscriptionName] != null) {
        this.subscriptions[subscriptionName].publish(payload);
      }
    }
  }, {
    key: "remove",
    value: function remove(subscriptionName, id) {
      if (this.subscriptions[subscriptionName] != null) {
        var subscription = this.subscriptions[subscriptionName];
        subscription.remove(id);

        if (subscription.order.length === 0) {
          delete this.subscriptions[subscriptionName];
        }
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "_excludeStateKeys",
    value: function _excludeStateKeys() {
      return ['fnMap'];
    }
  }]);

  return SubscriptionManager;
}();

function download(filename, text) {
  var element = document.createElement('a');
  element.setAttribute('href', "data:text/plain;charset=utf-8,".concat(encodeURIComponent(text)));
  element.setAttribute('download', filename);
  element.style.display = 'none';
  var _document = document,
      body = _document.body;

  if (body != null) {
    body.appendChild(element);
    element.click();
    body.removeChild(element);
  }
}

function splitString(str) {
  var token = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '|';
  var escape = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var letters = str.split('');
  var split = [];
  var currentSplit = [];
  var escaped = false;
  var escapedEscape = false;
  var tokenStringIndex = 0;
  letters.forEach(function (letter) {
    currentSplit.push(letter);

    if (tokenStringIndex === 0 && letter === escape && escaped === false) {
      escaped = true;
    } else if (letter === escape && tokenStringIndex === 0 && escaped) {
      escapedEscape = true;
    } else if (letter === token[tokenStringIndex]) {
      tokenStringIndex += 1;
    } else {
      tokenStringIndex = 0;
      escaped = false;
    }

    if (tokenStringIndex === token.length) {
      if (!escaped) {
        var newSplitString = currentSplit.slice(0, -token.length).join('');

        if (newSplitString.length > 0) {
          split.push(newSplitString);
        }

        currentSplit = [];
      } else {
        var preEscape = currentSplit.slice(0, -token.length - escape.length);
        var postEscape = currentSplit.slice(-token.length);
        currentSplit = [].concat(_toConsumableArray(preEscape), _toConsumableArray(postEscape));
      }

      escaped = false;
      tokenStringIndex = 0;
    }

    if (escapedEscape) {
      escapedEscape = false;
      escaped = false;
      currentSplit = currentSplit.slice(0, -1);
    }
  });

  if (currentSplit.length > 0) {
    split.push(currentSplit.join(''));
  }

  return split;
}



/***/ }),

/***/ "./src/js/tools/types.js":
/*!*******************************!*\
  !*** ./src/js/tools/types.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Defines whether a line is solid or dashed.
 *
 * `Array<number>`
 *
 * Leave empty for solid line.
 *
 * Use array of numbers for a dashed line where indexes 0, 2, 4... are line
 * lengths and indexes 1, 3, 5... are gap lengths. If line is longer than
 * cumulative length of line and gap lengths, then pattern will repeat.
 *
 * If array length is odd, then the first element will be the offset of the
 * dash pattern - the length where the dash pattern starts. In this case index
 * 0 is the offset, indexes 1, 3, 5... are the dash lengths and indexes 2, 4,
 * 6... are the gap lengths.
 *
 * For example [0.1, 0.01, 0.02, 0.01] produces 0.1 length dash, then a 0.01
 * length gap, then a 0.02 length dash, then a 0.01 length gap. This pattern
 * will repeat for the length of the line.
 */

/**
 * Defines a color
 *
 * `[number, number, number, number]`
 *
 * Color is defined as an RGBA array with values between 0 and 1. The alpha
 * channel defines the transparency or opacity of the color where
 * 1 is fully opaque and 0 is fully transparent.
 */

/**
  Curved Corner Definition
 */

/* eslint-disable max-len */

/**
 * Font definition object.
 *
 * Text is drawn in a [Context2D canvas](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D) and so `family`, `style` and `weight` are any valid [options](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font).
 *
 * `size` is the vertex space size of the font.
 *
 * @property {string} [family] The font family (`Times New Roman`)
 * @property {`normal` | `italic`} [style] (`normal`)
 * @property {number} [size] size of font in vertex space (`0.2`)
 * @property {'normal' | 'bold' | 'lighter' | 'bolder' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'} [weight]
 * font weight (`200`)
 * @property {[number, number, number, number]} [color] Font color
 * [red, green, blue, alpha] between 0 and 1 - (`[1, 0, 0, 1]`)
 * @property {number} [opacity] opacity multiplier (final opacity will be
 * `opacity` * `color` alpha) [`1`]
 * @example
 * // Full font definition
 * const font = new FigureFont({
 *   family: 'Helvetica',
 *   style: 'italic',
 *   weight: 'bold',
 *   color: [1, 1, 0, 1],
 *   opacity: 1,
 * });
 * @example
 * // Define style only, remaining properties are defaults
 * const font = new FigureFont({
 *   style: 'italic',
 * });
 */
var doNothing = 1;
/* harmony default export */ __webpack_exports__["default"] = (doNothing);

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=index.js.map