<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: math.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: math.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// @flow

const roundNum = (value: number, precision: number = 5): number => {
  const multiplier = 10 ** precision;
  let result = Math.round(value * multiplier) / multiplier;
  // if (Object.is(result, -0)) {
  // if (result === -0) {
  //   result = 0;
  // }
  const objectIsPolyfill = (x, y) => {
    if (x === y) {
      // 0 === -0, but they are not identical
      return x !== 0 || 1 / x === 1 / y;
    }
    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is a NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN("foo") => true
    // eslint-disable-next-line no-self-compare
    return x !== x &amp;&amp; y !== y;
  };
  if (objectIsPolyfill(result, -0)) {
    result = 0;
  }
  // if (result === -0) {
  //   // 0 === -0, but they are not identical
  //   return result !== 0 || 1 / x === 1 / y;
  // }

  return result;
};

/**
 * Rounds a number or numbers in an array
 * @method
 * @param {number | Array&lt;number>} arrayOrValue - Value or array of values to be rounded
 * @param {number} precision - Number of decimal places to round to
 * @returns {number | Array&lt;number>} Rounded value or array of values
 */
function round&lt;T: number | Array&lt;number>>(
  arrayOrValue: T,
  precision: number = 5,
): T {
  let result = 0;
  if (Array.isArray(arrayOrValue)) {
    result = arrayOrValue.map(elem => round(elem, precision));
  }
  if (typeof arrayOrValue === 'number') {
    result = roundNum(arrayOrValue, precision);
  }
  // $FlowFixMe
  return result;
}


// // clipValue clips a value to either 0 if it's small enough, or to a max value
// // Value, and maxValue are sign independent. e.g.
// //    * value, maxValue = 2, 1 => clips to 1
// //    * value, maxValue = -2, -1 => clips to -1
// //    * value, maxValue = -2, 1 => clips to -1
// //    * value, maxValue = 2, -1 => clips to 1
// function clipValue(
//   value: number,
//   zeroThreshold: number,
//   maxValue: number = 0,
// ) {
//   let result = value;
//   let zero = zeroThreshold;
//   if (zero &lt; 0) {
//     zero = -zero;
//   }
//   if (value > -zero &amp;&amp; value &lt; zero) {
//     return 0;
//   }
//   let max = maxValue;
//   if (max &lt; 0) {
//     max = -max;
//   }

//   if (value > max) {
//     result = max;
//   }
//   if (value &lt; -max) {
//     result = -max;
//   }
//   return result;
// }


// Clip a value to either max velocity, or 0 once under the minimum
// threashold.
//  * velocity: can be positive or negative
//  * maxVelocity will clip velocity to:
//      * |maxVelocity| if velocity > 0
//      * -|maxVelocity| if velcity &lt; 0
//  * zeroThreshold will clip velocity to:
//       * 0 if velocity is larger than -|zeroThreshold| and smaller than
//         |zeroThreshold|.
function clipMag(
  value: number,
  zeroThreshold: number | null,
  maxValue: number | null,
): number {
  let result = value;
  let zeroT = zeroThreshold;
  let maxV = maxValue;

  if (zeroT === null) {
    zeroT = 0;
  }
  if (zeroT &lt; 0) {
    zeroT = -zeroT;
  }
  if (maxV === null) {
    return result;
  }
  if (maxV &lt; 0) {
    maxV = -maxV;
  }
  if (value >= -zeroT &amp;&amp; value &lt;= zeroT) {
    result = 0;
  }
  if (value > maxV) {
    result = maxV;
  }
  if (value &lt; -maxV) {
    result = -maxV;
  }
  return result;
}

function clipValue(
  value: number,
  minValue: number | null,
  maxValue: number | null,
): number {
  let clipped = value;
  if (minValue !== null) {
    if (value &lt; minValue) {
      clipped = minValue;
    }
  }

  if (maxValue !== null) {
    if (value > maxValue) {
      clipped = maxValue;
    }
  }
  return clipped;
}

const decelerate = function getPositionVelocityFromDecAndTime(
  position: number,
  velocity: number,
  magDeceleration: number | null,
  time: number,
  zeroThreshold: number | null,
) {
  let zeroT: number = 0;
  if (zeroThreshold !== null) {
    zeroT = zeroThreshold;
  }
  let decel: number = 0;
  if (magDeceleration !== null) {
    decel = magDeceleration;
  }
  // If the velocity is currently 0, then no further deceleration can occur, so
  // return the current velocity and position
  const v = clipMag(velocity, zeroT, velocity);
  if (v === 0) {
    return {
      p: position,
      v: 0,
    };
  }

  let d = decel;
  if (decel &lt; 0) {
    d = -d;
  }
  // If there is some initial velocity, then calc its sign and
  const sign = velocity / Math.abs(velocity);
  let newVelocity = velocity - sign * d * time;

  // if the new velocity changes sign, then it should go to 0. If it doesn't
  // change sign, then clip incase it should go to 0 because it is below
  // the zero velocity threshold.
  const newSign = newVelocity / Math.abs(newVelocity);
  if (newSign !== sign) {
    newVelocity = 0;
  } else {
    newVelocity = clipMag(newVelocity, zeroT, newVelocity);
  }

  // If the new velocity is clipped, then we need to use the time to where the
  // velocity crosses the clipping point.
  // v_new = v_init + a*t
  // Therefore, if v_new = zeroT: t = (zeroT - vi)/a
  let t = time;
  if (newVelocity === 0) {
    let z = zeroT;
    const zSign = z / Math.abs(z);
    if (zSign !== sign) {
      z = -z;
    }
    t = Math.abs((z - velocity) / d);
  }
  // Now can calculate the new position
  const newPosition = position + velocity * t - sign * 0.5 * d * t * t;

  return {
    p: newPosition,
    v: newVelocity,
  };
};


const linear = (percentTime: number, invert: ?boolean = false) => {
  if (invert) {
    return percentTime;
  }
  return percentTime;
};

const easeinout = (percentTime: number, invert: ?boolean = false) => {
  if (invert) {
    const a = percentTime;
    return (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2);
  }
  const x = percentTime;
  const percentDistance = (x ** 2) / ((x ** 2) + ((1 - x) ** 2));
  return percentDistance;
};

// TODO fix invert
function easeout(percentTime: number, invert: ?boolean = false) {
  if (invert) {
    const a = percentTime;
    const b = (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2);
    // return (b - 0.5) * 2;
    return b;
  }
  const x = 0.5 + percentTime / 2;
  const power = 2;
  const percentDistance = (x ** power) / ((x ** power) + ((1 - x) ** power));
  return (percentDistance - 0.5) * 2;
}

// TODO fix invert
function easein(percentTime: number, invert: ?boolean = false) {
  if (invert) {
    const a = percentTime;
    const b = (2 * a - Math.sqrt(-4 * a * a + 4 * a)) / (4 * a - 2);
    // return (b - 0.5) * 2;
    return b;
  }
  const x = percentTime / 2;
  const power = 2;
  const percentDistance = (x ** power) / ((x ** power) + ((1 - x) ** power));
  return percentDistance * 2;
}

function sinusoid(
  deltaTime: number = 1,
  frequency: number = 1,
  bias: number = 0,
  mag: number = 1,
  phaseOffset: number = 0,
) {
  return bias + mag * Math.sin(deltaTime * frequency * 2.0 * Math.PI + phaseOffset);
}

// const animationPhase = (transform, time, rotDirection = 0, animationStyle = easeinout) => {
//     return {
//         transform: transform._dup(),
//         time: time,
//         rotDirection: rotDirection,
//         animationStyle: animationStyle,
//     }
// }

function range(start: number, stop: number, step: number = 1) {
  const out = [];
  for (let i = start; i &lt;= stop + step * 0.5; i += step) {
    out.push(i);
  }
  return out;
}

function randSign() {
  return Math.random() > 0.5 ? 1 : -1;
}

function randInt(minOrMax: number, max: ?number = null, plusOrMinus: boolean = false) {
  let r = 0;
  if (max != null) {
    const min = minOrMax;
    r = Math.floor(Math.random() * Math.floor((max - min)) + Math.floor(min));
  } else {
    r = Math.floor(Math.random() * Math.floor(minOrMax));
  }
  if (plusOrMinus) {
    r *= randSign();
  }
  return r;
}

function rand(minOrMax: number, max: ?number = null, plusOrMinus: boolean = false) {
  let r = 0;
  if (max != null) {
    const min = minOrMax;
    r = Math.random() * (max - min) + min;
  } else {
    r = Math.random() * minOrMax;
  }
  if (plusOrMinus) {
    r *= randSign();
  }
  return r;
}

function randElement&lt;T>(inputArray: Array&lt;T>): T {
  const index = randInt(inputArray.length);
  return inputArray[index];
}

function removeRandElement&lt;T>(inputArray: Array&lt;T>): T {
  const index = rand(inputArray.length);
  return inputArray.splice(index, 1)[0];
}

function randElements&lt;T>(num: number, inputArray: Array&lt;T>): Array&lt;T> {
  const possibleIndeces = range(0, inputArray.length - 1, 1);
  const elements = [];
  for (let i = 0; i &lt; num; i += 1) {
    const index = removeRandElement(possibleIndeces);
    elements.push(inputArray[index]);
  }
  return elements;
}

function rand2D(minX: number, minY: number, maxX: number, maxY: number) {
  return {
    x: rand(minX, maxX),
    y: rand(minY, maxY),
  };
}

export {
  round,
  roundNum,
  decelerate,
  easeinout,
  easeout,
  easein,
  sinusoid,
  linear,
  clipMag,
  clipValue,
  range,
  randInt,
  rand,
  randElement,
  removeRandElement,
  randElements,
  rand2D,
  randSign,
};

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#roundNum">roundNum</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Mar 05 2020 23:44:10 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
